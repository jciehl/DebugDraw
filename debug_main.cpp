
// very basic sample: display a mesh and use DebugDraw to show each pipeline stage output.
// jeanclaude.iehl@free.fr


#include <cstdio>

#include "GL/glew.h"
#include "GL/freeglut.h"

#include "Logger.h"
#include "DebugDraw.h"
#include "DebugDrawShaders.h"
#include "Buffers.h"
#include "Transform.h"


int windowWidth= 0;
int windowHeight= 0;

Mesh mesh;
GLuint program;
GLuint attributes;

int setUniform( const char *name, const gk::Matrix4x4& matrix )
{
    int location= glGetUniformLocation(program, name);
    if(location < 0)
    {
        WARNING("uniform mat4 '%s': not found.\n", name);
        return -1;
    }
    glUniformMatrix4fv(location, 1, GL_TRUE, matrix);
    return 0;
}

int setUniform( const char *name, const float x, const float y, const float z, const float w )
{
    int location= glGetUniformLocation(program, name);
    if(location < 0)
    {
        WARNING("uniform '%s': not found.\n", name);
        return -1;
    }
    glUniform4f(location, x, y, z, w);
    return 0;
}


void draw( )
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // draw something
    glBindVertexArray(attributes);
    glUseProgram(program);
    
    //~ setUniform("color", .8f, .8f, .8f, 1.f);
    
    std::vector<float> colors(16, 1.f);
    GLint location= glGetUniformLocation(program, "colors");
    if(location < 0)
        ERROR("unknown uniform.\n");
    glUniform4fv(location, colors.size() / 4, &colors.front() );
    
    gk::Transform model= gk::RotateY(30.f);
    gk::Transform view= gk::Translate( gk::Vector(0.f, 0.f, -30.f) );
    gk::Transform projection= gk::Perspective(50.f, 1.f, 1.f, 1000.f);
    gk::Transform mvp= projection * view * model;
    setUniform("mvpMatrix", mvp.matrix());
    
    if(mesh.indices > 0)
    {
        // usual openGL draw call:
        // glDrawElements(GL_TRIANGLES, mesh.count, GL_UNSIGNED_INT, 0);
        // replaced by:
        gk::DebugDrawElements(GL_TRIANGLES, mesh.count, GL_UNSIGNED_INT, 0, "position");
    }
    else
    {
        // usual openGL draw call:
        // glDrawArrays(GL_TRIANGLES, 0, mesh.count);
        // replaced by:
        gk::DebugDrawArrays(GL_TRIANGLES, 0, mesh.count);
    }
    
    glUseProgram(0);
    glBindVertexArray(0);
    
    glutSwapBuffers();
    glutPostRedisplay();
}


int init( )
{
    using namespace gk::debug;  // use available shader helpers from DebugDraw.
    
    mesh= read_OBJ("bigguy.vbo.obj");   // read a mesh
    if(mesh.count == 0)
        return -1;
    
    // compile some shaders
    program= create_program_from_file("vertex.vsl", "fragment_array.fsl");
    //~ program= create_program_from_file("vertex.vsl", "fragment.fsl");
    if(program == 0)
        return -1;

    // core profile : use a vertex array
    attributes= create_vertex_array();
    glBindBuffer(GL_ARRAY_BUFFER, mesh.positions);
    {
        int location= glGetAttribLocation(program, "position");
        glVertexAttribPointer(location, 3, GL_FLOAT, GL_FALSE, 0, 0);
        glEnableVertexAttribArray(location);
    }
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh.indices);
    
    //clean up
    glBindVertexArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
    
    // set up state
    glEnable(GL_CULL_FACE);
    return 0;
}

// clean up
void quit( )
{
    return;
}

// freeglut callback
void resize( int width, int height )
{
    windowWidth= width;
    windowHeight= height;
    
    glViewport(0, 0, width, height);
}


// define a callback to use with opengl debug context
void GLAPIENTRY debuglog( GLenum source, GLenum type, unsigned int id, GLenum severity, GLsizei length, const char* message, void* userParam )
{
    printf("openGL: %s\n", message);
    fflush(stdout);
}


int main( int argc, char *argv[] )
{
    // init a core profile / debug context using freeglut
    glutInit(&argc, argv);
    glutInitWindowSize(1440, 768);
    glutInitContextVersion(3, 3);
    glutInitContextFlags(GLUT_DEBUG);
    glutInitContextProfile(GLUT_CORE_PROFILE);
    glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);
    glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE, GLUT_ACTION_GLUTMAINLOOP_RETURNS);
    
    if(glutCreateWindow("DebugDraw") < 1)
    {
        ERROR("failed.\n");
        return 1;
    }
    
    // work around a bug in glew when using a core profile context
    glewExperimental= 1;
    GLenum err= glewInit();
    if(err != GLEW_OK)
    {
        ERROR("%s\nfailed.\n", glewGetErrorString(err));
        return 1;
    }
    
    // pump errors generated by glew
    while(glGetError() != GL_NO_ERROR) 
        {;}
    
    //~ // install debug logger
    if(glDebugMessageCallbackARB)
    {
        MESSAGE("debug output.\n");
        glDebugMessageCallbackARB(debuglog, NULL);
        glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB);
    }
    
    // init shaders, load objects, etc.
    if(init() < 0)
    {
        ERROR("failed.\n");
        return 1;
    }
    
    // go
    glutReshapeFunc(resize);
    glutDisplayFunc(draw);
    
    glutMainLoop();
    
    // clean up
    quit();
    MESSAGE("done.\n");
    return 0;
}
    
