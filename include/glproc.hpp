
#ifndef _GLPROC_HPP_
#define _GLPROC_HPP_

#include "glimports.hpp"
#include "os.hpp"



#if defined(_WIN32)
extern HMODULE _libGlHandle;
#else
extern void * _libGlHandle;
#endif

void * _getPublicProcAddress(const char *procName);
void * _getPrivateProcAddress(const char *procName);


typedef EGLint (* PFN_EGLGETERROR)(void);
static PFN_EGLGETERROR _eglGetError_ptr = NULL;

static inline EGLint _eglGetError(void) {
    const char *_name = "eglGetError";
    if (!_eglGetError_ptr) {
        _eglGetError_ptr = (PFN_EGLGETERROR)_getPublicProcAddress(_name);
        if (!_eglGetError_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglGetError_ptr();
}

typedef EGLDisplay (* PFN_EGLGETDISPLAY)(EGLNativeDisplayType display_id);
static PFN_EGLGETDISPLAY _eglGetDisplay_ptr = NULL;

static inline EGLDisplay _eglGetDisplay(EGLNativeDisplayType display_id) {
    const char *_name = "eglGetDisplay";
    if (!_eglGetDisplay_ptr) {
        _eglGetDisplay_ptr = (PFN_EGLGETDISPLAY)_getPublicProcAddress(_name);
        if (!_eglGetDisplay_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglGetDisplay_ptr(display_id);
}

typedef EGLBoolean (* PFN_EGLINITIALIZE)(EGLDisplay dpy, EGLint * major, EGLint * minor);
static PFN_EGLINITIALIZE _eglInitialize_ptr = NULL;

static inline EGLBoolean _eglInitialize(EGLDisplay dpy, EGLint * major, EGLint * minor) {
    const char *_name = "eglInitialize";
    if (!_eglInitialize_ptr) {
        _eglInitialize_ptr = (PFN_EGLINITIALIZE)_getPublicProcAddress(_name);
        if (!_eglInitialize_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglInitialize_ptr(dpy, major, minor);
}

typedef EGLBoolean (* PFN_EGLTERMINATE)(EGLDisplay dpy);
static PFN_EGLTERMINATE _eglTerminate_ptr = NULL;

static inline EGLBoolean _eglTerminate(EGLDisplay dpy) {
    const char *_name = "eglTerminate";
    if (!_eglTerminate_ptr) {
        _eglTerminate_ptr = (PFN_EGLTERMINATE)_getPublicProcAddress(_name);
        if (!_eglTerminate_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglTerminate_ptr(dpy);
}

typedef const char * (* PFN_EGLQUERYSTRING)(EGLDisplay dpy, EGLint name);
static PFN_EGLQUERYSTRING _eglQueryString_ptr = NULL;

static inline const char * _eglQueryString(EGLDisplay dpy, EGLint name) {
    const char *_name = "eglQueryString";
    if (!_eglQueryString_ptr) {
        _eglQueryString_ptr = (PFN_EGLQUERYSTRING)_getPublicProcAddress(_name);
        if (!_eglQueryString_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglQueryString_ptr(dpy, name);
}

typedef EGLBoolean (* PFN_EGLGETCONFIGS)(EGLDisplay dpy, EGLConfig * configs, EGLint config_size, EGLint * num_config);
static PFN_EGLGETCONFIGS _eglGetConfigs_ptr = NULL;

static inline EGLBoolean _eglGetConfigs(EGLDisplay dpy, EGLConfig * configs, EGLint config_size, EGLint * num_config) {
    const char *_name = "eglGetConfigs";
    if (!_eglGetConfigs_ptr) {
        _eglGetConfigs_ptr = (PFN_EGLGETCONFIGS)_getPublicProcAddress(_name);
        if (!_eglGetConfigs_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglGetConfigs_ptr(dpy, configs, config_size, num_config);
}

typedef EGLBoolean (* PFN_EGLCHOOSECONFIG)(EGLDisplay dpy, const EGLint * attrib_list, EGLConfig * configs, EGLint config_size, EGLint * num_config);
static PFN_EGLCHOOSECONFIG _eglChooseConfig_ptr = NULL;

static inline EGLBoolean _eglChooseConfig(EGLDisplay dpy, const EGLint * attrib_list, EGLConfig * configs, EGLint config_size, EGLint * num_config) {
    const char *_name = "eglChooseConfig";
    if (!_eglChooseConfig_ptr) {
        _eglChooseConfig_ptr = (PFN_EGLCHOOSECONFIG)_getPublicProcAddress(_name);
        if (!_eglChooseConfig_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglChooseConfig_ptr(dpy, attrib_list, configs, config_size, num_config);
}

typedef EGLBoolean (* PFN_EGLGETCONFIGATTRIB)(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint * value);
static PFN_EGLGETCONFIGATTRIB _eglGetConfigAttrib_ptr = NULL;

static inline EGLBoolean _eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint * value) {
    const char *_name = "eglGetConfigAttrib";
    if (!_eglGetConfigAttrib_ptr) {
        _eglGetConfigAttrib_ptr = (PFN_EGLGETCONFIGATTRIB)_getPublicProcAddress(_name);
        if (!_eglGetConfigAttrib_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglGetConfigAttrib_ptr(dpy, config, attribute, value);
}

typedef EGLSurface (* PFN_EGLCREATEWINDOWSURFACE)(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint * attrib_list);
static PFN_EGLCREATEWINDOWSURFACE _eglCreateWindowSurface_ptr = NULL;

static inline EGLSurface _eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint * attrib_list) {
    const char *_name = "eglCreateWindowSurface";
    if (!_eglCreateWindowSurface_ptr) {
        _eglCreateWindowSurface_ptr = (PFN_EGLCREATEWINDOWSURFACE)_getPublicProcAddress(_name);
        if (!_eglCreateWindowSurface_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglCreateWindowSurface_ptr(dpy, config, win, attrib_list);
}

typedef EGLSurface (* PFN_EGLCREATEPBUFFERSURFACE)(EGLDisplay dpy, EGLConfig config, const EGLint * attrib_list);
static PFN_EGLCREATEPBUFFERSURFACE _eglCreatePbufferSurface_ptr = NULL;

static inline EGLSurface _eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint * attrib_list) {
    const char *_name = "eglCreatePbufferSurface";
    if (!_eglCreatePbufferSurface_ptr) {
        _eglCreatePbufferSurface_ptr = (PFN_EGLCREATEPBUFFERSURFACE)_getPublicProcAddress(_name);
        if (!_eglCreatePbufferSurface_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglCreatePbufferSurface_ptr(dpy, config, attrib_list);
}

typedef EGLSurface (* PFN_EGLCREATEPIXMAPSURFACE)(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint * attrib_list);
static PFN_EGLCREATEPIXMAPSURFACE _eglCreatePixmapSurface_ptr = NULL;

static inline EGLSurface _eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint * attrib_list) {
    const char *_name = "eglCreatePixmapSurface";
    if (!_eglCreatePixmapSurface_ptr) {
        _eglCreatePixmapSurface_ptr = (PFN_EGLCREATEPIXMAPSURFACE)_getPublicProcAddress(_name);
        if (!_eglCreatePixmapSurface_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglCreatePixmapSurface_ptr(dpy, config, pixmap, attrib_list);
}

typedef EGLBoolean (* PFN_EGLDESTROYSURFACE)(EGLDisplay dpy, EGLSurface surface);
static PFN_EGLDESTROYSURFACE _eglDestroySurface_ptr = NULL;

static inline EGLBoolean _eglDestroySurface(EGLDisplay dpy, EGLSurface surface) {
    const char *_name = "eglDestroySurface";
    if (!_eglDestroySurface_ptr) {
        _eglDestroySurface_ptr = (PFN_EGLDESTROYSURFACE)_getPublicProcAddress(_name);
        if (!_eglDestroySurface_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglDestroySurface_ptr(dpy, surface);
}

typedef EGLBoolean (* PFN_EGLQUERYSURFACE)(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint * value);
static PFN_EGLQUERYSURFACE _eglQuerySurface_ptr = NULL;

static inline EGLBoolean _eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint * value) {
    const char *_name = "eglQuerySurface";
    if (!_eglQuerySurface_ptr) {
        _eglQuerySurface_ptr = (PFN_EGLQUERYSURFACE)_getPublicProcAddress(_name);
        if (!_eglQuerySurface_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglQuerySurface_ptr(dpy, surface, attribute, value);
}

typedef EGLBoolean (* PFN_EGLBINDAPI)(EGLenum api);
static PFN_EGLBINDAPI _eglBindAPI_ptr = NULL;

static inline EGLBoolean _eglBindAPI(EGLenum api) {
    const char *_name = "eglBindAPI";
    if (!_eglBindAPI_ptr) {
        _eglBindAPI_ptr = (PFN_EGLBINDAPI)_getPublicProcAddress(_name);
        if (!_eglBindAPI_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglBindAPI_ptr(api);
}

typedef EGLenum (* PFN_EGLQUERYAPI)(void);
static PFN_EGLQUERYAPI _eglQueryAPI_ptr = NULL;

static inline EGLenum _eglQueryAPI(void) {
    const char *_name = "eglQueryAPI";
    if (!_eglQueryAPI_ptr) {
        _eglQueryAPI_ptr = (PFN_EGLQUERYAPI)_getPublicProcAddress(_name);
        if (!_eglQueryAPI_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglQueryAPI_ptr();
}

typedef EGLBoolean (* PFN_EGLWAITCLIENT)(void);
static PFN_EGLWAITCLIENT _eglWaitClient_ptr = NULL;

static inline EGLBoolean _eglWaitClient(void) {
    const char *_name = "eglWaitClient";
    if (!_eglWaitClient_ptr) {
        _eglWaitClient_ptr = (PFN_EGLWAITCLIENT)_getPublicProcAddress(_name);
        if (!_eglWaitClient_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglWaitClient_ptr();
}

typedef EGLBoolean (* PFN_EGLRELEASETHREAD)(void);
static PFN_EGLRELEASETHREAD _eglReleaseThread_ptr = NULL;

static inline EGLBoolean _eglReleaseThread(void) {
    const char *_name = "eglReleaseThread";
    if (!_eglReleaseThread_ptr) {
        _eglReleaseThread_ptr = (PFN_EGLRELEASETHREAD)_getPublicProcAddress(_name);
        if (!_eglReleaseThread_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglReleaseThread_ptr();
}

typedef EGLSurface (* PFN_EGLCREATEPBUFFERFROMCLIENTBUFFER)(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint * attrib_list);
static PFN_EGLCREATEPBUFFERFROMCLIENTBUFFER _eglCreatePbufferFromClientBuffer_ptr = NULL;

static inline EGLSurface _eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint * attrib_list) {
    const char *_name = "eglCreatePbufferFromClientBuffer";
    if (!_eglCreatePbufferFromClientBuffer_ptr) {
        _eglCreatePbufferFromClientBuffer_ptr = (PFN_EGLCREATEPBUFFERFROMCLIENTBUFFER)_getPublicProcAddress(_name);
        if (!_eglCreatePbufferFromClientBuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglCreatePbufferFromClientBuffer_ptr(dpy, buftype, buffer, config, attrib_list);
}

typedef EGLBoolean (* PFN_EGLSURFACEATTRIB)(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value);
static PFN_EGLSURFACEATTRIB _eglSurfaceAttrib_ptr = NULL;

static inline EGLBoolean _eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value) {
    const char *_name = "eglSurfaceAttrib";
    if (!_eglSurfaceAttrib_ptr) {
        _eglSurfaceAttrib_ptr = (PFN_EGLSURFACEATTRIB)_getPublicProcAddress(_name);
        if (!_eglSurfaceAttrib_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglSurfaceAttrib_ptr(dpy, surface, attribute, value);
}

typedef EGLBoolean (* PFN_EGLBINDTEXIMAGE)(EGLDisplay dpy, EGLSurface surface, EGLint buffer);
static PFN_EGLBINDTEXIMAGE _eglBindTexImage_ptr = NULL;

static inline EGLBoolean _eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) {
    const char *_name = "eglBindTexImage";
    if (!_eglBindTexImage_ptr) {
        _eglBindTexImage_ptr = (PFN_EGLBINDTEXIMAGE)_getPublicProcAddress(_name);
        if (!_eglBindTexImage_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglBindTexImage_ptr(dpy, surface, buffer);
}

typedef EGLBoolean (* PFN_EGLRELEASETEXIMAGE)(EGLDisplay dpy, EGLSurface surface, EGLint buffer);
static PFN_EGLRELEASETEXIMAGE _eglReleaseTexImage_ptr = NULL;

static inline EGLBoolean _eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) {
    const char *_name = "eglReleaseTexImage";
    if (!_eglReleaseTexImage_ptr) {
        _eglReleaseTexImage_ptr = (PFN_EGLRELEASETEXIMAGE)_getPublicProcAddress(_name);
        if (!_eglReleaseTexImage_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglReleaseTexImage_ptr(dpy, surface, buffer);
}

typedef EGLBoolean (* PFN_EGLSWAPINTERVAL)(EGLDisplay dpy, EGLint interval);
static PFN_EGLSWAPINTERVAL _eglSwapInterval_ptr = NULL;

static inline EGLBoolean _eglSwapInterval(EGLDisplay dpy, EGLint interval) {
    const char *_name = "eglSwapInterval";
    if (!_eglSwapInterval_ptr) {
        _eglSwapInterval_ptr = (PFN_EGLSWAPINTERVAL)_getPublicProcAddress(_name);
        if (!_eglSwapInterval_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglSwapInterval_ptr(dpy, interval);
}

typedef EGLContext (* PFN_EGLCREATECONTEXT)(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint * attrib_list);
static PFN_EGLCREATECONTEXT _eglCreateContext_ptr = NULL;

static inline EGLContext _eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint * attrib_list) {
    const char *_name = "eglCreateContext";
    if (!_eglCreateContext_ptr) {
        _eglCreateContext_ptr = (PFN_EGLCREATECONTEXT)_getPublicProcAddress(_name);
        if (!_eglCreateContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglCreateContext_ptr(dpy, config, share_context, attrib_list);
}

typedef EGLBoolean (* PFN_EGLDESTROYCONTEXT)(EGLDisplay dpy, EGLContext ctx);
static PFN_EGLDESTROYCONTEXT _eglDestroyContext_ptr = NULL;

static inline EGLBoolean _eglDestroyContext(EGLDisplay dpy, EGLContext ctx) {
    const char *_name = "eglDestroyContext";
    if (!_eglDestroyContext_ptr) {
        _eglDestroyContext_ptr = (PFN_EGLDESTROYCONTEXT)_getPublicProcAddress(_name);
        if (!_eglDestroyContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglDestroyContext_ptr(dpy, ctx);
}

typedef EGLBoolean (* PFN_EGLMAKECURRENT)(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx);
static PFN_EGLMAKECURRENT _eglMakeCurrent_ptr = NULL;

static inline EGLBoolean _eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx) {
    const char *_name = "eglMakeCurrent";
    if (!_eglMakeCurrent_ptr) {
        _eglMakeCurrent_ptr = (PFN_EGLMAKECURRENT)_getPublicProcAddress(_name);
        if (!_eglMakeCurrent_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglMakeCurrent_ptr(dpy, draw, read, ctx);
}

typedef EGLContext (* PFN_EGLGETCURRENTCONTEXT)(void);
static PFN_EGLGETCURRENTCONTEXT _eglGetCurrentContext_ptr = NULL;

static inline EGLContext _eglGetCurrentContext(void) {
    const char *_name = "eglGetCurrentContext";
    if (!_eglGetCurrentContext_ptr) {
        _eglGetCurrentContext_ptr = (PFN_EGLGETCURRENTCONTEXT)_getPublicProcAddress(_name);
        if (!_eglGetCurrentContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglGetCurrentContext_ptr();
}

typedef EGLSurface (* PFN_EGLGETCURRENTSURFACE)(EGLint readdraw);
static PFN_EGLGETCURRENTSURFACE _eglGetCurrentSurface_ptr = NULL;

static inline EGLSurface _eglGetCurrentSurface(EGLint readdraw) {
    const char *_name = "eglGetCurrentSurface";
    if (!_eglGetCurrentSurface_ptr) {
        _eglGetCurrentSurface_ptr = (PFN_EGLGETCURRENTSURFACE)_getPublicProcAddress(_name);
        if (!_eglGetCurrentSurface_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglGetCurrentSurface_ptr(readdraw);
}

typedef EGLDisplay (* PFN_EGLGETCURRENTDISPLAY)(void);
static PFN_EGLGETCURRENTDISPLAY _eglGetCurrentDisplay_ptr = NULL;

static inline EGLDisplay _eglGetCurrentDisplay(void) {
    const char *_name = "eglGetCurrentDisplay";
    if (!_eglGetCurrentDisplay_ptr) {
        _eglGetCurrentDisplay_ptr = (PFN_EGLGETCURRENTDISPLAY)_getPublicProcAddress(_name);
        if (!_eglGetCurrentDisplay_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglGetCurrentDisplay_ptr();
}

typedef EGLBoolean (* PFN_EGLQUERYCONTEXT)(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint * value);
static PFN_EGLQUERYCONTEXT _eglQueryContext_ptr = NULL;

static inline EGLBoolean _eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint * value) {
    const char *_name = "eglQueryContext";
    if (!_eglQueryContext_ptr) {
        _eglQueryContext_ptr = (PFN_EGLQUERYCONTEXT)_getPublicProcAddress(_name);
        if (!_eglQueryContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglQueryContext_ptr(dpy, ctx, attribute, value);
}

typedef EGLBoolean (* PFN_EGLWAITGL)(void);
static PFN_EGLWAITGL _eglWaitGL_ptr = NULL;

static inline EGLBoolean _eglWaitGL(void) {
    const char *_name = "eglWaitGL";
    if (!_eglWaitGL_ptr) {
        _eglWaitGL_ptr = (PFN_EGLWAITGL)_getPublicProcAddress(_name);
        if (!_eglWaitGL_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglWaitGL_ptr();
}

typedef EGLBoolean (* PFN_EGLWAITNATIVE)(EGLint engine);
static PFN_EGLWAITNATIVE _eglWaitNative_ptr = NULL;

static inline EGLBoolean _eglWaitNative(EGLint engine) {
    const char *_name = "eglWaitNative";
    if (!_eglWaitNative_ptr) {
        _eglWaitNative_ptr = (PFN_EGLWAITNATIVE)_getPublicProcAddress(_name);
        if (!_eglWaitNative_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglWaitNative_ptr(engine);
}

typedef EGLBoolean (* PFN_EGLSWAPBUFFERS)(EGLDisplay dpy, EGLSurface surface);
static PFN_EGLSWAPBUFFERS _eglSwapBuffers_ptr = NULL;

static inline EGLBoolean _eglSwapBuffers(EGLDisplay dpy, EGLSurface surface) {
    const char *_name = "eglSwapBuffers";
    if (!_eglSwapBuffers_ptr) {
        _eglSwapBuffers_ptr = (PFN_EGLSWAPBUFFERS)_getPublicProcAddress(_name);
        if (!_eglSwapBuffers_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglSwapBuffers_ptr(dpy, surface);
}

typedef EGLBoolean (* PFN_EGLCOPYBUFFERS)(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target);
static PFN_EGLCOPYBUFFERS _eglCopyBuffers_ptr = NULL;

static inline EGLBoolean _eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target) {
    const char *_name = "eglCopyBuffers";
    if (!_eglCopyBuffers_ptr) {
        _eglCopyBuffers_ptr = (PFN_EGLCOPYBUFFERS)_getPublicProcAddress(_name);
        if (!_eglCopyBuffers_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglCopyBuffers_ptr(dpy, surface, target);
}

typedef __eglMustCastToProperFunctionPointerType (* PFN_EGLGETPROCADDRESS)(const char * procname);
static PFN_EGLGETPROCADDRESS _eglGetProcAddress_ptr = NULL;

static inline __eglMustCastToProperFunctionPointerType _eglGetProcAddress(const char * procname) {
    const char *_name = "eglGetProcAddress";
    if (!_eglGetProcAddress_ptr) {
        _eglGetProcAddress_ptr = (PFN_EGLGETPROCADDRESS)_getPublicProcAddress(_name);
        if (!_eglGetProcAddress_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglGetProcAddress_ptr(procname);
}

typedef EGLBoolean (* PFN_EGLLOCKSURFACEKHR)(EGLDisplay display, EGLSurface surface, const EGLint * attrib_list);
static PFN_EGLLOCKSURFACEKHR _eglLockSurfaceKHR_ptr = NULL;

static inline EGLBoolean _eglLockSurfaceKHR(EGLDisplay display, EGLSurface surface, const EGLint * attrib_list) {
    const char *_name = "eglLockSurfaceKHR";
    if (!_eglLockSurfaceKHR_ptr) {
        _eglLockSurfaceKHR_ptr = (PFN_EGLLOCKSURFACEKHR)_getPrivateProcAddress(_name);
        if (!_eglLockSurfaceKHR_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglLockSurfaceKHR_ptr(display, surface, attrib_list);
}

typedef EGLBoolean (* PFN_EGLUNLOCKSURFACEKHR)(EGLDisplay display, EGLSurface surface);
static PFN_EGLUNLOCKSURFACEKHR _eglUnlockSurfaceKHR_ptr = NULL;

static inline EGLBoolean _eglUnlockSurfaceKHR(EGLDisplay display, EGLSurface surface) {
    const char *_name = "eglUnlockSurfaceKHR";
    if (!_eglUnlockSurfaceKHR_ptr) {
        _eglUnlockSurfaceKHR_ptr = (PFN_EGLUNLOCKSURFACEKHR)_getPrivateProcAddress(_name);
        if (!_eglUnlockSurfaceKHR_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglUnlockSurfaceKHR_ptr(display, surface);
}

typedef EGLImageKHR (* PFN_EGLCREATEIMAGEKHR)(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint * attrib_list);
static PFN_EGLCREATEIMAGEKHR _eglCreateImageKHR_ptr = NULL;

static inline EGLImageKHR _eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint * attrib_list) {
    const char *_name = "eglCreateImageKHR";
    if (!_eglCreateImageKHR_ptr) {
        _eglCreateImageKHR_ptr = (PFN_EGLCREATEIMAGEKHR)_getPrivateProcAddress(_name);
        if (!_eglCreateImageKHR_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglCreateImageKHR_ptr(dpy, ctx, target, buffer, attrib_list);
}

typedef EGLBoolean (* PFN_EGLDESTROYIMAGEKHR)(EGLDisplay dpy, EGLImageKHR image);
static PFN_EGLDESTROYIMAGEKHR _eglDestroyImageKHR_ptr = NULL;

static inline EGLBoolean _eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image) {
    const char *_name = "eglDestroyImageKHR";
    if (!_eglDestroyImageKHR_ptr) {
        _eglDestroyImageKHR_ptr = (PFN_EGLDESTROYIMAGEKHR)_getPrivateProcAddress(_name);
        if (!_eglDestroyImageKHR_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglDestroyImageKHR_ptr(dpy, image);
}

typedef EGLSyncKHR (* PFN_EGLCREATESYNCKHR)(EGLDisplay dpy, EGLenum type, const EGLint * attrib_list);
static PFN_EGLCREATESYNCKHR _eglCreateSyncKHR_ptr = NULL;

static inline EGLSyncKHR _eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint * attrib_list) {
    const char *_name = "eglCreateSyncKHR";
    if (!_eglCreateSyncKHR_ptr) {
        _eglCreateSyncKHR_ptr = (PFN_EGLCREATESYNCKHR)_getPrivateProcAddress(_name);
        if (!_eglCreateSyncKHR_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglCreateSyncKHR_ptr(dpy, type, attrib_list);
}

typedef EGLBoolean (* PFN_EGLDESTROYSYNCKHR)(EGLDisplay dpy, EGLSyncKHR sync);
static PFN_EGLDESTROYSYNCKHR _eglDestroySyncKHR_ptr = NULL;

static inline EGLBoolean _eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync) {
    const char *_name = "eglDestroySyncKHR";
    if (!_eglDestroySyncKHR_ptr) {
        _eglDestroySyncKHR_ptr = (PFN_EGLDESTROYSYNCKHR)_getPrivateProcAddress(_name);
        if (!_eglDestroySyncKHR_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglDestroySyncKHR_ptr(dpy, sync);
}

typedef EGLint (* PFN_EGLCLIENTWAITSYNCKHR)(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout);
static PFN_EGLCLIENTWAITSYNCKHR _eglClientWaitSyncKHR_ptr = NULL;

static inline EGLint _eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout) {
    const char *_name = "eglClientWaitSyncKHR";
    if (!_eglClientWaitSyncKHR_ptr) {
        _eglClientWaitSyncKHR_ptr = (PFN_EGLCLIENTWAITSYNCKHR)_getPrivateProcAddress(_name);
        if (!_eglClientWaitSyncKHR_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglClientWaitSyncKHR_ptr(dpy, sync, flags, timeout);
}

typedef EGLBoolean (* PFN_EGLSIGNALSYNCKHR)(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode);
static PFN_EGLSIGNALSYNCKHR _eglSignalSyncKHR_ptr = NULL;

static inline EGLBoolean _eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode) {
    const char *_name = "eglSignalSyncKHR";
    if (!_eglSignalSyncKHR_ptr) {
        _eglSignalSyncKHR_ptr = (PFN_EGLSIGNALSYNCKHR)_getPrivateProcAddress(_name);
        if (!_eglSignalSyncKHR_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglSignalSyncKHR_ptr(dpy, sync, mode);
}

typedef EGLBoolean (* PFN_EGLGETSYNCATTRIBKHR)(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint * value);
static PFN_EGLGETSYNCATTRIBKHR _eglGetSyncAttribKHR_ptr = NULL;

static inline EGLBoolean _eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint * value) {
    const char *_name = "eglGetSyncAttribKHR";
    if (!_eglGetSyncAttribKHR_ptr) {
        _eglGetSyncAttribKHR_ptr = (PFN_EGLGETSYNCATTRIBKHR)_getPrivateProcAddress(_name);
        if (!_eglGetSyncAttribKHR_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglGetSyncAttribKHR_ptr(dpy, sync, attribute, value);
}

typedef EGLSyncNV (* PFN_EGLCREATEFENCESYNCNV)(EGLDisplay dpy, EGLenum condition, const EGLint * attrib_list);
static PFN_EGLCREATEFENCESYNCNV _eglCreateFenceSyncNV_ptr = NULL;

static inline EGLSyncNV _eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint * attrib_list) {
    const char *_name = "eglCreateFenceSyncNV";
    if (!_eglCreateFenceSyncNV_ptr) {
        _eglCreateFenceSyncNV_ptr = (PFN_EGLCREATEFENCESYNCNV)_getPrivateProcAddress(_name);
        if (!_eglCreateFenceSyncNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglCreateFenceSyncNV_ptr(dpy, condition, attrib_list);
}

typedef EGLBoolean (* PFN_EGLDESTROYSYNCNV)(EGLSyncNV sync);
static PFN_EGLDESTROYSYNCNV _eglDestroySyncNV_ptr = NULL;

static inline EGLBoolean _eglDestroySyncNV(EGLSyncNV sync) {
    const char *_name = "eglDestroySyncNV";
    if (!_eglDestroySyncNV_ptr) {
        _eglDestroySyncNV_ptr = (PFN_EGLDESTROYSYNCNV)_getPrivateProcAddress(_name);
        if (!_eglDestroySyncNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglDestroySyncNV_ptr(sync);
}

typedef EGLBoolean (* PFN_EGLFENCENV)(EGLSyncNV sync);
static PFN_EGLFENCENV _eglFenceNV_ptr = NULL;

static inline EGLBoolean _eglFenceNV(EGLSyncNV sync) {
    const char *_name = "eglFenceNV";
    if (!_eglFenceNV_ptr) {
        _eglFenceNV_ptr = (PFN_EGLFENCENV)_getPrivateProcAddress(_name);
        if (!_eglFenceNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglFenceNV_ptr(sync);
}

typedef EGLint (* PFN_EGLCLIENTWAITSYNCNV)(EGLSyncNV sync, EGLint flags, EGLTimeNV timeout);
static PFN_EGLCLIENTWAITSYNCNV _eglClientWaitSyncNV_ptr = NULL;

static inline EGLint _eglClientWaitSyncNV(EGLSyncNV sync, EGLint flags, EGLTimeNV timeout) {
    const char *_name = "eglClientWaitSyncNV";
    if (!_eglClientWaitSyncNV_ptr) {
        _eglClientWaitSyncNV_ptr = (PFN_EGLCLIENTWAITSYNCNV)_getPrivateProcAddress(_name);
        if (!_eglClientWaitSyncNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglClientWaitSyncNV_ptr(sync, flags, timeout);
}

typedef EGLBoolean (* PFN_EGLSIGNALSYNCNV)(EGLSyncNV sync, EGLenum mode);
static PFN_EGLSIGNALSYNCNV _eglSignalSyncNV_ptr = NULL;

static inline EGLBoolean _eglSignalSyncNV(EGLSyncNV sync, EGLenum mode) {
    const char *_name = "eglSignalSyncNV";
    if (!_eglSignalSyncNV_ptr) {
        _eglSignalSyncNV_ptr = (PFN_EGLSIGNALSYNCNV)_getPrivateProcAddress(_name);
        if (!_eglSignalSyncNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglSignalSyncNV_ptr(sync, mode);
}

typedef EGLBoolean (* PFN_EGLGETSYNCATTRIBNV)(EGLSyncNV sync, EGLint attribute, EGLint * value);
static PFN_EGLGETSYNCATTRIBNV _eglGetSyncAttribNV_ptr = NULL;

static inline EGLBoolean _eglGetSyncAttribNV(EGLSyncNV sync, EGLint attribute, EGLint * value) {
    const char *_name = "eglGetSyncAttribNV";
    if (!_eglGetSyncAttribNV_ptr) {
        _eglGetSyncAttribNV_ptr = (PFN_EGLGETSYNCATTRIBNV)_getPrivateProcAddress(_name);
        if (!_eglGetSyncAttribNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglGetSyncAttribNV_ptr(sync, attribute, value);
}

typedef EGLSurface (* PFN_EGLCREATEPIXMAPSURFACEHI)(EGLDisplay dpy, EGLConfig config, struct EGLClientPixmapHI * pixmap);
static PFN_EGLCREATEPIXMAPSURFACEHI _eglCreatePixmapSurfaceHI_ptr = NULL;

static inline EGLSurface _eglCreatePixmapSurfaceHI(EGLDisplay dpy, EGLConfig config, struct EGLClientPixmapHI * pixmap) {
    const char *_name = "eglCreatePixmapSurfaceHI";
    if (!_eglCreatePixmapSurfaceHI_ptr) {
        _eglCreatePixmapSurfaceHI_ptr = (PFN_EGLCREATEPIXMAPSURFACEHI)_getPrivateProcAddress(_name);
        if (!_eglCreatePixmapSurfaceHI_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglCreatePixmapSurfaceHI_ptr(dpy, config, pixmap);
}

typedef EGLImageKHR (* PFN_EGLCREATEDRMIMAGEMESA)(EGLDisplay dpy, const EGLint * attrib_list);
static PFN_EGLCREATEDRMIMAGEMESA _eglCreateDRMImageMESA_ptr = NULL;

static inline EGLImageKHR _eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint * attrib_list) {
    const char *_name = "eglCreateDRMImageMESA";
    if (!_eglCreateDRMImageMESA_ptr) {
        _eglCreateDRMImageMESA_ptr = (PFN_EGLCREATEDRMIMAGEMESA)_getPrivateProcAddress(_name);
        if (!_eglCreateDRMImageMESA_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglCreateDRMImageMESA_ptr(dpy, attrib_list);
}

typedef EGLBoolean (* PFN_EGLEXPORTDRMIMAGEMESA)(EGLDisplay dpy, EGLImageKHR image, EGLint * name, EGLint * handle, EGLint * stride);
static PFN_EGLEXPORTDRMIMAGEMESA _eglExportDRMImageMESA_ptr = NULL;

static inline EGLBoolean _eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint * name, EGLint * handle, EGLint * stride) {
    const char *_name = "eglExportDRMImageMESA";
    if (!_eglExportDRMImageMESA_ptr) {
        _eglExportDRMImageMESA_ptr = (PFN_EGLEXPORTDRMIMAGEMESA)_getPrivateProcAddress(_name);
        if (!_eglExportDRMImageMESA_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglExportDRMImageMESA_ptr(dpy, image, name, handle, stride);
}

typedef EGLBoolean (* PFN_EGLPOSTSUBBUFFERNV)(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height);
static PFN_EGLPOSTSUBBUFFERNV _eglPostSubBufferNV_ptr = NULL;

static inline EGLBoolean _eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height) {
    const char *_name = "eglPostSubBufferNV";
    if (!_eglPostSubBufferNV_ptr) {
        _eglPostSubBufferNV_ptr = (PFN_EGLPOSTSUBBUFFERNV)_getPrivateProcAddress(_name);
        if (!_eglPostSubBufferNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglPostSubBufferNV_ptr(dpy, surface, x, y, width, height);
}

typedef EGLBoolean (* PFN_EGLQUERYSURFACEPOINTERANGLE)(EGLDisplay dpy, EGLSurface surface, EGLint attribute, void * * value);
static PFN_EGLQUERYSURFACEPOINTERANGLE _eglQuerySurfacePointerANGLE_ptr = NULL;

static inline EGLBoolean _eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, void * * value) {
    const char *_name = "eglQuerySurfacePointerANGLE";
    if (!_eglQuerySurfacePointerANGLE_ptr) {
        _eglQuerySurfacePointerANGLE_ptr = (PFN_EGLQUERYSURFACEPOINTERANGLE)_getPrivateProcAddress(_name);
        if (!_eglQuerySurfacePointerANGLE_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglQuerySurfacePointerANGLE_ptr(dpy, surface, attribute, value);
}

typedef EGLuint64NV (* PFN_EGLGETSYSTEMTIMEFREQUENCYNV)(void);
static PFN_EGLGETSYSTEMTIMEFREQUENCYNV _eglGetSystemTimeFrequencyNV_ptr = NULL;

static inline EGLuint64NV _eglGetSystemTimeFrequencyNV(void) {
    const char *_name = "eglGetSystemTimeFrequencyNV";
    if (!_eglGetSystemTimeFrequencyNV_ptr) {
        _eglGetSystemTimeFrequencyNV_ptr = (PFN_EGLGETSYSTEMTIMEFREQUENCYNV)_getPrivateProcAddress(_name);
        if (!_eglGetSystemTimeFrequencyNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglGetSystemTimeFrequencyNV_ptr();
}

typedef EGLuint64NV (* PFN_EGLGETSYSTEMTIMENV)(void);
static PFN_EGLGETSYSTEMTIMENV _eglGetSystemTimeNV_ptr = NULL;

static inline EGLuint64NV _eglGetSystemTimeNV(void) {
    const char *_name = "eglGetSystemTimeNV";
    if (!_eglGetSystemTimeNV_ptr) {
        _eglGetSystemTimeNV_ptr = (PFN_EGLGETSYSTEMTIMENV)_getPrivateProcAddress(_name);
        if (!_eglGetSystemTimeNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _eglGetSystemTimeNV_ptr();
}

typedef void (GL_APIENTRY * PFN_GLEGLIMAGETARGETTEXTURE2DOES)(GLenum target, EGLImageKHR image);
static PFN_GLEGLIMAGETARGETTEXTURE2DOES _glEGLImageTargetTexture2DOES_ptr = NULL;

static inline void GL_APIENTRY _glEGLImageTargetTexture2DOES(GLenum target, EGLImageKHR image) {
    const char *_name = "glEGLImageTargetTexture2DOES";
    if (!_glEGLImageTargetTexture2DOES_ptr) {
        _glEGLImageTargetTexture2DOES_ptr = (PFN_GLEGLIMAGETARGETTEXTURE2DOES)_getPrivateProcAddress(_name);
        if (!_glEGLImageTargetTexture2DOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEGLImageTargetTexture2DOES_ptr(target, image);
}

typedef void (GL_APIENTRY * PFN_GLEGLIMAGETARGETRENDERBUFFERSTORAGEOES)(GLenum target, EGLImageKHR image);
static PFN_GLEGLIMAGETARGETRENDERBUFFERSTORAGEOES _glEGLImageTargetRenderbufferStorageOES_ptr = NULL;

static inline void GL_APIENTRY _glEGLImageTargetRenderbufferStorageOES(GLenum target, EGLImageKHR image) {
    const char *_name = "glEGLImageTargetRenderbufferStorageOES";
    if (!_glEGLImageTargetRenderbufferStorageOES_ptr) {
        _glEGLImageTargetRenderbufferStorageOES_ptr = (PFN_GLEGLIMAGETARGETRENDERBUFFERSTORAGEOES)_getPrivateProcAddress(_name);
        if (!_glEGLImageTargetRenderbufferStorageOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEGLImageTargetRenderbufferStorageOES_ptr(target, image);
}

#ifdef RETRACE
#define eglGetError _eglGetError
#define eglGetDisplay _eglGetDisplay
#define eglInitialize _eglInitialize
#define eglTerminate _eglTerminate
#define eglQueryString _eglQueryString
#define eglGetConfigs _eglGetConfigs
#define eglChooseConfig _eglChooseConfig
#define eglGetConfigAttrib _eglGetConfigAttrib
#define eglCreateWindowSurface _eglCreateWindowSurface
#define eglCreatePbufferSurface _eglCreatePbufferSurface
#define eglCreatePixmapSurface _eglCreatePixmapSurface
#define eglDestroySurface _eglDestroySurface
#define eglQuerySurface _eglQuerySurface
#define eglBindAPI _eglBindAPI
#define eglQueryAPI _eglQueryAPI
#define eglWaitClient _eglWaitClient
#define eglReleaseThread _eglReleaseThread
#define eglCreatePbufferFromClientBuffer _eglCreatePbufferFromClientBuffer
#define eglSurfaceAttrib _eglSurfaceAttrib
#define eglBindTexImage _eglBindTexImage
#define eglReleaseTexImage _eglReleaseTexImage
#define eglSwapInterval _eglSwapInterval
#define eglCreateContext _eglCreateContext
#define eglDestroyContext _eglDestroyContext
#define eglMakeCurrent _eglMakeCurrent
#define eglGetCurrentContext _eglGetCurrentContext
#define eglGetCurrentSurface _eglGetCurrentSurface
#define eglGetCurrentDisplay _eglGetCurrentDisplay
#define eglQueryContext _eglQueryContext
#define eglWaitGL _eglWaitGL
#define eglWaitNative _eglWaitNative
#define eglSwapBuffers _eglSwapBuffers
#define eglCopyBuffers _eglCopyBuffers
#define eglGetProcAddress _eglGetProcAddress
#define eglLockSurfaceKHR _eglLockSurfaceKHR
#define eglUnlockSurfaceKHR _eglUnlockSurfaceKHR
#define eglCreateImageKHR _eglCreateImageKHR
#define eglDestroyImageKHR _eglDestroyImageKHR
#define eglCreateSyncKHR _eglCreateSyncKHR
#define eglDestroySyncKHR _eglDestroySyncKHR
#define eglClientWaitSyncKHR _eglClientWaitSyncKHR
#define eglSignalSyncKHR _eglSignalSyncKHR
#define eglGetSyncAttribKHR _eglGetSyncAttribKHR
#define eglCreateFenceSyncNV _eglCreateFenceSyncNV
#define eglDestroySyncNV _eglDestroySyncNV
#define eglFenceNV _eglFenceNV
#define eglClientWaitSyncNV _eglClientWaitSyncNV
#define eglSignalSyncNV _eglSignalSyncNV
#define eglGetSyncAttribNV _eglGetSyncAttribNV
#define eglCreatePixmapSurfaceHI _eglCreatePixmapSurfaceHI
#define eglCreateDRMImageMESA _eglCreateDRMImageMESA
#define eglExportDRMImageMESA _eglExportDRMImageMESA
#define eglPostSubBufferNV _eglPostSubBufferNV
#define eglQuerySurfacePointerANGLE _eglQuerySurfacePointerANGLE
#define eglGetSystemTimeFrequencyNV _eglGetSystemTimeFrequencyNV
#define eglGetSystemTimeNV _eglGetSystemTimeNV
#define glEGLImageTargetTexture2DOES _glEGLImageTargetTexture2DOES
#define glEGLImageTargetRenderbufferStorageOES _glEGLImageTargetRenderbufferStorageOES
#endif /* RETRACE */


#if defined(_WIN32)

typedef HGLRC (__stdcall * PFN_WGLCREATECONTEXT)(HDC hdc);
static PFN_WGLCREATECONTEXT _wglCreateContext_ptr = NULL;

static inline HGLRC __stdcall _wglCreateContext(HDC hdc) {
    const char *_name = "wglCreateContext";
    if (!_wglCreateContext_ptr) {
        _wglCreateContext_ptr = (PFN_WGLCREATECONTEXT)_getPublicProcAddress(_name);
        if (!_wglCreateContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglCreateContext_ptr(hdc);
}

typedef BOOL (__stdcall * PFN_WGLDELETECONTEXT)(HGLRC hglrc);
static PFN_WGLDELETECONTEXT _wglDeleteContext_ptr = NULL;

static inline BOOL __stdcall _wglDeleteContext(HGLRC hglrc) {
    const char *_name = "wglDeleteContext";
    if (!_wglDeleteContext_ptr) {
        _wglDeleteContext_ptr = (PFN_WGLDELETECONTEXT)_getPublicProcAddress(_name);
        if (!_wglDeleteContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglDeleteContext_ptr(hglrc);
}

typedef HGLRC (__stdcall * PFN_WGLGETCURRENTCONTEXT)(void);
static PFN_WGLGETCURRENTCONTEXT _wglGetCurrentContext_ptr = NULL;

static inline HGLRC __stdcall _wglGetCurrentContext(void) {
    const char *_name = "wglGetCurrentContext";
    if (!_wglGetCurrentContext_ptr) {
        _wglGetCurrentContext_ptr = (PFN_WGLGETCURRENTCONTEXT)_getPublicProcAddress(_name);
        if (!_wglGetCurrentContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetCurrentContext_ptr();
}

typedef BOOL (__stdcall * PFN_WGLMAKECURRENT)(HDC hdc, HGLRC hglrc);
static PFN_WGLMAKECURRENT _wglMakeCurrent_ptr = NULL;

static inline BOOL __stdcall _wglMakeCurrent(HDC hdc, HGLRC hglrc) {
    const char *_name = "wglMakeCurrent";
    if (!_wglMakeCurrent_ptr) {
        _wglMakeCurrent_ptr = (PFN_WGLMAKECURRENT)_getPublicProcAddress(_name);
        if (!_wglMakeCurrent_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglMakeCurrent_ptr(hdc, hglrc);
}

typedef BOOL (__stdcall * PFN_WGLCOPYCONTEXT)(HGLRC hglrcSrc, HGLRC hglrcDst, UINT mask);
static PFN_WGLCOPYCONTEXT _wglCopyContext_ptr = NULL;

static inline BOOL __stdcall _wglCopyContext(HGLRC hglrcSrc, HGLRC hglrcDst, UINT mask) {
    const char *_name = "wglCopyContext";
    if (!_wglCopyContext_ptr) {
        _wglCopyContext_ptr = (PFN_WGLCOPYCONTEXT)_getPublicProcAddress(_name);
        if (!_wglCopyContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglCopyContext_ptr(hglrcSrc, hglrcDst, mask);
}

typedef int (__stdcall * PFN_WGLCHOOSEPIXELFORMAT)(HDC hdc, const PIXELFORMATDESCRIPTOR * ppfd);
static PFN_WGLCHOOSEPIXELFORMAT _wglChoosePixelFormat_ptr = NULL;

static inline int __stdcall _wglChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR * ppfd) {
    const char *_name = "wglChoosePixelFormat";
    if (!_wglChoosePixelFormat_ptr) {
        _wglChoosePixelFormat_ptr = (PFN_WGLCHOOSEPIXELFORMAT)_getPublicProcAddress(_name);
        if (!_wglChoosePixelFormat_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglChoosePixelFormat_ptr(hdc, ppfd);
}

typedef int (__stdcall * PFN_WGLDESCRIBEPIXELFORMAT)(HDC hdc, int iPixelFormat, UINT nBytes, PIXELFORMATDESCRIPTOR * ppfd);
static PFN_WGLDESCRIBEPIXELFORMAT _wglDescribePixelFormat_ptr = NULL;

static inline int __stdcall _wglDescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, PIXELFORMATDESCRIPTOR * ppfd) {
    const char *_name = "wglDescribePixelFormat";
    if (!_wglDescribePixelFormat_ptr) {
        _wglDescribePixelFormat_ptr = (PFN_WGLDESCRIBEPIXELFORMAT)_getPublicProcAddress(_name);
        if (!_wglDescribePixelFormat_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglDescribePixelFormat_ptr(hdc, iPixelFormat, nBytes, ppfd);
}

typedef HDC (__stdcall * PFN_WGLGETCURRENTDC)(void);
static PFN_WGLGETCURRENTDC _wglGetCurrentDC_ptr = NULL;

static inline HDC __stdcall _wglGetCurrentDC(void) {
    const char *_name = "wglGetCurrentDC";
    if (!_wglGetCurrentDC_ptr) {
        _wglGetCurrentDC_ptr = (PFN_WGLGETCURRENTDC)_getPublicProcAddress(_name);
        if (!_wglGetCurrentDC_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetCurrentDC_ptr();
}

typedef PROC (__stdcall * PFN_WGLGETDEFAULTPROCADDRESS)(const char * lpszProc);
static PFN_WGLGETDEFAULTPROCADDRESS _wglGetDefaultProcAddress_ptr = NULL;

static inline PROC __stdcall _wglGetDefaultProcAddress(const char * lpszProc) {
    const char *_name = "wglGetDefaultProcAddress";
    if (!_wglGetDefaultProcAddress_ptr) {
        _wglGetDefaultProcAddress_ptr = (PFN_WGLGETDEFAULTPROCADDRESS)_getPublicProcAddress(_name);
        if (!_wglGetDefaultProcAddress_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetDefaultProcAddress_ptr(lpszProc);
}

typedef int (__stdcall * PFN_WGLGETPIXELFORMAT)(HDC hdc);
static PFN_WGLGETPIXELFORMAT _wglGetPixelFormat_ptr = NULL;

static inline int __stdcall _wglGetPixelFormat(HDC hdc) {
    const char *_name = "wglGetPixelFormat";
    if (!_wglGetPixelFormat_ptr) {
        _wglGetPixelFormat_ptr = (PFN_WGLGETPIXELFORMAT)_getPublicProcAddress(_name);
        if (!_wglGetPixelFormat_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetPixelFormat_ptr(hdc);
}

typedef BOOL (__stdcall * PFN_WGLSETPIXELFORMAT)(HDC hdc, int iPixelFormat, const PIXELFORMATDESCRIPTOR * ppfd);
static PFN_WGLSETPIXELFORMAT _wglSetPixelFormat_ptr = NULL;

static inline BOOL __stdcall _wglSetPixelFormat(HDC hdc, int iPixelFormat, const PIXELFORMATDESCRIPTOR * ppfd) {
    const char *_name = "wglSetPixelFormat";
    if (!_wglSetPixelFormat_ptr) {
        _wglSetPixelFormat_ptr = (PFN_WGLSETPIXELFORMAT)_getPublicProcAddress(_name);
        if (!_wglSetPixelFormat_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglSetPixelFormat_ptr(hdc, iPixelFormat, ppfd);
}

typedef BOOL (__stdcall * PFN_WGLSWAPBUFFERS)(HDC hdc);
static PFN_WGLSWAPBUFFERS _wglSwapBuffers_ptr = NULL;

static inline BOOL __stdcall _wglSwapBuffers(HDC hdc) {
    const char *_name = "wglSwapBuffers";
    if (!_wglSwapBuffers_ptr) {
        _wglSwapBuffers_ptr = (PFN_WGLSWAPBUFFERS)_getPublicProcAddress(_name);
        if (!_wglSwapBuffers_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglSwapBuffers_ptr(hdc);
}

typedef BOOL (__stdcall * PFN_WGLSHARELISTS)(HGLRC hglrc1, HGLRC hglrc2);
static PFN_WGLSHARELISTS _wglShareLists_ptr = NULL;

static inline BOOL __stdcall _wglShareLists(HGLRC hglrc1, HGLRC hglrc2) {
    const char *_name = "wglShareLists";
    if (!_wglShareLists_ptr) {
        _wglShareLists_ptr = (PFN_WGLSHARELISTS)_getPublicProcAddress(_name);
        if (!_wglShareLists_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglShareLists_ptr(hglrc1, hglrc2);
}

typedef HGLRC (__stdcall * PFN_WGLCREATELAYERCONTEXT)(HDC hdc, int iLayerPlane);
static PFN_WGLCREATELAYERCONTEXT _wglCreateLayerContext_ptr = NULL;

static inline HGLRC __stdcall _wglCreateLayerContext(HDC hdc, int iLayerPlane) {
    const char *_name = "wglCreateLayerContext";
    if (!_wglCreateLayerContext_ptr) {
        _wglCreateLayerContext_ptr = (PFN_WGLCREATELAYERCONTEXT)_getPublicProcAddress(_name);
        if (!_wglCreateLayerContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglCreateLayerContext_ptr(hdc, iLayerPlane);
}

typedef BOOL (__stdcall * PFN_WGLDESCRIBELAYERPLANE)(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nBytes, LAYERPLANEDESCRIPTOR * plpd);
static PFN_WGLDESCRIBELAYERPLANE _wglDescribeLayerPlane_ptr = NULL;

static inline BOOL __stdcall _wglDescribeLayerPlane(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nBytes, LAYERPLANEDESCRIPTOR * plpd) {
    const char *_name = "wglDescribeLayerPlane";
    if (!_wglDescribeLayerPlane_ptr) {
        _wglDescribeLayerPlane_ptr = (PFN_WGLDESCRIBELAYERPLANE)_getPublicProcAddress(_name);
        if (!_wglDescribeLayerPlane_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglDescribeLayerPlane_ptr(hdc, iPixelFormat, iLayerPlane, nBytes, plpd);
}

typedef int (__stdcall * PFN_WGLSETLAYERPALETTEENTRIES)(HDC hdc, int iLayerPlane, int iStart, int cEntries, const COLORREF * pcr);
static PFN_WGLSETLAYERPALETTEENTRIES _wglSetLayerPaletteEntries_ptr = NULL;

static inline int __stdcall _wglSetLayerPaletteEntries(HDC hdc, int iLayerPlane, int iStart, int cEntries, const COLORREF * pcr) {
    const char *_name = "wglSetLayerPaletteEntries";
    if (!_wglSetLayerPaletteEntries_ptr) {
        _wglSetLayerPaletteEntries_ptr = (PFN_WGLSETLAYERPALETTEENTRIES)_getPublicProcAddress(_name);
        if (!_wglSetLayerPaletteEntries_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglSetLayerPaletteEntries_ptr(hdc, iLayerPlane, iStart, cEntries, pcr);
}

typedef int (__stdcall * PFN_WGLGETLAYERPALETTEENTRIES)(HDC hdc, int iLayerPlane, int iStart, int cEntries, COLORREF * pcr);
static PFN_WGLGETLAYERPALETTEENTRIES _wglGetLayerPaletteEntries_ptr = NULL;

static inline int __stdcall _wglGetLayerPaletteEntries(HDC hdc, int iLayerPlane, int iStart, int cEntries, COLORREF * pcr) {
    const char *_name = "wglGetLayerPaletteEntries";
    if (!_wglGetLayerPaletteEntries_ptr) {
        _wglGetLayerPaletteEntries_ptr = (PFN_WGLGETLAYERPALETTEENTRIES)_getPublicProcAddress(_name);
        if (!_wglGetLayerPaletteEntries_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetLayerPaletteEntries_ptr(hdc, iLayerPlane, iStart, cEntries, pcr);
}

typedef BOOL (__stdcall * PFN_WGLREALIZELAYERPALETTE)(HDC hdc, int iLayerPlane, BOOL bRealize);
static PFN_WGLREALIZELAYERPALETTE _wglRealizeLayerPalette_ptr = NULL;

static inline BOOL __stdcall _wglRealizeLayerPalette(HDC hdc, int iLayerPlane, BOOL bRealize) {
    const char *_name = "wglRealizeLayerPalette";
    if (!_wglRealizeLayerPalette_ptr) {
        _wglRealizeLayerPalette_ptr = (PFN_WGLREALIZELAYERPALETTE)_getPublicProcAddress(_name);
        if (!_wglRealizeLayerPalette_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglRealizeLayerPalette_ptr(hdc, iLayerPlane, bRealize);
}

typedef BOOL (__stdcall * PFN_WGLSWAPLAYERBUFFERS)(HDC hdc, UINT fuPlanes);
static PFN_WGLSWAPLAYERBUFFERS _wglSwapLayerBuffers_ptr = NULL;

static inline BOOL __stdcall _wglSwapLayerBuffers(HDC hdc, UINT fuPlanes) {
    const char *_name = "wglSwapLayerBuffers";
    if (!_wglSwapLayerBuffers_ptr) {
        _wglSwapLayerBuffers_ptr = (PFN_WGLSWAPLAYERBUFFERS)_getPublicProcAddress(_name);
        if (!_wglSwapLayerBuffers_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglSwapLayerBuffers_ptr(hdc, fuPlanes);
}

typedef BOOL (__stdcall * PFN_WGLUSEFONTBITMAPSA)(HDC hdc, DWORD first, DWORD count, DWORD listBase);
static PFN_WGLUSEFONTBITMAPSA _wglUseFontBitmapsA_ptr = NULL;

static inline BOOL __stdcall _wglUseFontBitmapsA(HDC hdc, DWORD first, DWORD count, DWORD listBase) {
    const char *_name = "wglUseFontBitmapsA";
    if (!_wglUseFontBitmapsA_ptr) {
        _wglUseFontBitmapsA_ptr = (PFN_WGLUSEFONTBITMAPSA)_getPublicProcAddress(_name);
        if (!_wglUseFontBitmapsA_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglUseFontBitmapsA_ptr(hdc, first, count, listBase);
}

typedef BOOL (__stdcall * PFN_WGLUSEFONTBITMAPSW)(HDC hdc, DWORD first, DWORD count, DWORD listBase);
static PFN_WGLUSEFONTBITMAPSW _wglUseFontBitmapsW_ptr = NULL;

static inline BOOL __stdcall _wglUseFontBitmapsW(HDC hdc, DWORD first, DWORD count, DWORD listBase) {
    const char *_name = "wglUseFontBitmapsW";
    if (!_wglUseFontBitmapsW_ptr) {
        _wglUseFontBitmapsW_ptr = (PFN_WGLUSEFONTBITMAPSW)_getPublicProcAddress(_name);
        if (!_wglUseFontBitmapsW_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglUseFontBitmapsW_ptr(hdc, first, count, listBase);
}

typedef DWORD (__stdcall * PFN_WGLSWAPMULTIPLEBUFFERS)(UINT n, const WGLSWAP * ps);
static PFN_WGLSWAPMULTIPLEBUFFERS _wglSwapMultipleBuffers_ptr = NULL;

static inline DWORD __stdcall _wglSwapMultipleBuffers(UINT n, const WGLSWAP * ps) {
    const char *_name = "wglSwapMultipleBuffers";
    if (!_wglSwapMultipleBuffers_ptr) {
        _wglSwapMultipleBuffers_ptr = (PFN_WGLSWAPMULTIPLEBUFFERS)_getPublicProcAddress(_name);
        if (!_wglSwapMultipleBuffers_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglSwapMultipleBuffers_ptr(n, ps);
}

typedef BOOL (__stdcall * PFN_WGLUSEFONTOUTLINESA)(HDC hdc, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, GLYPHMETRICSFLOAT * lpgmf);
static PFN_WGLUSEFONTOUTLINESA _wglUseFontOutlinesA_ptr = NULL;

static inline BOOL __stdcall _wglUseFontOutlinesA(HDC hdc, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, GLYPHMETRICSFLOAT * lpgmf) {
    const char *_name = "wglUseFontOutlinesA";
    if (!_wglUseFontOutlinesA_ptr) {
        _wglUseFontOutlinesA_ptr = (PFN_WGLUSEFONTOUTLINESA)_getPublicProcAddress(_name);
        if (!_wglUseFontOutlinesA_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglUseFontOutlinesA_ptr(hdc, first, count, listBase, deviation, extrusion, format, lpgmf);
}

typedef BOOL (__stdcall * PFN_WGLUSEFONTOUTLINESW)(HDC hdc, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, GLYPHMETRICSFLOAT * lpgmf);
static PFN_WGLUSEFONTOUTLINESW _wglUseFontOutlinesW_ptr = NULL;

static inline BOOL __stdcall _wglUseFontOutlinesW(HDC hdc, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, GLYPHMETRICSFLOAT * lpgmf) {
    const char *_name = "wglUseFontOutlinesW";
    if (!_wglUseFontOutlinesW_ptr) {
        _wglUseFontOutlinesW_ptr = (PFN_WGLUSEFONTOUTLINESW)_getPublicProcAddress(_name);
        if (!_wglUseFontOutlinesW_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglUseFontOutlinesW_ptr(hdc, first, count, listBase, deviation, extrusion, format, lpgmf);
}

typedef HANDLE (__stdcall * PFN_WGLCREATEBUFFERREGIONARB)(HDC hDC, int iLayerPlane, UINT uType);
static PFN_WGLCREATEBUFFERREGIONARB _wglCreateBufferRegionARB_ptr = NULL;

static inline HANDLE __stdcall _wglCreateBufferRegionARB(HDC hDC, int iLayerPlane, UINT uType) {
    const char *_name = "wglCreateBufferRegionARB";
    if (!_wglCreateBufferRegionARB_ptr) {
        _wglCreateBufferRegionARB_ptr = (PFN_WGLCREATEBUFFERREGIONARB)_getPrivateProcAddress(_name);
        if (!_wglCreateBufferRegionARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglCreateBufferRegionARB_ptr(hDC, iLayerPlane, uType);
}

typedef void (__stdcall * PFN_WGLDELETEBUFFERREGIONARB)(HANDLE hRegion);
static PFN_WGLDELETEBUFFERREGIONARB _wglDeleteBufferRegionARB_ptr = NULL;

static inline void __stdcall _wglDeleteBufferRegionARB(HANDLE hRegion) {
    const char *_name = "wglDeleteBufferRegionARB";
    if (!_wglDeleteBufferRegionARB_ptr) {
        _wglDeleteBufferRegionARB_ptr = (PFN_WGLDELETEBUFFERREGIONARB)_getPrivateProcAddress(_name);
        if (!_wglDeleteBufferRegionARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _wglDeleteBufferRegionARB_ptr(hRegion);
}

typedef BOOL (__stdcall * PFN_WGLSAVEBUFFERREGIONARB)(HANDLE hRegion, int x, int y, int width, int height);
static PFN_WGLSAVEBUFFERREGIONARB _wglSaveBufferRegionARB_ptr = NULL;

static inline BOOL __stdcall _wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height) {
    const char *_name = "wglSaveBufferRegionARB";
    if (!_wglSaveBufferRegionARB_ptr) {
        _wglSaveBufferRegionARB_ptr = (PFN_WGLSAVEBUFFERREGIONARB)_getPrivateProcAddress(_name);
        if (!_wglSaveBufferRegionARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglSaveBufferRegionARB_ptr(hRegion, x, y, width, height);
}

typedef BOOL (__stdcall * PFN_WGLRESTOREBUFFERREGIONARB)(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc);
static PFN_WGLRESTOREBUFFERREGIONARB _wglRestoreBufferRegionARB_ptr = NULL;

static inline BOOL __stdcall _wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc) {
    const char *_name = "wglRestoreBufferRegionARB";
    if (!_wglRestoreBufferRegionARB_ptr) {
        _wglRestoreBufferRegionARB_ptr = (PFN_WGLRESTOREBUFFERREGIONARB)_getPrivateProcAddress(_name);
        if (!_wglRestoreBufferRegionARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglRestoreBufferRegionARB_ptr(hRegion, x, y, width, height, xSrc, ySrc);
}

typedef const char * (__stdcall * PFN_WGLGETEXTENSIONSSTRINGARB)(HDC hdc);
static PFN_WGLGETEXTENSIONSSTRINGARB _wglGetExtensionsStringARB_ptr = NULL;

static inline const char * __stdcall _wglGetExtensionsStringARB(HDC hdc) {
    const char *_name = "wglGetExtensionsStringARB";
    if (!_wglGetExtensionsStringARB_ptr) {
        _wglGetExtensionsStringARB_ptr = (PFN_WGLGETEXTENSIONSSTRINGARB)_getPrivateProcAddress(_name);
        if (!_wglGetExtensionsStringARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetExtensionsStringARB_ptr(hdc);
}

typedef BOOL (__stdcall * PFN_WGLGETPIXELFORMATATTRIBIVARB)(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, int * piValues);
static PFN_WGLGETPIXELFORMATATTRIBIVARB _wglGetPixelFormatAttribivARB_ptr = NULL;

static inline BOOL __stdcall _wglGetPixelFormatAttribivARB(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, int * piValues) {
    const char *_name = "wglGetPixelFormatAttribivARB";
    if (!_wglGetPixelFormatAttribivARB_ptr) {
        _wglGetPixelFormatAttribivARB_ptr = (PFN_WGLGETPIXELFORMATATTRIBIVARB)_getPrivateProcAddress(_name);
        if (!_wglGetPixelFormatAttribivARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetPixelFormatAttribivARB_ptr(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
}

typedef BOOL (__stdcall * PFN_WGLGETPIXELFORMATATTRIBFVARB)(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, FLOAT * pfValues);
static PFN_WGLGETPIXELFORMATATTRIBFVARB _wglGetPixelFormatAttribfvARB_ptr = NULL;

static inline BOOL __stdcall _wglGetPixelFormatAttribfvARB(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, FLOAT * pfValues) {
    const char *_name = "wglGetPixelFormatAttribfvARB";
    if (!_wglGetPixelFormatAttribfvARB_ptr) {
        _wglGetPixelFormatAttribfvARB_ptr = (PFN_WGLGETPIXELFORMATATTRIBFVARB)_getPrivateProcAddress(_name);
        if (!_wglGetPixelFormatAttribfvARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetPixelFormatAttribfvARB_ptr(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
}

typedef BOOL (__stdcall * PFN_WGLCHOOSEPIXELFORMATARB)(HDC hdc, const int * piAttribIList, const FLOAT * pfAttribFList, UINT nMaxFormats, int * piFormats, UINT * nNumFormats);
static PFN_WGLCHOOSEPIXELFORMATARB _wglChoosePixelFormatARB_ptr = NULL;

static inline BOOL __stdcall _wglChoosePixelFormatARB(HDC hdc, const int * piAttribIList, const FLOAT * pfAttribFList, UINT nMaxFormats, int * piFormats, UINT * nNumFormats) {
    const char *_name = "wglChoosePixelFormatARB";
    if (!_wglChoosePixelFormatARB_ptr) {
        _wglChoosePixelFormatARB_ptr = (PFN_WGLCHOOSEPIXELFORMATARB)_getPrivateProcAddress(_name);
        if (!_wglChoosePixelFormatARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglChoosePixelFormatARB_ptr(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
}

typedef BOOL (__stdcall * PFN_WGLMAKECONTEXTCURRENTARB)(HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
static PFN_WGLMAKECONTEXTCURRENTARB _wglMakeContextCurrentARB_ptr = NULL;

static inline BOOL __stdcall _wglMakeContextCurrentARB(HDC hDrawDC, HDC hReadDC, HGLRC hglrc) {
    const char *_name = "wglMakeContextCurrentARB";
    if (!_wglMakeContextCurrentARB_ptr) {
        _wglMakeContextCurrentARB_ptr = (PFN_WGLMAKECONTEXTCURRENTARB)_getPrivateProcAddress(_name);
        if (!_wglMakeContextCurrentARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglMakeContextCurrentARB_ptr(hDrawDC, hReadDC, hglrc);
}

typedef HDC (__stdcall * PFN_WGLGETCURRENTREADDCARB)(void);
static PFN_WGLGETCURRENTREADDCARB _wglGetCurrentReadDCARB_ptr = NULL;

static inline HDC __stdcall _wglGetCurrentReadDCARB(void) {
    const char *_name = "wglGetCurrentReadDCARB";
    if (!_wglGetCurrentReadDCARB_ptr) {
        _wglGetCurrentReadDCARB_ptr = (PFN_WGLGETCURRENTREADDCARB)_getPrivateProcAddress(_name);
        if (!_wglGetCurrentReadDCARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetCurrentReadDCARB_ptr();
}

typedef HPBUFFERARB (__stdcall * PFN_WGLCREATEPBUFFERARB)(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int * piAttribList);
static PFN_WGLCREATEPBUFFERARB _wglCreatePbufferARB_ptr = NULL;

static inline HPBUFFERARB __stdcall _wglCreatePbufferARB(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int * piAttribList) {
    const char *_name = "wglCreatePbufferARB";
    if (!_wglCreatePbufferARB_ptr) {
        _wglCreatePbufferARB_ptr = (PFN_WGLCREATEPBUFFERARB)_getPrivateProcAddress(_name);
        if (!_wglCreatePbufferARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglCreatePbufferARB_ptr(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
}

typedef HDC (__stdcall * PFN_WGLGETPBUFFERDCARB)(HPBUFFERARB hPbuffer);
static PFN_WGLGETPBUFFERDCARB _wglGetPbufferDCARB_ptr = NULL;

static inline HDC __stdcall _wglGetPbufferDCARB(HPBUFFERARB hPbuffer) {
    const char *_name = "wglGetPbufferDCARB";
    if (!_wglGetPbufferDCARB_ptr) {
        _wglGetPbufferDCARB_ptr = (PFN_WGLGETPBUFFERDCARB)_getPrivateProcAddress(_name);
        if (!_wglGetPbufferDCARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetPbufferDCARB_ptr(hPbuffer);
}

typedef int (__stdcall * PFN_WGLRELEASEPBUFFERDCARB)(HPBUFFERARB hPbuffer, HDC hDC);
static PFN_WGLRELEASEPBUFFERDCARB _wglReleasePbufferDCARB_ptr = NULL;

static inline int __stdcall _wglReleasePbufferDCARB(HPBUFFERARB hPbuffer, HDC hDC) {
    const char *_name = "wglReleasePbufferDCARB";
    if (!_wglReleasePbufferDCARB_ptr) {
        _wglReleasePbufferDCARB_ptr = (PFN_WGLRELEASEPBUFFERDCARB)_getPrivateProcAddress(_name);
        if (!_wglReleasePbufferDCARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglReleasePbufferDCARB_ptr(hPbuffer, hDC);
}

typedef BOOL (__stdcall * PFN_WGLDESTROYPBUFFERARB)(HPBUFFERARB hPbuffer);
static PFN_WGLDESTROYPBUFFERARB _wglDestroyPbufferARB_ptr = NULL;

static inline BOOL __stdcall _wglDestroyPbufferARB(HPBUFFERARB hPbuffer) {
    const char *_name = "wglDestroyPbufferARB";
    if (!_wglDestroyPbufferARB_ptr) {
        _wglDestroyPbufferARB_ptr = (PFN_WGLDESTROYPBUFFERARB)_getPrivateProcAddress(_name);
        if (!_wglDestroyPbufferARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglDestroyPbufferARB_ptr(hPbuffer);
}

typedef BOOL (__stdcall * PFN_WGLQUERYPBUFFERARB)(HPBUFFERARB hPbuffer, int iAttribute, int * piValue);
static PFN_WGLQUERYPBUFFERARB _wglQueryPbufferARB_ptr = NULL;

static inline BOOL __stdcall _wglQueryPbufferARB(HPBUFFERARB hPbuffer, int iAttribute, int * piValue) {
    const char *_name = "wglQueryPbufferARB";
    if (!_wglQueryPbufferARB_ptr) {
        _wglQueryPbufferARB_ptr = (PFN_WGLQUERYPBUFFERARB)_getPrivateProcAddress(_name);
        if (!_wglQueryPbufferARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglQueryPbufferARB_ptr(hPbuffer, iAttribute, piValue);
}

typedef BOOL (__stdcall * PFN_WGLBINDTEXIMAGEARB)(HPBUFFERARB hPbuffer, int iBuffer);
static PFN_WGLBINDTEXIMAGEARB _wglBindTexImageARB_ptr = NULL;

static inline BOOL __stdcall _wglBindTexImageARB(HPBUFFERARB hPbuffer, int iBuffer) {
    const char *_name = "wglBindTexImageARB";
    if (!_wglBindTexImageARB_ptr) {
        _wglBindTexImageARB_ptr = (PFN_WGLBINDTEXIMAGEARB)_getPrivateProcAddress(_name);
        if (!_wglBindTexImageARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglBindTexImageARB_ptr(hPbuffer, iBuffer);
}

typedef BOOL (__stdcall * PFN_WGLRELEASETEXIMAGEARB)(HPBUFFERARB hPbuffer, int iBuffer);
static PFN_WGLRELEASETEXIMAGEARB _wglReleaseTexImageARB_ptr = NULL;

static inline BOOL __stdcall _wglReleaseTexImageARB(HPBUFFERARB hPbuffer, int iBuffer) {
    const char *_name = "wglReleaseTexImageARB";
    if (!_wglReleaseTexImageARB_ptr) {
        _wglReleaseTexImageARB_ptr = (PFN_WGLRELEASETEXIMAGEARB)_getPrivateProcAddress(_name);
        if (!_wglReleaseTexImageARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglReleaseTexImageARB_ptr(hPbuffer, iBuffer);
}

typedef BOOL (__stdcall * PFN_WGLSETPBUFFERATTRIBARB)(HPBUFFERARB hPbuffer, const int * piAttribList);
static PFN_WGLSETPBUFFERATTRIBARB _wglSetPbufferAttribARB_ptr = NULL;

static inline BOOL __stdcall _wglSetPbufferAttribARB(HPBUFFERARB hPbuffer, const int * piAttribList) {
    const char *_name = "wglSetPbufferAttribARB";
    if (!_wglSetPbufferAttribARB_ptr) {
        _wglSetPbufferAttribARB_ptr = (PFN_WGLSETPBUFFERATTRIBARB)_getPrivateProcAddress(_name);
        if (!_wglSetPbufferAttribARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglSetPbufferAttribARB_ptr(hPbuffer, piAttribList);
}

typedef HGLRC (__stdcall * PFN_WGLCREATECONTEXTATTRIBSARB)(HDC hDC, HGLRC hShareContext, const int * attribList);
static PFN_WGLCREATECONTEXTATTRIBSARB _wglCreateContextAttribsARB_ptr = NULL;

static inline HGLRC __stdcall _wglCreateContextAttribsARB(HDC hDC, HGLRC hShareContext, const int * attribList) {
    const char *_name = "wglCreateContextAttribsARB";
    if (!_wglCreateContextAttribsARB_ptr) {
        _wglCreateContextAttribsARB_ptr = (PFN_WGLCREATECONTEXTATTRIBSARB)_getPrivateProcAddress(_name);
        if (!_wglCreateContextAttribsARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglCreateContextAttribsARB_ptr(hDC, hShareContext, attribList);
}

typedef const char * (__stdcall * PFN_WGLGETEXTENSIONSSTRINGEXT)(void);
static PFN_WGLGETEXTENSIONSSTRINGEXT _wglGetExtensionsStringEXT_ptr = NULL;

static inline const char * __stdcall _wglGetExtensionsStringEXT(void) {
    const char *_name = "wglGetExtensionsStringEXT";
    if (!_wglGetExtensionsStringEXT_ptr) {
        _wglGetExtensionsStringEXT_ptr = (PFN_WGLGETEXTENSIONSSTRINGEXT)_getPrivateProcAddress(_name);
        if (!_wglGetExtensionsStringEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetExtensionsStringEXT_ptr();
}

typedef BOOL (__stdcall * PFN_WGLMAKECONTEXTCURRENTEXT)(HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
static PFN_WGLMAKECONTEXTCURRENTEXT _wglMakeContextCurrentEXT_ptr = NULL;

static inline BOOL __stdcall _wglMakeContextCurrentEXT(HDC hDrawDC, HDC hReadDC, HGLRC hglrc) {
    const char *_name = "wglMakeContextCurrentEXT";
    if (!_wglMakeContextCurrentEXT_ptr) {
        _wglMakeContextCurrentEXT_ptr = (PFN_WGLMAKECONTEXTCURRENTEXT)_getPrivateProcAddress(_name);
        if (!_wglMakeContextCurrentEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglMakeContextCurrentEXT_ptr(hDrawDC, hReadDC, hglrc);
}

typedef HDC (__stdcall * PFN_WGLGETCURRENTREADDCEXT)(void);
static PFN_WGLGETCURRENTREADDCEXT _wglGetCurrentReadDCEXT_ptr = NULL;

static inline HDC __stdcall _wglGetCurrentReadDCEXT(void) {
    const char *_name = "wglGetCurrentReadDCEXT";
    if (!_wglGetCurrentReadDCEXT_ptr) {
        _wglGetCurrentReadDCEXT_ptr = (PFN_WGLGETCURRENTREADDCEXT)_getPrivateProcAddress(_name);
        if (!_wglGetCurrentReadDCEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetCurrentReadDCEXT_ptr();
}

typedef BOOL (__stdcall * PFN_WGLGETPIXELFORMATATTRIBIVEXT)(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, int * piValues);
static PFN_WGLGETPIXELFORMATATTRIBIVEXT _wglGetPixelFormatAttribivEXT_ptr = NULL;

static inline BOOL __stdcall _wglGetPixelFormatAttribivEXT(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, int * piValues) {
    const char *_name = "wglGetPixelFormatAttribivEXT";
    if (!_wglGetPixelFormatAttribivEXT_ptr) {
        _wglGetPixelFormatAttribivEXT_ptr = (PFN_WGLGETPIXELFORMATATTRIBIVEXT)_getPrivateProcAddress(_name);
        if (!_wglGetPixelFormatAttribivEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetPixelFormatAttribivEXT_ptr(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
}

typedef BOOL (__stdcall * PFN_WGLGETPIXELFORMATATTRIBFVEXT)(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, FLOAT * pfValues);
static PFN_WGLGETPIXELFORMATATTRIBFVEXT _wglGetPixelFormatAttribfvEXT_ptr = NULL;

static inline BOOL __stdcall _wglGetPixelFormatAttribfvEXT(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, FLOAT * pfValues) {
    const char *_name = "wglGetPixelFormatAttribfvEXT";
    if (!_wglGetPixelFormatAttribfvEXT_ptr) {
        _wglGetPixelFormatAttribfvEXT_ptr = (PFN_WGLGETPIXELFORMATATTRIBFVEXT)_getPrivateProcAddress(_name);
        if (!_wglGetPixelFormatAttribfvEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetPixelFormatAttribfvEXT_ptr(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
}

typedef BOOL (__stdcall * PFN_WGLCHOOSEPIXELFORMATEXT)(HDC hdc, const int * piAttribIList, const FLOAT * pfAttribFList, UINT nMaxFormats, int * piFormats, UINT * nNumFormats);
static PFN_WGLCHOOSEPIXELFORMATEXT _wglChoosePixelFormatEXT_ptr = NULL;

static inline BOOL __stdcall _wglChoosePixelFormatEXT(HDC hdc, const int * piAttribIList, const FLOAT * pfAttribFList, UINT nMaxFormats, int * piFormats, UINT * nNumFormats) {
    const char *_name = "wglChoosePixelFormatEXT";
    if (!_wglChoosePixelFormatEXT_ptr) {
        _wglChoosePixelFormatEXT_ptr = (PFN_WGLCHOOSEPIXELFORMATEXT)_getPrivateProcAddress(_name);
        if (!_wglChoosePixelFormatEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglChoosePixelFormatEXT_ptr(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
}

typedef BOOL (__stdcall * PFN_WGLSWAPINTERVALEXT)(int interval);
static PFN_WGLSWAPINTERVALEXT _wglSwapIntervalEXT_ptr = NULL;

static inline BOOL __stdcall _wglSwapIntervalEXT(int interval) {
    const char *_name = "wglSwapIntervalEXT";
    if (!_wglSwapIntervalEXT_ptr) {
        _wglSwapIntervalEXT_ptr = (PFN_WGLSWAPINTERVALEXT)_getPrivateProcAddress(_name);
        if (!_wglSwapIntervalEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglSwapIntervalEXT_ptr(interval);
}

typedef int (__stdcall * PFN_WGLGETSWAPINTERVALEXT)(void);
static PFN_WGLGETSWAPINTERVALEXT _wglGetSwapIntervalEXT_ptr = NULL;

static inline int __stdcall _wglGetSwapIntervalEXT(void) {
    const char *_name = "wglGetSwapIntervalEXT";
    if (!_wglGetSwapIntervalEXT_ptr) {
        _wglGetSwapIntervalEXT_ptr = (PFN_WGLGETSWAPINTERVALEXT)_getPrivateProcAddress(_name);
        if (!_wglGetSwapIntervalEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetSwapIntervalEXT_ptr();
}

typedef void * (__stdcall * PFN_WGLALLOCATEMEMORYNV)(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority);
static PFN_WGLALLOCATEMEMORYNV _wglAllocateMemoryNV_ptr = NULL;

static inline void * __stdcall _wglAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority) {
    const char *_name = "wglAllocateMemoryNV";
    if (!_wglAllocateMemoryNV_ptr) {
        _wglAllocateMemoryNV_ptr = (PFN_WGLALLOCATEMEMORYNV)_getPrivateProcAddress(_name);
        if (!_wglAllocateMemoryNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglAllocateMemoryNV_ptr(size, readfreq, writefreq, priority);
}

typedef void (__stdcall * PFN_WGLFREEMEMORYNV)(void * pointer);
static PFN_WGLFREEMEMORYNV _wglFreeMemoryNV_ptr = NULL;

static inline void __stdcall _wglFreeMemoryNV(void * pointer) {
    const char *_name = "wglFreeMemoryNV";
    if (!_wglFreeMemoryNV_ptr) {
        _wglFreeMemoryNV_ptr = (PFN_WGLFREEMEMORYNV)_getPrivateProcAddress(_name);
        if (!_wglFreeMemoryNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _wglFreeMemoryNV_ptr(pointer);
}

typedef PROC (__stdcall * PFN_WGLGETPROCADDRESS)(const char * lpszProc);
static PFN_WGLGETPROCADDRESS _wglGetProcAddress_ptr = NULL;

static inline PROC __stdcall _wglGetProcAddress(const char * lpszProc) {
    const char *_name = "wglGetProcAddress";
    if (!_wglGetProcAddress_ptr) {
        _wglGetProcAddress_ptr = (PFN_WGLGETPROCADDRESS)_getPublicProcAddress(_name);
        if (!_wglGetProcAddress_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _wglGetProcAddress_ptr(lpszProc);
}

#ifdef RETRACE
#define wglCreateContext _wglCreateContext
#define wglDeleteContext _wglDeleteContext
#define wglGetCurrentContext _wglGetCurrentContext
#define wglMakeCurrent _wglMakeCurrent
#define wglCopyContext _wglCopyContext
#define wglChoosePixelFormat _wglChoosePixelFormat
#define wglDescribePixelFormat _wglDescribePixelFormat
#define wglGetCurrentDC _wglGetCurrentDC
#define wglGetDefaultProcAddress _wglGetDefaultProcAddress
#define wglGetPixelFormat _wglGetPixelFormat
#define wglSetPixelFormat _wglSetPixelFormat
#define wglSwapBuffers _wglSwapBuffers
#define wglShareLists _wglShareLists
#define wglCreateLayerContext _wglCreateLayerContext
#define wglDescribeLayerPlane _wglDescribeLayerPlane
#define wglSetLayerPaletteEntries _wglSetLayerPaletteEntries
#define wglGetLayerPaletteEntries _wglGetLayerPaletteEntries
#define wglRealizeLayerPalette _wglRealizeLayerPalette
#define wglSwapLayerBuffers _wglSwapLayerBuffers
#define wglUseFontBitmapsA _wglUseFontBitmapsA
#define wglUseFontBitmapsW _wglUseFontBitmapsW
#define wglSwapMultipleBuffers _wglSwapMultipleBuffers
#define wglUseFontOutlinesA _wglUseFontOutlinesA
#define wglUseFontOutlinesW _wglUseFontOutlinesW
#define wglCreateBufferRegionARB _wglCreateBufferRegionARB
#define wglDeleteBufferRegionARB _wglDeleteBufferRegionARB
#define wglSaveBufferRegionARB _wglSaveBufferRegionARB
#define wglRestoreBufferRegionARB _wglRestoreBufferRegionARB
#define wglGetExtensionsStringARB _wglGetExtensionsStringARB
#define wglGetPixelFormatAttribivARB _wglGetPixelFormatAttribivARB
#define wglGetPixelFormatAttribfvARB _wglGetPixelFormatAttribfvARB
#define wglChoosePixelFormatARB _wglChoosePixelFormatARB
#define wglMakeContextCurrentARB _wglMakeContextCurrentARB
#define wglGetCurrentReadDCARB _wglGetCurrentReadDCARB
#define wglCreatePbufferARB _wglCreatePbufferARB
#define wglGetPbufferDCARB _wglGetPbufferDCARB
#define wglReleasePbufferDCARB _wglReleasePbufferDCARB
#define wglDestroyPbufferARB _wglDestroyPbufferARB
#define wglQueryPbufferARB _wglQueryPbufferARB
#define wglBindTexImageARB _wglBindTexImageARB
#define wglReleaseTexImageARB _wglReleaseTexImageARB
#define wglSetPbufferAttribARB _wglSetPbufferAttribARB
#define wglCreateContextAttribsARB _wglCreateContextAttribsARB
#define wglGetExtensionsStringEXT _wglGetExtensionsStringEXT
#define wglMakeContextCurrentEXT _wglMakeContextCurrentEXT
#define wglGetCurrentReadDCEXT _wglGetCurrentReadDCEXT
#define wglGetPixelFormatAttribivEXT _wglGetPixelFormatAttribivEXT
#define wglGetPixelFormatAttribfvEXT _wglGetPixelFormatAttribfvEXT
#define wglChoosePixelFormatEXT _wglChoosePixelFormatEXT
#define wglSwapIntervalEXT _wglSwapIntervalEXT
#define wglGetSwapIntervalEXT _wglGetSwapIntervalEXT
#define wglAllocateMemoryNV _wglAllocateMemoryNV
#define wglFreeMemoryNV _wglFreeMemoryNV
#define wglGetProcAddress _wglGetProcAddress
#endif /* RETRACE */


#elif defined(__APPLE__)

typedef CGLError (* PFN_CGLSETCURRENTCONTEXT)(CGLContextObj ctx);
static PFN_CGLSETCURRENTCONTEXT _CGLSetCurrentContext_ptr = NULL;

static inline CGLError _CGLSetCurrentContext(CGLContextObj ctx) {
    const char *_name = "CGLSetCurrentContext";
    if (!_CGLSetCurrentContext_ptr) {
        _CGLSetCurrentContext_ptr = (PFN_CGLSETCURRENTCONTEXT)_getPublicProcAddress(_name);
        if (!_CGLSetCurrentContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLSetCurrentContext_ptr(ctx);
}

typedef CGLContextObj (* PFN_CGLGETCURRENTCONTEXT)(void);
static PFN_CGLGETCURRENTCONTEXT _CGLGetCurrentContext_ptr = NULL;

static inline CGLContextObj _CGLGetCurrentContext(void) {
    const char *_name = "CGLGetCurrentContext";
    if (!_CGLGetCurrentContext_ptr) {
        _CGLGetCurrentContext_ptr = (PFN_CGLGETCURRENTCONTEXT)_getPublicProcAddress(_name);
        if (!_CGLGetCurrentContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLGetCurrentContext_ptr();
}

typedef CGLError (* PFN_CGLCHOOSEPIXELFORMAT)(const CGLPixelFormatAttribute * attribs, CGLPixelFormatObj * pix, GLint * npix);
static PFN_CGLCHOOSEPIXELFORMAT _CGLChoosePixelFormat_ptr = NULL;

static inline CGLError _CGLChoosePixelFormat(const CGLPixelFormatAttribute * attribs, CGLPixelFormatObj * pix, GLint * npix) {
    const char *_name = "CGLChoosePixelFormat";
    if (!_CGLChoosePixelFormat_ptr) {
        _CGLChoosePixelFormat_ptr = (PFN_CGLCHOOSEPIXELFORMAT)_getPublicProcAddress(_name);
        if (!_CGLChoosePixelFormat_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLChoosePixelFormat_ptr(attribs, pix, npix);
}

typedef CGLError (* PFN_CGLDESTROYPIXELFORMAT)(CGLPixelFormatObj pix);
static PFN_CGLDESTROYPIXELFORMAT _CGLDestroyPixelFormat_ptr = NULL;

static inline CGLError _CGLDestroyPixelFormat(CGLPixelFormatObj pix) {
    const char *_name = "CGLDestroyPixelFormat";
    if (!_CGLDestroyPixelFormat_ptr) {
        _CGLDestroyPixelFormat_ptr = (PFN_CGLDESTROYPIXELFORMAT)_getPublicProcAddress(_name);
        if (!_CGLDestroyPixelFormat_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLDestroyPixelFormat_ptr(pix);
}

typedef CGLError (* PFN_CGLDESCRIBEPIXELFORMAT)(CGLPixelFormatObj pix, GLint pix_num, CGLPixelFormatAttribute attrib, GLint * value);
static PFN_CGLDESCRIBEPIXELFORMAT _CGLDescribePixelFormat_ptr = NULL;

static inline CGLError _CGLDescribePixelFormat(CGLPixelFormatObj pix, GLint pix_num, CGLPixelFormatAttribute attrib, GLint * value) {
    const char *_name = "CGLDescribePixelFormat";
    if (!_CGLDescribePixelFormat_ptr) {
        _CGLDescribePixelFormat_ptr = (PFN_CGLDESCRIBEPIXELFORMAT)_getPublicProcAddress(_name);
        if (!_CGLDescribePixelFormat_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLDescribePixelFormat_ptr(pix, pix_num, attrib, value);
}

typedef void (* PFN_CGLRELEASEPIXELFORMAT)(CGLPixelFormatObj pix);
static PFN_CGLRELEASEPIXELFORMAT _CGLReleasePixelFormat_ptr = NULL;

static inline void _CGLReleasePixelFormat(CGLPixelFormatObj pix) {
    const char *_name = "CGLReleasePixelFormat";
    if (!_CGLReleasePixelFormat_ptr) {
        _CGLReleasePixelFormat_ptr = (PFN_CGLRELEASEPIXELFORMAT)_getPublicProcAddress(_name);
        if (!_CGLReleasePixelFormat_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _CGLReleasePixelFormat_ptr(pix);
}

typedef CGLPixelFormatObj (* PFN_CGLRETAINPIXELFORMAT)(CGLPixelFormatObj pix);
static PFN_CGLRETAINPIXELFORMAT _CGLRetainPixelFormat_ptr = NULL;

static inline CGLPixelFormatObj _CGLRetainPixelFormat(CGLPixelFormatObj pix) {
    const char *_name = "CGLRetainPixelFormat";
    if (!_CGLRetainPixelFormat_ptr) {
        _CGLRetainPixelFormat_ptr = (PFN_CGLRETAINPIXELFORMAT)_getPublicProcAddress(_name);
        if (!_CGLRetainPixelFormat_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLRetainPixelFormat_ptr(pix);
}

typedef GLuint (* PFN_CGLGETPIXELFORMATRETAINCOUNT)(CGLPixelFormatObj pix);
static PFN_CGLGETPIXELFORMATRETAINCOUNT _CGLGetPixelFormatRetainCount_ptr = NULL;

static inline GLuint _CGLGetPixelFormatRetainCount(CGLPixelFormatObj pix) {
    const char *_name = "CGLGetPixelFormatRetainCount";
    if (!_CGLGetPixelFormatRetainCount_ptr) {
        _CGLGetPixelFormatRetainCount_ptr = (PFN_CGLGETPIXELFORMATRETAINCOUNT)_getPublicProcAddress(_name);
        if (!_CGLGetPixelFormatRetainCount_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLGetPixelFormatRetainCount_ptr(pix);
}

typedef CGLError (* PFN_CGLQUERYRENDERERINFO)(GLuint display_mask, CGLRendererInfoObj * rend, GLint * nrend);
static PFN_CGLQUERYRENDERERINFO _CGLQueryRendererInfo_ptr = NULL;

static inline CGLError _CGLQueryRendererInfo(GLuint display_mask, CGLRendererInfoObj * rend, GLint * nrend) {
    const char *_name = "CGLQueryRendererInfo";
    if (!_CGLQueryRendererInfo_ptr) {
        _CGLQueryRendererInfo_ptr = (PFN_CGLQUERYRENDERERINFO)_getPublicProcAddress(_name);
        if (!_CGLQueryRendererInfo_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLQueryRendererInfo_ptr(display_mask, rend, nrend);
}

typedef CGLError (* PFN_CGLDESTROYRENDERERINFO)(CGLRendererInfoObj rend);
static PFN_CGLDESTROYRENDERERINFO _CGLDestroyRendererInfo_ptr = NULL;

static inline CGLError _CGLDestroyRendererInfo(CGLRendererInfoObj rend) {
    const char *_name = "CGLDestroyRendererInfo";
    if (!_CGLDestroyRendererInfo_ptr) {
        _CGLDestroyRendererInfo_ptr = (PFN_CGLDESTROYRENDERERINFO)_getPublicProcAddress(_name);
        if (!_CGLDestroyRendererInfo_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLDestroyRendererInfo_ptr(rend);
}

typedef CGLError (* PFN_CGLDESCRIBERENDERER)(CGLRendererInfoObj rend, GLint rend_num, CGLRendererProperty prop, GLint * value);
static PFN_CGLDESCRIBERENDERER _CGLDescribeRenderer_ptr = NULL;

static inline CGLError _CGLDescribeRenderer(CGLRendererInfoObj rend, GLint rend_num, CGLRendererProperty prop, GLint * value) {
    const char *_name = "CGLDescribeRenderer";
    if (!_CGLDescribeRenderer_ptr) {
        _CGLDescribeRenderer_ptr = (PFN_CGLDESCRIBERENDERER)_getPublicProcAddress(_name);
        if (!_CGLDescribeRenderer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLDescribeRenderer_ptr(rend, rend_num, prop, value);
}

typedef CGLError (* PFN_CGLCREATECONTEXT)(CGLPixelFormatObj pix, CGLContextObj share, CGLContextObj * ctx);
static PFN_CGLCREATECONTEXT _CGLCreateContext_ptr = NULL;

static inline CGLError _CGLCreateContext(CGLPixelFormatObj pix, CGLContextObj share, CGLContextObj * ctx) {
    const char *_name = "CGLCreateContext";
    if (!_CGLCreateContext_ptr) {
        _CGLCreateContext_ptr = (PFN_CGLCREATECONTEXT)_getPublicProcAddress(_name);
        if (!_CGLCreateContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLCreateContext_ptr(pix, share, ctx);
}

typedef CGLError (* PFN_CGLDESTROYCONTEXT)(CGLContextObj ctx);
static PFN_CGLDESTROYCONTEXT _CGLDestroyContext_ptr = NULL;

static inline CGLError _CGLDestroyContext(CGLContextObj ctx) {
    const char *_name = "CGLDestroyContext";
    if (!_CGLDestroyContext_ptr) {
        _CGLDestroyContext_ptr = (PFN_CGLDESTROYCONTEXT)_getPublicProcAddress(_name);
        if (!_CGLDestroyContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLDestroyContext_ptr(ctx);
}

typedef CGLError (* PFN_CGLCOPYCONTEXT)(CGLContextObj src, CGLContextObj dst, GLbitfield mask);
static PFN_CGLCOPYCONTEXT _CGLCopyContext_ptr = NULL;

static inline CGLError _CGLCopyContext(CGLContextObj src, CGLContextObj dst, GLbitfield mask) {
    const char *_name = "CGLCopyContext";
    if (!_CGLCopyContext_ptr) {
        _CGLCopyContext_ptr = (PFN_CGLCOPYCONTEXT)_getPublicProcAddress(_name);
        if (!_CGLCopyContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLCopyContext_ptr(src, dst, mask);
}

typedef CGLContextObj (* PFN_CGLRETAINCONTEXT)(CGLContextObj ctx);
static PFN_CGLRETAINCONTEXT _CGLRetainContext_ptr = NULL;

static inline CGLContextObj _CGLRetainContext(CGLContextObj ctx) {
    const char *_name = "CGLRetainContext";
    if (!_CGLRetainContext_ptr) {
        _CGLRetainContext_ptr = (PFN_CGLRETAINCONTEXT)_getPublicProcAddress(_name);
        if (!_CGLRetainContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLRetainContext_ptr(ctx);
}

typedef void (* PFN_CGLRELEASECONTEXT)(CGLContextObj ctx);
static PFN_CGLRELEASECONTEXT _CGLReleaseContext_ptr = NULL;

static inline void _CGLReleaseContext(CGLContextObj ctx) {
    const char *_name = "CGLReleaseContext";
    if (!_CGLReleaseContext_ptr) {
        _CGLReleaseContext_ptr = (PFN_CGLRELEASECONTEXT)_getPublicProcAddress(_name);
        if (!_CGLReleaseContext_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _CGLReleaseContext_ptr(ctx);
}

typedef GLuint (* PFN_CGLGETCONTEXTRETAINCOUNT)(CGLContextObj ctx);
static PFN_CGLGETCONTEXTRETAINCOUNT _CGLGetContextRetainCount_ptr = NULL;

static inline GLuint _CGLGetContextRetainCount(CGLContextObj ctx) {
    const char *_name = "CGLGetContextRetainCount";
    if (!_CGLGetContextRetainCount_ptr) {
        _CGLGetContextRetainCount_ptr = (PFN_CGLGETCONTEXTRETAINCOUNT)_getPublicProcAddress(_name);
        if (!_CGLGetContextRetainCount_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLGetContextRetainCount_ptr(ctx);
}

typedef CGLPixelFormatObj (* PFN_CGLGETPIXELFORMAT)(CGLContextObj ctx);
static PFN_CGLGETPIXELFORMAT _CGLGetPixelFormat_ptr = NULL;

static inline CGLPixelFormatObj _CGLGetPixelFormat(CGLContextObj ctx) {
    const char *_name = "CGLGetPixelFormat";
    if (!_CGLGetPixelFormat_ptr) {
        _CGLGetPixelFormat_ptr = (PFN_CGLGETPIXELFORMAT)_getPublicProcAddress(_name);
        if (!_CGLGetPixelFormat_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLGetPixelFormat_ptr(ctx);
}

typedef CGLError (* PFN_CGLCREATEPBUFFER)(GLsizei width, GLsizei height, GLenum target, GLenum internalFormat, GLint max_level, CGLPBufferObj * pbuffer);
static PFN_CGLCREATEPBUFFER _CGLCreatePBuffer_ptr = NULL;

static inline CGLError _CGLCreatePBuffer(GLsizei width, GLsizei height, GLenum target, GLenum internalFormat, GLint max_level, CGLPBufferObj * pbuffer) {
    const char *_name = "CGLCreatePBuffer";
    if (!_CGLCreatePBuffer_ptr) {
        _CGLCreatePBuffer_ptr = (PFN_CGLCREATEPBUFFER)_getPublicProcAddress(_name);
        if (!_CGLCreatePBuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLCreatePBuffer_ptr(width, height, target, internalFormat, max_level, pbuffer);
}

typedef CGLError (* PFN_CGLDESTROYPBUFFER)(CGLPBufferObj pbuffer);
static PFN_CGLDESTROYPBUFFER _CGLDestroyPBuffer_ptr = NULL;

static inline CGLError _CGLDestroyPBuffer(CGLPBufferObj pbuffer) {
    const char *_name = "CGLDestroyPBuffer";
    if (!_CGLDestroyPBuffer_ptr) {
        _CGLDestroyPBuffer_ptr = (PFN_CGLDESTROYPBUFFER)_getPublicProcAddress(_name);
        if (!_CGLDestroyPBuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLDestroyPBuffer_ptr(pbuffer);
}

typedef CGLError (* PFN_CGLDESCRIBEPBUFFER)(CGLPBufferObj obj, GLsizei * width, GLsizei * height, GLenum * target, GLenum * internalFormat, GLint * mipmap);
static PFN_CGLDESCRIBEPBUFFER _CGLDescribePBuffer_ptr = NULL;

static inline CGLError _CGLDescribePBuffer(CGLPBufferObj obj, GLsizei * width, GLsizei * height, GLenum * target, GLenum * internalFormat, GLint * mipmap) {
    const char *_name = "CGLDescribePBuffer";
    if (!_CGLDescribePBuffer_ptr) {
        _CGLDescribePBuffer_ptr = (PFN_CGLDESCRIBEPBUFFER)_getPublicProcAddress(_name);
        if (!_CGLDescribePBuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLDescribePBuffer_ptr(obj, width, height, target, internalFormat, mipmap);
}

typedef CGLError (* PFN_CGLTEXIMAGEPBUFFER)(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum source);
static PFN_CGLTEXIMAGEPBUFFER _CGLTexImagePBuffer_ptr = NULL;

static inline CGLError _CGLTexImagePBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum source) {
    const char *_name = "CGLTexImagePBuffer";
    if (!_CGLTexImagePBuffer_ptr) {
        _CGLTexImagePBuffer_ptr = (PFN_CGLTEXIMAGEPBUFFER)_getPublicProcAddress(_name);
        if (!_CGLTexImagePBuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLTexImagePBuffer_ptr(ctx, pbuffer, source);
}

typedef CGLPBufferObj (* PFN_CGLRETAINPBUFFER)(CGLPBufferObj pbuffer);
static PFN_CGLRETAINPBUFFER _CGLRetainPBuffer_ptr = NULL;

static inline CGLPBufferObj _CGLRetainPBuffer(CGLPBufferObj pbuffer) {
    const char *_name = "CGLRetainPBuffer";
    if (!_CGLRetainPBuffer_ptr) {
        _CGLRetainPBuffer_ptr = (PFN_CGLRETAINPBUFFER)_getPublicProcAddress(_name);
        if (!_CGLRetainPBuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLRetainPBuffer_ptr(pbuffer);
}

typedef void (* PFN_CGLRELEASEPBUFFER)(CGLPBufferObj pbuffer);
static PFN_CGLRELEASEPBUFFER _CGLReleasePBuffer_ptr = NULL;

static inline void _CGLReleasePBuffer(CGLPBufferObj pbuffer) {
    const char *_name = "CGLReleasePBuffer";
    if (!_CGLReleasePBuffer_ptr) {
        _CGLReleasePBuffer_ptr = (PFN_CGLRELEASEPBUFFER)_getPublicProcAddress(_name);
        if (!_CGLReleasePBuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _CGLReleasePBuffer_ptr(pbuffer);
}

typedef GLuint (* PFN_CGLGETPBUFFERRETAINCOUNT)(CGLPBufferObj pbuffer);
static PFN_CGLGETPBUFFERRETAINCOUNT _CGLGetPBufferRetainCount_ptr = NULL;

static inline GLuint _CGLGetPBufferRetainCount(CGLPBufferObj pbuffer) {
    const char *_name = "CGLGetPBufferRetainCount";
    if (!_CGLGetPBufferRetainCount_ptr) {
        _CGLGetPBufferRetainCount_ptr = (PFN_CGLGETPBUFFERRETAINCOUNT)_getPublicProcAddress(_name);
        if (!_CGLGetPBufferRetainCount_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLGetPBufferRetainCount_ptr(pbuffer);
}

typedef CGLError (* PFN_CGLSETOFFSCREEN)(CGLContextObj ctx, GLsizei width, GLsizei height, GLint rowbytes, void * baseaddr);
static PFN_CGLSETOFFSCREEN _CGLSetOffScreen_ptr = NULL;

static inline CGLError _CGLSetOffScreen(CGLContextObj ctx, GLsizei width, GLsizei height, GLint rowbytes, void * baseaddr) {
    const char *_name = "CGLSetOffScreen";
    if (!_CGLSetOffScreen_ptr) {
        _CGLSetOffScreen_ptr = (PFN_CGLSETOFFSCREEN)_getPublicProcAddress(_name);
        if (!_CGLSetOffScreen_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLSetOffScreen_ptr(ctx, width, height, rowbytes, baseaddr);
}

typedef CGLError (* PFN_CGLGETOFFSCREEN)(CGLContextObj ctx, GLsizei * width, GLsizei * height, GLint * rowbytes, void * * baseaddr);
static PFN_CGLGETOFFSCREEN _CGLGetOffScreen_ptr = NULL;

static inline CGLError _CGLGetOffScreen(CGLContextObj ctx, GLsizei * width, GLsizei * height, GLint * rowbytes, void * * baseaddr) {
    const char *_name = "CGLGetOffScreen";
    if (!_CGLGetOffScreen_ptr) {
        _CGLGetOffScreen_ptr = (PFN_CGLGETOFFSCREEN)_getPublicProcAddress(_name);
        if (!_CGLGetOffScreen_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLGetOffScreen_ptr(ctx, width, height, rowbytes, baseaddr);
}

typedef CGLError (* PFN_CGLSETFULLSCREEN)(CGLContextObj ctx);
static PFN_CGLSETFULLSCREEN _CGLSetFullScreen_ptr = NULL;

static inline CGLError _CGLSetFullScreen(CGLContextObj ctx) {
    const char *_name = "CGLSetFullScreen";
    if (!_CGLSetFullScreen_ptr) {
        _CGLSetFullScreen_ptr = (PFN_CGLSETFULLSCREEN)_getPublicProcAddress(_name);
        if (!_CGLSetFullScreen_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLSetFullScreen_ptr(ctx);
}

typedef CGLError (* PFN_CGLSETFULLSCREENONDISPLAY)(CGLContextObj ctx, GLuint display_mask);
static PFN_CGLSETFULLSCREENONDISPLAY _CGLSetFullScreenOnDisplay_ptr = NULL;

static inline CGLError _CGLSetFullScreenOnDisplay(CGLContextObj ctx, GLuint display_mask) {
    const char *_name = "CGLSetFullScreenOnDisplay";
    if (!_CGLSetFullScreenOnDisplay_ptr) {
        _CGLSetFullScreenOnDisplay_ptr = (PFN_CGLSETFULLSCREENONDISPLAY)_getPublicProcAddress(_name);
        if (!_CGLSetFullScreenOnDisplay_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLSetFullScreenOnDisplay_ptr(ctx, display_mask);
}

typedef CGLError (* PFN_CGLSETPBUFFER)(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum face, GLint level, GLint screen);
static PFN_CGLSETPBUFFER _CGLSetPBuffer_ptr = NULL;

static inline CGLError _CGLSetPBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum face, GLint level, GLint screen) {
    const char *_name = "CGLSetPBuffer";
    if (!_CGLSetPBuffer_ptr) {
        _CGLSetPBuffer_ptr = (PFN_CGLSETPBUFFER)_getPublicProcAddress(_name);
        if (!_CGLSetPBuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLSetPBuffer_ptr(ctx, pbuffer, face, level, screen);
}

typedef CGLError (* PFN_CGLGETPBUFFER)(CGLContextObj ctx, CGLPBufferObj * pbuffer, GLenum * face, GLint * level, GLint * screen);
static PFN_CGLGETPBUFFER _CGLGetPBuffer_ptr = NULL;

static inline CGLError _CGLGetPBuffer(CGLContextObj ctx, CGLPBufferObj * pbuffer, GLenum * face, GLint * level, GLint * screen) {
    const char *_name = "CGLGetPBuffer";
    if (!_CGLGetPBuffer_ptr) {
        _CGLGetPBuffer_ptr = (PFN_CGLGETPBUFFER)_getPublicProcAddress(_name);
        if (!_CGLGetPBuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLGetPBuffer_ptr(ctx, pbuffer, face, level, screen);
}

typedef CGLError (* PFN_CGLCLEARDRAWABLE)(CGLContextObj ctx);
static PFN_CGLCLEARDRAWABLE _CGLClearDrawable_ptr = NULL;

static inline CGLError _CGLClearDrawable(CGLContextObj ctx) {
    const char *_name = "CGLClearDrawable";
    if (!_CGLClearDrawable_ptr) {
        _CGLClearDrawable_ptr = (PFN_CGLCLEARDRAWABLE)_getPublicProcAddress(_name);
        if (!_CGLClearDrawable_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLClearDrawable_ptr(ctx);
}

typedef CGLError (* PFN_CGLFLUSHDRAWABLE)(CGLContextObj ctx);
static PFN_CGLFLUSHDRAWABLE _CGLFlushDrawable_ptr = NULL;

static inline CGLError _CGLFlushDrawable(CGLContextObj ctx) {
    const char *_name = "CGLFlushDrawable";
    if (!_CGLFlushDrawable_ptr) {
        _CGLFlushDrawable_ptr = (PFN_CGLFLUSHDRAWABLE)_getPublicProcAddress(_name);
        if (!_CGLFlushDrawable_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLFlushDrawable_ptr(ctx);
}

typedef CGLError (* PFN_CGLENABLE)(CGLContextObj ctx, CGLContextEnable pname);
static PFN_CGLENABLE _CGLEnable_ptr = NULL;

static inline CGLError _CGLEnable(CGLContextObj ctx, CGLContextEnable pname) {
    const char *_name = "CGLEnable";
    if (!_CGLEnable_ptr) {
        _CGLEnable_ptr = (PFN_CGLENABLE)_getPublicProcAddress(_name);
        if (!_CGLEnable_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLEnable_ptr(ctx, pname);
}

typedef CGLError (* PFN_CGLDISABLE)(CGLContextObj ctx, CGLContextEnable pname);
static PFN_CGLDISABLE _CGLDisable_ptr = NULL;

static inline CGLError _CGLDisable(CGLContextObj ctx, CGLContextEnable pname) {
    const char *_name = "CGLDisable";
    if (!_CGLDisable_ptr) {
        _CGLDisable_ptr = (PFN_CGLDISABLE)_getPublicProcAddress(_name);
        if (!_CGLDisable_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLDisable_ptr(ctx, pname);
}

typedef CGLError (* PFN_CGLISENABLED)(CGLContextObj ctx, CGLContextEnable pname, GLint * enable);
static PFN_CGLISENABLED _CGLIsEnabled_ptr = NULL;

static inline CGLError _CGLIsEnabled(CGLContextObj ctx, CGLContextEnable pname, GLint * enable) {
    const char *_name = "CGLIsEnabled";
    if (!_CGLIsEnabled_ptr) {
        _CGLIsEnabled_ptr = (PFN_CGLISENABLED)_getPublicProcAddress(_name);
        if (!_CGLIsEnabled_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLIsEnabled_ptr(ctx, pname, enable);
}

typedef CGLError (* PFN_CGLSETPARAMETER)(CGLContextObj ctx, CGLContextParameter pname, const GLint * params);
static PFN_CGLSETPARAMETER _CGLSetParameter_ptr = NULL;

static inline CGLError _CGLSetParameter(CGLContextObj ctx, CGLContextParameter pname, const GLint * params) {
    const char *_name = "CGLSetParameter";
    if (!_CGLSetParameter_ptr) {
        _CGLSetParameter_ptr = (PFN_CGLSETPARAMETER)_getPublicProcAddress(_name);
        if (!_CGLSetParameter_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLSetParameter_ptr(ctx, pname, params);
}

typedef CGLError (* PFN_CGLGETPARAMETER)(CGLContextObj ctx, CGLContextParameter pname, GLint * params);
static PFN_CGLGETPARAMETER _CGLGetParameter_ptr = NULL;

static inline CGLError _CGLGetParameter(CGLContextObj ctx, CGLContextParameter pname, GLint * params) {
    const char *_name = "CGLGetParameter";
    if (!_CGLGetParameter_ptr) {
        _CGLGetParameter_ptr = (PFN_CGLGETPARAMETER)_getPublicProcAddress(_name);
        if (!_CGLGetParameter_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLGetParameter_ptr(ctx, pname, params);
}

typedef CGLError (* PFN_CGLSETVIRTUALSCREEN)(CGLContextObj ctx, GLint screen);
static PFN_CGLSETVIRTUALSCREEN _CGLSetVirtualScreen_ptr = NULL;

static inline CGLError _CGLSetVirtualScreen(CGLContextObj ctx, GLint screen) {
    const char *_name = "CGLSetVirtualScreen";
    if (!_CGLSetVirtualScreen_ptr) {
        _CGLSetVirtualScreen_ptr = (PFN_CGLSETVIRTUALSCREEN)_getPublicProcAddress(_name);
        if (!_CGLSetVirtualScreen_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLSetVirtualScreen_ptr(ctx, screen);
}

typedef CGLError (* PFN_CGLGETVIRTUALSCREEN)(CGLContextObj ctx, GLint * screen);
static PFN_CGLGETVIRTUALSCREEN _CGLGetVirtualScreen_ptr = NULL;

static inline CGLError _CGLGetVirtualScreen(CGLContextObj ctx, GLint * screen) {
    const char *_name = "CGLGetVirtualScreen";
    if (!_CGLGetVirtualScreen_ptr) {
        _CGLGetVirtualScreen_ptr = (PFN_CGLGETVIRTUALSCREEN)_getPublicProcAddress(_name);
        if (!_CGLGetVirtualScreen_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLGetVirtualScreen_ptr(ctx, screen);
}

typedef CGLError (* PFN_CGLSETGLOBALOPTION)(CGLGlobalOption pname, const GLint * params);
static PFN_CGLSETGLOBALOPTION _CGLSetGlobalOption_ptr = NULL;

static inline CGLError _CGLSetGlobalOption(CGLGlobalOption pname, const GLint * params) {
    const char *_name = "CGLSetGlobalOption";
    if (!_CGLSetGlobalOption_ptr) {
        _CGLSetGlobalOption_ptr = (PFN_CGLSETGLOBALOPTION)_getPublicProcAddress(_name);
        if (!_CGLSetGlobalOption_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLSetGlobalOption_ptr(pname, params);
}

typedef CGLError (* PFN_CGLGETGLOBALOPTION)(CGLGlobalOption pname, GLint * params);
static PFN_CGLGETGLOBALOPTION _CGLGetGlobalOption_ptr = NULL;

static inline CGLError _CGLGetGlobalOption(CGLGlobalOption pname, GLint * params) {
    const char *_name = "CGLGetGlobalOption";
    if (!_CGLGetGlobalOption_ptr) {
        _CGLGetGlobalOption_ptr = (PFN_CGLGETGLOBALOPTION)_getPublicProcAddress(_name);
        if (!_CGLGetGlobalOption_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLGetGlobalOption_ptr(pname, params);
}

typedef CGLError (* PFN_CGLSETOPTION)(CGLGlobalOption pname, GLint param);
static PFN_CGLSETOPTION _CGLSetOption_ptr = NULL;

static inline CGLError _CGLSetOption(CGLGlobalOption pname, GLint param) {
    const char *_name = "CGLSetOption";
    if (!_CGLSetOption_ptr) {
        _CGLSetOption_ptr = (PFN_CGLSETOPTION)_getPublicProcAddress(_name);
        if (!_CGLSetOption_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLSetOption_ptr(pname, param);
}

typedef CGLError (* PFN_CGLGETOPTION)(CGLGlobalOption pname, GLint * param);
static PFN_CGLGETOPTION _CGLGetOption_ptr = NULL;

static inline CGLError _CGLGetOption(CGLGlobalOption pname, GLint * param) {
    const char *_name = "CGLGetOption";
    if (!_CGLGetOption_ptr) {
        _CGLGetOption_ptr = (PFN_CGLGETOPTION)_getPublicProcAddress(_name);
        if (!_CGLGetOption_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLGetOption_ptr(pname, param);
}

typedef CGLError (* PFN_CGLLOCKCONTEXT)(CGLContextObj ctx);
static PFN_CGLLOCKCONTEXT _CGLLockContext_ptr = NULL;

static inline CGLError _CGLLockContext(CGLContextObj ctx) {
    const char *_name = "CGLLockContext";
    if (!_CGLLockContext_ptr) {
        _CGLLockContext_ptr = (PFN_CGLLOCKCONTEXT)_getPublicProcAddress(_name);
        if (!_CGLLockContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLLockContext_ptr(ctx);
}

typedef CGLError (* PFN_CGLUNLOCKCONTEXT)(CGLContextObj ctx);
static PFN_CGLUNLOCKCONTEXT _CGLUnlockContext_ptr = NULL;

static inline CGLError _CGLUnlockContext(CGLContextObj ctx) {
    const char *_name = "CGLUnlockContext";
    if (!_CGLUnlockContext_ptr) {
        _CGLUnlockContext_ptr = (PFN_CGLUNLOCKCONTEXT)_getPublicProcAddress(_name);
        if (!_CGLUnlockContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLUnlockContext_ptr(ctx);
}

typedef void (* PFN_CGLGETVERSION)(GLint * majorvers, GLint * minorvers);
static PFN_CGLGETVERSION _CGLGetVersion_ptr = NULL;

static inline void _CGLGetVersion(GLint * majorvers, GLint * minorvers) {
    const char *_name = "CGLGetVersion";
    if (!_CGLGetVersion_ptr) {
        _CGLGetVersion_ptr = (PFN_CGLGETVERSION)_getPublicProcAddress(_name);
        if (!_CGLGetVersion_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _CGLGetVersion_ptr(majorvers, minorvers);
}

typedef const char * (* PFN_CGLERRORSTRING)(CGLError error);
static PFN_CGLERRORSTRING _CGLErrorString_ptr = NULL;

static inline const char * _CGLErrorString(CGLError error) {
    const char *_name = "CGLErrorString";
    if (!_CGLErrorString_ptr) {
        _CGLErrorString_ptr = (PFN_CGLERRORSTRING)_getPublicProcAddress(_name);
        if (!_CGLErrorString_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLErrorString_ptr(error);
}

typedef CGLError (* PFN_CGLTEXIMAGEIOSURFACE2D)(CGLContextObj ctx, GLenum target, GLenum internal_format, GLsizei width, GLsizei height, GLenum format, GLenum type, IOSurfaceRef ioSurface, GLuint plane);
static PFN_CGLTEXIMAGEIOSURFACE2D _CGLTexImageIOSurface2D_ptr = NULL;

static inline CGLError _CGLTexImageIOSurface2D(CGLContextObj ctx, GLenum target, GLenum internal_format, GLsizei width, GLsizei height, GLenum format, GLenum type, IOSurfaceRef ioSurface, GLuint plane) {
    const char *_name = "CGLTexImageIOSurface2D";
    if (!_CGLTexImageIOSurface2D_ptr) {
        _CGLTexImageIOSurface2D_ptr = (PFN_CGLTEXIMAGEIOSURFACE2D)_getPublicProcAddress(_name);
        if (!_CGLTexImageIOSurface2D_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLTexImageIOSurface2D_ptr(ctx, target, internal_format, width, height, format, type, ioSurface, plane);
}

typedef CGLShareGroupObj (* PFN_CGLGETSHAREGROUP)(CGLContextObj ctx);
static PFN_CGLGETSHAREGROUP _CGLGetShareGroup_ptr = NULL;

static inline CGLShareGroupObj _CGLGetShareGroup(CGLContextObj ctx) {
    const char *_name = "CGLGetShareGroup";
    if (!_CGLGetShareGroup_ptr) {
        _CGLGetShareGroup_ptr = (PFN_CGLGETSHAREGROUP)_getPublicProcAddress(_name);
        if (!_CGLGetShareGroup_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLGetShareGroup_ptr(ctx);
}

typedef CGLError (* PFN_CGLSETSURFACE)(CGLContextObj ctx, CGSConnectionID cid, CGSWindowID wid, CGSSurfaceID sid);
static PFN_CGLSETSURFACE _CGLSetSurface_ptr = NULL;

static inline CGLError _CGLSetSurface(CGLContextObj ctx, CGSConnectionID cid, CGSWindowID wid, CGSSurfaceID sid) {
    const char *_name = "CGLSetSurface";
    if (!_CGLSetSurface_ptr) {
        _CGLSetSurface_ptr = (PFN_CGLSETSURFACE)_getPublicProcAddress(_name);
        if (!_CGLSetSurface_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLSetSurface_ptr(ctx, cid, wid, sid);
}

typedef CGLError (* PFN_CGLGETSURFACE)(CGLContextObj ctx, CGSConnectionID * cid, CGSWindowID * wid, CGSSurfaceID * sid);
static PFN_CGLGETSURFACE _CGLGetSurface_ptr = NULL;

static inline CGLError _CGLGetSurface(CGLContextObj ctx, CGSConnectionID * cid, CGSWindowID * wid, CGSSurfaceID * sid) {
    const char *_name = "CGLGetSurface";
    if (!_CGLGetSurface_ptr) {
        _CGLGetSurface_ptr = (PFN_CGLGETSURFACE)_getPublicProcAddress(_name);
        if (!_CGLGetSurface_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLGetSurface_ptr(ctx, cid, wid, sid);
}

typedef CGLError (* PFN_CGLUPDATECONTEXT)(CGLContextObj ctx);
static PFN_CGLUPDATECONTEXT _CGLUpdateContext_ptr = NULL;

static inline CGLError _CGLUpdateContext(CGLContextObj ctx) {
    const char *_name = "CGLUpdateContext";
    if (!_CGLUpdateContext_ptr) {
        _CGLUpdateContext_ptr = (PFN_CGLUPDATECONTEXT)_getPublicProcAddress(_name);
        if (!_CGLUpdateContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLUpdateContext_ptr(ctx);
}

typedef CGLError (* PFN_CGLOPENCLMUXLOCKDOWN)(void);
static PFN_CGLOPENCLMUXLOCKDOWN _CGLOpenCLMuxLockDown_ptr = NULL;

static inline CGLError _CGLOpenCLMuxLockDown(void) {
    const char *_name = "CGLOpenCLMuxLockDown";
    if (!_CGLOpenCLMuxLockDown_ptr) {
        _CGLOpenCLMuxLockDown_ptr = (PFN_CGLOPENCLMUXLOCKDOWN)_getPublicProcAddress(_name);
        if (!_CGLOpenCLMuxLockDown_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _CGLOpenCLMuxLockDown_ptr();
}

#ifdef RETRACE
#define CGLSetCurrentContext _CGLSetCurrentContext
#define CGLGetCurrentContext _CGLGetCurrentContext
#define CGLChoosePixelFormat _CGLChoosePixelFormat
#define CGLDestroyPixelFormat _CGLDestroyPixelFormat
#define CGLDescribePixelFormat _CGLDescribePixelFormat
#define CGLReleasePixelFormat _CGLReleasePixelFormat
#define CGLRetainPixelFormat _CGLRetainPixelFormat
#define CGLGetPixelFormatRetainCount _CGLGetPixelFormatRetainCount
#define CGLQueryRendererInfo _CGLQueryRendererInfo
#define CGLDestroyRendererInfo _CGLDestroyRendererInfo
#define CGLDescribeRenderer _CGLDescribeRenderer
#define CGLCreateContext _CGLCreateContext
#define CGLDestroyContext _CGLDestroyContext
#define CGLCopyContext _CGLCopyContext
#define CGLRetainContext _CGLRetainContext
#define CGLReleaseContext _CGLReleaseContext
#define CGLGetContextRetainCount _CGLGetContextRetainCount
#define CGLGetPixelFormat _CGLGetPixelFormat
#define CGLCreatePBuffer _CGLCreatePBuffer
#define CGLDestroyPBuffer _CGLDestroyPBuffer
#define CGLDescribePBuffer _CGLDescribePBuffer
#define CGLTexImagePBuffer _CGLTexImagePBuffer
#define CGLRetainPBuffer _CGLRetainPBuffer
#define CGLReleasePBuffer _CGLReleasePBuffer
#define CGLGetPBufferRetainCount _CGLGetPBufferRetainCount
#define CGLSetOffScreen _CGLSetOffScreen
#define CGLGetOffScreen _CGLGetOffScreen
#define CGLSetFullScreen _CGLSetFullScreen
#define CGLSetFullScreenOnDisplay _CGLSetFullScreenOnDisplay
#define CGLSetPBuffer _CGLSetPBuffer
#define CGLGetPBuffer _CGLGetPBuffer
#define CGLClearDrawable _CGLClearDrawable
#define CGLFlushDrawable _CGLFlushDrawable
#define CGLEnable _CGLEnable
#define CGLDisable _CGLDisable
#define CGLIsEnabled _CGLIsEnabled
#define CGLSetParameter _CGLSetParameter
#define CGLGetParameter _CGLGetParameter
#define CGLSetVirtualScreen _CGLSetVirtualScreen
#define CGLGetVirtualScreen _CGLGetVirtualScreen
#define CGLSetGlobalOption _CGLSetGlobalOption
#define CGLGetGlobalOption _CGLGetGlobalOption
#define CGLSetOption _CGLSetOption
#define CGLGetOption _CGLGetOption
#define CGLLockContext _CGLLockContext
#define CGLUnlockContext _CGLUnlockContext
#define CGLGetVersion _CGLGetVersion
#define CGLErrorString _CGLErrorString
#define CGLTexImageIOSurface2D _CGLTexImageIOSurface2D
#define CGLGetShareGroup _CGLGetShareGroup
#define CGLSetSurface _CGLSetSurface
#define CGLGetSurface _CGLGetSurface
#define CGLUpdateContext _CGLUpdateContext
#define CGLOpenCLMuxLockDown _CGLOpenCLMuxLockDown
#endif /* RETRACE */


#elif defined(HAVE_X11)

typedef XVisualInfo * (* PFN_GLXCHOOSEVISUAL)(Display * dpy, int screen, int * attribList);
static PFN_GLXCHOOSEVISUAL _glXChooseVisual_ptr = NULL;

static inline XVisualInfo * _glXChooseVisual(Display * dpy, int screen, int * attribList) {
    const char *_name = "glXChooseVisual";
    if (!_glXChooseVisual_ptr) {
        _glXChooseVisual_ptr = (PFN_GLXCHOOSEVISUAL)_getPublicProcAddress(_name);
        if (!_glXChooseVisual_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXChooseVisual_ptr(dpy, screen, attribList);
}

typedef GLXContext (* PFN_GLXCREATECONTEXT)(Display * dpy, XVisualInfo * vis, GLXContext shareList, int direct);
static PFN_GLXCREATECONTEXT _glXCreateContext_ptr = NULL;

static inline GLXContext _glXCreateContext(Display * dpy, XVisualInfo * vis, GLXContext shareList, int direct) {
    const char *_name = "glXCreateContext";
    if (!_glXCreateContext_ptr) {
        _glXCreateContext_ptr = (PFN_GLXCREATECONTEXT)_getPublicProcAddress(_name);
        if (!_glXCreateContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXCreateContext_ptr(dpy, vis, shareList, direct);
}

typedef void (* PFN_GLXDESTROYCONTEXT)(Display * dpy, GLXContext ctx);
static PFN_GLXDESTROYCONTEXT _glXDestroyContext_ptr = NULL;

static inline void _glXDestroyContext(Display * dpy, GLXContext ctx) {
    const char *_name = "glXDestroyContext";
    if (!_glXDestroyContext_ptr) {
        _glXDestroyContext_ptr = (PFN_GLXDESTROYCONTEXT)_getPublicProcAddress(_name);
        if (!_glXDestroyContext_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXDestroyContext_ptr(dpy, ctx);
}

typedef int (* PFN_GLXMAKECURRENT)(Display * dpy, GLXDrawable drawable, GLXContext ctx);
static PFN_GLXMAKECURRENT _glXMakeCurrent_ptr = NULL;

static inline int _glXMakeCurrent(Display * dpy, GLXDrawable drawable, GLXContext ctx) {
    const char *_name = "glXMakeCurrent";
    if (!_glXMakeCurrent_ptr) {
        _glXMakeCurrent_ptr = (PFN_GLXMAKECURRENT)_getPublicProcAddress(_name);
        if (!_glXMakeCurrent_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXMakeCurrent_ptr(dpy, drawable, ctx);
}

typedef void (* PFN_GLXCOPYCONTEXT)(Display * dpy, GLXContext src, GLXContext dst, unsigned long mask);
static PFN_GLXCOPYCONTEXT _glXCopyContext_ptr = NULL;

static inline void _glXCopyContext(Display * dpy, GLXContext src, GLXContext dst, unsigned long mask) {
    const char *_name = "glXCopyContext";
    if (!_glXCopyContext_ptr) {
        _glXCopyContext_ptr = (PFN_GLXCOPYCONTEXT)_getPublicProcAddress(_name);
        if (!_glXCopyContext_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXCopyContext_ptr(dpy, src, dst, mask);
}

typedef void (* PFN_GLXSWAPBUFFERS)(Display * dpy, GLXDrawable drawable);
static PFN_GLXSWAPBUFFERS _glXSwapBuffers_ptr = NULL;

static inline void _glXSwapBuffers(Display * dpy, GLXDrawable drawable) {
    const char *_name = "glXSwapBuffers";
    if (!_glXSwapBuffers_ptr) {
        _glXSwapBuffers_ptr = (PFN_GLXSWAPBUFFERS)_getPublicProcAddress(_name);
        if (!_glXSwapBuffers_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXSwapBuffers_ptr(dpy, drawable);
}

typedef GLXPixmap (* PFN_GLXCREATEGLXPIXMAP)(Display * dpy, XVisualInfo * visual, Pixmap pixmap);
static PFN_GLXCREATEGLXPIXMAP _glXCreateGLXPixmap_ptr = NULL;

static inline GLXPixmap _glXCreateGLXPixmap(Display * dpy, XVisualInfo * visual, Pixmap pixmap) {
    const char *_name = "glXCreateGLXPixmap";
    if (!_glXCreateGLXPixmap_ptr) {
        _glXCreateGLXPixmap_ptr = (PFN_GLXCREATEGLXPIXMAP)_getPublicProcAddress(_name);
        if (!_glXCreateGLXPixmap_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXCreateGLXPixmap_ptr(dpy, visual, pixmap);
}

typedef void (* PFN_GLXDESTROYGLXPIXMAP)(Display * dpy, GLXPixmap pixmap);
static PFN_GLXDESTROYGLXPIXMAP _glXDestroyGLXPixmap_ptr = NULL;

static inline void _glXDestroyGLXPixmap(Display * dpy, GLXPixmap pixmap) {
    const char *_name = "glXDestroyGLXPixmap";
    if (!_glXDestroyGLXPixmap_ptr) {
        _glXDestroyGLXPixmap_ptr = (PFN_GLXDESTROYGLXPIXMAP)_getPublicProcAddress(_name);
        if (!_glXDestroyGLXPixmap_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXDestroyGLXPixmap_ptr(dpy, pixmap);
}

typedef int (* PFN_GLXQUERYEXTENSION)(Display * dpy, int * errorb, int * event);
static PFN_GLXQUERYEXTENSION _glXQueryExtension_ptr = NULL;

static inline int _glXQueryExtension(Display * dpy, int * errorb, int * event) {
    const char *_name = "glXQueryExtension";
    if (!_glXQueryExtension_ptr) {
        _glXQueryExtension_ptr = (PFN_GLXQUERYEXTENSION)_getPublicProcAddress(_name);
        if (!_glXQueryExtension_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXQueryExtension_ptr(dpy, errorb, event);
}

typedef int (* PFN_GLXQUERYVERSION)(Display * dpy, int * maj, int * min);
static PFN_GLXQUERYVERSION _glXQueryVersion_ptr = NULL;

static inline int _glXQueryVersion(Display * dpy, int * maj, int * min) {
    const char *_name = "glXQueryVersion";
    if (!_glXQueryVersion_ptr) {
        _glXQueryVersion_ptr = (PFN_GLXQUERYVERSION)_getPublicProcAddress(_name);
        if (!_glXQueryVersion_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXQueryVersion_ptr(dpy, maj, min);
}

typedef int (* PFN_GLXISDIRECT)(Display * dpy, GLXContext ctx);
static PFN_GLXISDIRECT _glXIsDirect_ptr = NULL;

static inline int _glXIsDirect(Display * dpy, GLXContext ctx) {
    const char *_name = "glXIsDirect";
    if (!_glXIsDirect_ptr) {
        _glXIsDirect_ptr = (PFN_GLXISDIRECT)_getPublicProcAddress(_name);
        if (!_glXIsDirect_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXIsDirect_ptr(dpy, ctx);
}

typedef int (* PFN_GLXGETCONFIG)(Display * dpy, XVisualInfo * visual, int attrib, int * value);
static PFN_GLXGETCONFIG _glXGetConfig_ptr = NULL;

static inline int _glXGetConfig(Display * dpy, XVisualInfo * visual, int attrib, int * value) {
    const char *_name = "glXGetConfig";
    if (!_glXGetConfig_ptr) {
        _glXGetConfig_ptr = (PFN_GLXGETCONFIG)_getPublicProcAddress(_name);
        if (!_glXGetConfig_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetConfig_ptr(dpy, visual, attrib, value);
}

typedef GLXContext (* PFN_GLXGETCURRENTCONTEXT)(void);
static PFN_GLXGETCURRENTCONTEXT _glXGetCurrentContext_ptr = NULL;

static inline GLXContext _glXGetCurrentContext(void) {
    const char *_name = "glXGetCurrentContext";
    if (!_glXGetCurrentContext_ptr) {
        _glXGetCurrentContext_ptr = (PFN_GLXGETCURRENTCONTEXT)_getPublicProcAddress(_name);
        if (!_glXGetCurrentContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetCurrentContext_ptr();
}

typedef GLXDrawable (* PFN_GLXGETCURRENTDRAWABLE)(void);
static PFN_GLXGETCURRENTDRAWABLE _glXGetCurrentDrawable_ptr = NULL;

static inline GLXDrawable _glXGetCurrentDrawable(void) {
    const char *_name = "glXGetCurrentDrawable";
    if (!_glXGetCurrentDrawable_ptr) {
        _glXGetCurrentDrawable_ptr = (PFN_GLXGETCURRENTDRAWABLE)_getPublicProcAddress(_name);
        if (!_glXGetCurrentDrawable_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetCurrentDrawable_ptr();
}

typedef void (* PFN_GLXWAITGL)(void);
static PFN_GLXWAITGL _glXWaitGL_ptr = NULL;

static inline void _glXWaitGL(void) {
    const char *_name = "glXWaitGL";
    if (!_glXWaitGL_ptr) {
        _glXWaitGL_ptr = (PFN_GLXWAITGL)_getPublicProcAddress(_name);
        if (!_glXWaitGL_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXWaitGL_ptr();
}

typedef void (* PFN_GLXWAITX)(void);
static PFN_GLXWAITX _glXWaitX_ptr = NULL;

static inline void _glXWaitX(void) {
    const char *_name = "glXWaitX";
    if (!_glXWaitX_ptr) {
        _glXWaitX_ptr = (PFN_GLXWAITX)_getPublicProcAddress(_name);
        if (!_glXWaitX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXWaitX_ptr();
}

typedef void (* PFN_GLXUSEXFONT)(Font font, int first, int count, int list);
static PFN_GLXUSEXFONT _glXUseXFont_ptr = NULL;

static inline void _glXUseXFont(Font font, int first, int count, int list) {
    const char *_name = "glXUseXFont";
    if (!_glXUseXFont_ptr) {
        _glXUseXFont_ptr = (PFN_GLXUSEXFONT)_getPublicProcAddress(_name);
        if (!_glXUseXFont_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXUseXFont_ptr(font, first, count, list);
}

typedef const char * (* PFN_GLXQUERYEXTENSIONSSTRING)(Display * dpy, int screen);
static PFN_GLXQUERYEXTENSIONSSTRING _glXQueryExtensionsString_ptr = NULL;

static inline const char * _glXQueryExtensionsString(Display * dpy, int screen) {
    const char *_name = "glXQueryExtensionsString";
    if (!_glXQueryExtensionsString_ptr) {
        _glXQueryExtensionsString_ptr = (PFN_GLXQUERYEXTENSIONSSTRING)_getPublicProcAddress(_name);
        if (!_glXQueryExtensionsString_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXQueryExtensionsString_ptr(dpy, screen);
}

typedef const char * (* PFN_GLXQUERYSERVERSTRING)(Display * dpy, int screen, int name);
static PFN_GLXQUERYSERVERSTRING _glXQueryServerString_ptr = NULL;

static inline const char * _glXQueryServerString(Display * dpy, int screen, int name) {
    const char *_name = "glXQueryServerString";
    if (!_glXQueryServerString_ptr) {
        _glXQueryServerString_ptr = (PFN_GLXQUERYSERVERSTRING)_getPublicProcAddress(_name);
        if (!_glXQueryServerString_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXQueryServerString_ptr(dpy, screen, name);
}

typedef const char * (* PFN_GLXGETCLIENTSTRING)(Display * dpy, int name);
static PFN_GLXGETCLIENTSTRING _glXGetClientString_ptr = NULL;

static inline const char * _glXGetClientString(Display * dpy, int name) {
    const char *_name = "glXGetClientString";
    if (!_glXGetClientString_ptr) {
        _glXGetClientString_ptr = (PFN_GLXGETCLIENTSTRING)_getPublicProcAddress(_name);
        if (!_glXGetClientString_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetClientString_ptr(dpy, name);
}

typedef Display * (* PFN_GLXGETCURRENTDISPLAY)(void);
static PFN_GLXGETCURRENTDISPLAY _glXGetCurrentDisplay_ptr = NULL;

static inline Display * _glXGetCurrentDisplay(void) {
    const char *_name = "glXGetCurrentDisplay";
    if (!_glXGetCurrentDisplay_ptr) {
        _glXGetCurrentDisplay_ptr = (PFN_GLXGETCURRENTDISPLAY)_getPublicProcAddress(_name);
        if (!_glXGetCurrentDisplay_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetCurrentDisplay_ptr();
}

typedef GLXFBConfig * (* PFN_GLXCHOOSEFBCONFIG)(Display * dpy, int screen, const int * attribList, int * nitems);
static PFN_GLXCHOOSEFBCONFIG _glXChooseFBConfig_ptr = NULL;

static inline GLXFBConfig * _glXChooseFBConfig(Display * dpy, int screen, const int * attribList, int * nitems) {
    const char *_name = "glXChooseFBConfig";
    if (!_glXChooseFBConfig_ptr) {
        _glXChooseFBConfig_ptr = (PFN_GLXCHOOSEFBCONFIG)_getPublicProcAddress(_name);
        if (!_glXChooseFBConfig_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXChooseFBConfig_ptr(dpy, screen, attribList, nitems);
}

typedef int (* PFN_GLXGETFBCONFIGATTRIB)(Display * dpy, GLXFBConfig config, int attribute, int * value);
static PFN_GLXGETFBCONFIGATTRIB _glXGetFBConfigAttrib_ptr = NULL;

static inline int _glXGetFBConfigAttrib(Display * dpy, GLXFBConfig config, int attribute, int * value) {
    const char *_name = "glXGetFBConfigAttrib";
    if (!_glXGetFBConfigAttrib_ptr) {
        _glXGetFBConfigAttrib_ptr = (PFN_GLXGETFBCONFIGATTRIB)_getPublicProcAddress(_name);
        if (!_glXGetFBConfigAttrib_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetFBConfigAttrib_ptr(dpy, config, attribute, value);
}

typedef GLXFBConfig * (* PFN_GLXGETFBCONFIGS)(Display * dpy, int screen, int * nelements);
static PFN_GLXGETFBCONFIGS _glXGetFBConfigs_ptr = NULL;

static inline GLXFBConfig * _glXGetFBConfigs(Display * dpy, int screen, int * nelements) {
    const char *_name = "glXGetFBConfigs";
    if (!_glXGetFBConfigs_ptr) {
        _glXGetFBConfigs_ptr = (PFN_GLXGETFBCONFIGS)_getPublicProcAddress(_name);
        if (!_glXGetFBConfigs_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetFBConfigs_ptr(dpy, screen, nelements);
}

typedef XVisualInfo * (* PFN_GLXGETVISUALFROMFBCONFIG)(Display * dpy, GLXFBConfig config);
static PFN_GLXGETVISUALFROMFBCONFIG _glXGetVisualFromFBConfig_ptr = NULL;

static inline XVisualInfo * _glXGetVisualFromFBConfig(Display * dpy, GLXFBConfig config) {
    const char *_name = "glXGetVisualFromFBConfig";
    if (!_glXGetVisualFromFBConfig_ptr) {
        _glXGetVisualFromFBConfig_ptr = (PFN_GLXGETVISUALFROMFBCONFIG)_getPublicProcAddress(_name);
        if (!_glXGetVisualFromFBConfig_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetVisualFromFBConfig_ptr(dpy, config);
}

typedef GLXWindow (* PFN_GLXCREATEWINDOW)(Display * dpy, GLXFBConfig config, Window win, const int * attribList);
static PFN_GLXCREATEWINDOW _glXCreateWindow_ptr = NULL;

static inline GLXWindow _glXCreateWindow(Display * dpy, GLXFBConfig config, Window win, const int * attribList) {
    const char *_name = "glXCreateWindow";
    if (!_glXCreateWindow_ptr) {
        _glXCreateWindow_ptr = (PFN_GLXCREATEWINDOW)_getPublicProcAddress(_name);
        if (!_glXCreateWindow_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXCreateWindow_ptr(dpy, config, win, attribList);
}

typedef void (* PFN_GLXDESTROYWINDOW)(Display * dpy, GLXWindow window);
static PFN_GLXDESTROYWINDOW _glXDestroyWindow_ptr = NULL;

static inline void _glXDestroyWindow(Display * dpy, GLXWindow window) {
    const char *_name = "glXDestroyWindow";
    if (!_glXDestroyWindow_ptr) {
        _glXDestroyWindow_ptr = (PFN_GLXDESTROYWINDOW)_getPublicProcAddress(_name);
        if (!_glXDestroyWindow_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXDestroyWindow_ptr(dpy, window);
}

typedef GLXPixmap (* PFN_GLXCREATEPIXMAP)(Display * dpy, GLXFBConfig config, Pixmap pixmap, const int * attribList);
static PFN_GLXCREATEPIXMAP _glXCreatePixmap_ptr = NULL;

static inline GLXPixmap _glXCreatePixmap(Display * dpy, GLXFBConfig config, Pixmap pixmap, const int * attribList) {
    const char *_name = "glXCreatePixmap";
    if (!_glXCreatePixmap_ptr) {
        _glXCreatePixmap_ptr = (PFN_GLXCREATEPIXMAP)_getPublicProcAddress(_name);
        if (!_glXCreatePixmap_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXCreatePixmap_ptr(dpy, config, pixmap, attribList);
}

typedef void (* PFN_GLXDESTROYPIXMAP)(Display * dpy, GLXPixmap pixmap);
static PFN_GLXDESTROYPIXMAP _glXDestroyPixmap_ptr = NULL;

static inline void _glXDestroyPixmap(Display * dpy, GLXPixmap pixmap) {
    const char *_name = "glXDestroyPixmap";
    if (!_glXDestroyPixmap_ptr) {
        _glXDestroyPixmap_ptr = (PFN_GLXDESTROYPIXMAP)_getPublicProcAddress(_name);
        if (!_glXDestroyPixmap_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXDestroyPixmap_ptr(dpy, pixmap);
}

typedef GLXPbuffer (* PFN_GLXCREATEPBUFFER)(Display * dpy, GLXFBConfig config, const int * attribList);
static PFN_GLXCREATEPBUFFER _glXCreatePbuffer_ptr = NULL;

static inline GLXPbuffer _glXCreatePbuffer(Display * dpy, GLXFBConfig config, const int * attribList) {
    const char *_name = "glXCreatePbuffer";
    if (!_glXCreatePbuffer_ptr) {
        _glXCreatePbuffer_ptr = (PFN_GLXCREATEPBUFFER)_getPublicProcAddress(_name);
        if (!_glXCreatePbuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXCreatePbuffer_ptr(dpy, config, attribList);
}

typedef void (* PFN_GLXDESTROYPBUFFER)(Display * dpy, GLXPbuffer pbuf);
static PFN_GLXDESTROYPBUFFER _glXDestroyPbuffer_ptr = NULL;

static inline void _glXDestroyPbuffer(Display * dpy, GLXPbuffer pbuf) {
    const char *_name = "glXDestroyPbuffer";
    if (!_glXDestroyPbuffer_ptr) {
        _glXDestroyPbuffer_ptr = (PFN_GLXDESTROYPBUFFER)_getPublicProcAddress(_name);
        if (!_glXDestroyPbuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXDestroyPbuffer_ptr(dpy, pbuf);
}

typedef void (* PFN_GLXQUERYDRAWABLE)(Display * dpy, GLXDrawable draw, int attribute, unsigned int * value);
static PFN_GLXQUERYDRAWABLE _glXQueryDrawable_ptr = NULL;

static inline void _glXQueryDrawable(Display * dpy, GLXDrawable draw, int attribute, unsigned int * value) {
    const char *_name = "glXQueryDrawable";
    if (!_glXQueryDrawable_ptr) {
        _glXQueryDrawable_ptr = (PFN_GLXQUERYDRAWABLE)_getPublicProcAddress(_name);
        if (!_glXQueryDrawable_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXQueryDrawable_ptr(dpy, draw, attribute, value);
}

typedef GLXContext (* PFN_GLXCREATENEWCONTEXT)(Display * dpy, GLXFBConfig config, int renderType, GLXContext shareList, int direct);
static PFN_GLXCREATENEWCONTEXT _glXCreateNewContext_ptr = NULL;

static inline GLXContext _glXCreateNewContext(Display * dpy, GLXFBConfig config, int renderType, GLXContext shareList, int direct) {
    const char *_name = "glXCreateNewContext";
    if (!_glXCreateNewContext_ptr) {
        _glXCreateNewContext_ptr = (PFN_GLXCREATENEWCONTEXT)_getPublicProcAddress(_name);
        if (!_glXCreateNewContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXCreateNewContext_ptr(dpy, config, renderType, shareList, direct);
}

typedef int (* PFN_GLXMAKECONTEXTCURRENT)(Display * dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
static PFN_GLXMAKECONTEXTCURRENT _glXMakeContextCurrent_ptr = NULL;

static inline int _glXMakeContextCurrent(Display * dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx) {
    const char *_name = "glXMakeContextCurrent";
    if (!_glXMakeContextCurrent_ptr) {
        _glXMakeContextCurrent_ptr = (PFN_GLXMAKECONTEXTCURRENT)_getPublicProcAddress(_name);
        if (!_glXMakeContextCurrent_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXMakeContextCurrent_ptr(dpy, draw, read, ctx);
}

typedef GLXDrawable (* PFN_GLXGETCURRENTREADDRAWABLE)(void);
static PFN_GLXGETCURRENTREADDRAWABLE _glXGetCurrentReadDrawable_ptr = NULL;

static inline GLXDrawable _glXGetCurrentReadDrawable(void) {
    const char *_name = "glXGetCurrentReadDrawable";
    if (!_glXGetCurrentReadDrawable_ptr) {
        _glXGetCurrentReadDrawable_ptr = (PFN_GLXGETCURRENTREADDRAWABLE)_getPublicProcAddress(_name);
        if (!_glXGetCurrentReadDrawable_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetCurrentReadDrawable_ptr();
}

typedef int (* PFN_GLXQUERYCONTEXT)(Display * dpy, GLXContext ctx, int attribute, int * value);
static PFN_GLXQUERYCONTEXT _glXQueryContext_ptr = NULL;

static inline int _glXQueryContext(Display * dpy, GLXContext ctx, int attribute, int * value) {
    const char *_name = "glXQueryContext";
    if (!_glXQueryContext_ptr) {
        _glXQueryContext_ptr = (PFN_GLXQUERYCONTEXT)_getPublicProcAddress(_name);
        if (!_glXQueryContext_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXQueryContext_ptr(dpy, ctx, attribute, value);
}

typedef void (* PFN_GLXSELECTEVENT)(Display * dpy, GLXDrawable drawable, unsigned long mask);
static PFN_GLXSELECTEVENT _glXSelectEvent_ptr = NULL;

static inline void _glXSelectEvent(Display * dpy, GLXDrawable drawable, unsigned long mask) {
    const char *_name = "glXSelectEvent";
    if (!_glXSelectEvent_ptr) {
        _glXSelectEvent_ptr = (PFN_GLXSELECTEVENT)_getPublicProcAddress(_name);
        if (!_glXSelectEvent_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXSelectEvent_ptr(dpy, drawable, mask);
}

typedef void (* PFN_GLXGETSELECTEDEVENT)(Display * dpy, GLXDrawable drawable, unsigned long * mask);
static PFN_GLXGETSELECTEDEVENT _glXGetSelectedEvent_ptr = NULL;

static inline void _glXGetSelectedEvent(Display * dpy, GLXDrawable drawable, unsigned long * mask) {
    const char *_name = "glXGetSelectedEvent";
    if (!_glXGetSelectedEvent_ptr) {
        _glXGetSelectedEvent_ptr = (PFN_GLXGETSELECTEDEVENT)_getPublicProcAddress(_name);
        if (!_glXGetSelectedEvent_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXGetSelectedEvent_ptr(dpy, drawable, mask);
}

typedef GLXContext (* PFN_GLXCREATECONTEXTATTRIBSARB)(Display * dpy, GLXFBConfig config, GLXContext share_context, int direct, const int * attrib_list);
static PFN_GLXCREATECONTEXTATTRIBSARB _glXCreateContextAttribsARB_ptr = NULL;

static inline GLXContext _glXCreateContextAttribsARB(Display * dpy, GLXFBConfig config, GLXContext share_context, int direct, const int * attrib_list) {
    const char *_name = "glXCreateContextAttribsARB";
    if (!_glXCreateContextAttribsARB_ptr) {
        _glXCreateContextAttribsARB_ptr = (PFN_GLXCREATECONTEXTATTRIBSARB)_getPrivateProcAddress(_name);
        if (!_glXCreateContextAttribsARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXCreateContextAttribsARB_ptr(dpy, config, share_context, direct, attrib_list);
}

typedef int (* PFN_GLXSWAPINTERVALSGI)(int interval);
static PFN_GLXSWAPINTERVALSGI _glXSwapIntervalSGI_ptr = NULL;

static inline int _glXSwapIntervalSGI(int interval) {
    const char *_name = "glXSwapIntervalSGI";
    if (!_glXSwapIntervalSGI_ptr) {
        _glXSwapIntervalSGI_ptr = (PFN_GLXSWAPINTERVALSGI)_getPrivateProcAddress(_name);
        if (!_glXSwapIntervalSGI_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXSwapIntervalSGI_ptr(interval);
}

typedef int (* PFN_GLXGETVIDEOSYNCSGI)(unsigned int * count);
static PFN_GLXGETVIDEOSYNCSGI _glXGetVideoSyncSGI_ptr = NULL;

static inline int _glXGetVideoSyncSGI(unsigned int * count) {
    const char *_name = "glXGetVideoSyncSGI";
    if (!_glXGetVideoSyncSGI_ptr) {
        _glXGetVideoSyncSGI_ptr = (PFN_GLXGETVIDEOSYNCSGI)_getPrivateProcAddress(_name);
        if (!_glXGetVideoSyncSGI_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetVideoSyncSGI_ptr(count);
}

typedef int (* PFN_GLXWAITVIDEOSYNCSGI)(int divisor, int remainder, unsigned int * count);
static PFN_GLXWAITVIDEOSYNCSGI _glXWaitVideoSyncSGI_ptr = NULL;

static inline int _glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int * count) {
    const char *_name = "glXWaitVideoSyncSGI";
    if (!_glXWaitVideoSyncSGI_ptr) {
        _glXWaitVideoSyncSGI_ptr = (PFN_GLXWAITVIDEOSYNCSGI)_getPrivateProcAddress(_name);
        if (!_glXWaitVideoSyncSGI_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXWaitVideoSyncSGI_ptr(divisor, remainder, count);
}

typedef int (* PFN_GLXMAKECURRENTREADSGI)(Display * dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
static PFN_GLXMAKECURRENTREADSGI _glXMakeCurrentReadSGI_ptr = NULL;

static inline int _glXMakeCurrentReadSGI(Display * dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx) {
    const char *_name = "glXMakeCurrentReadSGI";
    if (!_glXMakeCurrentReadSGI_ptr) {
        _glXMakeCurrentReadSGI_ptr = (PFN_GLXMAKECURRENTREADSGI)_getPrivateProcAddress(_name);
        if (!_glXMakeCurrentReadSGI_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXMakeCurrentReadSGI_ptr(dpy, draw, read, ctx);
}

typedef GLXDrawable (* PFN_GLXGETCURRENTREADDRAWABLESGI)(void);
static PFN_GLXGETCURRENTREADDRAWABLESGI _glXGetCurrentReadDrawableSGI_ptr = NULL;

static inline GLXDrawable _glXGetCurrentReadDrawableSGI(void) {
    const char *_name = "glXGetCurrentReadDrawableSGI";
    if (!_glXGetCurrentReadDrawableSGI_ptr) {
        _glXGetCurrentReadDrawableSGI_ptr = (PFN_GLXGETCURRENTREADDRAWABLESGI)_getPrivateProcAddress(_name);
        if (!_glXGetCurrentReadDrawableSGI_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetCurrentReadDrawableSGI_ptr();
}

typedef Display * (* PFN_GLXGETCURRENTDISPLAYEXT)(void);
static PFN_GLXGETCURRENTDISPLAYEXT _glXGetCurrentDisplayEXT_ptr = NULL;

static inline Display * _glXGetCurrentDisplayEXT(void) {
    const char *_name = "glXGetCurrentDisplayEXT";
    if (!_glXGetCurrentDisplayEXT_ptr) {
        _glXGetCurrentDisplayEXT_ptr = (PFN_GLXGETCURRENTDISPLAYEXT)_getPrivateProcAddress(_name);
        if (!_glXGetCurrentDisplayEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetCurrentDisplayEXT_ptr();
}

typedef int (* PFN_GLXQUERYCONTEXTINFOEXT)(Display * dpy, GLXContext context, int attribute, int * value);
static PFN_GLXQUERYCONTEXTINFOEXT _glXQueryContextInfoEXT_ptr = NULL;

static inline int _glXQueryContextInfoEXT(Display * dpy, GLXContext context, int attribute, int * value) {
    const char *_name = "glXQueryContextInfoEXT";
    if (!_glXQueryContextInfoEXT_ptr) {
        _glXQueryContextInfoEXT_ptr = (PFN_GLXQUERYCONTEXTINFOEXT)_getPrivateProcAddress(_name);
        if (!_glXQueryContextInfoEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXQueryContextInfoEXT_ptr(dpy, context, attribute, value);
}

typedef GLXContextID (* PFN_GLXGETCONTEXTIDEXT)(const GLXContext context);
static PFN_GLXGETCONTEXTIDEXT _glXGetContextIDEXT_ptr = NULL;

static inline GLXContextID _glXGetContextIDEXT(const GLXContext context) {
    const char *_name = "glXGetContextIDEXT";
    if (!_glXGetContextIDEXT_ptr) {
        _glXGetContextIDEXT_ptr = (PFN_GLXGETCONTEXTIDEXT)_getPrivateProcAddress(_name);
        if (!_glXGetContextIDEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetContextIDEXT_ptr(context);
}

typedef GLXContext (* PFN_GLXIMPORTCONTEXTEXT)(Display * dpy, GLXContextID contextID);
static PFN_GLXIMPORTCONTEXTEXT _glXImportContextEXT_ptr = NULL;

static inline GLXContext _glXImportContextEXT(Display * dpy, GLXContextID contextID) {
    const char *_name = "glXImportContextEXT";
    if (!_glXImportContextEXT_ptr) {
        _glXImportContextEXT_ptr = (PFN_GLXIMPORTCONTEXTEXT)_getPrivateProcAddress(_name);
        if (!_glXImportContextEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXImportContextEXT_ptr(dpy, contextID);
}

typedef void (* PFN_GLXFREECONTEXTEXT)(Display * dpy, GLXContext context);
static PFN_GLXFREECONTEXTEXT _glXFreeContextEXT_ptr = NULL;

static inline void _glXFreeContextEXT(Display * dpy, GLXContext context) {
    const char *_name = "glXFreeContextEXT";
    if (!_glXFreeContextEXT_ptr) {
        _glXFreeContextEXT_ptr = (PFN_GLXFREECONTEXTEXT)_getPrivateProcAddress(_name);
        if (!_glXFreeContextEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXFreeContextEXT_ptr(dpy, context);
}

typedef int (* PFN_GLXGETFBCONFIGATTRIBSGIX)(Display * dpy, GLXFBConfigSGIX config, int attribute, int * value);
static PFN_GLXGETFBCONFIGATTRIBSGIX _glXGetFBConfigAttribSGIX_ptr = NULL;

static inline int _glXGetFBConfigAttribSGIX(Display * dpy, GLXFBConfigSGIX config, int attribute, int * value) {
    const char *_name = "glXGetFBConfigAttribSGIX";
    if (!_glXGetFBConfigAttribSGIX_ptr) {
        _glXGetFBConfigAttribSGIX_ptr = (PFN_GLXGETFBCONFIGATTRIBSGIX)_getPrivateProcAddress(_name);
        if (!_glXGetFBConfigAttribSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetFBConfigAttribSGIX_ptr(dpy, config, attribute, value);
}

typedef GLXFBConfigSGIX * (* PFN_GLXCHOOSEFBCONFIGSGIX)(Display * dpy, int screen, int * attrib_list, int * nelements);
static PFN_GLXCHOOSEFBCONFIGSGIX _glXChooseFBConfigSGIX_ptr = NULL;

static inline GLXFBConfigSGIX * _glXChooseFBConfigSGIX(Display * dpy, int screen, int * attrib_list, int * nelements) {
    const char *_name = "glXChooseFBConfigSGIX";
    if (!_glXChooseFBConfigSGIX_ptr) {
        _glXChooseFBConfigSGIX_ptr = (PFN_GLXCHOOSEFBCONFIGSGIX)_getPrivateProcAddress(_name);
        if (!_glXChooseFBConfigSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXChooseFBConfigSGIX_ptr(dpy, screen, attrib_list, nelements);
}

typedef GLXPixmap (* PFN_GLXCREATEGLXPIXMAPWITHCONFIGSGIX)(Display * dpy, GLXFBConfigSGIX config, Pixmap pixmap);
static PFN_GLXCREATEGLXPIXMAPWITHCONFIGSGIX _glXCreateGLXPixmapWithConfigSGIX_ptr = NULL;

static inline GLXPixmap _glXCreateGLXPixmapWithConfigSGIX(Display * dpy, GLXFBConfigSGIX config, Pixmap pixmap) {
    const char *_name = "glXCreateGLXPixmapWithConfigSGIX";
    if (!_glXCreateGLXPixmapWithConfigSGIX_ptr) {
        _glXCreateGLXPixmapWithConfigSGIX_ptr = (PFN_GLXCREATEGLXPIXMAPWITHCONFIGSGIX)_getPrivateProcAddress(_name);
        if (!_glXCreateGLXPixmapWithConfigSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXCreateGLXPixmapWithConfigSGIX_ptr(dpy, config, pixmap);
}

typedef GLXContext (* PFN_GLXCREATECONTEXTWITHCONFIGSGIX)(Display * dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, int direct);
static PFN_GLXCREATECONTEXTWITHCONFIGSGIX _glXCreateContextWithConfigSGIX_ptr = NULL;

static inline GLXContext _glXCreateContextWithConfigSGIX(Display * dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, int direct) {
    const char *_name = "glXCreateContextWithConfigSGIX";
    if (!_glXCreateContextWithConfigSGIX_ptr) {
        _glXCreateContextWithConfigSGIX_ptr = (PFN_GLXCREATECONTEXTWITHCONFIGSGIX)_getPrivateProcAddress(_name);
        if (!_glXCreateContextWithConfigSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXCreateContextWithConfigSGIX_ptr(dpy, config, render_type, share_list, direct);
}

typedef XVisualInfo * (* PFN_GLXGETVISUALFROMFBCONFIGSGIX)(Display * dpy, GLXFBConfigSGIX config);
static PFN_GLXGETVISUALFROMFBCONFIGSGIX _glXGetVisualFromFBConfigSGIX_ptr = NULL;

static inline XVisualInfo * _glXGetVisualFromFBConfigSGIX(Display * dpy, GLXFBConfigSGIX config) {
    const char *_name = "glXGetVisualFromFBConfigSGIX";
    if (!_glXGetVisualFromFBConfigSGIX_ptr) {
        _glXGetVisualFromFBConfigSGIX_ptr = (PFN_GLXGETVISUALFROMFBCONFIGSGIX)_getPrivateProcAddress(_name);
        if (!_glXGetVisualFromFBConfigSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetVisualFromFBConfigSGIX_ptr(dpy, config);
}

typedef GLXFBConfigSGIX (* PFN_GLXGETFBCONFIGFROMVISUALSGIX)(Display * dpy, XVisualInfo * vis);
static PFN_GLXGETFBCONFIGFROMVISUALSGIX _glXGetFBConfigFromVisualSGIX_ptr = NULL;

static inline GLXFBConfigSGIX _glXGetFBConfigFromVisualSGIX(Display * dpy, XVisualInfo * vis) {
    const char *_name = "glXGetFBConfigFromVisualSGIX";
    if (!_glXGetFBConfigFromVisualSGIX_ptr) {
        _glXGetFBConfigFromVisualSGIX_ptr = (PFN_GLXGETFBCONFIGFROMVISUALSGIX)_getPrivateProcAddress(_name);
        if (!_glXGetFBConfigFromVisualSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetFBConfigFromVisualSGIX_ptr(dpy, vis);
}

typedef GLXPbufferSGIX (* PFN_GLXCREATEGLXPBUFFERSGIX)(Display * dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int * attrib_list);
static PFN_GLXCREATEGLXPBUFFERSGIX _glXCreateGLXPbufferSGIX_ptr = NULL;

static inline GLXPbufferSGIX _glXCreateGLXPbufferSGIX(Display * dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int * attrib_list) {
    const char *_name = "glXCreateGLXPbufferSGIX";
    if (!_glXCreateGLXPbufferSGIX_ptr) {
        _glXCreateGLXPbufferSGIX_ptr = (PFN_GLXCREATEGLXPBUFFERSGIX)_getPrivateProcAddress(_name);
        if (!_glXCreateGLXPbufferSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXCreateGLXPbufferSGIX_ptr(dpy, config, width, height, attrib_list);
}

typedef void (* PFN_GLXDESTROYGLXPBUFFERSGIX)(Display * dpy, GLXPbufferSGIX pbuf);
static PFN_GLXDESTROYGLXPBUFFERSGIX _glXDestroyGLXPbufferSGIX_ptr = NULL;

static inline void _glXDestroyGLXPbufferSGIX(Display * dpy, GLXPbufferSGIX pbuf) {
    const char *_name = "glXDestroyGLXPbufferSGIX";
    if (!_glXDestroyGLXPbufferSGIX_ptr) {
        _glXDestroyGLXPbufferSGIX_ptr = (PFN_GLXDESTROYGLXPBUFFERSGIX)_getPrivateProcAddress(_name);
        if (!_glXDestroyGLXPbufferSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXDestroyGLXPbufferSGIX_ptr(dpy, pbuf);
}

typedef int (* PFN_GLXQUERYGLXPBUFFERSGIX)(Display * dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int * value);
static PFN_GLXQUERYGLXPBUFFERSGIX _glXQueryGLXPbufferSGIX_ptr = NULL;

static inline int _glXQueryGLXPbufferSGIX(Display * dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int * value) {
    const char *_name = "glXQueryGLXPbufferSGIX";
    if (!_glXQueryGLXPbufferSGIX_ptr) {
        _glXQueryGLXPbufferSGIX_ptr = (PFN_GLXQUERYGLXPBUFFERSGIX)_getPrivateProcAddress(_name);
        if (!_glXQueryGLXPbufferSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXQueryGLXPbufferSGIX_ptr(dpy, pbuf, attribute, value);
}

typedef void (* PFN_GLXSELECTEVENTSGIX)(Display * dpy, GLXDrawable drawable, unsigned long mask);
static PFN_GLXSELECTEVENTSGIX _glXSelectEventSGIX_ptr = NULL;

static inline void _glXSelectEventSGIX(Display * dpy, GLXDrawable drawable, unsigned long mask) {
    const char *_name = "glXSelectEventSGIX";
    if (!_glXSelectEventSGIX_ptr) {
        _glXSelectEventSGIX_ptr = (PFN_GLXSELECTEVENTSGIX)_getPrivateProcAddress(_name);
        if (!_glXSelectEventSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXSelectEventSGIX_ptr(dpy, drawable, mask);
}

typedef void (* PFN_GLXGETSELECTEDEVENTSGIX)(Display * dpy, GLXDrawable drawable, unsigned long * mask);
static PFN_GLXGETSELECTEDEVENTSGIX _glXGetSelectedEventSGIX_ptr = NULL;

static inline void _glXGetSelectedEventSGIX(Display * dpy, GLXDrawable drawable, unsigned long * mask) {
    const char *_name = "glXGetSelectedEventSGIX";
    if (!_glXGetSelectedEventSGIX_ptr) {
        _glXGetSelectedEventSGIX_ptr = (PFN_GLXGETSELECTEDEVENTSGIX)_getPrivateProcAddress(_name);
        if (!_glXGetSelectedEventSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXGetSelectedEventSGIX_ptr(dpy, drawable, mask);
}

typedef void (* PFN_GLXCUSHIONSGI)(Display * dpy, Window window, float cushion);
static PFN_GLXCUSHIONSGI _glXCushionSGI_ptr = NULL;

static inline void _glXCushionSGI(Display * dpy, Window window, float cushion) {
    const char *_name = "glXCushionSGI";
    if (!_glXCushionSGI_ptr) {
        _glXCushionSGI_ptr = (PFN_GLXCUSHIONSGI)_getPrivateProcAddress(_name);
        if (!_glXCushionSGI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXCushionSGI_ptr(dpy, window, cushion);
}

typedef int (* PFN_GLXBINDCHANNELTOWINDOWSGIX)(Display * display, int screen, int channel, Window window);
static PFN_GLXBINDCHANNELTOWINDOWSGIX _glXBindChannelToWindowSGIX_ptr = NULL;

static inline int _glXBindChannelToWindowSGIX(Display * display, int screen, int channel, Window window) {
    const char *_name = "glXBindChannelToWindowSGIX";
    if (!_glXBindChannelToWindowSGIX_ptr) {
        _glXBindChannelToWindowSGIX_ptr = (PFN_GLXBINDCHANNELTOWINDOWSGIX)_getPrivateProcAddress(_name);
        if (!_glXBindChannelToWindowSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXBindChannelToWindowSGIX_ptr(display, screen, channel, window);
}

typedef int (* PFN_GLXCHANNELRECTSGIX)(Display * display, int screen, int channel, int x, int y, int w, int h);
static PFN_GLXCHANNELRECTSGIX _glXChannelRectSGIX_ptr = NULL;

static inline int _glXChannelRectSGIX(Display * display, int screen, int channel, int x, int y, int w, int h) {
    const char *_name = "glXChannelRectSGIX";
    if (!_glXChannelRectSGIX_ptr) {
        _glXChannelRectSGIX_ptr = (PFN_GLXCHANNELRECTSGIX)_getPrivateProcAddress(_name);
        if (!_glXChannelRectSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXChannelRectSGIX_ptr(display, screen, channel, x, y, w, h);
}

typedef int (* PFN_GLXQUERYCHANNELRECTSGIX)(Display * display, int screen, int channel, int * dx, int * dy, int * dw, int * dh);
static PFN_GLXQUERYCHANNELRECTSGIX _glXQueryChannelRectSGIX_ptr = NULL;

static inline int _glXQueryChannelRectSGIX(Display * display, int screen, int channel, int * dx, int * dy, int * dw, int * dh) {
    const char *_name = "glXQueryChannelRectSGIX";
    if (!_glXQueryChannelRectSGIX_ptr) {
        _glXQueryChannelRectSGIX_ptr = (PFN_GLXQUERYCHANNELRECTSGIX)_getPrivateProcAddress(_name);
        if (!_glXQueryChannelRectSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXQueryChannelRectSGIX_ptr(display, screen, channel, dx, dy, dw, dh);
}

typedef int (* PFN_GLXQUERYCHANNELDELTASSGIX)(Display * display, int screen, int channel, int * x, int * y, int * w, int * h);
static PFN_GLXQUERYCHANNELDELTASSGIX _glXQueryChannelDeltasSGIX_ptr = NULL;

static inline int _glXQueryChannelDeltasSGIX(Display * display, int screen, int channel, int * x, int * y, int * w, int * h) {
    const char *_name = "glXQueryChannelDeltasSGIX";
    if (!_glXQueryChannelDeltasSGIX_ptr) {
        _glXQueryChannelDeltasSGIX_ptr = (PFN_GLXQUERYCHANNELDELTASSGIX)_getPrivateProcAddress(_name);
        if (!_glXQueryChannelDeltasSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXQueryChannelDeltasSGIX_ptr(display, screen, channel, x, y, w, h);
}

typedef int (* PFN_GLXCHANNELRECTSYNCSGIX)(Display * display, int screen, int channel, GLenum synctype);
static PFN_GLXCHANNELRECTSYNCSGIX _glXChannelRectSyncSGIX_ptr = NULL;

static inline int _glXChannelRectSyncSGIX(Display * display, int screen, int channel, GLenum synctype) {
    const char *_name = "glXChannelRectSyncSGIX";
    if (!_glXChannelRectSyncSGIX_ptr) {
        _glXChannelRectSyncSGIX_ptr = (PFN_GLXCHANNELRECTSYNCSGIX)_getPrivateProcAddress(_name);
        if (!_glXChannelRectSyncSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXChannelRectSyncSGIX_ptr(display, screen, channel, synctype);
}

typedef void (* PFN_GLXJOINSWAPGROUPSGIX)(Display * dpy, GLXDrawable drawable, GLXDrawable member);
static PFN_GLXJOINSWAPGROUPSGIX _glXJoinSwapGroupSGIX_ptr = NULL;

static inline void _glXJoinSwapGroupSGIX(Display * dpy, GLXDrawable drawable, GLXDrawable member) {
    const char *_name = "glXJoinSwapGroupSGIX";
    if (!_glXJoinSwapGroupSGIX_ptr) {
        _glXJoinSwapGroupSGIX_ptr = (PFN_GLXJOINSWAPGROUPSGIX)_getPrivateProcAddress(_name);
        if (!_glXJoinSwapGroupSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXJoinSwapGroupSGIX_ptr(dpy, drawable, member);
}

typedef void (* PFN_GLXBINDSWAPBARRIERSGIX)(Display * dpy, GLXDrawable drawable, int barrier);
static PFN_GLXBINDSWAPBARRIERSGIX _glXBindSwapBarrierSGIX_ptr = NULL;

static inline void _glXBindSwapBarrierSGIX(Display * dpy, GLXDrawable drawable, int barrier) {
    const char *_name = "glXBindSwapBarrierSGIX";
    if (!_glXBindSwapBarrierSGIX_ptr) {
        _glXBindSwapBarrierSGIX_ptr = (PFN_GLXBINDSWAPBARRIERSGIX)_getPrivateProcAddress(_name);
        if (!_glXBindSwapBarrierSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXBindSwapBarrierSGIX_ptr(dpy, drawable, barrier);
}

typedef int (* PFN_GLXQUERYMAXSWAPBARRIERSSGIX)(Display * dpy, int screen, int * max);
static PFN_GLXQUERYMAXSWAPBARRIERSSGIX _glXQueryMaxSwapBarriersSGIX_ptr = NULL;

static inline int _glXQueryMaxSwapBarriersSGIX(Display * dpy, int screen, int * max) {
    const char *_name = "glXQueryMaxSwapBarriersSGIX";
    if (!_glXQueryMaxSwapBarriersSGIX_ptr) {
        _glXQueryMaxSwapBarriersSGIX_ptr = (PFN_GLXQUERYMAXSWAPBARRIERSSGIX)_getPrivateProcAddress(_name);
        if (!_glXQueryMaxSwapBarriersSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXQueryMaxSwapBarriersSGIX_ptr(dpy, screen, max);
}

typedef void (* PFN_GLXCOPYSUBBUFFERMESA)(Display * dpy, GLXDrawable drawable, int x, int y, int width, int height);
static PFN_GLXCOPYSUBBUFFERMESA _glXCopySubBufferMESA_ptr = NULL;

static inline void _glXCopySubBufferMESA(Display * dpy, GLXDrawable drawable, int x, int y, int width, int height) {
    const char *_name = "glXCopySubBufferMESA";
    if (!_glXCopySubBufferMESA_ptr) {
        _glXCopySubBufferMESA_ptr = (PFN_GLXCOPYSUBBUFFERMESA)_getPrivateProcAddress(_name);
        if (!_glXCopySubBufferMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXCopySubBufferMESA_ptr(dpy, drawable, x, y, width, height);
}

typedef GLXPixmap (* PFN_GLXCREATEGLXPIXMAPMESA)(Display * dpy, XVisualInfo * visual, Pixmap pixmap, Colormap cmap);
static PFN_GLXCREATEGLXPIXMAPMESA _glXCreateGLXPixmapMESA_ptr = NULL;

static inline GLXPixmap _glXCreateGLXPixmapMESA(Display * dpy, XVisualInfo * visual, Pixmap pixmap, Colormap cmap) {
    const char *_name = "glXCreateGLXPixmapMESA";
    if (!_glXCreateGLXPixmapMESA_ptr) {
        _glXCreateGLXPixmapMESA_ptr = (PFN_GLXCREATEGLXPIXMAPMESA)_getPrivateProcAddress(_name);
        if (!_glXCreateGLXPixmapMESA_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXCreateGLXPixmapMESA_ptr(dpy, visual, pixmap, cmap);
}

typedef int (* PFN_GLXRELEASEBUFFERSMESA)(Display * dpy, GLXDrawable drawable);
static PFN_GLXRELEASEBUFFERSMESA _glXReleaseBuffersMESA_ptr = NULL;

static inline int _glXReleaseBuffersMESA(Display * dpy, GLXDrawable drawable) {
    const char *_name = "glXReleaseBuffersMESA";
    if (!_glXReleaseBuffersMESA_ptr) {
        _glXReleaseBuffersMESA_ptr = (PFN_GLXRELEASEBUFFERSMESA)_getPrivateProcAddress(_name);
        if (!_glXReleaseBuffersMESA_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXReleaseBuffersMESA_ptr(dpy, drawable);
}

typedef int (* PFN_GLXSET3DFXMODEMESA)(int mode);
static PFN_GLXSET3DFXMODEMESA _glXSet3DfxModeMESA_ptr = NULL;

static inline int _glXSet3DfxModeMESA(int mode) {
    const char *_name = "glXSet3DfxModeMESA";
    if (!_glXSet3DfxModeMESA_ptr) {
        _glXSet3DfxModeMESA_ptr = (PFN_GLXSET3DFXMODEMESA)_getPrivateProcAddress(_name);
        if (!_glXSet3DfxModeMESA_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXSet3DfxModeMESA_ptr(mode);
}

typedef int (* PFN_GLXSWAPINTERVALMESA)(unsigned int interval);
static PFN_GLXSWAPINTERVALMESA _glXSwapIntervalMESA_ptr = NULL;

static inline int _glXSwapIntervalMESA(unsigned int interval) {
    const char *_name = "glXSwapIntervalMESA";
    if (!_glXSwapIntervalMESA_ptr) {
        _glXSwapIntervalMESA_ptr = (PFN_GLXSWAPINTERVALMESA)_getPrivateProcAddress(_name);
        if (!_glXSwapIntervalMESA_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXSwapIntervalMESA_ptr(interval);
}

typedef int (* PFN_GLXGETSWAPINTERVALMESA)(void);
static PFN_GLXGETSWAPINTERVALMESA _glXGetSwapIntervalMESA_ptr = NULL;

static inline int _glXGetSwapIntervalMESA(void) {
    const char *_name = "glXGetSwapIntervalMESA";
    if (!_glXGetSwapIntervalMESA_ptr) {
        _glXGetSwapIntervalMESA_ptr = (PFN_GLXGETSWAPINTERVALMESA)_getPrivateProcAddress(_name);
        if (!_glXGetSwapIntervalMESA_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetSwapIntervalMESA_ptr();
}

typedef int (* PFN_GLXGETSYNCVALUESOML)(Display * dpy, GLXDrawable drawable, int64_t * ust, int64_t * msc, int64_t * sbc);
static PFN_GLXGETSYNCVALUESOML _glXGetSyncValuesOML_ptr = NULL;

static inline int _glXGetSyncValuesOML(Display * dpy, GLXDrawable drawable, int64_t * ust, int64_t * msc, int64_t * sbc) {
    const char *_name = "glXGetSyncValuesOML";
    if (!_glXGetSyncValuesOML_ptr) {
        _glXGetSyncValuesOML_ptr = (PFN_GLXGETSYNCVALUESOML)_getPrivateProcAddress(_name);
        if (!_glXGetSyncValuesOML_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetSyncValuesOML_ptr(dpy, drawable, ust, msc, sbc);
}

typedef int (* PFN_GLXGETMSCRATEOML)(Display * dpy, GLXDrawable drawable, int32_t * numerator, int32_t * denominator);
static PFN_GLXGETMSCRATEOML _glXGetMscRateOML_ptr = NULL;

static inline int _glXGetMscRateOML(Display * dpy, GLXDrawable drawable, int32_t * numerator, int32_t * denominator) {
    const char *_name = "glXGetMscRateOML";
    if (!_glXGetMscRateOML_ptr) {
        _glXGetMscRateOML_ptr = (PFN_GLXGETMSCRATEOML)_getPrivateProcAddress(_name);
        if (!_glXGetMscRateOML_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetMscRateOML_ptr(dpy, drawable, numerator, denominator);
}

typedef int64_t (* PFN_GLXSWAPBUFFERSMSCOML)(Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
static PFN_GLXSWAPBUFFERSMSCOML _glXSwapBuffersMscOML_ptr = NULL;

static inline int64_t _glXSwapBuffersMscOML(Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder) {
    const char *_name = "glXSwapBuffersMscOML";
    if (!_glXSwapBuffersMscOML_ptr) {
        _glXSwapBuffersMscOML_ptr = (PFN_GLXSWAPBUFFERSMSCOML)_getPrivateProcAddress(_name);
        if (!_glXSwapBuffersMscOML_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXSwapBuffersMscOML_ptr(dpy, drawable, target_msc, divisor, remainder);
}

typedef int (* PFN_GLXWAITFORMSCOML)(Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t * ust, int64_t * msc, int64_t * sbc);
static PFN_GLXWAITFORMSCOML _glXWaitForMscOML_ptr = NULL;

static inline int _glXWaitForMscOML(Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t * ust, int64_t * msc, int64_t * sbc) {
    const char *_name = "glXWaitForMscOML";
    if (!_glXWaitForMscOML_ptr) {
        _glXWaitForMscOML_ptr = (PFN_GLXWAITFORMSCOML)_getPrivateProcAddress(_name);
        if (!_glXWaitForMscOML_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXWaitForMscOML_ptr(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
}

typedef int (* PFN_GLXWAITFORSBCOML)(Display * dpy, GLXDrawable drawable, int64_t target_sbc, int64_t * ust, int64_t * msc, int64_t * sbc);
static PFN_GLXWAITFORSBCOML _glXWaitForSbcOML_ptr = NULL;

static inline int _glXWaitForSbcOML(Display * dpy, GLXDrawable drawable, int64_t target_sbc, int64_t * ust, int64_t * msc, int64_t * sbc) {
    const char *_name = "glXWaitForSbcOML";
    if (!_glXWaitForSbcOML_ptr) {
        _glXWaitForSbcOML_ptr = (PFN_GLXWAITFORSBCOML)_getPrivateProcAddress(_name);
        if (!_glXWaitForSbcOML_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXWaitForSbcOML_ptr(dpy, drawable, target_sbc, ust, msc, sbc);
}

typedef unsigned int (* PFN_GLXGETAGPOFFSETMESA)(const void * pointer);
static PFN_GLXGETAGPOFFSETMESA _glXGetAGPOffsetMESA_ptr = NULL;

static inline unsigned int _glXGetAGPOffsetMESA(const void * pointer) {
    const char *_name = "glXGetAGPOffsetMESA";
    if (!_glXGetAGPOffsetMESA_ptr) {
        _glXGetAGPOffsetMESA_ptr = (PFN_GLXGETAGPOFFSETMESA)_getPrivateProcAddress(_name);
        if (!_glXGetAGPOffsetMESA_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetAGPOffsetMESA_ptr(pointer);
}

typedef void (* PFN_GLXBINDTEXIMAGEEXT)(Display * display, GLXDrawable drawable, int buffer, const int * attrib_list);
static PFN_GLXBINDTEXIMAGEEXT _glXBindTexImageEXT_ptr = NULL;

static inline void _glXBindTexImageEXT(Display * display, GLXDrawable drawable, int buffer, const int * attrib_list) {
    const char *_name = "glXBindTexImageEXT";
    if (!_glXBindTexImageEXT_ptr) {
        _glXBindTexImageEXT_ptr = (PFN_GLXBINDTEXIMAGEEXT)_getPrivateProcAddress(_name);
        if (!_glXBindTexImageEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXBindTexImageEXT_ptr(display, drawable, buffer, attrib_list);
}

typedef void (* PFN_GLXRELEASETEXIMAGEEXT)(Display * display, GLXDrawable drawable, int buffer);
static PFN_GLXRELEASETEXIMAGEEXT _glXReleaseTexImageEXT_ptr = NULL;

static inline void _glXReleaseTexImageEXT(Display * display, GLXDrawable drawable, int buffer) {
    const char *_name = "glXReleaseTexImageEXT";
    if (!_glXReleaseTexImageEXT_ptr) {
        _glXReleaseTexImageEXT_ptr = (PFN_GLXRELEASETEXIMAGEEXT)_getPrivateProcAddress(_name);
        if (!_glXReleaseTexImageEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXReleaseTexImageEXT_ptr(display, drawable, buffer);
}

typedef int (* PFN_GLXJOINSWAPGROUPNV)(Display * dpy, GLXDrawable drawable, GLuint group);
static PFN_GLXJOINSWAPGROUPNV _glXJoinSwapGroupNV_ptr = NULL;

static inline int _glXJoinSwapGroupNV(Display * dpy, GLXDrawable drawable, GLuint group) {
    const char *_name = "glXJoinSwapGroupNV";
    if (!_glXJoinSwapGroupNV_ptr) {
        _glXJoinSwapGroupNV_ptr = (PFN_GLXJOINSWAPGROUPNV)_getPrivateProcAddress(_name);
        if (!_glXJoinSwapGroupNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXJoinSwapGroupNV_ptr(dpy, drawable, group);
}

typedef int (* PFN_GLXBINDSWAPBARRIERNV)(Display * dpy, GLuint group, GLuint barrier);
static PFN_GLXBINDSWAPBARRIERNV _glXBindSwapBarrierNV_ptr = NULL;

static inline int _glXBindSwapBarrierNV(Display * dpy, GLuint group, GLuint barrier) {
    const char *_name = "glXBindSwapBarrierNV";
    if (!_glXBindSwapBarrierNV_ptr) {
        _glXBindSwapBarrierNV_ptr = (PFN_GLXBINDSWAPBARRIERNV)_getPrivateProcAddress(_name);
        if (!_glXBindSwapBarrierNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXBindSwapBarrierNV_ptr(dpy, group, barrier);
}

typedef int (* PFN_GLXQUERYSWAPGROUPNV)(Display * dpy, GLXDrawable drawable, GLuint * group, GLuint * barrier);
static PFN_GLXQUERYSWAPGROUPNV _glXQuerySwapGroupNV_ptr = NULL;

static inline int _glXQuerySwapGroupNV(Display * dpy, GLXDrawable drawable, GLuint * group, GLuint * barrier) {
    const char *_name = "glXQuerySwapGroupNV";
    if (!_glXQuerySwapGroupNV_ptr) {
        _glXQuerySwapGroupNV_ptr = (PFN_GLXQUERYSWAPGROUPNV)_getPrivateProcAddress(_name);
        if (!_glXQuerySwapGroupNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXQuerySwapGroupNV_ptr(dpy, drawable, group, barrier);
}

typedef int (* PFN_GLXQUERYMAXSWAPGROUPSNV)(Display * dpy, int screen, GLuint * maxGroups, GLuint * maxBarriers);
static PFN_GLXQUERYMAXSWAPGROUPSNV _glXQueryMaxSwapGroupsNV_ptr = NULL;

static inline int _glXQueryMaxSwapGroupsNV(Display * dpy, int screen, GLuint * maxGroups, GLuint * maxBarriers) {
    const char *_name = "glXQueryMaxSwapGroupsNV";
    if (!_glXQueryMaxSwapGroupsNV_ptr) {
        _glXQueryMaxSwapGroupsNV_ptr = (PFN_GLXQUERYMAXSWAPGROUPSNV)_getPrivateProcAddress(_name);
        if (!_glXQueryMaxSwapGroupsNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXQueryMaxSwapGroupsNV_ptr(dpy, screen, maxGroups, maxBarriers);
}

typedef int (* PFN_GLXQUERYFRAMECOUNTNV)(Display * dpy, int screen, GLuint * count);
static PFN_GLXQUERYFRAMECOUNTNV _glXQueryFrameCountNV_ptr = NULL;

static inline int _glXQueryFrameCountNV(Display * dpy, int screen, GLuint * count) {
    const char *_name = "glXQueryFrameCountNV";
    if (!_glXQueryFrameCountNV_ptr) {
        _glXQueryFrameCountNV_ptr = (PFN_GLXQUERYFRAMECOUNTNV)_getPrivateProcAddress(_name);
        if (!_glXQueryFrameCountNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXQueryFrameCountNV_ptr(dpy, screen, count);
}

typedef int (* PFN_GLXRESETFRAMECOUNTNV)(Display * dpy, int screen);
static PFN_GLXRESETFRAMECOUNTNV _glXResetFrameCountNV_ptr = NULL;

static inline int _glXResetFrameCountNV(Display * dpy, int screen) {
    const char *_name = "glXResetFrameCountNV";
    if (!_glXResetFrameCountNV_ptr) {
        _glXResetFrameCountNV_ptr = (PFN_GLXRESETFRAMECOUNTNV)_getPrivateProcAddress(_name);
        if (!_glXResetFrameCountNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXResetFrameCountNV_ptr(dpy, screen);
}

typedef void (* PFN_GLXSWAPINTERVALEXT)(Display * dpy, GLXDrawable drawable, int interval);
static PFN_GLXSWAPINTERVALEXT _glXSwapIntervalEXT_ptr = NULL;

static inline void _glXSwapIntervalEXT(Display * dpy, GLXDrawable drawable, int interval) {
    const char *_name = "glXSwapIntervalEXT";
    if (!_glXSwapIntervalEXT_ptr) {
        _glXSwapIntervalEXT_ptr = (PFN_GLXSWAPINTERVALEXT)_getPrivateProcAddress(_name);
        if (!_glXSwapIntervalEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXSwapIntervalEXT_ptr(dpy, drawable, interval);
}

typedef void (* PFN_GLXCOPYIMAGESUBDATANV)(Display * dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
static PFN_GLXCOPYIMAGESUBDATANV _glXCopyImageSubDataNV_ptr = NULL;

static inline void _glXCopyImageSubDataNV(Display * dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) {
    const char *_name = "glXCopyImageSubDataNV";
    if (!_glXCopyImageSubDataNV_ptr) {
        _glXCopyImageSubDataNV_ptr = (PFN_GLXCOPYIMAGESUBDATANV)_getPrivateProcAddress(_name);
        if (!_glXCopyImageSubDataNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXCopyImageSubDataNV_ptr(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
}

typedef void * (* PFN_GLXALLOCATEMEMORYNV)(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority);
static PFN_GLXALLOCATEMEMORYNV _glXAllocateMemoryNV_ptr = NULL;

static inline void * _glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority) {
    const char *_name = "glXAllocateMemoryNV";
    if (!_glXAllocateMemoryNV_ptr) {
        _glXAllocateMemoryNV_ptr = (PFN_GLXALLOCATEMEMORYNV)_getPrivateProcAddress(_name);
        if (!_glXAllocateMemoryNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXAllocateMemoryNV_ptr(size, readfreq, writefreq, priority);
}

typedef void (* PFN_GLXFREEMEMORYNV)(void * pointer);
static PFN_GLXFREEMEMORYNV _glXFreeMemoryNV_ptr = NULL;

static inline void _glXFreeMemoryNV(void * pointer) {
    const char *_name = "glXFreeMemoryNV";
    if (!_glXFreeMemoryNV_ptr) {
        _glXFreeMemoryNV_ptr = (PFN_GLXFREEMEMORYNV)_getPrivateProcAddress(_name);
        if (!_glXFreeMemoryNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glXFreeMemoryNV_ptr(pointer);
}

typedef __GLXextFuncPtr (* PFN_GLXGETPROCADDRESSARB)(const GLubyte * procName);
static PFN_GLXGETPROCADDRESSARB _glXGetProcAddressARB_ptr = NULL;

static inline __GLXextFuncPtr _glXGetProcAddressARB(const GLubyte * procName) {
    const char *_name = "glXGetProcAddressARB";
    if (!_glXGetProcAddressARB_ptr) {
        _glXGetProcAddressARB_ptr = (PFN_GLXGETPROCADDRESSARB)_getPublicProcAddress(_name);
        if (!_glXGetProcAddressARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetProcAddressARB_ptr(procName);
}

typedef __GLXextFuncPtr (* PFN_GLXGETPROCADDRESS)(const GLubyte * procName);
static PFN_GLXGETPROCADDRESS _glXGetProcAddress_ptr = NULL;

static inline __GLXextFuncPtr _glXGetProcAddress(const GLubyte * procName) {
    const char *_name = "glXGetProcAddress";
    if (!_glXGetProcAddress_ptr) {
        _glXGetProcAddress_ptr = (PFN_GLXGETPROCADDRESS)_getPublicProcAddress(_name);
        if (!_glXGetProcAddress_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glXGetProcAddress_ptr(procName);
}

#ifdef RETRACE
#define glXChooseVisual _glXChooseVisual
#define glXCreateContext _glXCreateContext
#define glXDestroyContext _glXDestroyContext
#define glXMakeCurrent _glXMakeCurrent
#define glXCopyContext _glXCopyContext
#define glXSwapBuffers _glXSwapBuffers
#define glXCreateGLXPixmap _glXCreateGLXPixmap
#define glXDestroyGLXPixmap _glXDestroyGLXPixmap
#define glXQueryExtension _glXQueryExtension
#define glXQueryVersion _glXQueryVersion
#define glXIsDirect _glXIsDirect
#define glXGetConfig _glXGetConfig
#define glXGetCurrentContext _glXGetCurrentContext
#define glXGetCurrentDrawable _glXGetCurrentDrawable
#define glXWaitGL _glXWaitGL
#define glXWaitX _glXWaitX
#define glXUseXFont _glXUseXFont
#define glXQueryExtensionsString _glXQueryExtensionsString
#define glXQueryServerString _glXQueryServerString
#define glXGetClientString _glXGetClientString
#define glXGetCurrentDisplay _glXGetCurrentDisplay
#define glXChooseFBConfig _glXChooseFBConfig
#define glXGetFBConfigAttrib _glXGetFBConfigAttrib
#define glXGetFBConfigs _glXGetFBConfigs
#define glXGetVisualFromFBConfig _glXGetVisualFromFBConfig
#define glXCreateWindow _glXCreateWindow
#define glXDestroyWindow _glXDestroyWindow
#define glXCreatePixmap _glXCreatePixmap
#define glXDestroyPixmap _glXDestroyPixmap
#define glXCreatePbuffer _glXCreatePbuffer
#define glXDestroyPbuffer _glXDestroyPbuffer
#define glXQueryDrawable _glXQueryDrawable
#define glXCreateNewContext _glXCreateNewContext
#define glXMakeContextCurrent _glXMakeContextCurrent
#define glXGetCurrentReadDrawable _glXGetCurrentReadDrawable
#define glXQueryContext _glXQueryContext
#define glXSelectEvent _glXSelectEvent
#define glXGetSelectedEvent _glXGetSelectedEvent
#define glXCreateContextAttribsARB _glXCreateContextAttribsARB
#define glXSwapIntervalSGI _glXSwapIntervalSGI
#define glXGetVideoSyncSGI _glXGetVideoSyncSGI
#define glXWaitVideoSyncSGI _glXWaitVideoSyncSGI
#define glXMakeCurrentReadSGI _glXMakeCurrentReadSGI
#define glXGetCurrentReadDrawableSGI _glXGetCurrentReadDrawableSGI
#define glXGetCurrentDisplayEXT _glXGetCurrentDisplayEXT
#define glXQueryContextInfoEXT _glXQueryContextInfoEXT
#define glXGetContextIDEXT _glXGetContextIDEXT
#define glXImportContextEXT _glXImportContextEXT
#define glXFreeContextEXT _glXFreeContextEXT
#define glXGetFBConfigAttribSGIX _glXGetFBConfigAttribSGIX
#define glXChooseFBConfigSGIX _glXChooseFBConfigSGIX
#define glXCreateGLXPixmapWithConfigSGIX _glXCreateGLXPixmapWithConfigSGIX
#define glXCreateContextWithConfigSGIX _glXCreateContextWithConfigSGIX
#define glXGetVisualFromFBConfigSGIX _glXGetVisualFromFBConfigSGIX
#define glXGetFBConfigFromVisualSGIX _glXGetFBConfigFromVisualSGIX
#define glXCreateGLXPbufferSGIX _glXCreateGLXPbufferSGIX
#define glXDestroyGLXPbufferSGIX _glXDestroyGLXPbufferSGIX
#define glXQueryGLXPbufferSGIX _glXQueryGLXPbufferSGIX
#define glXSelectEventSGIX _glXSelectEventSGIX
#define glXGetSelectedEventSGIX _glXGetSelectedEventSGIX
#define glXCushionSGI _glXCushionSGI
#define glXBindChannelToWindowSGIX _glXBindChannelToWindowSGIX
#define glXChannelRectSGIX _glXChannelRectSGIX
#define glXQueryChannelRectSGIX _glXQueryChannelRectSGIX
#define glXQueryChannelDeltasSGIX _glXQueryChannelDeltasSGIX
#define glXChannelRectSyncSGIX _glXChannelRectSyncSGIX
#define glXJoinSwapGroupSGIX _glXJoinSwapGroupSGIX
#define glXBindSwapBarrierSGIX _glXBindSwapBarrierSGIX
#define glXQueryMaxSwapBarriersSGIX _glXQueryMaxSwapBarriersSGIX
#define glXCopySubBufferMESA _glXCopySubBufferMESA
#define glXCreateGLXPixmapMESA _glXCreateGLXPixmapMESA
#define glXReleaseBuffersMESA _glXReleaseBuffersMESA
#define glXSet3DfxModeMESA _glXSet3DfxModeMESA
#define glXSwapIntervalMESA _glXSwapIntervalMESA
#define glXGetSwapIntervalMESA _glXGetSwapIntervalMESA
#define glXGetSyncValuesOML _glXGetSyncValuesOML
#define glXGetMscRateOML _glXGetMscRateOML
#define glXSwapBuffersMscOML _glXSwapBuffersMscOML
#define glXWaitForMscOML _glXWaitForMscOML
#define glXWaitForSbcOML _glXWaitForSbcOML
#define glXGetAGPOffsetMESA _glXGetAGPOffsetMESA
#define glXBindTexImageEXT _glXBindTexImageEXT
#define glXReleaseTexImageEXT _glXReleaseTexImageEXT
#define glXJoinSwapGroupNV _glXJoinSwapGroupNV
#define glXBindSwapBarrierNV _glXBindSwapBarrierNV
#define glXQuerySwapGroupNV _glXQuerySwapGroupNV
#define glXQueryMaxSwapGroupsNV _glXQueryMaxSwapGroupsNV
#define glXQueryFrameCountNV _glXQueryFrameCountNV
#define glXResetFrameCountNV _glXResetFrameCountNV
#define glXSwapIntervalEXT _glXSwapIntervalEXT
#define glXCopyImageSubDataNV _glXCopyImageSubDataNV
#define glXAllocateMemoryNV _glXAllocateMemoryNV
#define glXFreeMemoryNV _glXFreeMemoryNV
#define glXGetProcAddressARB _glXGetProcAddressARB
#define glXGetProcAddress _glXGetProcAddress
#endif /* RETRACE */


#endif

typedef void (APIENTRY * PFN_GLCULLFACE)(GLenum mode);
static PFN_GLCULLFACE _glCullFace_ptr = NULL;

static inline void APIENTRY _glCullFace(GLenum mode) {
    const char *_name = "glCullFace";
    if (!_glCullFace_ptr) {
        _glCullFace_ptr = (PFN_GLCULLFACE)_getPublicProcAddress(_name);
        if (!_glCullFace_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCullFace_ptr(mode);
}

typedef void (APIENTRY * PFN_GLFRONTFACE)(GLenum mode);
static PFN_GLFRONTFACE _glFrontFace_ptr = NULL;

static inline void APIENTRY _glFrontFace(GLenum mode) {
    const char *_name = "glFrontFace";
    if (!_glFrontFace_ptr) {
        _glFrontFace_ptr = (PFN_GLFRONTFACE)_getPublicProcAddress(_name);
        if (!_glFrontFace_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFrontFace_ptr(mode);
}

typedef void (APIENTRY * PFN_GLHINT)(GLenum target, GLenum mode);
static PFN_GLHINT _glHint_ptr = NULL;

static inline void APIENTRY _glHint(GLenum target, GLenum mode) {
    const char *_name = "glHint";
    if (!_glHint_ptr) {
        _glHint_ptr = (PFN_GLHINT)_getPublicProcAddress(_name);
        if (!_glHint_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glHint_ptr(target, mode);
}

typedef void (APIENTRY * PFN_GLLINEWIDTH)(GLfloat width);
static PFN_GLLINEWIDTH _glLineWidth_ptr = NULL;

static inline void APIENTRY _glLineWidth(GLfloat width) {
    const char *_name = "glLineWidth";
    if (!_glLineWidth_ptr) {
        _glLineWidth_ptr = (PFN_GLLINEWIDTH)_getPublicProcAddress(_name);
        if (!_glLineWidth_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLineWidth_ptr(width);
}

typedef void (APIENTRY * PFN_GLPOINTSIZE)(GLfloat size);
static PFN_GLPOINTSIZE _glPointSize_ptr = NULL;

static inline void APIENTRY _glPointSize(GLfloat size) {
    const char *_name = "glPointSize";
    if (!_glPointSize_ptr) {
        _glPointSize_ptr = (PFN_GLPOINTSIZE)_getPublicProcAddress(_name);
        if (!_glPointSize_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointSize_ptr(size);
}

typedef void (APIENTRY * PFN_GLPOLYGONMODE)(GLenum face, GLenum mode);
static PFN_GLPOLYGONMODE _glPolygonMode_ptr = NULL;

static inline void APIENTRY _glPolygonMode(GLenum face, GLenum mode) {
    const char *_name = "glPolygonMode";
    if (!_glPolygonMode_ptr) {
        _glPolygonMode_ptr = (PFN_GLPOLYGONMODE)_getPublicProcAddress(_name);
        if (!_glPolygonMode_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPolygonMode_ptr(face, mode);
}

typedef void (APIENTRY * PFN_GLSCISSOR)(GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLSCISSOR _glScissor_ptr = NULL;

static inline void APIENTRY _glScissor(GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glScissor";
    if (!_glScissor_ptr) {
        _glScissor_ptr = (PFN_GLSCISSOR)_getPublicProcAddress(_name);
        if (!_glScissor_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glScissor_ptr(x, y, width, height);
}

typedef void (APIENTRY * PFN_GLTEXPARAMETERF)(GLenum target, GLenum pname, GLfloat param);
static PFN_GLTEXPARAMETERF _glTexParameterf_ptr = NULL;

static inline void APIENTRY _glTexParameterf(GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glTexParameterf";
    if (!_glTexParameterf_ptr) {
        _glTexParameterf_ptr = (PFN_GLTEXPARAMETERF)_getPublicProcAddress(_name);
        if (!_glTexParameterf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexParameterf_ptr(target, pname, param);
}

typedef void (APIENTRY * PFN_GLTEXPARAMETERFV)(GLenum target, GLenum pname, const GLfloat * params);
static PFN_GLTEXPARAMETERFV _glTexParameterfv_ptr = NULL;

static inline void APIENTRY _glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glTexParameterfv";
    if (!_glTexParameterfv_ptr) {
        _glTexParameterfv_ptr = (PFN_GLTEXPARAMETERFV)_getPublicProcAddress(_name);
        if (!_glTexParameterfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexParameterfv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLTEXPARAMETERI)(GLenum target, GLenum pname, GLint param);
static PFN_GLTEXPARAMETERI _glTexParameteri_ptr = NULL;

static inline void APIENTRY _glTexParameteri(GLenum target, GLenum pname, GLint param) {
    const char *_name = "glTexParameteri";
    if (!_glTexParameteri_ptr) {
        _glTexParameteri_ptr = (PFN_GLTEXPARAMETERI)_getPublicProcAddress(_name);
        if (!_glTexParameteri_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexParameteri_ptr(target, pname, param);
}

typedef void (APIENTRY * PFN_GLTEXPARAMETERIV)(GLenum target, GLenum pname, const GLint * params);
static PFN_GLTEXPARAMETERIV _glTexParameteriv_ptr = NULL;

static inline void APIENTRY _glTexParameteriv(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glTexParameteriv";
    if (!_glTexParameteriv_ptr) {
        _glTexParameteriv_ptr = (PFN_GLTEXPARAMETERIV)_getPublicProcAddress(_name);
        if (!_glTexParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexParameteriv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLTEXIMAGE1D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXIMAGE1D _glTexImage1D_ptr = NULL;

static inline void APIENTRY _glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexImage1D";
    if (!_glTexImage1D_ptr) {
        _glTexImage1D_ptr = (PFN_GLTEXIMAGE1D)_getPublicProcAddress(_name);
        if (!_glTexImage1D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexImage1D_ptr(target, level, internalformat, width, border, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLTEXIMAGE2D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXIMAGE2D _glTexImage2D_ptr = NULL;

static inline void APIENTRY _glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexImage2D";
    if (!_glTexImage2D_ptr) {
        _glTexImage2D_ptr = (PFN_GLTEXIMAGE2D)_getPublicProcAddress(_name);
        if (!_glTexImage2D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexImage2D_ptr(target, level, internalformat, width, height, border, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLDRAWBUFFER)(GLenum mode);
static PFN_GLDRAWBUFFER _glDrawBuffer_ptr = NULL;

static inline void APIENTRY _glDrawBuffer(GLenum mode) {
    const char *_name = "glDrawBuffer";
    if (!_glDrawBuffer_ptr) {
        _glDrawBuffer_ptr = (PFN_GLDRAWBUFFER)_getPublicProcAddress(_name);
        if (!_glDrawBuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawBuffer_ptr(mode);
}

typedef void (APIENTRY * PFN_GLCLEAR)(GLbitfield mask);
static PFN_GLCLEAR _glClear_ptr = NULL;

static inline void APIENTRY _glClear(GLbitfield mask) {
    const char *_name = "glClear";
    if (!_glClear_ptr) {
        _glClear_ptr = (PFN_GLCLEAR)_getPublicProcAddress(_name);
        if (!_glClear_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClear_ptr(mask);
}

typedef void (APIENTRY * PFN_GLCLEARCOLOR)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
static PFN_GLCLEARCOLOR _glClearColor_ptr = NULL;

static inline void APIENTRY _glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    const char *_name = "glClearColor";
    if (!_glClearColor_ptr) {
        _glClearColor_ptr = (PFN_GLCLEARCOLOR)_getPublicProcAddress(_name);
        if (!_glClearColor_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearColor_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLCLEARSTENCIL)(GLint s);
static PFN_GLCLEARSTENCIL _glClearStencil_ptr = NULL;

static inline void APIENTRY _glClearStencil(GLint s) {
    const char *_name = "glClearStencil";
    if (!_glClearStencil_ptr) {
        _glClearStencil_ptr = (PFN_GLCLEARSTENCIL)_getPublicProcAddress(_name);
        if (!_glClearStencil_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearStencil_ptr(s);
}

typedef void (APIENTRY * PFN_GLCLEARDEPTH)(GLdouble depth);
static PFN_GLCLEARDEPTH _glClearDepth_ptr = NULL;

static inline void APIENTRY _glClearDepth(GLdouble depth) {
    const char *_name = "glClearDepth";
    if (!_glClearDepth_ptr) {
        _glClearDepth_ptr = (PFN_GLCLEARDEPTH)_getPublicProcAddress(_name);
        if (!_glClearDepth_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearDepth_ptr(depth);
}

typedef void (APIENTRY * PFN_GLSTENCILMASK)(GLuint mask);
static PFN_GLSTENCILMASK _glStencilMask_ptr = NULL;

static inline void APIENTRY _glStencilMask(GLuint mask) {
    const char *_name = "glStencilMask";
    if (!_glStencilMask_ptr) {
        _glStencilMask_ptr = (PFN_GLSTENCILMASK)_getPublicProcAddress(_name);
        if (!_glStencilMask_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glStencilMask_ptr(mask);
}

typedef void (APIENTRY * PFN_GLCOLORMASK)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
static PFN_GLCOLORMASK _glColorMask_ptr = NULL;

static inline void APIENTRY _glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
    const char *_name = "glColorMask";
    if (!_glColorMask_ptr) {
        _glColorMask_ptr = (PFN_GLCOLORMASK)_getPublicProcAddress(_name);
        if (!_glColorMask_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorMask_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLDEPTHMASK)(GLboolean flag);
static PFN_GLDEPTHMASK _glDepthMask_ptr = NULL;

static inline void APIENTRY _glDepthMask(GLboolean flag) {
    const char *_name = "glDepthMask";
    if (!_glDepthMask_ptr) {
        _glDepthMask_ptr = (PFN_GLDEPTHMASK)_getPublicProcAddress(_name);
        if (!_glDepthMask_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDepthMask_ptr(flag);
}

typedef void (APIENTRY * PFN_GLDISABLE)(GLenum cap);
static PFN_GLDISABLE _glDisable_ptr = NULL;

static inline void APIENTRY _glDisable(GLenum cap) {
    const char *_name = "glDisable";
    if (!_glDisable_ptr) {
        _glDisable_ptr = (PFN_GLDISABLE)_getPublicProcAddress(_name);
        if (!_glDisable_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDisable_ptr(cap);
}

typedef void (APIENTRY * PFN_GLENABLE)(GLenum cap);
static PFN_GLENABLE _glEnable_ptr = NULL;

static inline void APIENTRY _glEnable(GLenum cap) {
    const char *_name = "glEnable";
    if (!_glEnable_ptr) {
        _glEnable_ptr = (PFN_GLENABLE)_getPublicProcAddress(_name);
        if (!_glEnable_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEnable_ptr(cap);
}

typedef void (APIENTRY * PFN_GLFINISH)(void);
static PFN_GLFINISH _glFinish_ptr = NULL;

static inline void APIENTRY _glFinish(void) {
    const char *_name = "glFinish";
    if (!_glFinish_ptr) {
        _glFinish_ptr = (PFN_GLFINISH)_getPublicProcAddress(_name);
        if (!_glFinish_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFinish_ptr();
}

typedef void (APIENTRY * PFN_GLFLUSH)(void);
static PFN_GLFLUSH _glFlush_ptr = NULL;

static inline void APIENTRY _glFlush(void) {
    const char *_name = "glFlush";
    if (!_glFlush_ptr) {
        _glFlush_ptr = (PFN_GLFLUSH)_getPublicProcAddress(_name);
        if (!_glFlush_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFlush_ptr();
}

typedef void (APIENTRY * PFN_GLBLENDFUNC)(GLenum sfactor, GLenum dfactor);
static PFN_GLBLENDFUNC _glBlendFunc_ptr = NULL;

static inline void APIENTRY _glBlendFunc(GLenum sfactor, GLenum dfactor) {
    const char *_name = "glBlendFunc";
    if (!_glBlendFunc_ptr) {
        _glBlendFunc_ptr = (PFN_GLBLENDFUNC)_getPublicProcAddress(_name);
        if (!_glBlendFunc_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendFunc_ptr(sfactor, dfactor);
}

typedef void (APIENTRY * PFN_GLLOGICOP)(GLenum opcode);
static PFN_GLLOGICOP _glLogicOp_ptr = NULL;

static inline void APIENTRY _glLogicOp(GLenum opcode) {
    const char *_name = "glLogicOp";
    if (!_glLogicOp_ptr) {
        _glLogicOp_ptr = (PFN_GLLOGICOP)_getPublicProcAddress(_name);
        if (!_glLogicOp_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLogicOp_ptr(opcode);
}

typedef void (APIENTRY * PFN_GLSTENCILFUNC)(GLenum func, GLint ref, GLuint mask);
static PFN_GLSTENCILFUNC _glStencilFunc_ptr = NULL;

static inline void APIENTRY _glStencilFunc(GLenum func, GLint ref, GLuint mask) {
    const char *_name = "glStencilFunc";
    if (!_glStencilFunc_ptr) {
        _glStencilFunc_ptr = (PFN_GLSTENCILFUNC)_getPublicProcAddress(_name);
        if (!_glStencilFunc_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glStencilFunc_ptr(func, ref, mask);
}

typedef void (APIENTRY * PFN_GLSTENCILOP)(GLenum fail, GLenum zfail, GLenum zpass);
static PFN_GLSTENCILOP _glStencilOp_ptr = NULL;

static inline void APIENTRY _glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {
    const char *_name = "glStencilOp";
    if (!_glStencilOp_ptr) {
        _glStencilOp_ptr = (PFN_GLSTENCILOP)_getPublicProcAddress(_name);
        if (!_glStencilOp_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glStencilOp_ptr(fail, zfail, zpass);
}

typedef void (APIENTRY * PFN_GLDEPTHFUNC)(GLenum func);
static PFN_GLDEPTHFUNC _glDepthFunc_ptr = NULL;

static inline void APIENTRY _glDepthFunc(GLenum func) {
    const char *_name = "glDepthFunc";
    if (!_glDepthFunc_ptr) {
        _glDepthFunc_ptr = (PFN_GLDEPTHFUNC)_getPublicProcAddress(_name);
        if (!_glDepthFunc_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDepthFunc_ptr(func);
}

typedef void (APIENTRY * PFN_GLPIXELSTOREF)(GLenum pname, GLfloat param);
static PFN_GLPIXELSTOREF _glPixelStoref_ptr = NULL;

static inline void APIENTRY _glPixelStoref(GLenum pname, GLfloat param) {
    const char *_name = "glPixelStoref";
    if (!_glPixelStoref_ptr) {
        _glPixelStoref_ptr = (PFN_GLPIXELSTOREF)_getPublicProcAddress(_name);
        if (!_glPixelStoref_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelStoref_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLPIXELSTOREI)(GLenum pname, GLint param);
static PFN_GLPIXELSTOREI _glPixelStorei_ptr = NULL;

static inline void APIENTRY _glPixelStorei(GLenum pname, GLint param) {
    const char *_name = "glPixelStorei";
    if (!_glPixelStorei_ptr) {
        _glPixelStorei_ptr = (PFN_GLPIXELSTOREI)_getPublicProcAddress(_name);
        if (!_glPixelStorei_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelStorei_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLREADBUFFER)(GLenum mode);
static PFN_GLREADBUFFER _glReadBuffer_ptr = NULL;

static inline void APIENTRY _glReadBuffer(GLenum mode) {
    const char *_name = "glReadBuffer";
    if (!_glReadBuffer_ptr) {
        _glReadBuffer_ptr = (PFN_GLREADBUFFER)_getPublicProcAddress(_name);
        if (!_glReadBuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReadBuffer_ptr(mode);
}

typedef void (APIENTRY * PFN_GLREADPIXELS)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * pixels);
static PFN_GLREADPIXELS _glReadPixels_ptr = NULL;

static inline void APIENTRY _glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * pixels) {
    const char *_name = "glReadPixels";
    if (!_glReadPixels_ptr) {
        _glReadPixels_ptr = (PFN_GLREADPIXELS)_getPublicProcAddress(_name);
        if (!_glReadPixels_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReadPixels_ptr(x, y, width, height, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLGETBOOLEANV)(GLenum pname, GLboolean * params);
static PFN_GLGETBOOLEANV _glGetBooleanv_ptr = NULL;

static inline void APIENTRY _glGetBooleanv(GLenum pname, GLboolean * params) {
    const char *_name = "glGetBooleanv";
    if (!_glGetBooleanv_ptr) {
        _glGetBooleanv_ptr = (PFN_GLGETBOOLEANV)_getPublicProcAddress(_name);
        if (!_glGetBooleanv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetBooleanv_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLGETDOUBLEV)(GLenum pname, GLdouble * params);
static PFN_GLGETDOUBLEV _glGetDoublev_ptr = NULL;

static inline void APIENTRY _glGetDoublev(GLenum pname, GLdouble * params) {
    const char *_name = "glGetDoublev";
    if (!_glGetDoublev_ptr) {
        _glGetDoublev_ptr = (PFN_GLGETDOUBLEV)_getPublicProcAddress(_name);
        if (!_glGetDoublev_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetDoublev_ptr(pname, params);
}

typedef GLenum (APIENTRY * PFN_GLGETERROR)(void);
static PFN_GLGETERROR _glGetError_ptr = NULL;

static inline GLenum APIENTRY _glGetError(void) {
    const char *_name = "glGetError";
    if (!_glGetError_ptr) {
        _glGetError_ptr = (PFN_GLGETERROR)_getPublicProcAddress(_name);
        if (!_glGetError_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetError_ptr();
}

typedef void (APIENTRY * PFN_GLGETFLOATV)(GLenum pname, GLfloat * params);
static PFN_GLGETFLOATV _glGetFloatv_ptr = NULL;

static inline void APIENTRY _glGetFloatv(GLenum pname, GLfloat * params) {
    const char *_name = "glGetFloatv";
    if (!_glGetFloatv_ptr) {
        _glGetFloatv_ptr = (PFN_GLGETFLOATV)_getPublicProcAddress(_name);
        if (!_glGetFloatv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFloatv_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLGETINTEGERV)(GLenum pname, GLint * params);
static PFN_GLGETINTEGERV _glGetIntegerv_ptr = NULL;

static inline void APIENTRY _glGetIntegerv(GLenum pname, GLint * params) {
    const char *_name = "glGetIntegerv";
    if (!_glGetIntegerv_ptr) {
        _glGetIntegerv_ptr = (PFN_GLGETINTEGERV)_getPublicProcAddress(_name);
        if (!_glGetIntegerv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetIntegerv_ptr(pname, params);
}

typedef const GLubyte * (APIENTRY * PFN_GLGETSTRING)(GLenum name);
static PFN_GLGETSTRING _glGetString_ptr = NULL;

static inline const GLubyte * APIENTRY _glGetString(GLenum name) {
    const char *_name = "glGetString";
    if (!_glGetString_ptr) {
        _glGetString_ptr = (PFN_GLGETSTRING)_getPublicProcAddress(_name);
        if (!_glGetString_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetString_ptr(name);
}

typedef void (APIENTRY * PFN_GLGETTEXIMAGE)(GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels);
static PFN_GLGETTEXIMAGE _glGetTexImage_ptr = NULL;

static inline void APIENTRY _glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels) {
    const char *_name = "glGetTexImage";
    if (!_glGetTexImage_ptr) {
        _glGetTexImage_ptr = (PFN_GLGETTEXIMAGE)_getPublicProcAddress(_name);
        if (!_glGetTexImage_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexImage_ptr(target, level, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLGETTEXPARAMETERFV)(GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETTEXPARAMETERFV _glGetTexParameterfv_ptr = NULL;

static inline void APIENTRY _glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTexParameterfv";
    if (!_glGetTexParameterfv_ptr) {
        _glGetTexParameterfv_ptr = (PFN_GLGETTEXPARAMETERFV)_getPublicProcAddress(_name);
        if (!_glGetTexParameterfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexParameterfv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXPARAMETERIV)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETTEXPARAMETERIV _glGetTexParameteriv_ptr = NULL;

static inline void APIENTRY _glGetTexParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetTexParameteriv";
    if (!_glGetTexParameteriv_ptr) {
        _glGetTexParameteriv_ptr = (PFN_GLGETTEXPARAMETERIV)_getPublicProcAddress(_name);
        if (!_glGetTexParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexParameteriv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXLEVELPARAMETERFV)(GLenum target, GLint level, GLenum pname, GLfloat * params);
static PFN_GLGETTEXLEVELPARAMETERFV _glGetTexLevelParameterfv_ptr = NULL;

static inline void APIENTRY _glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTexLevelParameterfv";
    if (!_glGetTexLevelParameterfv_ptr) {
        _glGetTexLevelParameterfv_ptr = (PFN_GLGETTEXLEVELPARAMETERFV)_getPublicProcAddress(_name);
        if (!_glGetTexLevelParameterfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexLevelParameterfv_ptr(target, level, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXLEVELPARAMETERIV)(GLenum target, GLint level, GLenum pname, GLint * params);
static PFN_GLGETTEXLEVELPARAMETERIV _glGetTexLevelParameteriv_ptr = NULL;

static inline void APIENTRY _glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params) {
    const char *_name = "glGetTexLevelParameteriv";
    if (!_glGetTexLevelParameteriv_ptr) {
        _glGetTexLevelParameteriv_ptr = (PFN_GLGETTEXLEVELPARAMETERIV)_getPublicProcAddress(_name);
        if (!_glGetTexLevelParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexLevelParameteriv_ptr(target, level, pname, params);
}

typedef GLboolean (APIENTRY * PFN_GLISENABLED)(GLenum cap);
static PFN_GLISENABLED _glIsEnabled_ptr = NULL;

static inline GLboolean APIENTRY _glIsEnabled(GLenum cap) {
    const char *_name = "glIsEnabled";
    if (!_glIsEnabled_ptr) {
        _glIsEnabled_ptr = (PFN_GLISENABLED)_getPublicProcAddress(_name);
        if (!_glIsEnabled_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsEnabled_ptr(cap);
}

typedef void (APIENTRY * PFN_GLDEPTHRANGE)(GLdouble zNear, GLdouble zFar);
static PFN_GLDEPTHRANGE _glDepthRange_ptr = NULL;

static inline void APIENTRY _glDepthRange(GLdouble zNear, GLdouble zFar) {
    const char *_name = "glDepthRange";
    if (!_glDepthRange_ptr) {
        _glDepthRange_ptr = (PFN_GLDEPTHRANGE)_getPublicProcAddress(_name);
        if (!_glDepthRange_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDepthRange_ptr(zNear, zFar);
}

typedef void (APIENTRY * PFN_GLVIEWPORT)(GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLVIEWPORT _glViewport_ptr = NULL;

static inline void APIENTRY _glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glViewport";
    if (!_glViewport_ptr) {
        _glViewport_ptr = (PFN_GLVIEWPORT)_getPublicProcAddress(_name);
        if (!_glViewport_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glViewport_ptr(x, y, width, height);
}

typedef void (APIENTRY * PFN_GLNEWLIST)(GLuint list, GLenum mode);
static PFN_GLNEWLIST _glNewList_ptr = NULL;

static inline void APIENTRY _glNewList(GLuint list, GLenum mode) {
    const char *_name = "glNewList";
    if (!_glNewList_ptr) {
        _glNewList_ptr = (PFN_GLNEWLIST)_getPublicProcAddress(_name);
        if (!_glNewList_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNewList_ptr(list, mode);
}

typedef void (APIENTRY * PFN_GLENDLIST)(void);
static PFN_GLENDLIST _glEndList_ptr = NULL;

static inline void APIENTRY _glEndList(void) {
    const char *_name = "glEndList";
    if (!_glEndList_ptr) {
        _glEndList_ptr = (PFN_GLENDLIST)_getPublicProcAddress(_name);
        if (!_glEndList_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndList_ptr();
}

typedef void (APIENTRY * PFN_GLCALLLIST)(GLuint list);
static PFN_GLCALLLIST _glCallList_ptr = NULL;

static inline void APIENTRY _glCallList(GLuint list) {
    const char *_name = "glCallList";
    if (!_glCallList_ptr) {
        _glCallList_ptr = (PFN_GLCALLLIST)_getPublicProcAddress(_name);
        if (!_glCallList_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCallList_ptr(list);
}

typedef void (APIENTRY * PFN_GLCALLLISTS)(GLsizei n, GLenum type, const GLvoid * lists);
static PFN_GLCALLLISTS _glCallLists_ptr = NULL;

static inline void APIENTRY _glCallLists(GLsizei n, GLenum type, const GLvoid * lists) {
    const char *_name = "glCallLists";
    if (!_glCallLists_ptr) {
        _glCallLists_ptr = (PFN_GLCALLLISTS)_getPublicProcAddress(_name);
        if (!_glCallLists_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCallLists_ptr(n, type, lists);
}

typedef void (APIENTRY * PFN_GLDELETELISTS)(GLuint list, GLsizei range);
static PFN_GLDELETELISTS _glDeleteLists_ptr = NULL;

static inline void APIENTRY _glDeleteLists(GLuint list, GLsizei range) {
    const char *_name = "glDeleteLists";
    if (!_glDeleteLists_ptr) {
        _glDeleteLists_ptr = (PFN_GLDELETELISTS)_getPublicProcAddress(_name);
        if (!_glDeleteLists_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteLists_ptr(list, range);
}

typedef GLuint (APIENTRY * PFN_GLGENLISTS)(GLsizei range);
static PFN_GLGENLISTS _glGenLists_ptr = NULL;

static inline GLuint APIENTRY _glGenLists(GLsizei range) {
    const char *_name = "glGenLists";
    if (!_glGenLists_ptr) {
        _glGenLists_ptr = (PFN_GLGENLISTS)_getPublicProcAddress(_name);
        if (!_glGenLists_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGenLists_ptr(range);
}

typedef void (APIENTRY * PFN_GLLISTBASE)(GLuint base);
static PFN_GLLISTBASE _glListBase_ptr = NULL;

static inline void APIENTRY _glListBase(GLuint base) {
    const char *_name = "glListBase";
    if (!_glListBase_ptr) {
        _glListBase_ptr = (PFN_GLLISTBASE)_getPublicProcAddress(_name);
        if (!_glListBase_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glListBase_ptr(base);
}

typedef void (APIENTRY * PFN_GLBEGIN)(GLenum mode);
static PFN_GLBEGIN _glBegin_ptr = NULL;

static inline void APIENTRY _glBegin(GLenum mode) {
    const char *_name = "glBegin";
    if (!_glBegin_ptr) {
        _glBegin_ptr = (PFN_GLBEGIN)_getPublicProcAddress(_name);
        if (!_glBegin_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBegin_ptr(mode);
}

typedef void (APIENTRY * PFN_GLBITMAP)(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap);
static PFN_GLBITMAP _glBitmap_ptr = NULL;

static inline void APIENTRY _glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap) {
    const char *_name = "glBitmap";
    if (!_glBitmap_ptr) {
        _glBitmap_ptr = (PFN_GLBITMAP)_getPublicProcAddress(_name);
        if (!_glBitmap_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBitmap_ptr(width, height, xorig, yorig, xmove, ymove, bitmap);
}

typedef void (APIENTRY * PFN_GLCOLOR3B)(GLbyte red, GLbyte green, GLbyte blue);
static PFN_GLCOLOR3B _glColor3b_ptr = NULL;

static inline void APIENTRY _glColor3b(GLbyte red, GLbyte green, GLbyte blue) {
    const char *_name = "glColor3b";
    if (!_glColor3b_ptr) {
        _glColor3b_ptr = (PFN_GLCOLOR3B)_getPublicProcAddress(_name);
        if (!_glColor3b_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3b_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLCOLOR3BV)(const GLbyte * v);
static PFN_GLCOLOR3BV _glColor3bv_ptr = NULL;

static inline void APIENTRY _glColor3bv(const GLbyte * v) {
    const char *_name = "glColor3bv";
    if (!_glColor3bv_ptr) {
        _glColor3bv_ptr = (PFN_GLCOLOR3BV)_getPublicProcAddress(_name);
        if (!_glColor3bv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3bv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR3D)(GLdouble red, GLdouble green, GLdouble blue);
static PFN_GLCOLOR3D _glColor3d_ptr = NULL;

static inline void APIENTRY _glColor3d(GLdouble red, GLdouble green, GLdouble blue) {
    const char *_name = "glColor3d";
    if (!_glColor3d_ptr) {
        _glColor3d_ptr = (PFN_GLCOLOR3D)_getPublicProcAddress(_name);
        if (!_glColor3d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3d_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLCOLOR3DV)(const GLdouble * v);
static PFN_GLCOLOR3DV _glColor3dv_ptr = NULL;

static inline void APIENTRY _glColor3dv(const GLdouble * v) {
    const char *_name = "glColor3dv";
    if (!_glColor3dv_ptr) {
        _glColor3dv_ptr = (PFN_GLCOLOR3DV)_getPublicProcAddress(_name);
        if (!_glColor3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR3F)(GLfloat red, GLfloat green, GLfloat blue);
static PFN_GLCOLOR3F _glColor3f_ptr = NULL;

static inline void APIENTRY _glColor3f(GLfloat red, GLfloat green, GLfloat blue) {
    const char *_name = "glColor3f";
    if (!_glColor3f_ptr) {
        _glColor3f_ptr = (PFN_GLCOLOR3F)_getPublicProcAddress(_name);
        if (!_glColor3f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3f_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLCOLOR3FV)(const GLfloat * v);
static PFN_GLCOLOR3FV _glColor3fv_ptr = NULL;

static inline void APIENTRY _glColor3fv(const GLfloat * v) {
    const char *_name = "glColor3fv";
    if (!_glColor3fv_ptr) {
        _glColor3fv_ptr = (PFN_GLCOLOR3FV)_getPublicProcAddress(_name);
        if (!_glColor3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR3I)(GLint red, GLint green, GLint blue);
static PFN_GLCOLOR3I _glColor3i_ptr = NULL;

static inline void APIENTRY _glColor3i(GLint red, GLint green, GLint blue) {
    const char *_name = "glColor3i";
    if (!_glColor3i_ptr) {
        _glColor3i_ptr = (PFN_GLCOLOR3I)_getPublicProcAddress(_name);
        if (!_glColor3i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3i_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLCOLOR3IV)(const GLint * v);
static PFN_GLCOLOR3IV _glColor3iv_ptr = NULL;

static inline void APIENTRY _glColor3iv(const GLint * v) {
    const char *_name = "glColor3iv";
    if (!_glColor3iv_ptr) {
        _glColor3iv_ptr = (PFN_GLCOLOR3IV)_getPublicProcAddress(_name);
        if (!_glColor3iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR3S)(GLshort red, GLshort green, GLshort blue);
static PFN_GLCOLOR3S _glColor3s_ptr = NULL;

static inline void APIENTRY _glColor3s(GLshort red, GLshort green, GLshort blue) {
    const char *_name = "glColor3s";
    if (!_glColor3s_ptr) {
        _glColor3s_ptr = (PFN_GLCOLOR3S)_getPublicProcAddress(_name);
        if (!_glColor3s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3s_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLCOLOR3SV)(const GLshort * v);
static PFN_GLCOLOR3SV _glColor3sv_ptr = NULL;

static inline void APIENTRY _glColor3sv(const GLshort * v) {
    const char *_name = "glColor3sv";
    if (!_glColor3sv_ptr) {
        _glColor3sv_ptr = (PFN_GLCOLOR3SV)_getPublicProcAddress(_name);
        if (!_glColor3sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR3UB)(GLubyte red, GLubyte green, GLubyte blue);
static PFN_GLCOLOR3UB _glColor3ub_ptr = NULL;

static inline void APIENTRY _glColor3ub(GLubyte red, GLubyte green, GLubyte blue) {
    const char *_name = "glColor3ub";
    if (!_glColor3ub_ptr) {
        _glColor3ub_ptr = (PFN_GLCOLOR3UB)_getPublicProcAddress(_name);
        if (!_glColor3ub_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3ub_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLCOLOR3UBV)(const GLubyte * v);
static PFN_GLCOLOR3UBV _glColor3ubv_ptr = NULL;

static inline void APIENTRY _glColor3ubv(const GLubyte * v) {
    const char *_name = "glColor3ubv";
    if (!_glColor3ubv_ptr) {
        _glColor3ubv_ptr = (PFN_GLCOLOR3UBV)_getPublicProcAddress(_name);
        if (!_glColor3ubv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3ubv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR3UI)(GLuint red, GLuint green, GLuint blue);
static PFN_GLCOLOR3UI _glColor3ui_ptr = NULL;

static inline void APIENTRY _glColor3ui(GLuint red, GLuint green, GLuint blue) {
    const char *_name = "glColor3ui";
    if (!_glColor3ui_ptr) {
        _glColor3ui_ptr = (PFN_GLCOLOR3UI)_getPublicProcAddress(_name);
        if (!_glColor3ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3ui_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLCOLOR3UIV)(const GLuint * v);
static PFN_GLCOLOR3UIV _glColor3uiv_ptr = NULL;

static inline void APIENTRY _glColor3uiv(const GLuint * v) {
    const char *_name = "glColor3uiv";
    if (!_glColor3uiv_ptr) {
        _glColor3uiv_ptr = (PFN_GLCOLOR3UIV)_getPublicProcAddress(_name);
        if (!_glColor3uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3uiv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR3US)(GLushort red, GLushort green, GLushort blue);
static PFN_GLCOLOR3US _glColor3us_ptr = NULL;

static inline void APIENTRY _glColor3us(GLushort red, GLushort green, GLushort blue) {
    const char *_name = "glColor3us";
    if (!_glColor3us_ptr) {
        _glColor3us_ptr = (PFN_GLCOLOR3US)_getPublicProcAddress(_name);
        if (!_glColor3us_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3us_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLCOLOR3USV)(const GLushort * v);
static PFN_GLCOLOR3USV _glColor3usv_ptr = NULL;

static inline void APIENTRY _glColor3usv(const GLushort * v) {
    const char *_name = "glColor3usv";
    if (!_glColor3usv_ptr) {
        _glColor3usv_ptr = (PFN_GLCOLOR3USV)_getPublicProcAddress(_name);
        if (!_glColor3usv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3usv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR4B)(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
static PFN_GLCOLOR4B _glColor4b_ptr = NULL;

static inline void APIENTRY _glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) {
    const char *_name = "glColor4b";
    if (!_glColor4b_ptr) {
        _glColor4b_ptr = (PFN_GLCOLOR4B)_getPublicProcAddress(_name);
        if (!_glColor4b_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4b_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLCOLOR4BV)(const GLbyte * v);
static PFN_GLCOLOR4BV _glColor4bv_ptr = NULL;

static inline void APIENTRY _glColor4bv(const GLbyte * v) {
    const char *_name = "glColor4bv";
    if (!_glColor4bv_ptr) {
        _glColor4bv_ptr = (PFN_GLCOLOR4BV)_getPublicProcAddress(_name);
        if (!_glColor4bv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4bv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR4D)(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
static PFN_GLCOLOR4D _glColor4d_ptr = NULL;

static inline void APIENTRY _glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) {
    const char *_name = "glColor4d";
    if (!_glColor4d_ptr) {
        _glColor4d_ptr = (PFN_GLCOLOR4D)_getPublicProcAddress(_name);
        if (!_glColor4d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4d_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLCOLOR4DV)(const GLdouble * v);
static PFN_GLCOLOR4DV _glColor4dv_ptr = NULL;

static inline void APIENTRY _glColor4dv(const GLdouble * v) {
    const char *_name = "glColor4dv";
    if (!_glColor4dv_ptr) {
        _glColor4dv_ptr = (PFN_GLCOLOR4DV)_getPublicProcAddress(_name);
        if (!_glColor4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR4F)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
static PFN_GLCOLOR4F _glColor4f_ptr = NULL;

static inline void APIENTRY _glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    const char *_name = "glColor4f";
    if (!_glColor4f_ptr) {
        _glColor4f_ptr = (PFN_GLCOLOR4F)_getPublicProcAddress(_name);
        if (!_glColor4f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4f_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLCOLOR4FV)(const GLfloat * v);
static PFN_GLCOLOR4FV _glColor4fv_ptr = NULL;

static inline void APIENTRY _glColor4fv(const GLfloat * v) {
    const char *_name = "glColor4fv";
    if (!_glColor4fv_ptr) {
        _glColor4fv_ptr = (PFN_GLCOLOR4FV)_getPublicProcAddress(_name);
        if (!_glColor4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR4I)(GLint red, GLint green, GLint blue, GLint alpha);
static PFN_GLCOLOR4I _glColor4i_ptr = NULL;

static inline void APIENTRY _glColor4i(GLint red, GLint green, GLint blue, GLint alpha) {
    const char *_name = "glColor4i";
    if (!_glColor4i_ptr) {
        _glColor4i_ptr = (PFN_GLCOLOR4I)_getPublicProcAddress(_name);
        if (!_glColor4i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4i_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLCOLOR4IV)(const GLint * v);
static PFN_GLCOLOR4IV _glColor4iv_ptr = NULL;

static inline void APIENTRY _glColor4iv(const GLint * v) {
    const char *_name = "glColor4iv";
    if (!_glColor4iv_ptr) {
        _glColor4iv_ptr = (PFN_GLCOLOR4IV)_getPublicProcAddress(_name);
        if (!_glColor4iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR4S)(GLshort red, GLshort green, GLshort blue, GLshort alpha);
static PFN_GLCOLOR4S _glColor4s_ptr = NULL;

static inline void APIENTRY _glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) {
    const char *_name = "glColor4s";
    if (!_glColor4s_ptr) {
        _glColor4s_ptr = (PFN_GLCOLOR4S)_getPublicProcAddress(_name);
        if (!_glColor4s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4s_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLCOLOR4SV)(const GLshort * v);
static PFN_GLCOLOR4SV _glColor4sv_ptr = NULL;

static inline void APIENTRY _glColor4sv(const GLshort * v) {
    const char *_name = "glColor4sv";
    if (!_glColor4sv_ptr) {
        _glColor4sv_ptr = (PFN_GLCOLOR4SV)_getPublicProcAddress(_name);
        if (!_glColor4sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR4UB)(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
static PFN_GLCOLOR4UB _glColor4ub_ptr = NULL;

static inline void APIENTRY _glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) {
    const char *_name = "glColor4ub";
    if (!_glColor4ub_ptr) {
        _glColor4ub_ptr = (PFN_GLCOLOR4UB)_getPublicProcAddress(_name);
        if (!_glColor4ub_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4ub_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLCOLOR4UBV)(const GLubyte * v);
static PFN_GLCOLOR4UBV _glColor4ubv_ptr = NULL;

static inline void APIENTRY _glColor4ubv(const GLubyte * v) {
    const char *_name = "glColor4ubv";
    if (!_glColor4ubv_ptr) {
        _glColor4ubv_ptr = (PFN_GLCOLOR4UBV)_getPublicProcAddress(_name);
        if (!_glColor4ubv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4ubv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR4UI)(GLuint red, GLuint green, GLuint blue, GLuint alpha);
static PFN_GLCOLOR4UI _glColor4ui_ptr = NULL;

static inline void APIENTRY _glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
    const char *_name = "glColor4ui";
    if (!_glColor4ui_ptr) {
        _glColor4ui_ptr = (PFN_GLCOLOR4UI)_getPublicProcAddress(_name);
        if (!_glColor4ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4ui_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLCOLOR4UIV)(const GLuint * v);
static PFN_GLCOLOR4UIV _glColor4uiv_ptr = NULL;

static inline void APIENTRY _glColor4uiv(const GLuint * v) {
    const char *_name = "glColor4uiv";
    if (!_glColor4uiv_ptr) {
        _glColor4uiv_ptr = (PFN_GLCOLOR4UIV)_getPublicProcAddress(_name);
        if (!_glColor4uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4uiv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR4US)(GLushort red, GLushort green, GLushort blue, GLushort alpha);
static PFN_GLCOLOR4US _glColor4us_ptr = NULL;

static inline void APIENTRY _glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) {
    const char *_name = "glColor4us";
    if (!_glColor4us_ptr) {
        _glColor4us_ptr = (PFN_GLCOLOR4US)_getPublicProcAddress(_name);
        if (!_glColor4us_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4us_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLCOLOR4USV)(const GLushort * v);
static PFN_GLCOLOR4USV _glColor4usv_ptr = NULL;

static inline void APIENTRY _glColor4usv(const GLushort * v) {
    const char *_name = "glColor4usv";
    if (!_glColor4usv_ptr) {
        _glColor4usv_ptr = (PFN_GLCOLOR4USV)_getPublicProcAddress(_name);
        if (!_glColor4usv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4usv_ptr(v);
}

typedef void (APIENTRY * PFN_GLEDGEFLAG)(GLboolean flag);
static PFN_GLEDGEFLAG _glEdgeFlag_ptr = NULL;

static inline void APIENTRY _glEdgeFlag(GLboolean flag) {
    const char *_name = "glEdgeFlag";
    if (!_glEdgeFlag_ptr) {
        _glEdgeFlag_ptr = (PFN_GLEDGEFLAG)_getPublicProcAddress(_name);
        if (!_glEdgeFlag_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEdgeFlag_ptr(flag);
}

typedef void (APIENTRY * PFN_GLEDGEFLAGV)(const GLboolean * flag);
static PFN_GLEDGEFLAGV _glEdgeFlagv_ptr = NULL;

static inline void APIENTRY _glEdgeFlagv(const GLboolean * flag) {
    const char *_name = "glEdgeFlagv";
    if (!_glEdgeFlagv_ptr) {
        _glEdgeFlagv_ptr = (PFN_GLEDGEFLAGV)_getPublicProcAddress(_name);
        if (!_glEdgeFlagv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEdgeFlagv_ptr(flag);
}

typedef void (APIENTRY * PFN_GLEND)(void);
static PFN_GLEND _glEnd_ptr = NULL;

static inline void APIENTRY _glEnd(void) {
    const char *_name = "glEnd";
    if (!_glEnd_ptr) {
        _glEnd_ptr = (PFN_GLEND)_getPublicProcAddress(_name);
        if (!_glEnd_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEnd_ptr();
}

typedef void (APIENTRY * PFN_GLINDEXD)(GLdouble c);
static PFN_GLINDEXD _glIndexd_ptr = NULL;

static inline void APIENTRY _glIndexd(GLdouble c) {
    const char *_name = "glIndexd";
    if (!_glIndexd_ptr) {
        _glIndexd_ptr = (PFN_GLINDEXD)_getPublicProcAddress(_name);
        if (!_glIndexd_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexd_ptr(c);
}

typedef void (APIENTRY * PFN_GLINDEXDV)(const GLdouble * c);
static PFN_GLINDEXDV _glIndexdv_ptr = NULL;

static inline void APIENTRY _glIndexdv(const GLdouble * c) {
    const char *_name = "glIndexdv";
    if (!_glIndexdv_ptr) {
        _glIndexdv_ptr = (PFN_GLINDEXDV)_getPublicProcAddress(_name);
        if (!_glIndexdv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexdv_ptr(c);
}

typedef void (APIENTRY * PFN_GLINDEXF)(GLfloat c);
static PFN_GLINDEXF _glIndexf_ptr = NULL;

static inline void APIENTRY _glIndexf(GLfloat c) {
    const char *_name = "glIndexf";
    if (!_glIndexf_ptr) {
        _glIndexf_ptr = (PFN_GLINDEXF)_getPublicProcAddress(_name);
        if (!_glIndexf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexf_ptr(c);
}

typedef void (APIENTRY * PFN_GLINDEXFV)(const GLfloat * c);
static PFN_GLINDEXFV _glIndexfv_ptr = NULL;

static inline void APIENTRY _glIndexfv(const GLfloat * c) {
    const char *_name = "glIndexfv";
    if (!_glIndexfv_ptr) {
        _glIndexfv_ptr = (PFN_GLINDEXFV)_getPublicProcAddress(_name);
        if (!_glIndexfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexfv_ptr(c);
}

typedef void (APIENTRY * PFN_GLINDEXI)(GLint c);
static PFN_GLINDEXI _glIndexi_ptr = NULL;

static inline void APIENTRY _glIndexi(GLint c) {
    const char *_name = "glIndexi";
    if (!_glIndexi_ptr) {
        _glIndexi_ptr = (PFN_GLINDEXI)_getPublicProcAddress(_name);
        if (!_glIndexi_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexi_ptr(c);
}

typedef void (APIENTRY * PFN_GLINDEXIV)(const GLint * c);
static PFN_GLINDEXIV _glIndexiv_ptr = NULL;

static inline void APIENTRY _glIndexiv(const GLint * c) {
    const char *_name = "glIndexiv";
    if (!_glIndexiv_ptr) {
        _glIndexiv_ptr = (PFN_GLINDEXIV)_getPublicProcAddress(_name);
        if (!_glIndexiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexiv_ptr(c);
}

typedef void (APIENTRY * PFN_GLINDEXS)(GLshort c);
static PFN_GLINDEXS _glIndexs_ptr = NULL;

static inline void APIENTRY _glIndexs(GLshort c) {
    const char *_name = "glIndexs";
    if (!_glIndexs_ptr) {
        _glIndexs_ptr = (PFN_GLINDEXS)_getPublicProcAddress(_name);
        if (!_glIndexs_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexs_ptr(c);
}

typedef void (APIENTRY * PFN_GLINDEXSV)(const GLshort * c);
static PFN_GLINDEXSV _glIndexsv_ptr = NULL;

static inline void APIENTRY _glIndexsv(const GLshort * c) {
    const char *_name = "glIndexsv";
    if (!_glIndexsv_ptr) {
        _glIndexsv_ptr = (PFN_GLINDEXSV)_getPublicProcAddress(_name);
        if (!_glIndexsv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexsv_ptr(c);
}

typedef void (APIENTRY * PFN_GLNORMAL3B)(GLbyte nx, GLbyte ny, GLbyte nz);
static PFN_GLNORMAL3B _glNormal3b_ptr = NULL;

static inline void APIENTRY _glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz) {
    const char *_name = "glNormal3b";
    if (!_glNormal3b_ptr) {
        _glNormal3b_ptr = (PFN_GLNORMAL3B)_getPublicProcAddress(_name);
        if (!_glNormal3b_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3b_ptr(nx, ny, nz);
}

typedef void (APIENTRY * PFN_GLNORMAL3BV)(const GLbyte * v);
static PFN_GLNORMAL3BV _glNormal3bv_ptr = NULL;

static inline void APIENTRY _glNormal3bv(const GLbyte * v) {
    const char *_name = "glNormal3bv";
    if (!_glNormal3bv_ptr) {
        _glNormal3bv_ptr = (PFN_GLNORMAL3BV)_getPublicProcAddress(_name);
        if (!_glNormal3bv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3bv_ptr(v);
}

typedef void (APIENTRY * PFN_GLNORMAL3D)(GLdouble nx, GLdouble ny, GLdouble nz);
static PFN_GLNORMAL3D _glNormal3d_ptr = NULL;

static inline void APIENTRY _glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz) {
    const char *_name = "glNormal3d";
    if (!_glNormal3d_ptr) {
        _glNormal3d_ptr = (PFN_GLNORMAL3D)_getPublicProcAddress(_name);
        if (!_glNormal3d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3d_ptr(nx, ny, nz);
}

typedef void (APIENTRY * PFN_GLNORMAL3DV)(const GLdouble * v);
static PFN_GLNORMAL3DV _glNormal3dv_ptr = NULL;

static inline void APIENTRY _glNormal3dv(const GLdouble * v) {
    const char *_name = "glNormal3dv";
    if (!_glNormal3dv_ptr) {
        _glNormal3dv_ptr = (PFN_GLNORMAL3DV)_getPublicProcAddress(_name);
        if (!_glNormal3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLNORMAL3F)(GLfloat nx, GLfloat ny, GLfloat nz);
static PFN_GLNORMAL3F _glNormal3f_ptr = NULL;

static inline void APIENTRY _glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz) {
    const char *_name = "glNormal3f";
    if (!_glNormal3f_ptr) {
        _glNormal3f_ptr = (PFN_GLNORMAL3F)_getPublicProcAddress(_name);
        if (!_glNormal3f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3f_ptr(nx, ny, nz);
}

typedef void (APIENTRY * PFN_GLNORMAL3FV)(const GLfloat * v);
static PFN_GLNORMAL3FV _glNormal3fv_ptr = NULL;

static inline void APIENTRY _glNormal3fv(const GLfloat * v) {
    const char *_name = "glNormal3fv";
    if (!_glNormal3fv_ptr) {
        _glNormal3fv_ptr = (PFN_GLNORMAL3FV)_getPublicProcAddress(_name);
        if (!_glNormal3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLNORMAL3I)(GLint nx, GLint ny, GLint nz);
static PFN_GLNORMAL3I _glNormal3i_ptr = NULL;

static inline void APIENTRY _glNormal3i(GLint nx, GLint ny, GLint nz) {
    const char *_name = "glNormal3i";
    if (!_glNormal3i_ptr) {
        _glNormal3i_ptr = (PFN_GLNORMAL3I)_getPublicProcAddress(_name);
        if (!_glNormal3i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3i_ptr(nx, ny, nz);
}

typedef void (APIENTRY * PFN_GLNORMAL3IV)(const GLint * v);
static PFN_GLNORMAL3IV _glNormal3iv_ptr = NULL;

static inline void APIENTRY _glNormal3iv(const GLint * v) {
    const char *_name = "glNormal3iv";
    if (!_glNormal3iv_ptr) {
        _glNormal3iv_ptr = (PFN_GLNORMAL3IV)_getPublicProcAddress(_name);
        if (!_glNormal3iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLNORMAL3S)(GLshort nx, GLshort ny, GLshort nz);
static PFN_GLNORMAL3S _glNormal3s_ptr = NULL;

static inline void APIENTRY _glNormal3s(GLshort nx, GLshort ny, GLshort nz) {
    const char *_name = "glNormal3s";
    if (!_glNormal3s_ptr) {
        _glNormal3s_ptr = (PFN_GLNORMAL3S)_getPublicProcAddress(_name);
        if (!_glNormal3s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3s_ptr(nx, ny, nz);
}

typedef void (APIENTRY * PFN_GLNORMAL3SV)(const GLshort * v);
static PFN_GLNORMAL3SV _glNormal3sv_ptr = NULL;

static inline void APIENTRY _glNormal3sv(const GLshort * v) {
    const char *_name = "glNormal3sv";
    if (!_glNormal3sv_ptr) {
        _glNormal3sv_ptr = (PFN_GLNORMAL3SV)_getPublicProcAddress(_name);
        if (!_glNormal3sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLRASTERPOS2D)(GLdouble x, GLdouble y);
static PFN_GLRASTERPOS2D _glRasterPos2d_ptr = NULL;

static inline void APIENTRY _glRasterPos2d(GLdouble x, GLdouble y) {
    const char *_name = "glRasterPos2d";
    if (!_glRasterPos2d_ptr) {
        _glRasterPos2d_ptr = (PFN_GLRASTERPOS2D)_getPublicProcAddress(_name);
        if (!_glRasterPos2d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos2d_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLRASTERPOS2DV)(const GLdouble * v);
static PFN_GLRASTERPOS2DV _glRasterPos2dv_ptr = NULL;

static inline void APIENTRY _glRasterPos2dv(const GLdouble * v) {
    const char *_name = "glRasterPos2dv";
    if (!_glRasterPos2dv_ptr) {
        _glRasterPos2dv_ptr = (PFN_GLRASTERPOS2DV)_getPublicProcAddress(_name);
        if (!_glRasterPos2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos2dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLRASTERPOS2F)(GLfloat x, GLfloat y);
static PFN_GLRASTERPOS2F _glRasterPos2f_ptr = NULL;

static inline void APIENTRY _glRasterPos2f(GLfloat x, GLfloat y) {
    const char *_name = "glRasterPos2f";
    if (!_glRasterPos2f_ptr) {
        _glRasterPos2f_ptr = (PFN_GLRASTERPOS2F)_getPublicProcAddress(_name);
        if (!_glRasterPos2f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos2f_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLRASTERPOS2FV)(const GLfloat * v);
static PFN_GLRASTERPOS2FV _glRasterPos2fv_ptr = NULL;

static inline void APIENTRY _glRasterPos2fv(const GLfloat * v) {
    const char *_name = "glRasterPos2fv";
    if (!_glRasterPos2fv_ptr) {
        _glRasterPos2fv_ptr = (PFN_GLRASTERPOS2FV)_getPublicProcAddress(_name);
        if (!_glRasterPos2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos2fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLRASTERPOS2I)(GLint x, GLint y);
static PFN_GLRASTERPOS2I _glRasterPos2i_ptr = NULL;

static inline void APIENTRY _glRasterPos2i(GLint x, GLint y) {
    const char *_name = "glRasterPos2i";
    if (!_glRasterPos2i_ptr) {
        _glRasterPos2i_ptr = (PFN_GLRASTERPOS2I)_getPublicProcAddress(_name);
        if (!_glRasterPos2i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos2i_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLRASTERPOS2IV)(const GLint * v);
static PFN_GLRASTERPOS2IV _glRasterPos2iv_ptr = NULL;

static inline void APIENTRY _glRasterPos2iv(const GLint * v) {
    const char *_name = "glRasterPos2iv";
    if (!_glRasterPos2iv_ptr) {
        _glRasterPos2iv_ptr = (PFN_GLRASTERPOS2IV)_getPublicProcAddress(_name);
        if (!_glRasterPos2iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos2iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLRASTERPOS2S)(GLshort x, GLshort y);
static PFN_GLRASTERPOS2S _glRasterPos2s_ptr = NULL;

static inline void APIENTRY _glRasterPos2s(GLshort x, GLshort y) {
    const char *_name = "glRasterPos2s";
    if (!_glRasterPos2s_ptr) {
        _glRasterPos2s_ptr = (PFN_GLRASTERPOS2S)_getPublicProcAddress(_name);
        if (!_glRasterPos2s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos2s_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLRASTERPOS2SV)(const GLshort * v);
static PFN_GLRASTERPOS2SV _glRasterPos2sv_ptr = NULL;

static inline void APIENTRY _glRasterPos2sv(const GLshort * v) {
    const char *_name = "glRasterPos2sv";
    if (!_glRasterPos2sv_ptr) {
        _glRasterPos2sv_ptr = (PFN_GLRASTERPOS2SV)_getPublicProcAddress(_name);
        if (!_glRasterPos2sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos2sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLRASTERPOS3D)(GLdouble x, GLdouble y, GLdouble z);
static PFN_GLRASTERPOS3D _glRasterPos3d_ptr = NULL;

static inline void APIENTRY _glRasterPos3d(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glRasterPos3d";
    if (!_glRasterPos3d_ptr) {
        _glRasterPos3d_ptr = (PFN_GLRASTERPOS3D)_getPublicProcAddress(_name);
        if (!_glRasterPos3d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos3d_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLRASTERPOS3DV)(const GLdouble * v);
static PFN_GLRASTERPOS3DV _glRasterPos3dv_ptr = NULL;

static inline void APIENTRY _glRasterPos3dv(const GLdouble * v) {
    const char *_name = "glRasterPos3dv";
    if (!_glRasterPos3dv_ptr) {
        _glRasterPos3dv_ptr = (PFN_GLRASTERPOS3DV)_getPublicProcAddress(_name);
        if (!_glRasterPos3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos3dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLRASTERPOS3F)(GLfloat x, GLfloat y, GLfloat z);
static PFN_GLRASTERPOS3F _glRasterPos3f_ptr = NULL;

static inline void APIENTRY _glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glRasterPos3f";
    if (!_glRasterPos3f_ptr) {
        _glRasterPos3f_ptr = (PFN_GLRASTERPOS3F)_getPublicProcAddress(_name);
        if (!_glRasterPos3f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos3f_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLRASTERPOS3FV)(const GLfloat * v);
static PFN_GLRASTERPOS3FV _glRasterPos3fv_ptr = NULL;

static inline void APIENTRY _glRasterPos3fv(const GLfloat * v) {
    const char *_name = "glRasterPos3fv";
    if (!_glRasterPos3fv_ptr) {
        _glRasterPos3fv_ptr = (PFN_GLRASTERPOS3FV)_getPublicProcAddress(_name);
        if (!_glRasterPos3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos3fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLRASTERPOS3I)(GLint x, GLint y, GLint z);
static PFN_GLRASTERPOS3I _glRasterPos3i_ptr = NULL;

static inline void APIENTRY _glRasterPos3i(GLint x, GLint y, GLint z) {
    const char *_name = "glRasterPos3i";
    if (!_glRasterPos3i_ptr) {
        _glRasterPos3i_ptr = (PFN_GLRASTERPOS3I)_getPublicProcAddress(_name);
        if (!_glRasterPos3i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos3i_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLRASTERPOS3IV)(const GLint * v);
static PFN_GLRASTERPOS3IV _glRasterPos3iv_ptr = NULL;

static inline void APIENTRY _glRasterPos3iv(const GLint * v) {
    const char *_name = "glRasterPos3iv";
    if (!_glRasterPos3iv_ptr) {
        _glRasterPos3iv_ptr = (PFN_GLRASTERPOS3IV)_getPublicProcAddress(_name);
        if (!_glRasterPos3iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos3iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLRASTERPOS3S)(GLshort x, GLshort y, GLshort z);
static PFN_GLRASTERPOS3S _glRasterPos3s_ptr = NULL;

static inline void APIENTRY _glRasterPos3s(GLshort x, GLshort y, GLshort z) {
    const char *_name = "glRasterPos3s";
    if (!_glRasterPos3s_ptr) {
        _glRasterPos3s_ptr = (PFN_GLRASTERPOS3S)_getPublicProcAddress(_name);
        if (!_glRasterPos3s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos3s_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLRASTERPOS3SV)(const GLshort * v);
static PFN_GLRASTERPOS3SV _glRasterPos3sv_ptr = NULL;

static inline void APIENTRY _glRasterPos3sv(const GLshort * v) {
    const char *_name = "glRasterPos3sv";
    if (!_glRasterPos3sv_ptr) {
        _glRasterPos3sv_ptr = (PFN_GLRASTERPOS3SV)_getPublicProcAddress(_name);
        if (!_glRasterPos3sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos3sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLRASTERPOS4D)(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLRASTERPOS4D _glRasterPos4d_ptr = NULL;

static inline void APIENTRY _glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glRasterPos4d";
    if (!_glRasterPos4d_ptr) {
        _glRasterPos4d_ptr = (PFN_GLRASTERPOS4D)_getPublicProcAddress(_name);
        if (!_glRasterPos4d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos4d_ptr(x, y, z, w);
}

typedef void (APIENTRY * PFN_GLRASTERPOS4DV)(const GLdouble * v);
static PFN_GLRASTERPOS4DV _glRasterPos4dv_ptr = NULL;

static inline void APIENTRY _glRasterPos4dv(const GLdouble * v) {
    const char *_name = "glRasterPos4dv";
    if (!_glRasterPos4dv_ptr) {
        _glRasterPos4dv_ptr = (PFN_GLRASTERPOS4DV)_getPublicProcAddress(_name);
        if (!_glRasterPos4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos4dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLRASTERPOS4F)(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLRASTERPOS4F _glRasterPos4f_ptr = NULL;

static inline void APIENTRY _glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glRasterPos4f";
    if (!_glRasterPos4f_ptr) {
        _glRasterPos4f_ptr = (PFN_GLRASTERPOS4F)_getPublicProcAddress(_name);
        if (!_glRasterPos4f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos4f_ptr(x, y, z, w);
}

typedef void (APIENTRY * PFN_GLRASTERPOS4FV)(const GLfloat * v);
static PFN_GLRASTERPOS4FV _glRasterPos4fv_ptr = NULL;

static inline void APIENTRY _glRasterPos4fv(const GLfloat * v) {
    const char *_name = "glRasterPos4fv";
    if (!_glRasterPos4fv_ptr) {
        _glRasterPos4fv_ptr = (PFN_GLRASTERPOS4FV)_getPublicProcAddress(_name);
        if (!_glRasterPos4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos4fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLRASTERPOS4I)(GLint x, GLint y, GLint z, GLint w);
static PFN_GLRASTERPOS4I _glRasterPos4i_ptr = NULL;

static inline void APIENTRY _glRasterPos4i(GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glRasterPos4i";
    if (!_glRasterPos4i_ptr) {
        _glRasterPos4i_ptr = (PFN_GLRASTERPOS4I)_getPublicProcAddress(_name);
        if (!_glRasterPos4i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos4i_ptr(x, y, z, w);
}

typedef void (APIENTRY * PFN_GLRASTERPOS4IV)(const GLint * v);
static PFN_GLRASTERPOS4IV _glRasterPos4iv_ptr = NULL;

static inline void APIENTRY _glRasterPos4iv(const GLint * v) {
    const char *_name = "glRasterPos4iv";
    if (!_glRasterPos4iv_ptr) {
        _glRasterPos4iv_ptr = (PFN_GLRASTERPOS4IV)_getPublicProcAddress(_name);
        if (!_glRasterPos4iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos4iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLRASTERPOS4S)(GLshort x, GLshort y, GLshort z, GLshort w);
static PFN_GLRASTERPOS4S _glRasterPos4s_ptr = NULL;

static inline void APIENTRY _glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glRasterPos4s";
    if (!_glRasterPos4s_ptr) {
        _glRasterPos4s_ptr = (PFN_GLRASTERPOS4S)_getPublicProcAddress(_name);
        if (!_glRasterPos4s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos4s_ptr(x, y, z, w);
}

typedef void (APIENTRY * PFN_GLRASTERPOS4SV)(const GLshort * v);
static PFN_GLRASTERPOS4SV _glRasterPos4sv_ptr = NULL;

static inline void APIENTRY _glRasterPos4sv(const GLshort * v) {
    const char *_name = "glRasterPos4sv";
    if (!_glRasterPos4sv_ptr) {
        _glRasterPos4sv_ptr = (PFN_GLRASTERPOS4SV)_getPublicProcAddress(_name);
        if (!_glRasterPos4sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRasterPos4sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLRECTD)(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
static PFN_GLRECTD _glRectd_ptr = NULL;

static inline void APIENTRY _glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) {
    const char *_name = "glRectd";
    if (!_glRectd_ptr) {
        _glRectd_ptr = (PFN_GLRECTD)_getPublicProcAddress(_name);
        if (!_glRectd_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRectd_ptr(x1, y1, x2, y2);
}

typedef void (APIENTRY * PFN_GLRECTDV)(const GLdouble * v1, const GLdouble * v2);
static PFN_GLRECTDV _glRectdv_ptr = NULL;

static inline void APIENTRY _glRectdv(const GLdouble * v1, const GLdouble * v2) {
    const char *_name = "glRectdv";
    if (!_glRectdv_ptr) {
        _glRectdv_ptr = (PFN_GLRECTDV)_getPublicProcAddress(_name);
        if (!_glRectdv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRectdv_ptr(v1, v2);
}

typedef void (APIENTRY * PFN_GLRECTF)(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
static PFN_GLRECTF _glRectf_ptr = NULL;

static inline void APIENTRY _glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) {
    const char *_name = "glRectf";
    if (!_glRectf_ptr) {
        _glRectf_ptr = (PFN_GLRECTF)_getPublicProcAddress(_name);
        if (!_glRectf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRectf_ptr(x1, y1, x2, y2);
}

typedef void (APIENTRY * PFN_GLRECTFV)(const GLfloat * v1, const GLfloat * v2);
static PFN_GLRECTFV _glRectfv_ptr = NULL;

static inline void APIENTRY _glRectfv(const GLfloat * v1, const GLfloat * v2) {
    const char *_name = "glRectfv";
    if (!_glRectfv_ptr) {
        _glRectfv_ptr = (PFN_GLRECTFV)_getPublicProcAddress(_name);
        if (!_glRectfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRectfv_ptr(v1, v2);
}

typedef void (APIENTRY * PFN_GLRECTI)(GLint x1, GLint y1, GLint x2, GLint y2);
static PFN_GLRECTI _glRecti_ptr = NULL;

static inline void APIENTRY _glRecti(GLint x1, GLint y1, GLint x2, GLint y2) {
    const char *_name = "glRecti";
    if (!_glRecti_ptr) {
        _glRecti_ptr = (PFN_GLRECTI)_getPublicProcAddress(_name);
        if (!_glRecti_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRecti_ptr(x1, y1, x2, y2);
}

typedef void (APIENTRY * PFN_GLRECTIV)(const GLint * v1, const GLint * v2);
static PFN_GLRECTIV _glRectiv_ptr = NULL;

static inline void APIENTRY _glRectiv(const GLint * v1, const GLint * v2) {
    const char *_name = "glRectiv";
    if (!_glRectiv_ptr) {
        _glRectiv_ptr = (PFN_GLRECTIV)_getPublicProcAddress(_name);
        if (!_glRectiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRectiv_ptr(v1, v2);
}

typedef void (APIENTRY * PFN_GLRECTS)(GLshort x1, GLshort y1, GLshort x2, GLshort y2);
static PFN_GLRECTS _glRects_ptr = NULL;

static inline void APIENTRY _glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) {
    const char *_name = "glRects";
    if (!_glRects_ptr) {
        _glRects_ptr = (PFN_GLRECTS)_getPublicProcAddress(_name);
        if (!_glRects_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRects_ptr(x1, y1, x2, y2);
}

typedef void (APIENTRY * PFN_GLRECTSV)(const GLshort * v1, const GLshort * v2);
static PFN_GLRECTSV _glRectsv_ptr = NULL;

static inline void APIENTRY _glRectsv(const GLshort * v1, const GLshort * v2) {
    const char *_name = "glRectsv";
    if (!_glRectsv_ptr) {
        _glRectsv_ptr = (PFN_GLRECTSV)_getPublicProcAddress(_name);
        if (!_glRectsv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRectsv_ptr(v1, v2);
}

typedef void (APIENTRY * PFN_GLTEXCOORD1D)(GLdouble s);
static PFN_GLTEXCOORD1D _glTexCoord1d_ptr = NULL;

static inline void APIENTRY _glTexCoord1d(GLdouble s) {
    const char *_name = "glTexCoord1d";
    if (!_glTexCoord1d_ptr) {
        _glTexCoord1d_ptr = (PFN_GLTEXCOORD1D)_getPublicProcAddress(_name);
        if (!_glTexCoord1d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord1d_ptr(s);
}

typedef void (APIENTRY * PFN_GLTEXCOORD1DV)(const GLdouble * v);
static PFN_GLTEXCOORD1DV _glTexCoord1dv_ptr = NULL;

static inline void APIENTRY _glTexCoord1dv(const GLdouble * v) {
    const char *_name = "glTexCoord1dv";
    if (!_glTexCoord1dv_ptr) {
        _glTexCoord1dv_ptr = (PFN_GLTEXCOORD1DV)_getPublicProcAddress(_name);
        if (!_glTexCoord1dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord1dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD1F)(GLfloat s);
static PFN_GLTEXCOORD1F _glTexCoord1f_ptr = NULL;

static inline void APIENTRY _glTexCoord1f(GLfloat s) {
    const char *_name = "glTexCoord1f";
    if (!_glTexCoord1f_ptr) {
        _glTexCoord1f_ptr = (PFN_GLTEXCOORD1F)_getPublicProcAddress(_name);
        if (!_glTexCoord1f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord1f_ptr(s);
}

typedef void (APIENTRY * PFN_GLTEXCOORD1FV)(const GLfloat * v);
static PFN_GLTEXCOORD1FV _glTexCoord1fv_ptr = NULL;

static inline void APIENTRY _glTexCoord1fv(const GLfloat * v) {
    const char *_name = "glTexCoord1fv";
    if (!_glTexCoord1fv_ptr) {
        _glTexCoord1fv_ptr = (PFN_GLTEXCOORD1FV)_getPublicProcAddress(_name);
        if (!_glTexCoord1fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord1fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD1I)(GLint s);
static PFN_GLTEXCOORD1I _glTexCoord1i_ptr = NULL;

static inline void APIENTRY _glTexCoord1i(GLint s) {
    const char *_name = "glTexCoord1i";
    if (!_glTexCoord1i_ptr) {
        _glTexCoord1i_ptr = (PFN_GLTEXCOORD1I)_getPublicProcAddress(_name);
        if (!_glTexCoord1i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord1i_ptr(s);
}

typedef void (APIENTRY * PFN_GLTEXCOORD1IV)(const GLint * v);
static PFN_GLTEXCOORD1IV _glTexCoord1iv_ptr = NULL;

static inline void APIENTRY _glTexCoord1iv(const GLint * v) {
    const char *_name = "glTexCoord1iv";
    if (!_glTexCoord1iv_ptr) {
        _glTexCoord1iv_ptr = (PFN_GLTEXCOORD1IV)_getPublicProcAddress(_name);
        if (!_glTexCoord1iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord1iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD1S)(GLshort s);
static PFN_GLTEXCOORD1S _glTexCoord1s_ptr = NULL;

static inline void APIENTRY _glTexCoord1s(GLshort s) {
    const char *_name = "glTexCoord1s";
    if (!_glTexCoord1s_ptr) {
        _glTexCoord1s_ptr = (PFN_GLTEXCOORD1S)_getPublicProcAddress(_name);
        if (!_glTexCoord1s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord1s_ptr(s);
}

typedef void (APIENTRY * PFN_GLTEXCOORD1SV)(const GLshort * v);
static PFN_GLTEXCOORD1SV _glTexCoord1sv_ptr = NULL;

static inline void APIENTRY _glTexCoord1sv(const GLshort * v) {
    const char *_name = "glTexCoord1sv";
    if (!_glTexCoord1sv_ptr) {
        _glTexCoord1sv_ptr = (PFN_GLTEXCOORD1SV)_getPublicProcAddress(_name);
        if (!_glTexCoord1sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord1sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2D)(GLdouble s, GLdouble t);
static PFN_GLTEXCOORD2D _glTexCoord2d_ptr = NULL;

static inline void APIENTRY _glTexCoord2d(GLdouble s, GLdouble t) {
    const char *_name = "glTexCoord2d";
    if (!_glTexCoord2d_ptr) {
        _glTexCoord2d_ptr = (PFN_GLTEXCOORD2D)_getPublicProcAddress(_name);
        if (!_glTexCoord2d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2d_ptr(s, t);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2DV)(const GLdouble * v);
static PFN_GLTEXCOORD2DV _glTexCoord2dv_ptr = NULL;

static inline void APIENTRY _glTexCoord2dv(const GLdouble * v) {
    const char *_name = "glTexCoord2dv";
    if (!_glTexCoord2dv_ptr) {
        _glTexCoord2dv_ptr = (PFN_GLTEXCOORD2DV)_getPublicProcAddress(_name);
        if (!_glTexCoord2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2F)(GLfloat s, GLfloat t);
static PFN_GLTEXCOORD2F _glTexCoord2f_ptr = NULL;

static inline void APIENTRY _glTexCoord2f(GLfloat s, GLfloat t) {
    const char *_name = "glTexCoord2f";
    if (!_glTexCoord2f_ptr) {
        _glTexCoord2f_ptr = (PFN_GLTEXCOORD2F)_getPublicProcAddress(_name);
        if (!_glTexCoord2f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2f_ptr(s, t);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2FV)(const GLfloat * v);
static PFN_GLTEXCOORD2FV _glTexCoord2fv_ptr = NULL;

static inline void APIENTRY _glTexCoord2fv(const GLfloat * v) {
    const char *_name = "glTexCoord2fv";
    if (!_glTexCoord2fv_ptr) {
        _glTexCoord2fv_ptr = (PFN_GLTEXCOORD2FV)_getPublicProcAddress(_name);
        if (!_glTexCoord2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2I)(GLint s, GLint t);
static PFN_GLTEXCOORD2I _glTexCoord2i_ptr = NULL;

static inline void APIENTRY _glTexCoord2i(GLint s, GLint t) {
    const char *_name = "glTexCoord2i";
    if (!_glTexCoord2i_ptr) {
        _glTexCoord2i_ptr = (PFN_GLTEXCOORD2I)_getPublicProcAddress(_name);
        if (!_glTexCoord2i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2i_ptr(s, t);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2IV)(const GLint * v);
static PFN_GLTEXCOORD2IV _glTexCoord2iv_ptr = NULL;

static inline void APIENTRY _glTexCoord2iv(const GLint * v) {
    const char *_name = "glTexCoord2iv";
    if (!_glTexCoord2iv_ptr) {
        _glTexCoord2iv_ptr = (PFN_GLTEXCOORD2IV)_getPublicProcAddress(_name);
        if (!_glTexCoord2iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2S)(GLshort s, GLshort t);
static PFN_GLTEXCOORD2S _glTexCoord2s_ptr = NULL;

static inline void APIENTRY _glTexCoord2s(GLshort s, GLshort t) {
    const char *_name = "glTexCoord2s";
    if (!_glTexCoord2s_ptr) {
        _glTexCoord2s_ptr = (PFN_GLTEXCOORD2S)_getPublicProcAddress(_name);
        if (!_glTexCoord2s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2s_ptr(s, t);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2SV)(const GLshort * v);
static PFN_GLTEXCOORD2SV _glTexCoord2sv_ptr = NULL;

static inline void APIENTRY _glTexCoord2sv(const GLshort * v) {
    const char *_name = "glTexCoord2sv";
    if (!_glTexCoord2sv_ptr) {
        _glTexCoord2sv_ptr = (PFN_GLTEXCOORD2SV)_getPublicProcAddress(_name);
        if (!_glTexCoord2sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD3D)(GLdouble s, GLdouble t, GLdouble r);
static PFN_GLTEXCOORD3D _glTexCoord3d_ptr = NULL;

static inline void APIENTRY _glTexCoord3d(GLdouble s, GLdouble t, GLdouble r) {
    const char *_name = "glTexCoord3d";
    if (!_glTexCoord3d_ptr) {
        _glTexCoord3d_ptr = (PFN_GLTEXCOORD3D)_getPublicProcAddress(_name);
        if (!_glTexCoord3d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord3d_ptr(s, t, r);
}

typedef void (APIENTRY * PFN_GLTEXCOORD3DV)(const GLdouble * v);
static PFN_GLTEXCOORD3DV _glTexCoord3dv_ptr = NULL;

static inline void APIENTRY _glTexCoord3dv(const GLdouble * v) {
    const char *_name = "glTexCoord3dv";
    if (!_glTexCoord3dv_ptr) {
        _glTexCoord3dv_ptr = (PFN_GLTEXCOORD3DV)_getPublicProcAddress(_name);
        if (!_glTexCoord3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord3dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD3F)(GLfloat s, GLfloat t, GLfloat r);
static PFN_GLTEXCOORD3F _glTexCoord3f_ptr = NULL;

static inline void APIENTRY _glTexCoord3f(GLfloat s, GLfloat t, GLfloat r) {
    const char *_name = "glTexCoord3f";
    if (!_glTexCoord3f_ptr) {
        _glTexCoord3f_ptr = (PFN_GLTEXCOORD3F)_getPublicProcAddress(_name);
        if (!_glTexCoord3f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord3f_ptr(s, t, r);
}

typedef void (APIENTRY * PFN_GLTEXCOORD3FV)(const GLfloat * v);
static PFN_GLTEXCOORD3FV _glTexCoord3fv_ptr = NULL;

static inline void APIENTRY _glTexCoord3fv(const GLfloat * v) {
    const char *_name = "glTexCoord3fv";
    if (!_glTexCoord3fv_ptr) {
        _glTexCoord3fv_ptr = (PFN_GLTEXCOORD3FV)_getPublicProcAddress(_name);
        if (!_glTexCoord3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord3fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD3I)(GLint s, GLint t, GLint r);
static PFN_GLTEXCOORD3I _glTexCoord3i_ptr = NULL;

static inline void APIENTRY _glTexCoord3i(GLint s, GLint t, GLint r) {
    const char *_name = "glTexCoord3i";
    if (!_glTexCoord3i_ptr) {
        _glTexCoord3i_ptr = (PFN_GLTEXCOORD3I)_getPublicProcAddress(_name);
        if (!_glTexCoord3i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord3i_ptr(s, t, r);
}

typedef void (APIENTRY * PFN_GLTEXCOORD3IV)(const GLint * v);
static PFN_GLTEXCOORD3IV _glTexCoord3iv_ptr = NULL;

static inline void APIENTRY _glTexCoord3iv(const GLint * v) {
    const char *_name = "glTexCoord3iv";
    if (!_glTexCoord3iv_ptr) {
        _glTexCoord3iv_ptr = (PFN_GLTEXCOORD3IV)_getPublicProcAddress(_name);
        if (!_glTexCoord3iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord3iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD3S)(GLshort s, GLshort t, GLshort r);
static PFN_GLTEXCOORD3S _glTexCoord3s_ptr = NULL;

static inline void APIENTRY _glTexCoord3s(GLshort s, GLshort t, GLshort r) {
    const char *_name = "glTexCoord3s";
    if (!_glTexCoord3s_ptr) {
        _glTexCoord3s_ptr = (PFN_GLTEXCOORD3S)_getPublicProcAddress(_name);
        if (!_glTexCoord3s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord3s_ptr(s, t, r);
}

typedef void (APIENTRY * PFN_GLTEXCOORD3SV)(const GLshort * v);
static PFN_GLTEXCOORD3SV _glTexCoord3sv_ptr = NULL;

static inline void APIENTRY _glTexCoord3sv(const GLshort * v) {
    const char *_name = "glTexCoord3sv";
    if (!_glTexCoord3sv_ptr) {
        _glTexCoord3sv_ptr = (PFN_GLTEXCOORD3SV)_getPublicProcAddress(_name);
        if (!_glTexCoord3sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord3sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4D)(GLdouble s, GLdouble t, GLdouble r, GLdouble q);
static PFN_GLTEXCOORD4D _glTexCoord4d_ptr = NULL;

static inline void APIENTRY _glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    const char *_name = "glTexCoord4d";
    if (!_glTexCoord4d_ptr) {
        _glTexCoord4d_ptr = (PFN_GLTEXCOORD4D)_getPublicProcAddress(_name);
        if (!_glTexCoord4d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4d_ptr(s, t, r, q);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4DV)(const GLdouble * v);
static PFN_GLTEXCOORD4DV _glTexCoord4dv_ptr = NULL;

static inline void APIENTRY _glTexCoord4dv(const GLdouble * v) {
    const char *_name = "glTexCoord4dv";
    if (!_glTexCoord4dv_ptr) {
        _glTexCoord4dv_ptr = (PFN_GLTEXCOORD4DV)_getPublicProcAddress(_name);
        if (!_glTexCoord4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4F)(GLfloat s, GLfloat t, GLfloat r, GLfloat q);
static PFN_GLTEXCOORD4F _glTexCoord4f_ptr = NULL;

static inline void APIENTRY _glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    const char *_name = "glTexCoord4f";
    if (!_glTexCoord4f_ptr) {
        _glTexCoord4f_ptr = (PFN_GLTEXCOORD4F)_getPublicProcAddress(_name);
        if (!_glTexCoord4f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4f_ptr(s, t, r, q);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4FV)(const GLfloat * v);
static PFN_GLTEXCOORD4FV _glTexCoord4fv_ptr = NULL;

static inline void APIENTRY _glTexCoord4fv(const GLfloat * v) {
    const char *_name = "glTexCoord4fv";
    if (!_glTexCoord4fv_ptr) {
        _glTexCoord4fv_ptr = (PFN_GLTEXCOORD4FV)_getPublicProcAddress(_name);
        if (!_glTexCoord4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4I)(GLint s, GLint t, GLint r, GLint q);
static PFN_GLTEXCOORD4I _glTexCoord4i_ptr = NULL;

static inline void APIENTRY _glTexCoord4i(GLint s, GLint t, GLint r, GLint q) {
    const char *_name = "glTexCoord4i";
    if (!_glTexCoord4i_ptr) {
        _glTexCoord4i_ptr = (PFN_GLTEXCOORD4I)_getPublicProcAddress(_name);
        if (!_glTexCoord4i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4i_ptr(s, t, r, q);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4IV)(const GLint * v);
static PFN_GLTEXCOORD4IV _glTexCoord4iv_ptr = NULL;

static inline void APIENTRY _glTexCoord4iv(const GLint * v) {
    const char *_name = "glTexCoord4iv";
    if (!_glTexCoord4iv_ptr) {
        _glTexCoord4iv_ptr = (PFN_GLTEXCOORD4IV)_getPublicProcAddress(_name);
        if (!_glTexCoord4iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4S)(GLshort s, GLshort t, GLshort r, GLshort q);
static PFN_GLTEXCOORD4S _glTexCoord4s_ptr = NULL;

static inline void APIENTRY _glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) {
    const char *_name = "glTexCoord4s";
    if (!_glTexCoord4s_ptr) {
        _glTexCoord4s_ptr = (PFN_GLTEXCOORD4S)_getPublicProcAddress(_name);
        if (!_glTexCoord4s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4s_ptr(s, t, r, q);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4SV)(const GLshort * v);
static PFN_GLTEXCOORD4SV _glTexCoord4sv_ptr = NULL;

static inline void APIENTRY _glTexCoord4sv(const GLshort * v) {
    const char *_name = "glTexCoord4sv";
    if (!_glTexCoord4sv_ptr) {
        _glTexCoord4sv_ptr = (PFN_GLTEXCOORD4SV)_getPublicProcAddress(_name);
        if (!_glTexCoord4sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX2D)(GLdouble x, GLdouble y);
static PFN_GLVERTEX2D _glVertex2d_ptr = NULL;

static inline void APIENTRY _glVertex2d(GLdouble x, GLdouble y) {
    const char *_name = "glVertex2d";
    if (!_glVertex2d_ptr) {
        _glVertex2d_ptr = (PFN_GLVERTEX2D)_getPublicProcAddress(_name);
        if (!_glVertex2d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex2d_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLVERTEX2DV)(const GLdouble * v);
static PFN_GLVERTEX2DV _glVertex2dv_ptr = NULL;

static inline void APIENTRY _glVertex2dv(const GLdouble * v) {
    const char *_name = "glVertex2dv";
    if (!_glVertex2dv_ptr) {
        _glVertex2dv_ptr = (PFN_GLVERTEX2DV)_getPublicProcAddress(_name);
        if (!_glVertex2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex2dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX2F)(GLfloat x, GLfloat y);
static PFN_GLVERTEX2F _glVertex2f_ptr = NULL;

static inline void APIENTRY _glVertex2f(GLfloat x, GLfloat y) {
    const char *_name = "glVertex2f";
    if (!_glVertex2f_ptr) {
        _glVertex2f_ptr = (PFN_GLVERTEX2F)_getPublicProcAddress(_name);
        if (!_glVertex2f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex2f_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLVERTEX2FV)(const GLfloat * v);
static PFN_GLVERTEX2FV _glVertex2fv_ptr = NULL;

static inline void APIENTRY _glVertex2fv(const GLfloat * v) {
    const char *_name = "glVertex2fv";
    if (!_glVertex2fv_ptr) {
        _glVertex2fv_ptr = (PFN_GLVERTEX2FV)_getPublicProcAddress(_name);
        if (!_glVertex2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex2fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX2I)(GLint x, GLint y);
static PFN_GLVERTEX2I _glVertex2i_ptr = NULL;

static inline void APIENTRY _glVertex2i(GLint x, GLint y) {
    const char *_name = "glVertex2i";
    if (!_glVertex2i_ptr) {
        _glVertex2i_ptr = (PFN_GLVERTEX2I)_getPublicProcAddress(_name);
        if (!_glVertex2i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex2i_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLVERTEX2IV)(const GLint * v);
static PFN_GLVERTEX2IV _glVertex2iv_ptr = NULL;

static inline void APIENTRY _glVertex2iv(const GLint * v) {
    const char *_name = "glVertex2iv";
    if (!_glVertex2iv_ptr) {
        _glVertex2iv_ptr = (PFN_GLVERTEX2IV)_getPublicProcAddress(_name);
        if (!_glVertex2iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex2iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX2S)(GLshort x, GLshort y);
static PFN_GLVERTEX2S _glVertex2s_ptr = NULL;

static inline void APIENTRY _glVertex2s(GLshort x, GLshort y) {
    const char *_name = "glVertex2s";
    if (!_glVertex2s_ptr) {
        _glVertex2s_ptr = (PFN_GLVERTEX2S)_getPublicProcAddress(_name);
        if (!_glVertex2s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex2s_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLVERTEX2SV)(const GLshort * v);
static PFN_GLVERTEX2SV _glVertex2sv_ptr = NULL;

static inline void APIENTRY _glVertex2sv(const GLshort * v) {
    const char *_name = "glVertex2sv";
    if (!_glVertex2sv_ptr) {
        _glVertex2sv_ptr = (PFN_GLVERTEX2SV)_getPublicProcAddress(_name);
        if (!_glVertex2sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex2sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX3D)(GLdouble x, GLdouble y, GLdouble z);
static PFN_GLVERTEX3D _glVertex3d_ptr = NULL;

static inline void APIENTRY _glVertex3d(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertex3d";
    if (!_glVertex3d_ptr) {
        _glVertex3d_ptr = (PFN_GLVERTEX3D)_getPublicProcAddress(_name);
        if (!_glVertex3d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex3d_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEX3DV)(const GLdouble * v);
static PFN_GLVERTEX3DV _glVertex3dv_ptr = NULL;

static inline void APIENTRY _glVertex3dv(const GLdouble * v) {
    const char *_name = "glVertex3dv";
    if (!_glVertex3dv_ptr) {
        _glVertex3dv_ptr = (PFN_GLVERTEX3DV)_getPublicProcAddress(_name);
        if (!_glVertex3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex3dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX3F)(GLfloat x, GLfloat y, GLfloat z);
static PFN_GLVERTEX3F _glVertex3f_ptr = NULL;

static inline void APIENTRY _glVertex3f(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glVertex3f";
    if (!_glVertex3f_ptr) {
        _glVertex3f_ptr = (PFN_GLVERTEX3F)_getPublicProcAddress(_name);
        if (!_glVertex3f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex3f_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEX3FV)(const GLfloat * v);
static PFN_GLVERTEX3FV _glVertex3fv_ptr = NULL;

static inline void APIENTRY _glVertex3fv(const GLfloat * v) {
    const char *_name = "glVertex3fv";
    if (!_glVertex3fv_ptr) {
        _glVertex3fv_ptr = (PFN_GLVERTEX3FV)_getPublicProcAddress(_name);
        if (!_glVertex3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex3fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX3I)(GLint x, GLint y, GLint z);
static PFN_GLVERTEX3I _glVertex3i_ptr = NULL;

static inline void APIENTRY _glVertex3i(GLint x, GLint y, GLint z) {
    const char *_name = "glVertex3i";
    if (!_glVertex3i_ptr) {
        _glVertex3i_ptr = (PFN_GLVERTEX3I)_getPublicProcAddress(_name);
        if (!_glVertex3i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex3i_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEX3IV)(const GLint * v);
static PFN_GLVERTEX3IV _glVertex3iv_ptr = NULL;

static inline void APIENTRY _glVertex3iv(const GLint * v) {
    const char *_name = "glVertex3iv";
    if (!_glVertex3iv_ptr) {
        _glVertex3iv_ptr = (PFN_GLVERTEX3IV)_getPublicProcAddress(_name);
        if (!_glVertex3iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex3iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX3S)(GLshort x, GLshort y, GLshort z);
static PFN_GLVERTEX3S _glVertex3s_ptr = NULL;

static inline void APIENTRY _glVertex3s(GLshort x, GLshort y, GLshort z) {
    const char *_name = "glVertex3s";
    if (!_glVertex3s_ptr) {
        _glVertex3s_ptr = (PFN_GLVERTEX3S)_getPublicProcAddress(_name);
        if (!_glVertex3s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex3s_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEX3SV)(const GLshort * v);
static PFN_GLVERTEX3SV _glVertex3sv_ptr = NULL;

static inline void APIENTRY _glVertex3sv(const GLshort * v) {
    const char *_name = "glVertex3sv";
    if (!_glVertex3sv_ptr) {
        _glVertex3sv_ptr = (PFN_GLVERTEX3SV)_getPublicProcAddress(_name);
        if (!_glVertex3sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex3sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX4D)(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLVERTEX4D _glVertex4d_ptr = NULL;

static inline void APIENTRY _glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertex4d";
    if (!_glVertex4d_ptr) {
        _glVertex4d_ptr = (PFN_GLVERTEX4D)_getPublicProcAddress(_name);
        if (!_glVertex4d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex4d_ptr(x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEX4DV)(const GLdouble * v);
static PFN_GLVERTEX4DV _glVertex4dv_ptr = NULL;

static inline void APIENTRY _glVertex4dv(const GLdouble * v) {
    const char *_name = "glVertex4dv";
    if (!_glVertex4dv_ptr) {
        _glVertex4dv_ptr = (PFN_GLVERTEX4DV)_getPublicProcAddress(_name);
        if (!_glVertex4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex4dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX4F)(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLVERTEX4F _glVertex4f_ptr = NULL;

static inline void APIENTRY _glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glVertex4f";
    if (!_glVertex4f_ptr) {
        _glVertex4f_ptr = (PFN_GLVERTEX4F)_getPublicProcAddress(_name);
        if (!_glVertex4f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex4f_ptr(x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEX4FV)(const GLfloat * v);
static PFN_GLVERTEX4FV _glVertex4fv_ptr = NULL;

static inline void APIENTRY _glVertex4fv(const GLfloat * v) {
    const char *_name = "glVertex4fv";
    if (!_glVertex4fv_ptr) {
        _glVertex4fv_ptr = (PFN_GLVERTEX4FV)_getPublicProcAddress(_name);
        if (!_glVertex4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex4fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX4I)(GLint x, GLint y, GLint z, GLint w);
static PFN_GLVERTEX4I _glVertex4i_ptr = NULL;

static inline void APIENTRY _glVertex4i(GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glVertex4i";
    if (!_glVertex4i_ptr) {
        _glVertex4i_ptr = (PFN_GLVERTEX4I)_getPublicProcAddress(_name);
        if (!_glVertex4i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex4i_ptr(x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEX4IV)(const GLint * v);
static PFN_GLVERTEX4IV _glVertex4iv_ptr = NULL;

static inline void APIENTRY _glVertex4iv(const GLint * v) {
    const char *_name = "glVertex4iv";
    if (!_glVertex4iv_ptr) {
        _glVertex4iv_ptr = (PFN_GLVERTEX4IV)_getPublicProcAddress(_name);
        if (!_glVertex4iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex4iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX4S)(GLshort x, GLshort y, GLshort z, GLshort w);
static PFN_GLVERTEX4S _glVertex4s_ptr = NULL;

static inline void APIENTRY _glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glVertex4s";
    if (!_glVertex4s_ptr) {
        _glVertex4s_ptr = (PFN_GLVERTEX4S)_getPublicProcAddress(_name);
        if (!_glVertex4s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex4s_ptr(x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEX4SV)(const GLshort * v);
static PFN_GLVERTEX4SV _glVertex4sv_ptr = NULL;

static inline void APIENTRY _glVertex4sv(const GLshort * v) {
    const char *_name = "glVertex4sv";
    if (!_glVertex4sv_ptr) {
        _glVertex4sv_ptr = (PFN_GLVERTEX4SV)_getPublicProcAddress(_name);
        if (!_glVertex4sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex4sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLCLIPPLANE)(GLenum plane, const GLdouble * equation);
static PFN_GLCLIPPLANE _glClipPlane_ptr = NULL;

static inline void APIENTRY _glClipPlane(GLenum plane, const GLdouble * equation) {
    const char *_name = "glClipPlane";
    if (!_glClipPlane_ptr) {
        _glClipPlane_ptr = (PFN_GLCLIPPLANE)_getPublicProcAddress(_name);
        if (!_glClipPlane_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClipPlane_ptr(plane, equation);
}

typedef void (APIENTRY * PFN_GLCOLORMATERIAL)(GLenum face, GLenum mode);
static PFN_GLCOLORMATERIAL _glColorMaterial_ptr = NULL;

static inline void APIENTRY _glColorMaterial(GLenum face, GLenum mode) {
    const char *_name = "glColorMaterial";
    if (!_glColorMaterial_ptr) {
        _glColorMaterial_ptr = (PFN_GLCOLORMATERIAL)_getPublicProcAddress(_name);
        if (!_glColorMaterial_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorMaterial_ptr(face, mode);
}

typedef void (APIENTRY * PFN_GLFOGF)(GLenum pname, GLfloat param);
static PFN_GLFOGF _glFogf_ptr = NULL;

static inline void APIENTRY _glFogf(GLenum pname, GLfloat param) {
    const char *_name = "glFogf";
    if (!_glFogf_ptr) {
        _glFogf_ptr = (PFN_GLFOGF)_getPublicProcAddress(_name);
        if (!_glFogf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogf_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLFOGFV)(GLenum pname, const GLfloat * params);
static PFN_GLFOGFV _glFogfv_ptr = NULL;

static inline void APIENTRY _glFogfv(GLenum pname, const GLfloat * params) {
    const char *_name = "glFogfv";
    if (!_glFogfv_ptr) {
        _glFogfv_ptr = (PFN_GLFOGFV)_getPublicProcAddress(_name);
        if (!_glFogfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogfv_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLFOGI)(GLenum pname, GLint param);
static PFN_GLFOGI _glFogi_ptr = NULL;

static inline void APIENTRY _glFogi(GLenum pname, GLint param) {
    const char *_name = "glFogi";
    if (!_glFogi_ptr) {
        _glFogi_ptr = (PFN_GLFOGI)_getPublicProcAddress(_name);
        if (!_glFogi_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogi_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLFOGIV)(GLenum pname, const GLint * params);
static PFN_GLFOGIV _glFogiv_ptr = NULL;

static inline void APIENTRY _glFogiv(GLenum pname, const GLint * params) {
    const char *_name = "glFogiv";
    if (!_glFogiv_ptr) {
        _glFogiv_ptr = (PFN_GLFOGIV)_getPublicProcAddress(_name);
        if (!_glFogiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogiv_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLLIGHTF)(GLenum light, GLenum pname, GLfloat param);
static PFN_GLLIGHTF _glLightf_ptr = NULL;

static inline void APIENTRY _glLightf(GLenum light, GLenum pname, GLfloat param) {
    const char *_name = "glLightf";
    if (!_glLightf_ptr) {
        _glLightf_ptr = (PFN_GLLIGHTF)_getPublicProcAddress(_name);
        if (!_glLightf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLightf_ptr(light, pname, param);
}

typedef void (APIENTRY * PFN_GLLIGHTFV)(GLenum light, GLenum pname, const GLfloat * params);
static PFN_GLLIGHTFV _glLightfv_ptr = NULL;

static inline void APIENTRY _glLightfv(GLenum light, GLenum pname, const GLfloat * params) {
    const char *_name = "glLightfv";
    if (!_glLightfv_ptr) {
        _glLightfv_ptr = (PFN_GLLIGHTFV)_getPublicProcAddress(_name);
        if (!_glLightfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLightfv_ptr(light, pname, params);
}

typedef void (APIENTRY * PFN_GLLIGHTI)(GLenum light, GLenum pname, GLint param);
static PFN_GLLIGHTI _glLighti_ptr = NULL;

static inline void APIENTRY _glLighti(GLenum light, GLenum pname, GLint param) {
    const char *_name = "glLighti";
    if (!_glLighti_ptr) {
        _glLighti_ptr = (PFN_GLLIGHTI)_getPublicProcAddress(_name);
        if (!_glLighti_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLighti_ptr(light, pname, param);
}

typedef void (APIENTRY * PFN_GLLIGHTIV)(GLenum light, GLenum pname, const GLint * params);
static PFN_GLLIGHTIV _glLightiv_ptr = NULL;

static inline void APIENTRY _glLightiv(GLenum light, GLenum pname, const GLint * params) {
    const char *_name = "glLightiv";
    if (!_glLightiv_ptr) {
        _glLightiv_ptr = (PFN_GLLIGHTIV)_getPublicProcAddress(_name);
        if (!_glLightiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLightiv_ptr(light, pname, params);
}

typedef void (APIENTRY * PFN_GLLIGHTMODELF)(GLenum pname, GLfloat param);
static PFN_GLLIGHTMODELF _glLightModelf_ptr = NULL;

static inline void APIENTRY _glLightModelf(GLenum pname, GLfloat param) {
    const char *_name = "glLightModelf";
    if (!_glLightModelf_ptr) {
        _glLightModelf_ptr = (PFN_GLLIGHTMODELF)_getPublicProcAddress(_name);
        if (!_glLightModelf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLightModelf_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLLIGHTMODELFV)(GLenum pname, const GLfloat * params);
static PFN_GLLIGHTMODELFV _glLightModelfv_ptr = NULL;

static inline void APIENTRY _glLightModelfv(GLenum pname, const GLfloat * params) {
    const char *_name = "glLightModelfv";
    if (!_glLightModelfv_ptr) {
        _glLightModelfv_ptr = (PFN_GLLIGHTMODELFV)_getPublicProcAddress(_name);
        if (!_glLightModelfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLightModelfv_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLLIGHTMODELI)(GLenum pname, GLint param);
static PFN_GLLIGHTMODELI _glLightModeli_ptr = NULL;

static inline void APIENTRY _glLightModeli(GLenum pname, GLint param) {
    const char *_name = "glLightModeli";
    if (!_glLightModeli_ptr) {
        _glLightModeli_ptr = (PFN_GLLIGHTMODELI)_getPublicProcAddress(_name);
        if (!_glLightModeli_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLightModeli_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLLIGHTMODELIV)(GLenum pname, const GLint * params);
static PFN_GLLIGHTMODELIV _glLightModeliv_ptr = NULL;

static inline void APIENTRY _glLightModeliv(GLenum pname, const GLint * params) {
    const char *_name = "glLightModeliv";
    if (!_glLightModeliv_ptr) {
        _glLightModeliv_ptr = (PFN_GLLIGHTMODELIV)_getPublicProcAddress(_name);
        if (!_glLightModeliv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLightModeliv_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLLINESTIPPLE)(GLint factor, GLushort pattern);
static PFN_GLLINESTIPPLE _glLineStipple_ptr = NULL;

static inline void APIENTRY _glLineStipple(GLint factor, GLushort pattern) {
    const char *_name = "glLineStipple";
    if (!_glLineStipple_ptr) {
        _glLineStipple_ptr = (PFN_GLLINESTIPPLE)_getPublicProcAddress(_name);
        if (!_glLineStipple_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLineStipple_ptr(factor, pattern);
}

typedef void (APIENTRY * PFN_GLMATERIALF)(GLenum face, GLenum pname, GLfloat param);
static PFN_GLMATERIALF _glMaterialf_ptr = NULL;

static inline void APIENTRY _glMaterialf(GLenum face, GLenum pname, GLfloat param) {
    const char *_name = "glMaterialf";
    if (!_glMaterialf_ptr) {
        _glMaterialf_ptr = (PFN_GLMATERIALF)_getPublicProcAddress(_name);
        if (!_glMaterialf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMaterialf_ptr(face, pname, param);
}

typedef void (APIENTRY * PFN_GLMATERIALFV)(GLenum face, GLenum pname, const GLfloat * params);
static PFN_GLMATERIALFV _glMaterialfv_ptr = NULL;

static inline void APIENTRY _glMaterialfv(GLenum face, GLenum pname, const GLfloat * params) {
    const char *_name = "glMaterialfv";
    if (!_glMaterialfv_ptr) {
        _glMaterialfv_ptr = (PFN_GLMATERIALFV)_getPublicProcAddress(_name);
        if (!_glMaterialfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMaterialfv_ptr(face, pname, params);
}

typedef void (APIENTRY * PFN_GLMATERIALI)(GLenum face, GLenum pname, GLint param);
static PFN_GLMATERIALI _glMateriali_ptr = NULL;

static inline void APIENTRY _glMateriali(GLenum face, GLenum pname, GLint param) {
    const char *_name = "glMateriali";
    if (!_glMateriali_ptr) {
        _glMateriali_ptr = (PFN_GLMATERIALI)_getPublicProcAddress(_name);
        if (!_glMateriali_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMateriali_ptr(face, pname, param);
}

typedef void (APIENTRY * PFN_GLMATERIALIV)(GLenum face, GLenum pname, const GLint * params);
static PFN_GLMATERIALIV _glMaterialiv_ptr = NULL;

static inline void APIENTRY _glMaterialiv(GLenum face, GLenum pname, const GLint * params) {
    const char *_name = "glMaterialiv";
    if (!_glMaterialiv_ptr) {
        _glMaterialiv_ptr = (PFN_GLMATERIALIV)_getPublicProcAddress(_name);
        if (!_glMaterialiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMaterialiv_ptr(face, pname, params);
}

typedef void (APIENTRY * PFN_GLPOLYGONSTIPPLE)(const GLubyte * mask);
static PFN_GLPOLYGONSTIPPLE _glPolygonStipple_ptr = NULL;

static inline void APIENTRY _glPolygonStipple(const GLubyte * mask) {
    const char *_name = "glPolygonStipple";
    if (!_glPolygonStipple_ptr) {
        _glPolygonStipple_ptr = (PFN_GLPOLYGONSTIPPLE)_getPublicProcAddress(_name);
        if (!_glPolygonStipple_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPolygonStipple_ptr(mask);
}

typedef void (APIENTRY * PFN_GLSHADEMODEL)(GLenum mode);
static PFN_GLSHADEMODEL _glShadeModel_ptr = NULL;

static inline void APIENTRY _glShadeModel(GLenum mode) {
    const char *_name = "glShadeModel";
    if (!_glShadeModel_ptr) {
        _glShadeModel_ptr = (PFN_GLSHADEMODEL)_getPublicProcAddress(_name);
        if (!_glShadeModel_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glShadeModel_ptr(mode);
}

typedef void (APIENTRY * PFN_GLTEXENVF)(GLenum target, GLenum pname, GLfloat param);
static PFN_GLTEXENVF _glTexEnvf_ptr = NULL;

static inline void APIENTRY _glTexEnvf(GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glTexEnvf";
    if (!_glTexEnvf_ptr) {
        _glTexEnvf_ptr = (PFN_GLTEXENVF)_getPublicProcAddress(_name);
        if (!_glTexEnvf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexEnvf_ptr(target, pname, param);
}

typedef void (APIENTRY * PFN_GLTEXENVFV)(GLenum target, GLenum pname, const GLfloat * params);
static PFN_GLTEXENVFV _glTexEnvfv_ptr = NULL;

static inline void APIENTRY _glTexEnvfv(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glTexEnvfv";
    if (!_glTexEnvfv_ptr) {
        _glTexEnvfv_ptr = (PFN_GLTEXENVFV)_getPublicProcAddress(_name);
        if (!_glTexEnvfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexEnvfv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLTEXENVI)(GLenum target, GLenum pname, GLint param);
static PFN_GLTEXENVI _glTexEnvi_ptr = NULL;

static inline void APIENTRY _glTexEnvi(GLenum target, GLenum pname, GLint param) {
    const char *_name = "glTexEnvi";
    if (!_glTexEnvi_ptr) {
        _glTexEnvi_ptr = (PFN_GLTEXENVI)_getPublicProcAddress(_name);
        if (!_glTexEnvi_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexEnvi_ptr(target, pname, param);
}

typedef void (APIENTRY * PFN_GLTEXENVIV)(GLenum target, GLenum pname, const GLint * params);
static PFN_GLTEXENVIV _glTexEnviv_ptr = NULL;

static inline void APIENTRY _glTexEnviv(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glTexEnviv";
    if (!_glTexEnviv_ptr) {
        _glTexEnviv_ptr = (PFN_GLTEXENVIV)_getPublicProcAddress(_name);
        if (!_glTexEnviv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexEnviv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLTEXGEND)(GLenum coord, GLenum pname, GLdouble param);
static PFN_GLTEXGEND _glTexGend_ptr = NULL;

static inline void APIENTRY _glTexGend(GLenum coord, GLenum pname, GLdouble param) {
    const char *_name = "glTexGend";
    if (!_glTexGend_ptr) {
        _glTexGend_ptr = (PFN_GLTEXGEND)_getPublicProcAddress(_name);
        if (!_glTexGend_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexGend_ptr(coord, pname, param);
}

typedef void (APIENTRY * PFN_GLTEXGENDV)(GLenum coord, GLenum pname, const GLdouble * params);
static PFN_GLTEXGENDV _glTexGendv_ptr = NULL;

static inline void APIENTRY _glTexGendv(GLenum coord, GLenum pname, const GLdouble * params) {
    const char *_name = "glTexGendv";
    if (!_glTexGendv_ptr) {
        _glTexGendv_ptr = (PFN_GLTEXGENDV)_getPublicProcAddress(_name);
        if (!_glTexGendv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexGendv_ptr(coord, pname, params);
}

typedef void (APIENTRY * PFN_GLTEXGENF)(GLenum coord, GLenum pname, GLfloat param);
static PFN_GLTEXGENF _glTexGenf_ptr = NULL;

static inline void APIENTRY _glTexGenf(GLenum coord, GLenum pname, GLfloat param) {
    const char *_name = "glTexGenf";
    if (!_glTexGenf_ptr) {
        _glTexGenf_ptr = (PFN_GLTEXGENF)_getPublicProcAddress(_name);
        if (!_glTexGenf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexGenf_ptr(coord, pname, param);
}

typedef void (APIENTRY * PFN_GLTEXGENFV)(GLenum coord, GLenum pname, const GLfloat * params);
static PFN_GLTEXGENFV _glTexGenfv_ptr = NULL;

static inline void APIENTRY _glTexGenfv(GLenum coord, GLenum pname, const GLfloat * params) {
    const char *_name = "glTexGenfv";
    if (!_glTexGenfv_ptr) {
        _glTexGenfv_ptr = (PFN_GLTEXGENFV)_getPublicProcAddress(_name);
        if (!_glTexGenfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexGenfv_ptr(coord, pname, params);
}

typedef void (APIENTRY * PFN_GLTEXGENI)(GLenum coord, GLenum pname, GLint param);
static PFN_GLTEXGENI _glTexGeni_ptr = NULL;

static inline void APIENTRY _glTexGeni(GLenum coord, GLenum pname, GLint param) {
    const char *_name = "glTexGeni";
    if (!_glTexGeni_ptr) {
        _glTexGeni_ptr = (PFN_GLTEXGENI)_getPublicProcAddress(_name);
        if (!_glTexGeni_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexGeni_ptr(coord, pname, param);
}

typedef void (APIENTRY * PFN_GLTEXGENIV)(GLenum coord, GLenum pname, const GLint * params);
static PFN_GLTEXGENIV _glTexGeniv_ptr = NULL;

static inline void APIENTRY _glTexGeniv(GLenum coord, GLenum pname, const GLint * params) {
    const char *_name = "glTexGeniv";
    if (!_glTexGeniv_ptr) {
        _glTexGeniv_ptr = (PFN_GLTEXGENIV)_getPublicProcAddress(_name);
        if (!_glTexGeniv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexGeniv_ptr(coord, pname, params);
}

typedef void (APIENTRY * PFN_GLFEEDBACKBUFFER)(GLsizei size, GLenum type, GLfloat * buffer);
static PFN_GLFEEDBACKBUFFER _glFeedbackBuffer_ptr = NULL;

static inline void APIENTRY _glFeedbackBuffer(GLsizei size, GLenum type, GLfloat * buffer) {
    const char *_name = "glFeedbackBuffer";
    if (!_glFeedbackBuffer_ptr) {
        _glFeedbackBuffer_ptr = (PFN_GLFEEDBACKBUFFER)_getPublicProcAddress(_name);
        if (!_glFeedbackBuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFeedbackBuffer_ptr(size, type, buffer);
}

typedef void (APIENTRY * PFN_GLSELECTBUFFER)(GLsizei size, GLuint * buffer);
static PFN_GLSELECTBUFFER _glSelectBuffer_ptr = NULL;

static inline void APIENTRY _glSelectBuffer(GLsizei size, GLuint * buffer) {
    const char *_name = "glSelectBuffer";
    if (!_glSelectBuffer_ptr) {
        _glSelectBuffer_ptr = (PFN_GLSELECTBUFFER)_getPublicProcAddress(_name);
        if (!_glSelectBuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSelectBuffer_ptr(size, buffer);
}

typedef GLint (APIENTRY * PFN_GLRENDERMODE)(GLenum mode);
static PFN_GLRENDERMODE _glRenderMode_ptr = NULL;

static inline GLint APIENTRY _glRenderMode(GLenum mode) {
    const char *_name = "glRenderMode";
    if (!_glRenderMode_ptr) {
        _glRenderMode_ptr = (PFN_GLRENDERMODE)_getPublicProcAddress(_name);
        if (!_glRenderMode_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glRenderMode_ptr(mode);
}

typedef void (APIENTRY * PFN_GLINITNAMES)(void);
static PFN_GLINITNAMES _glInitNames_ptr = NULL;

static inline void APIENTRY _glInitNames(void) {
    const char *_name = "glInitNames";
    if (!_glInitNames_ptr) {
        _glInitNames_ptr = (PFN_GLINITNAMES)_getPublicProcAddress(_name);
        if (!_glInitNames_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glInitNames_ptr();
}

typedef void (APIENTRY * PFN_GLLOADNAME)(GLuint name);
static PFN_GLLOADNAME _glLoadName_ptr = NULL;

static inline void APIENTRY _glLoadName(GLuint name) {
    const char *_name = "glLoadName";
    if (!_glLoadName_ptr) {
        _glLoadName_ptr = (PFN_GLLOADNAME)_getPublicProcAddress(_name);
        if (!_glLoadName_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLoadName_ptr(name);
}

typedef void (APIENTRY * PFN_GLPASSTHROUGH)(GLfloat token);
static PFN_GLPASSTHROUGH _glPassThrough_ptr = NULL;

static inline void APIENTRY _glPassThrough(GLfloat token) {
    const char *_name = "glPassThrough";
    if (!_glPassThrough_ptr) {
        _glPassThrough_ptr = (PFN_GLPASSTHROUGH)_getPublicProcAddress(_name);
        if (!_glPassThrough_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPassThrough_ptr(token);
}

typedef void (APIENTRY * PFN_GLPOPNAME)(void);
static PFN_GLPOPNAME _glPopName_ptr = NULL;

static inline void APIENTRY _glPopName(void) {
    const char *_name = "glPopName";
    if (!_glPopName_ptr) {
        _glPopName_ptr = (PFN_GLPOPNAME)_getPublicProcAddress(_name);
        if (!_glPopName_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPopName_ptr();
}

typedef void (APIENTRY * PFN_GLPUSHNAME)(GLuint name);
static PFN_GLPUSHNAME _glPushName_ptr = NULL;

static inline void APIENTRY _glPushName(GLuint name) {
    const char *_name = "glPushName";
    if (!_glPushName_ptr) {
        _glPushName_ptr = (PFN_GLPUSHNAME)_getPublicProcAddress(_name);
        if (!_glPushName_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPushName_ptr(name);
}

typedef void (APIENTRY * PFN_GLCLEARACCUM)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
static PFN_GLCLEARACCUM _glClearAccum_ptr = NULL;

static inline void APIENTRY _glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    const char *_name = "glClearAccum";
    if (!_glClearAccum_ptr) {
        _glClearAccum_ptr = (PFN_GLCLEARACCUM)_getPublicProcAddress(_name);
        if (!_glClearAccum_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearAccum_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLCLEARINDEX)(GLfloat c);
static PFN_GLCLEARINDEX _glClearIndex_ptr = NULL;

static inline void APIENTRY _glClearIndex(GLfloat c) {
    const char *_name = "glClearIndex";
    if (!_glClearIndex_ptr) {
        _glClearIndex_ptr = (PFN_GLCLEARINDEX)_getPublicProcAddress(_name);
        if (!_glClearIndex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearIndex_ptr(c);
}

typedef void (APIENTRY * PFN_GLINDEXMASK)(GLuint mask);
static PFN_GLINDEXMASK _glIndexMask_ptr = NULL;

static inline void APIENTRY _glIndexMask(GLuint mask) {
    const char *_name = "glIndexMask";
    if (!_glIndexMask_ptr) {
        _glIndexMask_ptr = (PFN_GLINDEXMASK)_getPublicProcAddress(_name);
        if (!_glIndexMask_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexMask_ptr(mask);
}

typedef void (APIENTRY * PFN_GLACCUM)(GLenum op, GLfloat value);
static PFN_GLACCUM _glAccum_ptr = NULL;

static inline void APIENTRY _glAccum(GLenum op, GLfloat value) {
    const char *_name = "glAccum";
    if (!_glAccum_ptr) {
        _glAccum_ptr = (PFN_GLACCUM)_getPublicProcAddress(_name);
        if (!_glAccum_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glAccum_ptr(op, value);
}

typedef void (APIENTRY * PFN_GLPOPATTRIB)(void);
static PFN_GLPOPATTRIB _glPopAttrib_ptr = NULL;

static inline void APIENTRY _glPopAttrib(void) {
    const char *_name = "glPopAttrib";
    if (!_glPopAttrib_ptr) {
        _glPopAttrib_ptr = (PFN_GLPOPATTRIB)_getPublicProcAddress(_name);
        if (!_glPopAttrib_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPopAttrib_ptr();
}

typedef void (APIENTRY * PFN_GLPUSHATTRIB)(GLbitfield mask);
static PFN_GLPUSHATTRIB _glPushAttrib_ptr = NULL;

static inline void APIENTRY _glPushAttrib(GLbitfield mask) {
    const char *_name = "glPushAttrib";
    if (!_glPushAttrib_ptr) {
        _glPushAttrib_ptr = (PFN_GLPUSHATTRIB)_getPublicProcAddress(_name);
        if (!_glPushAttrib_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPushAttrib_ptr(mask);
}

typedef void (APIENTRY * PFN_GLMAP1D)(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points);
static PFN_GLMAP1D _glMap1d_ptr = NULL;

static inline void APIENTRY _glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points) {
    const char *_name = "glMap1d";
    if (!_glMap1d_ptr) {
        _glMap1d_ptr = (PFN_GLMAP1D)_getPublicProcAddress(_name);
        if (!_glMap1d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMap1d_ptr(target, u1, u2, stride, order, points);
}

typedef void (APIENTRY * PFN_GLMAP1F)(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points);
static PFN_GLMAP1F _glMap1f_ptr = NULL;

static inline void APIENTRY _glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points) {
    const char *_name = "glMap1f";
    if (!_glMap1f_ptr) {
        _glMap1f_ptr = (PFN_GLMAP1F)_getPublicProcAddress(_name);
        if (!_glMap1f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMap1f_ptr(target, u1, u2, stride, order, points);
}

typedef void (APIENTRY * PFN_GLMAP2D)(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points);
static PFN_GLMAP2D _glMap2d_ptr = NULL;

static inline void APIENTRY _glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points) {
    const char *_name = "glMap2d";
    if (!_glMap2d_ptr) {
        _glMap2d_ptr = (PFN_GLMAP2D)_getPublicProcAddress(_name);
        if (!_glMap2d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMap2d_ptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

typedef void (APIENTRY * PFN_GLMAP2F)(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points);
static PFN_GLMAP2F _glMap2f_ptr = NULL;

static inline void APIENTRY _glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points) {
    const char *_name = "glMap2f";
    if (!_glMap2f_ptr) {
        _glMap2f_ptr = (PFN_GLMAP2F)_getPublicProcAddress(_name);
        if (!_glMap2f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMap2f_ptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

typedef void (APIENTRY * PFN_GLMAPGRID1D)(GLint un, GLdouble u1, GLdouble u2);
static PFN_GLMAPGRID1D _glMapGrid1d_ptr = NULL;

static inline void APIENTRY _glMapGrid1d(GLint un, GLdouble u1, GLdouble u2) {
    const char *_name = "glMapGrid1d";
    if (!_glMapGrid1d_ptr) {
        _glMapGrid1d_ptr = (PFN_GLMAPGRID1D)_getPublicProcAddress(_name);
        if (!_glMapGrid1d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMapGrid1d_ptr(un, u1, u2);
}

typedef void (APIENTRY * PFN_GLMAPGRID1F)(GLint un, GLfloat u1, GLfloat u2);
static PFN_GLMAPGRID1F _glMapGrid1f_ptr = NULL;

static inline void APIENTRY _glMapGrid1f(GLint un, GLfloat u1, GLfloat u2) {
    const char *_name = "glMapGrid1f";
    if (!_glMapGrid1f_ptr) {
        _glMapGrid1f_ptr = (PFN_GLMAPGRID1F)_getPublicProcAddress(_name);
        if (!_glMapGrid1f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMapGrid1f_ptr(un, u1, u2);
}

typedef void (APIENTRY * PFN_GLMAPGRID2D)(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
static PFN_GLMAPGRID2D _glMapGrid2d_ptr = NULL;

static inline void APIENTRY _glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) {
    const char *_name = "glMapGrid2d";
    if (!_glMapGrid2d_ptr) {
        _glMapGrid2d_ptr = (PFN_GLMAPGRID2D)_getPublicProcAddress(_name);
        if (!_glMapGrid2d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMapGrid2d_ptr(un, u1, u2, vn, v1, v2);
}

typedef void (APIENTRY * PFN_GLMAPGRID2F)(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
static PFN_GLMAPGRID2F _glMapGrid2f_ptr = NULL;

static inline void APIENTRY _glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) {
    const char *_name = "glMapGrid2f";
    if (!_glMapGrid2f_ptr) {
        _glMapGrid2f_ptr = (PFN_GLMAPGRID2F)_getPublicProcAddress(_name);
        if (!_glMapGrid2f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMapGrid2f_ptr(un, u1, u2, vn, v1, v2);
}

typedef void (APIENTRY * PFN_GLEVALCOORD1D)(GLdouble u);
static PFN_GLEVALCOORD1D _glEvalCoord1d_ptr = NULL;

static inline void APIENTRY _glEvalCoord1d(GLdouble u) {
    const char *_name = "glEvalCoord1d";
    if (!_glEvalCoord1d_ptr) {
        _glEvalCoord1d_ptr = (PFN_GLEVALCOORD1D)_getPublicProcAddress(_name);
        if (!_glEvalCoord1d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEvalCoord1d_ptr(u);
}

typedef void (APIENTRY * PFN_GLEVALCOORD1DV)(const GLdouble * u);
static PFN_GLEVALCOORD1DV _glEvalCoord1dv_ptr = NULL;

static inline void APIENTRY _glEvalCoord1dv(const GLdouble * u) {
    const char *_name = "glEvalCoord1dv";
    if (!_glEvalCoord1dv_ptr) {
        _glEvalCoord1dv_ptr = (PFN_GLEVALCOORD1DV)_getPublicProcAddress(_name);
        if (!_glEvalCoord1dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEvalCoord1dv_ptr(u);
}

typedef void (APIENTRY * PFN_GLEVALCOORD1F)(GLfloat u);
static PFN_GLEVALCOORD1F _glEvalCoord1f_ptr = NULL;

static inline void APIENTRY _glEvalCoord1f(GLfloat u) {
    const char *_name = "glEvalCoord1f";
    if (!_glEvalCoord1f_ptr) {
        _glEvalCoord1f_ptr = (PFN_GLEVALCOORD1F)_getPublicProcAddress(_name);
        if (!_glEvalCoord1f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEvalCoord1f_ptr(u);
}

typedef void (APIENTRY * PFN_GLEVALCOORD1FV)(const GLfloat * u);
static PFN_GLEVALCOORD1FV _glEvalCoord1fv_ptr = NULL;

static inline void APIENTRY _glEvalCoord1fv(const GLfloat * u) {
    const char *_name = "glEvalCoord1fv";
    if (!_glEvalCoord1fv_ptr) {
        _glEvalCoord1fv_ptr = (PFN_GLEVALCOORD1FV)_getPublicProcAddress(_name);
        if (!_glEvalCoord1fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEvalCoord1fv_ptr(u);
}

typedef void (APIENTRY * PFN_GLEVALCOORD2D)(GLdouble u, GLdouble v);
static PFN_GLEVALCOORD2D _glEvalCoord2d_ptr = NULL;

static inline void APIENTRY _glEvalCoord2d(GLdouble u, GLdouble v) {
    const char *_name = "glEvalCoord2d";
    if (!_glEvalCoord2d_ptr) {
        _glEvalCoord2d_ptr = (PFN_GLEVALCOORD2D)_getPublicProcAddress(_name);
        if (!_glEvalCoord2d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEvalCoord2d_ptr(u, v);
}

typedef void (APIENTRY * PFN_GLEVALCOORD2DV)(const GLdouble * u);
static PFN_GLEVALCOORD2DV _glEvalCoord2dv_ptr = NULL;

static inline void APIENTRY _glEvalCoord2dv(const GLdouble * u) {
    const char *_name = "glEvalCoord2dv";
    if (!_glEvalCoord2dv_ptr) {
        _glEvalCoord2dv_ptr = (PFN_GLEVALCOORD2DV)_getPublicProcAddress(_name);
        if (!_glEvalCoord2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEvalCoord2dv_ptr(u);
}

typedef void (APIENTRY * PFN_GLEVALCOORD2F)(GLfloat u, GLfloat v);
static PFN_GLEVALCOORD2F _glEvalCoord2f_ptr = NULL;

static inline void APIENTRY _glEvalCoord2f(GLfloat u, GLfloat v) {
    const char *_name = "glEvalCoord2f";
    if (!_glEvalCoord2f_ptr) {
        _glEvalCoord2f_ptr = (PFN_GLEVALCOORD2F)_getPublicProcAddress(_name);
        if (!_glEvalCoord2f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEvalCoord2f_ptr(u, v);
}

typedef void (APIENTRY * PFN_GLEVALCOORD2FV)(const GLfloat * u);
static PFN_GLEVALCOORD2FV _glEvalCoord2fv_ptr = NULL;

static inline void APIENTRY _glEvalCoord2fv(const GLfloat * u) {
    const char *_name = "glEvalCoord2fv";
    if (!_glEvalCoord2fv_ptr) {
        _glEvalCoord2fv_ptr = (PFN_GLEVALCOORD2FV)_getPublicProcAddress(_name);
        if (!_glEvalCoord2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEvalCoord2fv_ptr(u);
}

typedef void (APIENTRY * PFN_GLEVALMESH1)(GLenum mode, GLint i1, GLint i2);
static PFN_GLEVALMESH1 _glEvalMesh1_ptr = NULL;

static inline void APIENTRY _glEvalMesh1(GLenum mode, GLint i1, GLint i2) {
    const char *_name = "glEvalMesh1";
    if (!_glEvalMesh1_ptr) {
        _glEvalMesh1_ptr = (PFN_GLEVALMESH1)_getPublicProcAddress(_name);
        if (!_glEvalMesh1_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEvalMesh1_ptr(mode, i1, i2);
}

typedef void (APIENTRY * PFN_GLEVALPOINT1)(GLint i);
static PFN_GLEVALPOINT1 _glEvalPoint1_ptr = NULL;

static inline void APIENTRY _glEvalPoint1(GLint i) {
    const char *_name = "glEvalPoint1";
    if (!_glEvalPoint1_ptr) {
        _glEvalPoint1_ptr = (PFN_GLEVALPOINT1)_getPublicProcAddress(_name);
        if (!_glEvalPoint1_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEvalPoint1_ptr(i);
}

typedef void (APIENTRY * PFN_GLEVALMESH2)(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
static PFN_GLEVALMESH2 _glEvalMesh2_ptr = NULL;

static inline void APIENTRY _glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) {
    const char *_name = "glEvalMesh2";
    if (!_glEvalMesh2_ptr) {
        _glEvalMesh2_ptr = (PFN_GLEVALMESH2)_getPublicProcAddress(_name);
        if (!_glEvalMesh2_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEvalMesh2_ptr(mode, i1, i2, j1, j2);
}

typedef void (APIENTRY * PFN_GLEVALPOINT2)(GLint i, GLint j);
static PFN_GLEVALPOINT2 _glEvalPoint2_ptr = NULL;

static inline void APIENTRY _glEvalPoint2(GLint i, GLint j) {
    const char *_name = "glEvalPoint2";
    if (!_glEvalPoint2_ptr) {
        _glEvalPoint2_ptr = (PFN_GLEVALPOINT2)_getPublicProcAddress(_name);
        if (!_glEvalPoint2_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEvalPoint2_ptr(i, j);
}

typedef void (APIENTRY * PFN_GLALPHAFUNC)(GLenum func, GLfloat ref);
static PFN_GLALPHAFUNC _glAlphaFunc_ptr = NULL;

static inline void APIENTRY _glAlphaFunc(GLenum func, GLfloat ref) {
    const char *_name = "glAlphaFunc";
    if (!_glAlphaFunc_ptr) {
        _glAlphaFunc_ptr = (PFN_GLALPHAFUNC)_getPublicProcAddress(_name);
        if (!_glAlphaFunc_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glAlphaFunc_ptr(func, ref);
}

typedef void (APIENTRY * PFN_GLPIXELZOOM)(GLfloat xfactor, GLfloat yfactor);
static PFN_GLPIXELZOOM _glPixelZoom_ptr = NULL;

static inline void APIENTRY _glPixelZoom(GLfloat xfactor, GLfloat yfactor) {
    const char *_name = "glPixelZoom";
    if (!_glPixelZoom_ptr) {
        _glPixelZoom_ptr = (PFN_GLPIXELZOOM)_getPublicProcAddress(_name);
        if (!_glPixelZoom_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelZoom_ptr(xfactor, yfactor);
}

typedef void (APIENTRY * PFN_GLPIXELTRANSFERF)(GLenum pname, GLfloat param);
static PFN_GLPIXELTRANSFERF _glPixelTransferf_ptr = NULL;

static inline void APIENTRY _glPixelTransferf(GLenum pname, GLfloat param) {
    const char *_name = "glPixelTransferf";
    if (!_glPixelTransferf_ptr) {
        _glPixelTransferf_ptr = (PFN_GLPIXELTRANSFERF)_getPublicProcAddress(_name);
        if (!_glPixelTransferf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelTransferf_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLPIXELTRANSFERI)(GLenum pname, GLint param);
static PFN_GLPIXELTRANSFERI _glPixelTransferi_ptr = NULL;

static inline void APIENTRY _glPixelTransferi(GLenum pname, GLint param) {
    const char *_name = "glPixelTransferi";
    if (!_glPixelTransferi_ptr) {
        _glPixelTransferi_ptr = (PFN_GLPIXELTRANSFERI)_getPublicProcAddress(_name);
        if (!_glPixelTransferi_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelTransferi_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLPIXELMAPFV)(GLenum map, GLsizei mapsize, const GLfloat * values);
static PFN_GLPIXELMAPFV _glPixelMapfv_ptr = NULL;

static inline void APIENTRY _glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat * values) {
    const char *_name = "glPixelMapfv";
    if (!_glPixelMapfv_ptr) {
        _glPixelMapfv_ptr = (PFN_GLPIXELMAPFV)_getPublicProcAddress(_name);
        if (!_glPixelMapfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelMapfv_ptr(map, mapsize, values);
}

typedef void (APIENTRY * PFN_GLPIXELMAPUIV)(GLenum map, GLsizei mapsize, const GLuint * values);
static PFN_GLPIXELMAPUIV _glPixelMapuiv_ptr = NULL;

static inline void APIENTRY _glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint * values) {
    const char *_name = "glPixelMapuiv";
    if (!_glPixelMapuiv_ptr) {
        _glPixelMapuiv_ptr = (PFN_GLPIXELMAPUIV)_getPublicProcAddress(_name);
        if (!_glPixelMapuiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelMapuiv_ptr(map, mapsize, values);
}

typedef void (APIENTRY * PFN_GLPIXELMAPUSV)(GLenum map, GLsizei mapsize, const GLushort * values);
static PFN_GLPIXELMAPUSV _glPixelMapusv_ptr = NULL;

static inline void APIENTRY _glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort * values) {
    const char *_name = "glPixelMapusv";
    if (!_glPixelMapusv_ptr) {
        _glPixelMapusv_ptr = (PFN_GLPIXELMAPUSV)_getPublicProcAddress(_name);
        if (!_glPixelMapusv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelMapusv_ptr(map, mapsize, values);
}

typedef void (APIENTRY * PFN_GLCOPYPIXELS)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
static PFN_GLCOPYPIXELS _glCopyPixels_ptr = NULL;

static inline void APIENTRY _glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) {
    const char *_name = "glCopyPixels";
    if (!_glCopyPixels_ptr) {
        _glCopyPixels_ptr = (PFN_GLCOPYPIXELS)_getPublicProcAddress(_name);
        if (!_glCopyPixels_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyPixels_ptr(x, y, width, height, type);
}

typedef void (APIENTRY * PFN_GLDRAWPIXELS)(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLDRAWPIXELS _glDrawPixels_ptr = NULL;

static inline void APIENTRY _glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glDrawPixels";
    if (!_glDrawPixels_ptr) {
        _glDrawPixels_ptr = (PFN_GLDRAWPIXELS)_getPublicProcAddress(_name);
        if (!_glDrawPixels_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawPixels_ptr(width, height, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLGETCLIPPLANE)(GLenum plane, GLdouble * equation);
static PFN_GLGETCLIPPLANE _glGetClipPlane_ptr = NULL;

static inline void APIENTRY _glGetClipPlane(GLenum plane, GLdouble * equation) {
    const char *_name = "glGetClipPlane";
    if (!_glGetClipPlane_ptr) {
        _glGetClipPlane_ptr = (PFN_GLGETCLIPPLANE)_getPublicProcAddress(_name);
        if (!_glGetClipPlane_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetClipPlane_ptr(plane, equation);
}

typedef void (APIENTRY * PFN_GLGETLIGHTFV)(GLenum light, GLenum pname, GLfloat * params);
static PFN_GLGETLIGHTFV _glGetLightfv_ptr = NULL;

static inline void APIENTRY _glGetLightfv(GLenum light, GLenum pname, GLfloat * params) {
    const char *_name = "glGetLightfv";
    if (!_glGetLightfv_ptr) {
        _glGetLightfv_ptr = (PFN_GLGETLIGHTFV)_getPublicProcAddress(_name);
        if (!_glGetLightfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetLightfv_ptr(light, pname, params);
}

typedef void (APIENTRY * PFN_GLGETLIGHTIV)(GLenum light, GLenum pname, GLint * params);
static PFN_GLGETLIGHTIV _glGetLightiv_ptr = NULL;

static inline void APIENTRY _glGetLightiv(GLenum light, GLenum pname, GLint * params) {
    const char *_name = "glGetLightiv";
    if (!_glGetLightiv_ptr) {
        _glGetLightiv_ptr = (PFN_GLGETLIGHTIV)_getPublicProcAddress(_name);
        if (!_glGetLightiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetLightiv_ptr(light, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMAPDV)(GLenum target, GLenum query, GLdouble * v);
static PFN_GLGETMAPDV _glGetMapdv_ptr = NULL;

static inline void APIENTRY _glGetMapdv(GLenum target, GLenum query, GLdouble * v) {
    const char *_name = "glGetMapdv";
    if (!_glGetMapdv_ptr) {
        _glGetMapdv_ptr = (PFN_GLGETMAPDV)_getPublicProcAddress(_name);
        if (!_glGetMapdv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMapdv_ptr(target, query, v);
}

typedef void (APIENTRY * PFN_GLGETMAPFV)(GLenum target, GLenum query, GLfloat * v);
static PFN_GLGETMAPFV _glGetMapfv_ptr = NULL;

static inline void APIENTRY _glGetMapfv(GLenum target, GLenum query, GLfloat * v) {
    const char *_name = "glGetMapfv";
    if (!_glGetMapfv_ptr) {
        _glGetMapfv_ptr = (PFN_GLGETMAPFV)_getPublicProcAddress(_name);
        if (!_glGetMapfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMapfv_ptr(target, query, v);
}

typedef void (APIENTRY * PFN_GLGETMAPIV)(GLenum target, GLenum query, GLint * v);
static PFN_GLGETMAPIV _glGetMapiv_ptr = NULL;

static inline void APIENTRY _glGetMapiv(GLenum target, GLenum query, GLint * v) {
    const char *_name = "glGetMapiv";
    if (!_glGetMapiv_ptr) {
        _glGetMapiv_ptr = (PFN_GLGETMAPIV)_getPublicProcAddress(_name);
        if (!_glGetMapiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMapiv_ptr(target, query, v);
}

typedef void (APIENTRY * PFN_GLGETMATERIALFV)(GLenum face, GLenum pname, GLfloat * params);
static PFN_GLGETMATERIALFV _glGetMaterialfv_ptr = NULL;

static inline void APIENTRY _glGetMaterialfv(GLenum face, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMaterialfv";
    if (!_glGetMaterialfv_ptr) {
        _glGetMaterialfv_ptr = (PFN_GLGETMATERIALFV)_getPublicProcAddress(_name);
        if (!_glGetMaterialfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMaterialfv_ptr(face, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMATERIALIV)(GLenum face, GLenum pname, GLint * params);
static PFN_GLGETMATERIALIV _glGetMaterialiv_ptr = NULL;

static inline void APIENTRY _glGetMaterialiv(GLenum face, GLenum pname, GLint * params) {
    const char *_name = "glGetMaterialiv";
    if (!_glGetMaterialiv_ptr) {
        _glGetMaterialiv_ptr = (PFN_GLGETMATERIALIV)_getPublicProcAddress(_name);
        if (!_glGetMaterialiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMaterialiv_ptr(face, pname, params);
}

typedef void (APIENTRY * PFN_GLGETPIXELMAPFV)(GLenum map, GLfloat * values);
static PFN_GLGETPIXELMAPFV _glGetPixelMapfv_ptr = NULL;

static inline void APIENTRY _glGetPixelMapfv(GLenum map, GLfloat * values) {
    const char *_name = "glGetPixelMapfv";
    if (!_glGetPixelMapfv_ptr) {
        _glGetPixelMapfv_ptr = (PFN_GLGETPIXELMAPFV)_getPublicProcAddress(_name);
        if (!_glGetPixelMapfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPixelMapfv_ptr(map, values);
}

typedef void (APIENTRY * PFN_GLGETPIXELMAPUIV)(GLenum map, GLuint * values);
static PFN_GLGETPIXELMAPUIV _glGetPixelMapuiv_ptr = NULL;

static inline void APIENTRY _glGetPixelMapuiv(GLenum map, GLuint * values) {
    const char *_name = "glGetPixelMapuiv";
    if (!_glGetPixelMapuiv_ptr) {
        _glGetPixelMapuiv_ptr = (PFN_GLGETPIXELMAPUIV)_getPublicProcAddress(_name);
        if (!_glGetPixelMapuiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPixelMapuiv_ptr(map, values);
}

typedef void (APIENTRY * PFN_GLGETPIXELMAPUSV)(GLenum map, GLushort * values);
static PFN_GLGETPIXELMAPUSV _glGetPixelMapusv_ptr = NULL;

static inline void APIENTRY _glGetPixelMapusv(GLenum map, GLushort * values) {
    const char *_name = "glGetPixelMapusv";
    if (!_glGetPixelMapusv_ptr) {
        _glGetPixelMapusv_ptr = (PFN_GLGETPIXELMAPUSV)_getPublicProcAddress(_name);
        if (!_glGetPixelMapusv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPixelMapusv_ptr(map, values);
}

typedef void (APIENTRY * PFN_GLGETPOLYGONSTIPPLE)(GLubyte * mask);
static PFN_GLGETPOLYGONSTIPPLE _glGetPolygonStipple_ptr = NULL;

static inline void APIENTRY _glGetPolygonStipple(GLubyte * mask) {
    const char *_name = "glGetPolygonStipple";
    if (!_glGetPolygonStipple_ptr) {
        _glGetPolygonStipple_ptr = (PFN_GLGETPOLYGONSTIPPLE)_getPublicProcAddress(_name);
        if (!_glGetPolygonStipple_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPolygonStipple_ptr(mask);
}

typedef void (APIENTRY * PFN_GLGETTEXENVFV)(GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETTEXENVFV _glGetTexEnvfv_ptr = NULL;

static inline void APIENTRY _glGetTexEnvfv(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTexEnvfv";
    if (!_glGetTexEnvfv_ptr) {
        _glGetTexEnvfv_ptr = (PFN_GLGETTEXENVFV)_getPublicProcAddress(_name);
        if (!_glGetTexEnvfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexEnvfv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXENVIV)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETTEXENVIV _glGetTexEnviv_ptr = NULL;

static inline void APIENTRY _glGetTexEnviv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetTexEnviv";
    if (!_glGetTexEnviv_ptr) {
        _glGetTexEnviv_ptr = (PFN_GLGETTEXENVIV)_getPublicProcAddress(_name);
        if (!_glGetTexEnviv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexEnviv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXGENDV)(GLenum coord, GLenum pname, GLdouble * params);
static PFN_GLGETTEXGENDV _glGetTexGendv_ptr = NULL;

static inline void APIENTRY _glGetTexGendv(GLenum coord, GLenum pname, GLdouble * params) {
    const char *_name = "glGetTexGendv";
    if (!_glGetTexGendv_ptr) {
        _glGetTexGendv_ptr = (PFN_GLGETTEXGENDV)_getPublicProcAddress(_name);
        if (!_glGetTexGendv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexGendv_ptr(coord, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXGENFV)(GLenum coord, GLenum pname, GLfloat * params);
static PFN_GLGETTEXGENFV _glGetTexGenfv_ptr = NULL;

static inline void APIENTRY _glGetTexGenfv(GLenum coord, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTexGenfv";
    if (!_glGetTexGenfv_ptr) {
        _glGetTexGenfv_ptr = (PFN_GLGETTEXGENFV)_getPublicProcAddress(_name);
        if (!_glGetTexGenfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexGenfv_ptr(coord, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXGENIV)(GLenum coord, GLenum pname, GLint * params);
static PFN_GLGETTEXGENIV _glGetTexGeniv_ptr = NULL;

static inline void APIENTRY _glGetTexGeniv(GLenum coord, GLenum pname, GLint * params) {
    const char *_name = "glGetTexGeniv";
    if (!_glGetTexGeniv_ptr) {
        _glGetTexGeniv_ptr = (PFN_GLGETTEXGENIV)_getPublicProcAddress(_name);
        if (!_glGetTexGeniv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexGeniv_ptr(coord, pname, params);
}

typedef GLboolean (APIENTRY * PFN_GLISLIST)(GLuint list);
static PFN_GLISLIST _glIsList_ptr = NULL;

static inline GLboolean APIENTRY _glIsList(GLuint list) {
    const char *_name = "glIsList";
    if (!_glIsList_ptr) {
        _glIsList_ptr = (PFN_GLISLIST)_getPublicProcAddress(_name);
        if (!_glIsList_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsList_ptr(list);
}

typedef void (APIENTRY * PFN_GLFRUSTUM)(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
static PFN_GLFRUSTUM _glFrustum_ptr = NULL;

static inline void APIENTRY _glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    const char *_name = "glFrustum";
    if (!_glFrustum_ptr) {
        _glFrustum_ptr = (PFN_GLFRUSTUM)_getPublicProcAddress(_name);
        if (!_glFrustum_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFrustum_ptr(left, right, bottom, top, zNear, zFar);
}

typedef void (APIENTRY * PFN_GLLOADIDENTITY)(void);
static PFN_GLLOADIDENTITY _glLoadIdentity_ptr = NULL;

static inline void APIENTRY _glLoadIdentity(void) {
    const char *_name = "glLoadIdentity";
    if (!_glLoadIdentity_ptr) {
        _glLoadIdentity_ptr = (PFN_GLLOADIDENTITY)_getPublicProcAddress(_name);
        if (!_glLoadIdentity_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLoadIdentity_ptr();
}

typedef void (APIENTRY * PFN_GLLOADMATRIXF)(const GLfloat * m);
static PFN_GLLOADMATRIXF _glLoadMatrixf_ptr = NULL;

static inline void APIENTRY _glLoadMatrixf(const GLfloat * m) {
    const char *_name = "glLoadMatrixf";
    if (!_glLoadMatrixf_ptr) {
        _glLoadMatrixf_ptr = (PFN_GLLOADMATRIXF)_getPublicProcAddress(_name);
        if (!_glLoadMatrixf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLoadMatrixf_ptr(m);
}

typedef void (APIENTRY * PFN_GLLOADMATRIXD)(const GLdouble * m);
static PFN_GLLOADMATRIXD _glLoadMatrixd_ptr = NULL;

static inline void APIENTRY _glLoadMatrixd(const GLdouble * m) {
    const char *_name = "glLoadMatrixd";
    if (!_glLoadMatrixd_ptr) {
        _glLoadMatrixd_ptr = (PFN_GLLOADMATRIXD)_getPublicProcAddress(_name);
        if (!_glLoadMatrixd_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLoadMatrixd_ptr(m);
}

typedef void (APIENTRY * PFN_GLMATRIXMODE)(GLenum mode);
static PFN_GLMATRIXMODE _glMatrixMode_ptr = NULL;

static inline void APIENTRY _glMatrixMode(GLenum mode) {
    const char *_name = "glMatrixMode";
    if (!_glMatrixMode_ptr) {
        _glMatrixMode_ptr = (PFN_GLMATRIXMODE)_getPublicProcAddress(_name);
        if (!_glMatrixMode_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixMode_ptr(mode);
}

typedef void (APIENTRY * PFN_GLMULTMATRIXF)(const GLfloat * m);
static PFN_GLMULTMATRIXF _glMultMatrixf_ptr = NULL;

static inline void APIENTRY _glMultMatrixf(const GLfloat * m) {
    const char *_name = "glMultMatrixf";
    if (!_glMultMatrixf_ptr) {
        _glMultMatrixf_ptr = (PFN_GLMULTMATRIXF)_getPublicProcAddress(_name);
        if (!_glMultMatrixf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultMatrixf_ptr(m);
}

typedef void (APIENTRY * PFN_GLMULTMATRIXD)(const GLdouble * m);
static PFN_GLMULTMATRIXD _glMultMatrixd_ptr = NULL;

static inline void APIENTRY _glMultMatrixd(const GLdouble * m) {
    const char *_name = "glMultMatrixd";
    if (!_glMultMatrixd_ptr) {
        _glMultMatrixd_ptr = (PFN_GLMULTMATRIXD)_getPublicProcAddress(_name);
        if (!_glMultMatrixd_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultMatrixd_ptr(m);
}

typedef void (APIENTRY * PFN_GLORTHO)(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
static PFN_GLORTHO _glOrtho_ptr = NULL;

static inline void APIENTRY _glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    const char *_name = "glOrtho";
    if (!_glOrtho_ptr) {
        _glOrtho_ptr = (PFN_GLORTHO)_getPublicProcAddress(_name);
        if (!_glOrtho_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glOrtho_ptr(left, right, bottom, top, zNear, zFar);
}

typedef void (APIENTRY * PFN_GLPOPMATRIX)(void);
static PFN_GLPOPMATRIX _glPopMatrix_ptr = NULL;

static inline void APIENTRY _glPopMatrix(void) {
    const char *_name = "glPopMatrix";
    if (!_glPopMatrix_ptr) {
        _glPopMatrix_ptr = (PFN_GLPOPMATRIX)_getPublicProcAddress(_name);
        if (!_glPopMatrix_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPopMatrix_ptr();
}

typedef void (APIENTRY * PFN_GLPUSHMATRIX)(void);
static PFN_GLPUSHMATRIX _glPushMatrix_ptr = NULL;

static inline void APIENTRY _glPushMatrix(void) {
    const char *_name = "glPushMatrix";
    if (!_glPushMatrix_ptr) {
        _glPushMatrix_ptr = (PFN_GLPUSHMATRIX)_getPublicProcAddress(_name);
        if (!_glPushMatrix_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPushMatrix_ptr();
}

typedef void (APIENTRY * PFN_GLROTATED)(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
static PFN_GLROTATED _glRotated_ptr = NULL;

static inline void APIENTRY _glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glRotated";
    if (!_glRotated_ptr) {
        _glRotated_ptr = (PFN_GLROTATED)_getPublicProcAddress(_name);
        if (!_glRotated_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRotated_ptr(angle, x, y, z);
}

typedef void (APIENTRY * PFN_GLROTATEF)(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLROTATEF _glRotatef_ptr = NULL;

static inline void APIENTRY _glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glRotatef";
    if (!_glRotatef_ptr) {
        _glRotatef_ptr = (PFN_GLROTATEF)_getPublicProcAddress(_name);
        if (!_glRotatef_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRotatef_ptr(angle, x, y, z);
}

typedef void (APIENTRY * PFN_GLSCALED)(GLdouble x, GLdouble y, GLdouble z);
static PFN_GLSCALED _glScaled_ptr = NULL;

static inline void APIENTRY _glScaled(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glScaled";
    if (!_glScaled_ptr) {
        _glScaled_ptr = (PFN_GLSCALED)_getPublicProcAddress(_name);
        if (!_glScaled_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glScaled_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLSCALEF)(GLfloat x, GLfloat y, GLfloat z);
static PFN_GLSCALEF _glScalef_ptr = NULL;

static inline void APIENTRY _glScalef(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glScalef";
    if (!_glScalef_ptr) {
        _glScalef_ptr = (PFN_GLSCALEF)_getPublicProcAddress(_name);
        if (!_glScalef_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glScalef_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLTRANSLATED)(GLdouble x, GLdouble y, GLdouble z);
static PFN_GLTRANSLATED _glTranslated_ptr = NULL;

static inline void APIENTRY _glTranslated(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glTranslated";
    if (!_glTranslated_ptr) {
        _glTranslated_ptr = (PFN_GLTRANSLATED)_getPublicProcAddress(_name);
        if (!_glTranslated_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTranslated_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLTRANSLATEF)(GLfloat x, GLfloat y, GLfloat z);
static PFN_GLTRANSLATEF _glTranslatef_ptr = NULL;

static inline void APIENTRY _glTranslatef(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glTranslatef";
    if (!_glTranslatef_ptr) {
        _glTranslatef_ptr = (PFN_GLTRANSLATEF)_getPublicProcAddress(_name);
        if (!_glTranslatef_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTranslatef_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLDRAWARRAYS)(GLenum mode, GLint first, GLsizei count);
static PFN_GLDRAWARRAYS _glDrawArrays_ptr = NULL;

static inline void APIENTRY _glDrawArrays(GLenum mode, GLint first, GLsizei count) {
    const char *_name = "glDrawArrays";
    if (!_glDrawArrays_ptr) {
        _glDrawArrays_ptr = (PFN_GLDRAWARRAYS)_getPublicProcAddress(_name);
        if (!_glDrawArrays_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawArrays_ptr(mode, first, count);
}

typedef void (APIENTRY * PFN_GLDRAWELEMENTS)(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices);
static PFN_GLDRAWELEMENTS _glDrawElements_ptr = NULL;

static inline void APIENTRY _glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices) {
    const char *_name = "glDrawElements";
    if (!_glDrawElements_ptr) {
        _glDrawElements_ptr = (PFN_GLDRAWELEMENTS)_getPublicProcAddress(_name);
        if (!_glDrawElements_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawElements_ptr(mode, count, type, indices);
}

typedef void (APIENTRY * PFN_GLGETPOINTERV)(GLenum pname, GLvoid * * params);
static PFN_GLGETPOINTERV _glGetPointerv_ptr = NULL;

static inline void APIENTRY _glGetPointerv(GLenum pname, GLvoid * * params) {
    const char *_name = "glGetPointerv";
    if (!_glGetPointerv_ptr) {
        _glGetPointerv_ptr = (PFN_GLGETPOINTERV)_getPublicProcAddress(_name);
        if (!_glGetPointerv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPointerv_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLPOLYGONOFFSET)(GLfloat factor, GLfloat units);
static PFN_GLPOLYGONOFFSET _glPolygonOffset_ptr = NULL;

static inline void APIENTRY _glPolygonOffset(GLfloat factor, GLfloat units) {
    const char *_name = "glPolygonOffset";
    if (!_glPolygonOffset_ptr) {
        _glPolygonOffset_ptr = (PFN_GLPOLYGONOFFSET)_getPublicProcAddress(_name);
        if (!_glPolygonOffset_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPolygonOffset_ptr(factor, units);
}

typedef void (APIENTRY * PFN_GLCOPYTEXIMAGE1D)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
static PFN_GLCOPYTEXIMAGE1D _glCopyTexImage1D_ptr = NULL;

static inline void APIENTRY _glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    const char *_name = "glCopyTexImage1D";
    if (!_glCopyTexImage1D_ptr) {
        _glCopyTexImage1D_ptr = (PFN_GLCOPYTEXIMAGE1D)_getPublicProcAddress(_name);
        if (!_glCopyTexImage1D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTexImage1D_ptr(target, level, internalformat, x, y, width, border);
}

typedef void (APIENTRY * PFN_GLCOPYTEXIMAGE2D)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
static PFN_GLCOPYTEXIMAGE2D _glCopyTexImage2D_ptr = NULL;

static inline void APIENTRY _glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    const char *_name = "glCopyTexImage2D";
    if (!_glCopyTexImage2D_ptr) {
        _glCopyTexImage2D_ptr = (PFN_GLCOPYTEXIMAGE2D)_getPublicProcAddress(_name);
        if (!_glCopyTexImage2D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTexImage2D_ptr(target, level, internalformat, x, y, width, height, border);
}

typedef void (APIENTRY * PFN_GLCOPYTEXSUBIMAGE1D)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
static PFN_GLCOPYTEXSUBIMAGE1D _glCopyTexSubImage1D_ptr = NULL;

static inline void APIENTRY _glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyTexSubImage1D";
    if (!_glCopyTexSubImage1D_ptr) {
        _glCopyTexSubImage1D_ptr = (PFN_GLCOPYTEXSUBIMAGE1D)_getPublicProcAddress(_name);
        if (!_glCopyTexSubImage1D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTexSubImage1D_ptr(target, level, xoffset, x, y, width);
}

typedef void (APIENTRY * PFN_GLCOPYTEXSUBIMAGE2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLCOPYTEXSUBIMAGE2D _glCopyTexSubImage2D_ptr = NULL;

static inline void APIENTRY _glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTexSubImage2D";
    if (!_glCopyTexSubImage2D_ptr) {
        _glCopyTexSubImage2D_ptr = (PFN_GLCOPYTEXSUBIMAGE2D)_getPublicProcAddress(_name);
        if (!_glCopyTexSubImage2D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTexSubImage2D_ptr(target, level, xoffset, yoffset, x, y, width, height);
}

typedef void (APIENTRY * PFN_GLTEXSUBIMAGE1D)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXSUBIMAGE1D _glTexSubImage1D_ptr = NULL;

static inline void APIENTRY _glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage1D";
    if (!_glTexSubImage1D_ptr) {
        _glTexSubImage1D_ptr = (PFN_GLTEXSUBIMAGE1D)_getPublicProcAddress(_name);
        if (!_glTexSubImage1D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexSubImage1D_ptr(target, level, xoffset, width, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLTEXSUBIMAGE2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXSUBIMAGE2D _glTexSubImage2D_ptr = NULL;

static inline void APIENTRY _glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage2D";
    if (!_glTexSubImage2D_ptr) {
        _glTexSubImage2D_ptr = (PFN_GLTEXSUBIMAGE2D)_getPublicProcAddress(_name);
        if (!_glTexSubImage2D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexSubImage2D_ptr(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLBINDTEXTURE)(GLenum target, GLuint texture);
static PFN_GLBINDTEXTURE _glBindTexture_ptr = NULL;

static inline void APIENTRY _glBindTexture(GLenum target, GLuint texture) {
    const char *_name = "glBindTexture";
    if (!_glBindTexture_ptr) {
        _glBindTexture_ptr = (PFN_GLBINDTEXTURE)_getPublicProcAddress(_name);
        if (!_glBindTexture_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindTexture_ptr(target, texture);
}

typedef void (APIENTRY * PFN_GLDELETETEXTURES)(GLsizei n, const GLuint * textures);
static PFN_GLDELETETEXTURES _glDeleteTextures_ptr = NULL;

static inline void APIENTRY _glDeleteTextures(GLsizei n, const GLuint * textures) {
    const char *_name = "glDeleteTextures";
    if (!_glDeleteTextures_ptr) {
        _glDeleteTextures_ptr = (PFN_GLDELETETEXTURES)_getPublicProcAddress(_name);
        if (!_glDeleteTextures_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteTextures_ptr(n, textures);
}

typedef void (APIENTRY * PFN_GLGENTEXTURES)(GLsizei n, GLuint * textures);
static PFN_GLGENTEXTURES _glGenTextures_ptr = NULL;

static inline void APIENTRY _glGenTextures(GLsizei n, GLuint * textures) {
    const char *_name = "glGenTextures";
    if (!_glGenTextures_ptr) {
        _glGenTextures_ptr = (PFN_GLGENTEXTURES)_getPublicProcAddress(_name);
        if (!_glGenTextures_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenTextures_ptr(n, textures);
}

typedef GLboolean (APIENTRY * PFN_GLISTEXTURE)(GLuint texture);
static PFN_GLISTEXTURE _glIsTexture_ptr = NULL;

static inline GLboolean APIENTRY _glIsTexture(GLuint texture) {
    const char *_name = "glIsTexture";
    if (!_glIsTexture_ptr) {
        _glIsTexture_ptr = (PFN_GLISTEXTURE)_getPublicProcAddress(_name);
        if (!_glIsTexture_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsTexture_ptr(texture);
}

typedef void (APIENTRY * PFN_GLARRAYELEMENT)(GLint i);
static PFN_GLARRAYELEMENT _glArrayElement_ptr = NULL;

static inline void APIENTRY _glArrayElement(GLint i) {
    const char *_name = "glArrayElement";
    if (!_glArrayElement_ptr) {
        _glArrayElement_ptr = (PFN_GLARRAYELEMENT)_getPublicProcAddress(_name);
        if (!_glArrayElement_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glArrayElement_ptr(i);
}

typedef void (APIENTRY * PFN_GLCOLORPOINTER)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLCOLORPOINTER _glColorPointer_ptr = NULL;

static inline void APIENTRY _glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glColorPointer";
    if (!_glColorPointer_ptr) {
        _glColorPointer_ptr = (PFN_GLCOLORPOINTER)_getPublicProcAddress(_name);
        if (!_glColorPointer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorPointer_ptr(size, type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLDISABLECLIENTSTATE)(GLenum array);
static PFN_GLDISABLECLIENTSTATE _glDisableClientState_ptr = NULL;

static inline void APIENTRY _glDisableClientState(GLenum array) {
    const char *_name = "glDisableClientState";
    if (!_glDisableClientState_ptr) {
        _glDisableClientState_ptr = (PFN_GLDISABLECLIENTSTATE)_getPublicProcAddress(_name);
        if (!_glDisableClientState_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDisableClientState_ptr(array);
}

typedef void (APIENTRY * PFN_GLEDGEFLAGPOINTER)(GLsizei stride, const GLvoid * pointer);
static PFN_GLEDGEFLAGPOINTER _glEdgeFlagPointer_ptr = NULL;

static inline void APIENTRY _glEdgeFlagPointer(GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glEdgeFlagPointer";
    if (!_glEdgeFlagPointer_ptr) {
        _glEdgeFlagPointer_ptr = (PFN_GLEDGEFLAGPOINTER)_getPublicProcAddress(_name);
        if (!_glEdgeFlagPointer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEdgeFlagPointer_ptr(stride, pointer);
}

typedef void (APIENTRY * PFN_GLENABLECLIENTSTATE)(GLenum array);
static PFN_GLENABLECLIENTSTATE _glEnableClientState_ptr = NULL;

static inline void APIENTRY _glEnableClientState(GLenum array) {
    const char *_name = "glEnableClientState";
    if (!_glEnableClientState_ptr) {
        _glEnableClientState_ptr = (PFN_GLENABLECLIENTSTATE)_getPublicProcAddress(_name);
        if (!_glEnableClientState_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEnableClientState_ptr(array);
}

typedef void (APIENTRY * PFN_GLINDEXPOINTER)(GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLINDEXPOINTER _glIndexPointer_ptr = NULL;

static inline void APIENTRY _glIndexPointer(GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glIndexPointer";
    if (!_glIndexPointer_ptr) {
        _glIndexPointer_ptr = (PFN_GLINDEXPOINTER)_getPublicProcAddress(_name);
        if (!_glIndexPointer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexPointer_ptr(type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLINTERLEAVEDARRAYS)(GLenum format, GLsizei stride, const GLvoid * pointer);
static PFN_GLINTERLEAVEDARRAYS _glInterleavedArrays_ptr = NULL;

static inline void APIENTRY _glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glInterleavedArrays";
    if (!_glInterleavedArrays_ptr) {
        _glInterleavedArrays_ptr = (PFN_GLINTERLEAVEDARRAYS)_getPublicProcAddress(_name);
        if (!_glInterleavedArrays_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glInterleavedArrays_ptr(format, stride, pointer);
}

typedef void (APIENTRY * PFN_GLNORMALPOINTER)(GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLNORMALPOINTER _glNormalPointer_ptr = NULL;

static inline void APIENTRY _glNormalPointer(GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glNormalPointer";
    if (!_glNormalPointer_ptr) {
        _glNormalPointer_ptr = (PFN_GLNORMALPOINTER)_getPublicProcAddress(_name);
        if (!_glNormalPointer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalPointer_ptr(type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLTEXCOORDPOINTER)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLTEXCOORDPOINTER _glTexCoordPointer_ptr = NULL;

static inline void APIENTRY _glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glTexCoordPointer";
    if (!_glTexCoordPointer_ptr) {
        _glTexCoordPointer_ptr = (PFN_GLTEXCOORDPOINTER)_getPublicProcAddress(_name);
        if (!_glTexCoordPointer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoordPointer_ptr(size, type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLVERTEXPOINTER)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLVERTEXPOINTER _glVertexPointer_ptr = NULL;

static inline void APIENTRY _glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexPointer";
    if (!_glVertexPointer_ptr) {
        _glVertexPointer_ptr = (PFN_GLVERTEXPOINTER)_getPublicProcAddress(_name);
        if (!_glVertexPointer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexPointer_ptr(size, type, stride, pointer);
}

typedef GLboolean (APIENTRY * PFN_GLARETEXTURESRESIDENT)(GLsizei n, const GLuint * textures, GLboolean * residences);
static PFN_GLARETEXTURESRESIDENT _glAreTexturesResident_ptr = NULL;

static inline GLboolean APIENTRY _glAreTexturesResident(GLsizei n, const GLuint * textures, GLboolean * residences) {
    const char *_name = "glAreTexturesResident";
    if (!_glAreTexturesResident_ptr) {
        _glAreTexturesResident_ptr = (PFN_GLARETEXTURESRESIDENT)_getPublicProcAddress(_name);
        if (!_glAreTexturesResident_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glAreTexturesResident_ptr(n, textures, residences);
}

typedef void (APIENTRY * PFN_GLPRIORITIZETEXTURES)(GLsizei n, const GLuint * textures, const GLclampf * priorities);
static PFN_GLPRIORITIZETEXTURES _glPrioritizeTextures_ptr = NULL;

static inline void APIENTRY _glPrioritizeTextures(GLsizei n, const GLuint * textures, const GLclampf * priorities) {
    const char *_name = "glPrioritizeTextures";
    if (!_glPrioritizeTextures_ptr) {
        _glPrioritizeTextures_ptr = (PFN_GLPRIORITIZETEXTURES)_getPublicProcAddress(_name);
        if (!_glPrioritizeTextures_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPrioritizeTextures_ptr(n, textures, priorities);
}

typedef void (APIENTRY * PFN_GLINDEXUB)(GLubyte c);
static PFN_GLINDEXUB _glIndexub_ptr = NULL;

static inline void APIENTRY _glIndexub(GLubyte c) {
    const char *_name = "glIndexub";
    if (!_glIndexub_ptr) {
        _glIndexub_ptr = (PFN_GLINDEXUB)_getPublicProcAddress(_name);
        if (!_glIndexub_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexub_ptr(c);
}

typedef void (APIENTRY * PFN_GLINDEXUBV)(const GLubyte * c);
static PFN_GLINDEXUBV _glIndexubv_ptr = NULL;

static inline void APIENTRY _glIndexubv(const GLubyte * c) {
    const char *_name = "glIndexubv";
    if (!_glIndexubv_ptr) {
        _glIndexubv_ptr = (PFN_GLINDEXUBV)_getPublicProcAddress(_name);
        if (!_glIndexubv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexubv_ptr(c);
}

typedef void (APIENTRY * PFN_GLPOPCLIENTATTRIB)(void);
static PFN_GLPOPCLIENTATTRIB _glPopClientAttrib_ptr = NULL;

static inline void APIENTRY _glPopClientAttrib(void) {
    const char *_name = "glPopClientAttrib";
    if (!_glPopClientAttrib_ptr) {
        _glPopClientAttrib_ptr = (PFN_GLPOPCLIENTATTRIB)_getPublicProcAddress(_name);
        if (!_glPopClientAttrib_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPopClientAttrib_ptr();
}

typedef void (APIENTRY * PFN_GLPUSHCLIENTATTRIB)(GLbitfield mask);
static PFN_GLPUSHCLIENTATTRIB _glPushClientAttrib_ptr = NULL;

static inline void APIENTRY _glPushClientAttrib(GLbitfield mask) {
    const char *_name = "glPushClientAttrib";
    if (!_glPushClientAttrib_ptr) {
        _glPushClientAttrib_ptr = (PFN_GLPUSHCLIENTATTRIB)_getPublicProcAddress(_name);
        if (!_glPushClientAttrib_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPushClientAttrib_ptr(mask);
}

typedef void (APIENTRY * PFN_GLBLENDCOLOR)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
static PFN_GLBLENDCOLOR _glBlendColor_ptr = NULL;

static inline void APIENTRY _glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    const char *_name = "glBlendColor";
    if (!_glBlendColor_ptr) {
        _glBlendColor_ptr = (PFN_GLBLENDCOLOR)_getPrivateProcAddress(_name);
        if (!_glBlendColor_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendColor_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLBLENDEQUATION)(GLenum mode);
static PFN_GLBLENDEQUATION _glBlendEquation_ptr = NULL;

static inline void APIENTRY _glBlendEquation(GLenum mode) {
    const char *_name = "glBlendEquation";
    if (!_glBlendEquation_ptr) {
        _glBlendEquation_ptr = (PFN_GLBLENDEQUATION)_getPrivateProcAddress(_name);
        if (!_glBlendEquation_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendEquation_ptr(mode);
}

typedef void (APIENTRY * PFN_GLDRAWRANGEELEMENTS)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices);
static PFN_GLDRAWRANGEELEMENTS _glDrawRangeElements_ptr = NULL;

static inline void APIENTRY _glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices) {
    const char *_name = "glDrawRangeElements";
    if (!_glDrawRangeElements_ptr) {
        _glDrawRangeElements_ptr = (PFN_GLDRAWRANGEELEMENTS)_getPrivateProcAddress(_name);
        if (!_glDrawRangeElements_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawRangeElements_ptr(mode, start, end, count, type, indices);
}

typedef void (APIENTRY * PFN_GLTEXIMAGE3D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXIMAGE3D _glTexImage3D_ptr = NULL;

static inline void APIENTRY _glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexImage3D";
    if (!_glTexImage3D_ptr) {
        _glTexImage3D_ptr = (PFN_GLTEXIMAGE3D)_getPrivateProcAddress(_name);
        if (!_glTexImage3D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexImage3D_ptr(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLTEXSUBIMAGE3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXSUBIMAGE3D _glTexSubImage3D_ptr = NULL;

static inline void APIENTRY _glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage3D";
    if (!_glTexSubImage3D_ptr) {
        _glTexSubImage3D_ptr = (PFN_GLTEXSUBIMAGE3D)_getPrivateProcAddress(_name);
        if (!_glTexSubImage3D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexSubImage3D_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLCOPYTEXSUBIMAGE3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLCOPYTEXSUBIMAGE3D _glCopyTexSubImage3D_ptr = NULL;

static inline void APIENTRY _glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTexSubImage3D";
    if (!_glCopyTexSubImage3D_ptr) {
        _glCopyTexSubImage3D_ptr = (PFN_GLCOPYTEXSUBIMAGE3D)_getPrivateProcAddress(_name);
        if (!_glCopyTexSubImage3D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTexSubImage3D_ptr(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

typedef void (APIENTRY * PFN_GLCOLORTABLE)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table);
static PFN_GLCOLORTABLE _glColorTable_ptr = NULL;

static inline void APIENTRY _glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table) {
    const char *_name = "glColorTable";
    if (!_glColorTable_ptr) {
        _glColorTable_ptr = (PFN_GLCOLORTABLE)_getPrivateProcAddress(_name);
        if (!_glColorTable_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorTable_ptr(target, internalformat, width, format, type, table);
}

typedef void (APIENTRY * PFN_GLCOLORTABLEPARAMETERFV)(GLenum target, GLenum pname, const GLfloat * params);
static PFN_GLCOLORTABLEPARAMETERFV _glColorTableParameterfv_ptr = NULL;

static inline void APIENTRY _glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glColorTableParameterfv";
    if (!_glColorTableParameterfv_ptr) {
        _glColorTableParameterfv_ptr = (PFN_GLCOLORTABLEPARAMETERFV)_getPrivateProcAddress(_name);
        if (!_glColorTableParameterfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorTableParameterfv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCOLORTABLEPARAMETERIV)(GLenum target, GLenum pname, const GLint * params);
static PFN_GLCOLORTABLEPARAMETERIV _glColorTableParameteriv_ptr = NULL;

static inline void APIENTRY _glColorTableParameteriv(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glColorTableParameteriv";
    if (!_glColorTableParameteriv_ptr) {
        _glColorTableParameteriv_ptr = (PFN_GLCOLORTABLEPARAMETERIV)_getPrivateProcAddress(_name);
        if (!_glColorTableParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorTableParameteriv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCOPYCOLORTABLE)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
static PFN_GLCOPYCOLORTABLE _glCopyColorTable_ptr = NULL;

static inline void APIENTRY _glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyColorTable";
    if (!_glCopyColorTable_ptr) {
        _glCopyColorTable_ptr = (PFN_GLCOPYCOLORTABLE)_getPrivateProcAddress(_name);
        if (!_glCopyColorTable_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyColorTable_ptr(target, internalformat, x, y, width);
}

typedef void (APIENTRY * PFN_GLGETCOLORTABLE)(GLenum target, GLenum format, GLenum type, GLvoid * table);
static PFN_GLGETCOLORTABLE _glGetColorTable_ptr = NULL;

static inline void APIENTRY _glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid * table) {
    const char *_name = "glGetColorTable";
    if (!_glGetColorTable_ptr) {
        _glGetColorTable_ptr = (PFN_GLGETCOLORTABLE)_getPrivateProcAddress(_name);
        if (!_glGetColorTable_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetColorTable_ptr(target, format, type, table);
}

typedef void (APIENTRY * PFN_GLGETCOLORTABLEPARAMETERFV)(GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETCOLORTABLEPARAMETERFV _glGetColorTableParameterfv_ptr = NULL;

static inline void APIENTRY _glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetColorTableParameterfv";
    if (!_glGetColorTableParameterfv_ptr) {
        _glGetColorTableParameterfv_ptr = (PFN_GLGETCOLORTABLEPARAMETERFV)_getPrivateProcAddress(_name);
        if (!_glGetColorTableParameterfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetColorTableParameterfv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETCOLORTABLEPARAMETERIV)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETCOLORTABLEPARAMETERIV _glGetColorTableParameteriv_ptr = NULL;

static inline void APIENTRY _glGetColorTableParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetColorTableParameteriv";
    if (!_glGetColorTableParameteriv_ptr) {
        _glGetColorTableParameteriv_ptr = (PFN_GLGETCOLORTABLEPARAMETERIV)_getPrivateProcAddress(_name);
        if (!_glGetColorTableParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetColorTableParameteriv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCOLORSUBTABLE)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data);
static PFN_GLCOLORSUBTABLE _glColorSubTable_ptr = NULL;

static inline void APIENTRY _glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data) {
    const char *_name = "glColorSubTable";
    if (!_glColorSubTable_ptr) {
        _glColorSubTable_ptr = (PFN_GLCOLORSUBTABLE)_getPrivateProcAddress(_name);
        if (!_glColorSubTable_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorSubTable_ptr(target, start, count, format, type, data);
}

typedef void (APIENTRY * PFN_GLCOPYCOLORSUBTABLE)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
static PFN_GLCOPYCOLORSUBTABLE _glCopyColorSubTable_ptr = NULL;

static inline void APIENTRY _glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyColorSubTable";
    if (!_glCopyColorSubTable_ptr) {
        _glCopyColorSubTable_ptr = (PFN_GLCOPYCOLORSUBTABLE)_getPrivateProcAddress(_name);
        if (!_glCopyColorSubTable_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyColorSubTable_ptr(target, start, x, y, width);
}

typedef void (APIENTRY * PFN_GLCONVOLUTIONFILTER1D)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image);
static PFN_GLCONVOLUTIONFILTER1D _glConvolutionFilter1D_ptr = NULL;

static inline void APIENTRY _glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image) {
    const char *_name = "glConvolutionFilter1D";
    if (!_glConvolutionFilter1D_ptr) {
        _glConvolutionFilter1D_ptr = (PFN_GLCONVOLUTIONFILTER1D)_getPrivateProcAddress(_name);
        if (!_glConvolutionFilter1D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glConvolutionFilter1D_ptr(target, internalformat, width, format, type, image);
}

typedef void (APIENTRY * PFN_GLCONVOLUTIONFILTER2D)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image);
static PFN_GLCONVOLUTIONFILTER2D _glConvolutionFilter2D_ptr = NULL;

static inline void APIENTRY _glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image) {
    const char *_name = "glConvolutionFilter2D";
    if (!_glConvolutionFilter2D_ptr) {
        _glConvolutionFilter2D_ptr = (PFN_GLCONVOLUTIONFILTER2D)_getPrivateProcAddress(_name);
        if (!_glConvolutionFilter2D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glConvolutionFilter2D_ptr(target, internalformat, width, height, format, type, image);
}

typedef void (APIENTRY * PFN_GLCONVOLUTIONPARAMETERF)(GLenum target, GLenum pname, GLfloat params);
static PFN_GLCONVOLUTIONPARAMETERF _glConvolutionParameterf_ptr = NULL;

static inline void APIENTRY _glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params) {
    const char *_name = "glConvolutionParameterf";
    if (!_glConvolutionParameterf_ptr) {
        _glConvolutionParameterf_ptr = (PFN_GLCONVOLUTIONPARAMETERF)_getPrivateProcAddress(_name);
        if (!_glConvolutionParameterf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glConvolutionParameterf_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCONVOLUTIONPARAMETERFV)(GLenum target, GLenum pname, const GLfloat * params);
static PFN_GLCONVOLUTIONPARAMETERFV _glConvolutionParameterfv_ptr = NULL;

static inline void APIENTRY _glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glConvolutionParameterfv";
    if (!_glConvolutionParameterfv_ptr) {
        _glConvolutionParameterfv_ptr = (PFN_GLCONVOLUTIONPARAMETERFV)_getPrivateProcAddress(_name);
        if (!_glConvolutionParameterfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glConvolutionParameterfv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCONVOLUTIONPARAMETERI)(GLenum target, GLenum pname, GLint params);
static PFN_GLCONVOLUTIONPARAMETERI _glConvolutionParameteri_ptr = NULL;

static inline void APIENTRY _glConvolutionParameteri(GLenum target, GLenum pname, GLint params) {
    const char *_name = "glConvolutionParameteri";
    if (!_glConvolutionParameteri_ptr) {
        _glConvolutionParameteri_ptr = (PFN_GLCONVOLUTIONPARAMETERI)_getPrivateProcAddress(_name);
        if (!_glConvolutionParameteri_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glConvolutionParameteri_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCONVOLUTIONPARAMETERIV)(GLenum target, GLenum pname, const GLint * params);
static PFN_GLCONVOLUTIONPARAMETERIV _glConvolutionParameteriv_ptr = NULL;

static inline void APIENTRY _glConvolutionParameteriv(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glConvolutionParameteriv";
    if (!_glConvolutionParameteriv_ptr) {
        _glConvolutionParameteriv_ptr = (PFN_GLCONVOLUTIONPARAMETERIV)_getPrivateProcAddress(_name);
        if (!_glConvolutionParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glConvolutionParameteriv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCOPYCONVOLUTIONFILTER1D)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
static PFN_GLCOPYCONVOLUTIONFILTER1D _glCopyConvolutionFilter1D_ptr = NULL;

static inline void APIENTRY _glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyConvolutionFilter1D";
    if (!_glCopyConvolutionFilter1D_ptr) {
        _glCopyConvolutionFilter1D_ptr = (PFN_GLCOPYCONVOLUTIONFILTER1D)_getPrivateProcAddress(_name);
        if (!_glCopyConvolutionFilter1D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyConvolutionFilter1D_ptr(target, internalformat, x, y, width);
}

typedef void (APIENTRY * PFN_GLCOPYCONVOLUTIONFILTER2D)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLCOPYCONVOLUTIONFILTER2D _glCopyConvolutionFilter2D_ptr = NULL;

static inline void APIENTRY _glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyConvolutionFilter2D";
    if (!_glCopyConvolutionFilter2D_ptr) {
        _glCopyConvolutionFilter2D_ptr = (PFN_GLCOPYCONVOLUTIONFILTER2D)_getPrivateProcAddress(_name);
        if (!_glCopyConvolutionFilter2D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyConvolutionFilter2D_ptr(target, internalformat, x, y, width, height);
}

typedef void (APIENTRY * PFN_GLGETCONVOLUTIONFILTER)(GLenum target, GLenum format, GLenum type, GLvoid * image);
static PFN_GLGETCONVOLUTIONFILTER _glGetConvolutionFilter_ptr = NULL;

static inline void APIENTRY _glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid * image) {
    const char *_name = "glGetConvolutionFilter";
    if (!_glGetConvolutionFilter_ptr) {
        _glGetConvolutionFilter_ptr = (PFN_GLGETCONVOLUTIONFILTER)_getPrivateProcAddress(_name);
        if (!_glGetConvolutionFilter_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetConvolutionFilter_ptr(target, format, type, image);
}

typedef void (APIENTRY * PFN_GLGETCONVOLUTIONPARAMETERFV)(GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETCONVOLUTIONPARAMETERFV _glGetConvolutionParameterfv_ptr = NULL;

static inline void APIENTRY _glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetConvolutionParameterfv";
    if (!_glGetConvolutionParameterfv_ptr) {
        _glGetConvolutionParameterfv_ptr = (PFN_GLGETCONVOLUTIONPARAMETERFV)_getPrivateProcAddress(_name);
        if (!_glGetConvolutionParameterfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetConvolutionParameterfv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETCONVOLUTIONPARAMETERIV)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETCONVOLUTIONPARAMETERIV _glGetConvolutionParameteriv_ptr = NULL;

static inline void APIENTRY _glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetConvolutionParameteriv";
    if (!_glGetConvolutionParameteriv_ptr) {
        _glGetConvolutionParameteriv_ptr = (PFN_GLGETCONVOLUTIONPARAMETERIV)_getPrivateProcAddress(_name);
        if (!_glGetConvolutionParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetConvolutionParameteriv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETSEPARABLEFILTER)(GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span);
static PFN_GLGETSEPARABLEFILTER _glGetSeparableFilter_ptr = NULL;

static inline void APIENTRY _glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span) {
    const char *_name = "glGetSeparableFilter";
    if (!_glGetSeparableFilter_ptr) {
        _glGetSeparableFilter_ptr = (PFN_GLGETSEPARABLEFILTER)_getPrivateProcAddress(_name);
        if (!_glGetSeparableFilter_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetSeparableFilter_ptr(target, format, type, row, column, span);
}

typedef void (APIENTRY * PFN_GLSEPARABLEFILTER2D)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column);
static PFN_GLSEPARABLEFILTER2D _glSeparableFilter2D_ptr = NULL;

static inline void APIENTRY _glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column) {
    const char *_name = "glSeparableFilter2D";
    if (!_glSeparableFilter2D_ptr) {
        _glSeparableFilter2D_ptr = (PFN_GLSEPARABLEFILTER2D)_getPrivateProcAddress(_name);
        if (!_glSeparableFilter2D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSeparableFilter2D_ptr(target, internalformat, width, height, format, type, row, column);
}

typedef void (APIENTRY * PFN_GLGETHISTOGRAM)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values);
static PFN_GLGETHISTOGRAM _glGetHistogram_ptr = NULL;

static inline void APIENTRY _glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values) {
    const char *_name = "glGetHistogram";
    if (!_glGetHistogram_ptr) {
        _glGetHistogram_ptr = (PFN_GLGETHISTOGRAM)_getPrivateProcAddress(_name);
        if (!_glGetHistogram_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetHistogram_ptr(target, reset, format, type, values);
}

typedef void (APIENTRY * PFN_GLGETHISTOGRAMPARAMETERFV)(GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETHISTOGRAMPARAMETERFV _glGetHistogramParameterfv_ptr = NULL;

static inline void APIENTRY _glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetHistogramParameterfv";
    if (!_glGetHistogramParameterfv_ptr) {
        _glGetHistogramParameterfv_ptr = (PFN_GLGETHISTOGRAMPARAMETERFV)_getPrivateProcAddress(_name);
        if (!_glGetHistogramParameterfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetHistogramParameterfv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETHISTOGRAMPARAMETERIV)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETHISTOGRAMPARAMETERIV _glGetHistogramParameteriv_ptr = NULL;

static inline void APIENTRY _glGetHistogramParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetHistogramParameteriv";
    if (!_glGetHistogramParameteriv_ptr) {
        _glGetHistogramParameteriv_ptr = (PFN_GLGETHISTOGRAMPARAMETERIV)_getPrivateProcAddress(_name);
        if (!_glGetHistogramParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetHistogramParameteriv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMINMAX)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values);
static PFN_GLGETMINMAX _glGetMinmax_ptr = NULL;

static inline void APIENTRY _glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values) {
    const char *_name = "glGetMinmax";
    if (!_glGetMinmax_ptr) {
        _glGetMinmax_ptr = (PFN_GLGETMINMAX)_getPrivateProcAddress(_name);
        if (!_glGetMinmax_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMinmax_ptr(target, reset, format, type, values);
}

typedef void (APIENTRY * PFN_GLGETMINMAXPARAMETERFV)(GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETMINMAXPARAMETERFV _glGetMinmaxParameterfv_ptr = NULL;

static inline void APIENTRY _glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMinmaxParameterfv";
    if (!_glGetMinmaxParameterfv_ptr) {
        _glGetMinmaxParameterfv_ptr = (PFN_GLGETMINMAXPARAMETERFV)_getPrivateProcAddress(_name);
        if (!_glGetMinmaxParameterfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMinmaxParameterfv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMINMAXPARAMETERIV)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETMINMAXPARAMETERIV _glGetMinmaxParameteriv_ptr = NULL;

static inline void APIENTRY _glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetMinmaxParameteriv";
    if (!_glGetMinmaxParameteriv_ptr) {
        _glGetMinmaxParameteriv_ptr = (PFN_GLGETMINMAXPARAMETERIV)_getPrivateProcAddress(_name);
        if (!_glGetMinmaxParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMinmaxParameteriv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLHISTOGRAM)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
static PFN_GLHISTOGRAM _glHistogram_ptr = NULL;

static inline void APIENTRY _glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {
    const char *_name = "glHistogram";
    if (!_glHistogram_ptr) {
        _glHistogram_ptr = (PFN_GLHISTOGRAM)_getPrivateProcAddress(_name);
        if (!_glHistogram_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glHistogram_ptr(target, width, internalformat, sink);
}

typedef void (APIENTRY * PFN_GLMINMAX)(GLenum target, GLenum internalformat, GLboolean sink);
static PFN_GLMINMAX _glMinmax_ptr = NULL;

static inline void APIENTRY _glMinmax(GLenum target, GLenum internalformat, GLboolean sink) {
    const char *_name = "glMinmax";
    if (!_glMinmax_ptr) {
        _glMinmax_ptr = (PFN_GLMINMAX)_getPrivateProcAddress(_name);
        if (!_glMinmax_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMinmax_ptr(target, internalformat, sink);
}

typedef void (APIENTRY * PFN_GLRESETHISTOGRAM)(GLenum target);
static PFN_GLRESETHISTOGRAM _glResetHistogram_ptr = NULL;

static inline void APIENTRY _glResetHistogram(GLenum target) {
    const char *_name = "glResetHistogram";
    if (!_glResetHistogram_ptr) {
        _glResetHistogram_ptr = (PFN_GLRESETHISTOGRAM)_getPrivateProcAddress(_name);
        if (!_glResetHistogram_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glResetHistogram_ptr(target);
}

typedef void (APIENTRY * PFN_GLRESETMINMAX)(GLenum target);
static PFN_GLRESETMINMAX _glResetMinmax_ptr = NULL;

static inline void APIENTRY _glResetMinmax(GLenum target) {
    const char *_name = "glResetMinmax";
    if (!_glResetMinmax_ptr) {
        _glResetMinmax_ptr = (PFN_GLRESETMINMAX)_getPrivateProcAddress(_name);
        if (!_glResetMinmax_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glResetMinmax_ptr(target);
}

typedef void (APIENTRY * PFN_GLACTIVETEXTURE)(GLenum texture);
static PFN_GLACTIVETEXTURE _glActiveTexture_ptr = NULL;

static inline void APIENTRY _glActiveTexture(GLenum texture) {
    const char *_name = "glActiveTexture";
    if (!_glActiveTexture_ptr) {
        _glActiveTexture_ptr = (PFN_GLACTIVETEXTURE)_getPrivateProcAddress(_name);
        if (!_glActiveTexture_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glActiveTexture_ptr(texture);
}

typedef void (APIENTRY * PFN_GLSAMPLECOVERAGE)(GLfloat value, GLboolean invert);
static PFN_GLSAMPLECOVERAGE _glSampleCoverage_ptr = NULL;

static inline void APIENTRY _glSampleCoverage(GLfloat value, GLboolean invert) {
    const char *_name = "glSampleCoverage";
    if (!_glSampleCoverage_ptr) {
        _glSampleCoverage_ptr = (PFN_GLSAMPLECOVERAGE)_getPrivateProcAddress(_name);
        if (!_glSampleCoverage_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSampleCoverage_ptr(value, invert);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXIMAGE3D)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXIMAGE3D _glCompressedTexImage3D_ptr = NULL;

static inline void APIENTRY _glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage3D";
    if (!_glCompressedTexImage3D_ptr) {
        _glCompressedTexImage3D_ptr = (PFN_GLCOMPRESSEDTEXIMAGE3D)_getPrivateProcAddress(_name);
        if (!_glCompressedTexImage3D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexImage3D_ptr(target, level, internalformat, width, height, depth, border, imageSize, data);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXIMAGE2D)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXIMAGE2D _glCompressedTexImage2D_ptr = NULL;

static inline void APIENTRY _glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage2D";
    if (!_glCompressedTexImage2D_ptr) {
        _glCompressedTexImage2D_ptr = (PFN_GLCOMPRESSEDTEXIMAGE2D)_getPrivateProcAddress(_name);
        if (!_glCompressedTexImage2D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexImage2D_ptr(target, level, internalformat, width, height, border, imageSize, data);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXIMAGE1D)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXIMAGE1D _glCompressedTexImage1D_ptr = NULL;

static inline void APIENTRY _glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage1D";
    if (!_glCompressedTexImage1D_ptr) {
        _glCompressedTexImage1D_ptr = (PFN_GLCOMPRESSEDTEXIMAGE1D)_getPrivateProcAddress(_name);
        if (!_glCompressedTexImage1D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexImage1D_ptr(target, level, internalformat, width, border, imageSize, data);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXSUBIMAGE3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXSUBIMAGE3D _glCompressedTexSubImage3D_ptr = NULL;

static inline void APIENTRY _glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage3D";
    if (!_glCompressedTexSubImage3D_ptr) {
        _glCompressedTexSubImage3D_ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE3D)_getPrivateProcAddress(_name);
        if (!_glCompressedTexSubImage3D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexSubImage3D_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXSUBIMAGE2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXSUBIMAGE2D _glCompressedTexSubImage2D_ptr = NULL;

static inline void APIENTRY _glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage2D";
    if (!_glCompressedTexSubImage2D_ptr) {
        _glCompressedTexSubImage2D_ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE2D)_getPrivateProcAddress(_name);
        if (!_glCompressedTexSubImage2D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexSubImage2D_ptr(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXSUBIMAGE1D)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXSUBIMAGE1D _glCompressedTexSubImage1D_ptr = NULL;

static inline void APIENTRY _glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage1D";
    if (!_glCompressedTexSubImage1D_ptr) {
        _glCompressedTexSubImage1D_ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE1D)_getPrivateProcAddress(_name);
        if (!_glCompressedTexSubImage1D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexSubImage1D_ptr(target, level, xoffset, width, format, imageSize, data);
}

typedef void (APIENTRY * PFN_GLGETCOMPRESSEDTEXIMAGE)(GLenum target, GLint level, GLvoid * img);
static PFN_GLGETCOMPRESSEDTEXIMAGE _glGetCompressedTexImage_ptr = NULL;

static inline void APIENTRY _glGetCompressedTexImage(GLenum target, GLint level, GLvoid * img) {
    const char *_name = "glGetCompressedTexImage";
    if (!_glGetCompressedTexImage_ptr) {
        _glGetCompressedTexImage_ptr = (PFN_GLGETCOMPRESSEDTEXIMAGE)_getPrivateProcAddress(_name);
        if (!_glGetCompressedTexImage_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetCompressedTexImage_ptr(target, level, img);
}

typedef void (APIENTRY * PFN_GLCLIENTACTIVETEXTURE)(GLenum texture);
static PFN_GLCLIENTACTIVETEXTURE _glClientActiveTexture_ptr = NULL;

static inline void APIENTRY _glClientActiveTexture(GLenum texture) {
    const char *_name = "glClientActiveTexture";
    if (!_glClientActiveTexture_ptr) {
        _glClientActiveTexture_ptr = (PFN_GLCLIENTACTIVETEXTURE)_getPrivateProcAddress(_name);
        if (!_glClientActiveTexture_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClientActiveTexture_ptr(texture);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1D)(GLenum target, GLdouble s);
static PFN_GLMULTITEXCOORD1D _glMultiTexCoord1d_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1d(GLenum target, GLdouble s) {
    const char *_name = "glMultiTexCoord1d";
    if (!_glMultiTexCoord1d_ptr) {
        _glMultiTexCoord1d_ptr = (PFN_GLMULTITEXCOORD1D)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1d_ptr(target, s);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1DV)(GLenum target, const GLdouble * v);
static PFN_GLMULTITEXCOORD1DV _glMultiTexCoord1dv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1dv(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord1dv";
    if (!_glMultiTexCoord1dv_ptr) {
        _glMultiTexCoord1dv_ptr = (PFN_GLMULTITEXCOORD1DV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1dv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1F)(GLenum target, GLfloat s);
static PFN_GLMULTITEXCOORD1F _glMultiTexCoord1f_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1f(GLenum target, GLfloat s) {
    const char *_name = "glMultiTexCoord1f";
    if (!_glMultiTexCoord1f_ptr) {
        _glMultiTexCoord1f_ptr = (PFN_GLMULTITEXCOORD1F)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1f_ptr(target, s);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1FV)(GLenum target, const GLfloat * v);
static PFN_GLMULTITEXCOORD1FV _glMultiTexCoord1fv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1fv(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord1fv";
    if (!_glMultiTexCoord1fv_ptr) {
        _glMultiTexCoord1fv_ptr = (PFN_GLMULTITEXCOORD1FV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1fv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1I)(GLenum target, GLint s);
static PFN_GLMULTITEXCOORD1I _glMultiTexCoord1i_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1i(GLenum target, GLint s) {
    const char *_name = "glMultiTexCoord1i";
    if (!_glMultiTexCoord1i_ptr) {
        _glMultiTexCoord1i_ptr = (PFN_GLMULTITEXCOORD1I)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1i_ptr(target, s);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1IV)(GLenum target, const GLint * v);
static PFN_GLMULTITEXCOORD1IV _glMultiTexCoord1iv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1iv(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord1iv";
    if (!_glMultiTexCoord1iv_ptr) {
        _glMultiTexCoord1iv_ptr = (PFN_GLMULTITEXCOORD1IV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1iv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1S)(GLenum target, GLshort s);
static PFN_GLMULTITEXCOORD1S _glMultiTexCoord1s_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1s(GLenum target, GLshort s) {
    const char *_name = "glMultiTexCoord1s";
    if (!_glMultiTexCoord1s_ptr) {
        _glMultiTexCoord1s_ptr = (PFN_GLMULTITEXCOORD1S)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1s_ptr(target, s);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1SV)(GLenum target, const GLshort * v);
static PFN_GLMULTITEXCOORD1SV _glMultiTexCoord1sv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1sv(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord1sv";
    if (!_glMultiTexCoord1sv_ptr) {
        _glMultiTexCoord1sv_ptr = (PFN_GLMULTITEXCOORD1SV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1sv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2D)(GLenum target, GLdouble s, GLdouble t);
static PFN_GLMULTITEXCOORD2D _glMultiTexCoord2d_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t) {
    const char *_name = "glMultiTexCoord2d";
    if (!_glMultiTexCoord2d_ptr) {
        _glMultiTexCoord2d_ptr = (PFN_GLMULTITEXCOORD2D)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2d_ptr(target, s, t);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2DV)(GLenum target, const GLdouble * v);
static PFN_GLMULTITEXCOORD2DV _glMultiTexCoord2dv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2dv(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord2dv";
    if (!_glMultiTexCoord2dv_ptr) {
        _glMultiTexCoord2dv_ptr = (PFN_GLMULTITEXCOORD2DV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2dv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2F)(GLenum target, GLfloat s, GLfloat t);
static PFN_GLMULTITEXCOORD2F _glMultiTexCoord2f_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t) {
    const char *_name = "glMultiTexCoord2f";
    if (!_glMultiTexCoord2f_ptr) {
        _glMultiTexCoord2f_ptr = (PFN_GLMULTITEXCOORD2F)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2f_ptr(target, s, t);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2FV)(GLenum target, const GLfloat * v);
static PFN_GLMULTITEXCOORD2FV _glMultiTexCoord2fv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2fv(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord2fv";
    if (!_glMultiTexCoord2fv_ptr) {
        _glMultiTexCoord2fv_ptr = (PFN_GLMULTITEXCOORD2FV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2fv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2I)(GLenum target, GLint s, GLint t);
static PFN_GLMULTITEXCOORD2I _glMultiTexCoord2i_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2i(GLenum target, GLint s, GLint t) {
    const char *_name = "glMultiTexCoord2i";
    if (!_glMultiTexCoord2i_ptr) {
        _glMultiTexCoord2i_ptr = (PFN_GLMULTITEXCOORD2I)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2i_ptr(target, s, t);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2IV)(GLenum target, const GLint * v);
static PFN_GLMULTITEXCOORD2IV _glMultiTexCoord2iv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2iv(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord2iv";
    if (!_glMultiTexCoord2iv_ptr) {
        _glMultiTexCoord2iv_ptr = (PFN_GLMULTITEXCOORD2IV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2iv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2S)(GLenum target, GLshort s, GLshort t);
static PFN_GLMULTITEXCOORD2S _glMultiTexCoord2s_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2s(GLenum target, GLshort s, GLshort t) {
    const char *_name = "glMultiTexCoord2s";
    if (!_glMultiTexCoord2s_ptr) {
        _glMultiTexCoord2s_ptr = (PFN_GLMULTITEXCOORD2S)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2s_ptr(target, s, t);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2SV)(GLenum target, const GLshort * v);
static PFN_GLMULTITEXCOORD2SV _glMultiTexCoord2sv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2sv(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord2sv";
    if (!_glMultiTexCoord2sv_ptr) {
        _glMultiTexCoord2sv_ptr = (PFN_GLMULTITEXCOORD2SV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2sv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3D)(GLenum target, GLdouble s, GLdouble t, GLdouble r);
static PFN_GLMULTITEXCOORD3D _glMultiTexCoord3d_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r) {
    const char *_name = "glMultiTexCoord3d";
    if (!_glMultiTexCoord3d_ptr) {
        _glMultiTexCoord3d_ptr = (PFN_GLMULTITEXCOORD3D)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3d_ptr(target, s, t, r);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3DV)(GLenum target, const GLdouble * v);
static PFN_GLMULTITEXCOORD3DV _glMultiTexCoord3dv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3dv(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord3dv";
    if (!_glMultiTexCoord3dv_ptr) {
        _glMultiTexCoord3dv_ptr = (PFN_GLMULTITEXCOORD3DV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3dv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3F)(GLenum target, GLfloat s, GLfloat t, GLfloat r);
static PFN_GLMULTITEXCOORD3F _glMultiTexCoord3f_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r) {
    const char *_name = "glMultiTexCoord3f";
    if (!_glMultiTexCoord3f_ptr) {
        _glMultiTexCoord3f_ptr = (PFN_GLMULTITEXCOORD3F)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3f_ptr(target, s, t, r);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3FV)(GLenum target, const GLfloat * v);
static PFN_GLMULTITEXCOORD3FV _glMultiTexCoord3fv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3fv(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord3fv";
    if (!_glMultiTexCoord3fv_ptr) {
        _glMultiTexCoord3fv_ptr = (PFN_GLMULTITEXCOORD3FV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3fv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3I)(GLenum target, GLint s, GLint t, GLint r);
static PFN_GLMULTITEXCOORD3I _glMultiTexCoord3i_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r) {
    const char *_name = "glMultiTexCoord3i";
    if (!_glMultiTexCoord3i_ptr) {
        _glMultiTexCoord3i_ptr = (PFN_GLMULTITEXCOORD3I)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3i_ptr(target, s, t, r);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3IV)(GLenum target, const GLint * v);
static PFN_GLMULTITEXCOORD3IV _glMultiTexCoord3iv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3iv(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord3iv";
    if (!_glMultiTexCoord3iv_ptr) {
        _glMultiTexCoord3iv_ptr = (PFN_GLMULTITEXCOORD3IV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3iv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3S)(GLenum target, GLshort s, GLshort t, GLshort r);
static PFN_GLMULTITEXCOORD3S _glMultiTexCoord3s_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r) {
    const char *_name = "glMultiTexCoord3s";
    if (!_glMultiTexCoord3s_ptr) {
        _glMultiTexCoord3s_ptr = (PFN_GLMULTITEXCOORD3S)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3s_ptr(target, s, t, r);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3SV)(GLenum target, const GLshort * v);
static PFN_GLMULTITEXCOORD3SV _glMultiTexCoord3sv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3sv(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord3sv";
    if (!_glMultiTexCoord3sv_ptr) {
        _glMultiTexCoord3sv_ptr = (PFN_GLMULTITEXCOORD3SV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3sv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4D)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
static PFN_GLMULTITEXCOORD4D _glMultiTexCoord4d_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    const char *_name = "glMultiTexCoord4d";
    if (!_glMultiTexCoord4d_ptr) {
        _glMultiTexCoord4d_ptr = (PFN_GLMULTITEXCOORD4D)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4d_ptr(target, s, t, r, q);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4DV)(GLenum target, const GLdouble * v);
static PFN_GLMULTITEXCOORD4DV _glMultiTexCoord4dv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4dv(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord4dv";
    if (!_glMultiTexCoord4dv_ptr) {
        _glMultiTexCoord4dv_ptr = (PFN_GLMULTITEXCOORD4DV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4dv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4F)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
static PFN_GLMULTITEXCOORD4F _glMultiTexCoord4f_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    const char *_name = "glMultiTexCoord4f";
    if (!_glMultiTexCoord4f_ptr) {
        _glMultiTexCoord4f_ptr = (PFN_GLMULTITEXCOORD4F)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4f_ptr(target, s, t, r, q);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4FV)(GLenum target, const GLfloat * v);
static PFN_GLMULTITEXCOORD4FV _glMultiTexCoord4fv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4fv(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord4fv";
    if (!_glMultiTexCoord4fv_ptr) {
        _glMultiTexCoord4fv_ptr = (PFN_GLMULTITEXCOORD4FV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4fv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4I)(GLenum target, GLint s, GLint t, GLint r, GLint q);
static PFN_GLMULTITEXCOORD4I _glMultiTexCoord4i_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q) {
    const char *_name = "glMultiTexCoord4i";
    if (!_glMultiTexCoord4i_ptr) {
        _glMultiTexCoord4i_ptr = (PFN_GLMULTITEXCOORD4I)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4i_ptr(target, s, t, r, q);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4IV)(GLenum target, const GLint * v);
static PFN_GLMULTITEXCOORD4IV _glMultiTexCoord4iv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4iv(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord4iv";
    if (!_glMultiTexCoord4iv_ptr) {
        _glMultiTexCoord4iv_ptr = (PFN_GLMULTITEXCOORD4IV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4iv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4S)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
static PFN_GLMULTITEXCOORD4S _glMultiTexCoord4s_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) {
    const char *_name = "glMultiTexCoord4s";
    if (!_glMultiTexCoord4s_ptr) {
        _glMultiTexCoord4s_ptr = (PFN_GLMULTITEXCOORD4S)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4s_ptr(target, s, t, r, q);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4SV)(GLenum target, const GLshort * v);
static PFN_GLMULTITEXCOORD4SV _glMultiTexCoord4sv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4sv(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord4sv";
    if (!_glMultiTexCoord4sv_ptr) {
        _glMultiTexCoord4sv_ptr = (PFN_GLMULTITEXCOORD4SV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4sv_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLLOADTRANSPOSEMATRIXF)(const GLfloat * m);
static PFN_GLLOADTRANSPOSEMATRIXF _glLoadTransposeMatrixf_ptr = NULL;

static inline void APIENTRY _glLoadTransposeMatrixf(const GLfloat * m) {
    const char *_name = "glLoadTransposeMatrixf";
    if (!_glLoadTransposeMatrixf_ptr) {
        _glLoadTransposeMatrixf_ptr = (PFN_GLLOADTRANSPOSEMATRIXF)_getPrivateProcAddress(_name);
        if (!_glLoadTransposeMatrixf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLoadTransposeMatrixf_ptr(m);
}

typedef void (APIENTRY * PFN_GLLOADTRANSPOSEMATRIXD)(const GLdouble * m);
static PFN_GLLOADTRANSPOSEMATRIXD _glLoadTransposeMatrixd_ptr = NULL;

static inline void APIENTRY _glLoadTransposeMatrixd(const GLdouble * m) {
    const char *_name = "glLoadTransposeMatrixd";
    if (!_glLoadTransposeMatrixd_ptr) {
        _glLoadTransposeMatrixd_ptr = (PFN_GLLOADTRANSPOSEMATRIXD)_getPrivateProcAddress(_name);
        if (!_glLoadTransposeMatrixd_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLoadTransposeMatrixd_ptr(m);
}

typedef void (APIENTRY * PFN_GLMULTTRANSPOSEMATRIXF)(const GLfloat * m);
static PFN_GLMULTTRANSPOSEMATRIXF _glMultTransposeMatrixf_ptr = NULL;

static inline void APIENTRY _glMultTransposeMatrixf(const GLfloat * m) {
    const char *_name = "glMultTransposeMatrixf";
    if (!_glMultTransposeMatrixf_ptr) {
        _glMultTransposeMatrixf_ptr = (PFN_GLMULTTRANSPOSEMATRIXF)_getPrivateProcAddress(_name);
        if (!_glMultTransposeMatrixf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultTransposeMatrixf_ptr(m);
}

typedef void (APIENTRY * PFN_GLMULTTRANSPOSEMATRIXD)(const GLdouble * m);
static PFN_GLMULTTRANSPOSEMATRIXD _glMultTransposeMatrixd_ptr = NULL;

static inline void APIENTRY _glMultTransposeMatrixd(const GLdouble * m) {
    const char *_name = "glMultTransposeMatrixd";
    if (!_glMultTransposeMatrixd_ptr) {
        _glMultTransposeMatrixd_ptr = (PFN_GLMULTTRANSPOSEMATRIXD)_getPrivateProcAddress(_name);
        if (!_glMultTransposeMatrixd_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultTransposeMatrixd_ptr(m);
}

typedef void (APIENTRY * PFN_GLBLENDFUNCSEPARATE)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
static PFN_GLBLENDFUNCSEPARATE _glBlendFuncSeparate_ptr = NULL;

static inline void APIENTRY _glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
    const char *_name = "glBlendFuncSeparate";
    if (!_glBlendFuncSeparate_ptr) {
        _glBlendFuncSeparate_ptr = (PFN_GLBLENDFUNCSEPARATE)_getPrivateProcAddress(_name);
        if (!_glBlendFuncSeparate_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendFuncSeparate_ptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

typedef void (APIENTRY * PFN_GLMULTIDRAWARRAYS)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount);
static PFN_GLMULTIDRAWARRAYS _glMultiDrawArrays_ptr = NULL;

static inline void APIENTRY _glMultiDrawArrays(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount) {
    const char *_name = "glMultiDrawArrays";
    if (!_glMultiDrawArrays_ptr) {
        _glMultiDrawArrays_ptr = (PFN_GLMULTIDRAWARRAYS)_getPrivateProcAddress(_name);
        if (!_glMultiDrawArrays_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiDrawArrays_ptr(mode, first, count, drawcount);
}

typedef void (APIENTRY * PFN_GLMULTIDRAWELEMENTS)(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei drawcount);
static PFN_GLMULTIDRAWELEMENTS _glMultiDrawElements_ptr = NULL;

static inline void APIENTRY _glMultiDrawElements(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei drawcount) {
    const char *_name = "glMultiDrawElements";
    if (!_glMultiDrawElements_ptr) {
        _glMultiDrawElements_ptr = (PFN_GLMULTIDRAWELEMENTS)_getPrivateProcAddress(_name);
        if (!_glMultiDrawElements_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiDrawElements_ptr(mode, count, type, indices, drawcount);
}

typedef void (APIENTRY * PFN_GLPOINTPARAMETERF)(GLenum pname, GLfloat param);
static PFN_GLPOINTPARAMETERF _glPointParameterf_ptr = NULL;

static inline void APIENTRY _glPointParameterf(GLenum pname, GLfloat param) {
    const char *_name = "glPointParameterf";
    if (!_glPointParameterf_ptr) {
        _glPointParameterf_ptr = (PFN_GLPOINTPARAMETERF)_getPrivateProcAddress(_name);
        if (!_glPointParameterf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameterf_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLPOINTPARAMETERFV)(GLenum pname, const GLfloat * params);
static PFN_GLPOINTPARAMETERFV _glPointParameterfv_ptr = NULL;

static inline void APIENTRY _glPointParameterfv(GLenum pname, const GLfloat * params) {
    const char *_name = "glPointParameterfv";
    if (!_glPointParameterfv_ptr) {
        _glPointParameterfv_ptr = (PFN_GLPOINTPARAMETERFV)_getPrivateProcAddress(_name);
        if (!_glPointParameterfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameterfv_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLPOINTPARAMETERI)(GLenum pname, GLint param);
static PFN_GLPOINTPARAMETERI _glPointParameteri_ptr = NULL;

static inline void APIENTRY _glPointParameteri(GLenum pname, GLint param) {
    const char *_name = "glPointParameteri";
    if (!_glPointParameteri_ptr) {
        _glPointParameteri_ptr = (PFN_GLPOINTPARAMETERI)_getPrivateProcAddress(_name);
        if (!_glPointParameteri_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameteri_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLPOINTPARAMETERIV)(GLenum pname, const GLint * params);
static PFN_GLPOINTPARAMETERIV _glPointParameteriv_ptr = NULL;

static inline void APIENTRY _glPointParameteriv(GLenum pname, const GLint * params) {
    const char *_name = "glPointParameteriv";
    if (!_glPointParameteriv_ptr) {
        _glPointParameteriv_ptr = (PFN_GLPOINTPARAMETERIV)_getPrivateProcAddress(_name);
        if (!_glPointParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameteriv_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLFOGCOORDF)(GLfloat coord);
static PFN_GLFOGCOORDF _glFogCoordf_ptr = NULL;

static inline void APIENTRY _glFogCoordf(GLfloat coord) {
    const char *_name = "glFogCoordf";
    if (!_glFogCoordf_ptr) {
        _glFogCoordf_ptr = (PFN_GLFOGCOORDF)_getPrivateProcAddress(_name);
        if (!_glFogCoordf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoordf_ptr(coord);
}

typedef void (APIENTRY * PFN_GLFOGCOORDFV)(const GLfloat * coord);
static PFN_GLFOGCOORDFV _glFogCoordfv_ptr = NULL;

static inline void APIENTRY _glFogCoordfv(const GLfloat * coord) {
    const char *_name = "glFogCoordfv";
    if (!_glFogCoordfv_ptr) {
        _glFogCoordfv_ptr = (PFN_GLFOGCOORDFV)_getPrivateProcAddress(_name);
        if (!_glFogCoordfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoordfv_ptr(coord);
}

typedef void (APIENTRY * PFN_GLFOGCOORDD)(GLdouble coord);
static PFN_GLFOGCOORDD _glFogCoordd_ptr = NULL;

static inline void APIENTRY _glFogCoordd(GLdouble coord) {
    const char *_name = "glFogCoordd";
    if (!_glFogCoordd_ptr) {
        _glFogCoordd_ptr = (PFN_GLFOGCOORDD)_getPrivateProcAddress(_name);
        if (!_glFogCoordd_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoordd_ptr(coord);
}

typedef void (APIENTRY * PFN_GLFOGCOORDDV)(const GLdouble * coord);
static PFN_GLFOGCOORDDV _glFogCoorddv_ptr = NULL;

static inline void APIENTRY _glFogCoorddv(const GLdouble * coord) {
    const char *_name = "glFogCoorddv";
    if (!_glFogCoorddv_ptr) {
        _glFogCoorddv_ptr = (PFN_GLFOGCOORDDV)_getPrivateProcAddress(_name);
        if (!_glFogCoorddv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoorddv_ptr(coord);
}

typedef void (APIENTRY * PFN_GLFOGCOORDPOINTER)(GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLFOGCOORDPOINTER _glFogCoordPointer_ptr = NULL;

static inline void APIENTRY _glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glFogCoordPointer";
    if (!_glFogCoordPointer_ptr) {
        _glFogCoordPointer_ptr = (PFN_GLFOGCOORDPOINTER)_getPrivateProcAddress(_name);
        if (!_glFogCoordPointer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoordPointer_ptr(type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3B)(GLbyte red, GLbyte green, GLbyte blue);
static PFN_GLSECONDARYCOLOR3B _glSecondaryColor3b_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue) {
    const char *_name = "glSecondaryColor3b";
    if (!_glSecondaryColor3b_ptr) {
        _glSecondaryColor3b_ptr = (PFN_GLSECONDARYCOLOR3B)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3b_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3b_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3BV)(const GLbyte * v);
static PFN_GLSECONDARYCOLOR3BV _glSecondaryColor3bv_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3bv(const GLbyte * v) {
    const char *_name = "glSecondaryColor3bv";
    if (!_glSecondaryColor3bv_ptr) {
        _glSecondaryColor3bv_ptr = (PFN_GLSECONDARYCOLOR3BV)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3bv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3bv_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3D)(GLdouble red, GLdouble green, GLdouble blue);
static PFN_GLSECONDARYCOLOR3D _glSecondaryColor3d_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue) {
    const char *_name = "glSecondaryColor3d";
    if (!_glSecondaryColor3d_ptr) {
        _glSecondaryColor3d_ptr = (PFN_GLSECONDARYCOLOR3D)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3d_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3DV)(const GLdouble * v);
static PFN_GLSECONDARYCOLOR3DV _glSecondaryColor3dv_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3dv(const GLdouble * v) {
    const char *_name = "glSecondaryColor3dv";
    if (!_glSecondaryColor3dv_ptr) {
        _glSecondaryColor3dv_ptr = (PFN_GLSECONDARYCOLOR3DV)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3F)(GLfloat red, GLfloat green, GLfloat blue);
static PFN_GLSECONDARYCOLOR3F _glSecondaryColor3f_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue) {
    const char *_name = "glSecondaryColor3f";
    if (!_glSecondaryColor3f_ptr) {
        _glSecondaryColor3f_ptr = (PFN_GLSECONDARYCOLOR3F)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3f_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3FV)(const GLfloat * v);
static PFN_GLSECONDARYCOLOR3FV _glSecondaryColor3fv_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3fv(const GLfloat * v) {
    const char *_name = "glSecondaryColor3fv";
    if (!_glSecondaryColor3fv_ptr) {
        _glSecondaryColor3fv_ptr = (PFN_GLSECONDARYCOLOR3FV)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3I)(GLint red, GLint green, GLint blue);
static PFN_GLSECONDARYCOLOR3I _glSecondaryColor3i_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3i(GLint red, GLint green, GLint blue) {
    const char *_name = "glSecondaryColor3i";
    if (!_glSecondaryColor3i_ptr) {
        _glSecondaryColor3i_ptr = (PFN_GLSECONDARYCOLOR3I)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3i_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3IV)(const GLint * v);
static PFN_GLSECONDARYCOLOR3IV _glSecondaryColor3iv_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3iv(const GLint * v) {
    const char *_name = "glSecondaryColor3iv";
    if (!_glSecondaryColor3iv_ptr) {
        _glSecondaryColor3iv_ptr = (PFN_GLSECONDARYCOLOR3IV)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3S)(GLshort red, GLshort green, GLshort blue);
static PFN_GLSECONDARYCOLOR3S _glSecondaryColor3s_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3s(GLshort red, GLshort green, GLshort blue) {
    const char *_name = "glSecondaryColor3s";
    if (!_glSecondaryColor3s_ptr) {
        _glSecondaryColor3s_ptr = (PFN_GLSECONDARYCOLOR3S)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3s_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3SV)(const GLshort * v);
static PFN_GLSECONDARYCOLOR3SV _glSecondaryColor3sv_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3sv(const GLshort * v) {
    const char *_name = "glSecondaryColor3sv";
    if (!_glSecondaryColor3sv_ptr) {
        _glSecondaryColor3sv_ptr = (PFN_GLSECONDARYCOLOR3SV)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3UB)(GLubyte red, GLubyte green, GLubyte blue);
static PFN_GLSECONDARYCOLOR3UB _glSecondaryColor3ub_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue) {
    const char *_name = "glSecondaryColor3ub";
    if (!_glSecondaryColor3ub_ptr) {
        _glSecondaryColor3ub_ptr = (PFN_GLSECONDARYCOLOR3UB)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3ub_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3ub_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3UBV)(const GLubyte * v);
static PFN_GLSECONDARYCOLOR3UBV _glSecondaryColor3ubv_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3ubv(const GLubyte * v) {
    const char *_name = "glSecondaryColor3ubv";
    if (!_glSecondaryColor3ubv_ptr) {
        _glSecondaryColor3ubv_ptr = (PFN_GLSECONDARYCOLOR3UBV)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3ubv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3ubv_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3UI)(GLuint red, GLuint green, GLuint blue);
static PFN_GLSECONDARYCOLOR3UI _glSecondaryColor3ui_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue) {
    const char *_name = "glSecondaryColor3ui";
    if (!_glSecondaryColor3ui_ptr) {
        _glSecondaryColor3ui_ptr = (PFN_GLSECONDARYCOLOR3UI)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3ui_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3UIV)(const GLuint * v);
static PFN_GLSECONDARYCOLOR3UIV _glSecondaryColor3uiv_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3uiv(const GLuint * v) {
    const char *_name = "glSecondaryColor3uiv";
    if (!_glSecondaryColor3uiv_ptr) {
        _glSecondaryColor3uiv_ptr = (PFN_GLSECONDARYCOLOR3UIV)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3uiv_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3US)(GLushort red, GLushort green, GLushort blue);
static PFN_GLSECONDARYCOLOR3US _glSecondaryColor3us_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3us(GLushort red, GLushort green, GLushort blue) {
    const char *_name = "glSecondaryColor3us";
    if (!_glSecondaryColor3us_ptr) {
        _glSecondaryColor3us_ptr = (PFN_GLSECONDARYCOLOR3US)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3us_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3us_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3USV)(const GLushort * v);
static PFN_GLSECONDARYCOLOR3USV _glSecondaryColor3usv_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3usv(const GLushort * v) {
    const char *_name = "glSecondaryColor3usv";
    if (!_glSecondaryColor3usv_ptr) {
        _glSecondaryColor3usv_ptr = (PFN_GLSECONDARYCOLOR3USV)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3usv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3usv_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLORPOINTER)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLSECONDARYCOLORPOINTER _glSecondaryColorPointer_ptr = NULL;

static inline void APIENTRY _glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glSecondaryColorPointer";
    if (!_glSecondaryColorPointer_ptr) {
        _glSecondaryColorPointer_ptr = (PFN_GLSECONDARYCOLORPOINTER)_getPrivateProcAddress(_name);
        if (!_glSecondaryColorPointer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColorPointer_ptr(size, type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2D)(GLdouble x, GLdouble y);
static PFN_GLWINDOWPOS2D _glWindowPos2d_ptr = NULL;

static inline void APIENTRY _glWindowPos2d(GLdouble x, GLdouble y) {
    const char *_name = "glWindowPos2d";
    if (!_glWindowPos2d_ptr) {
        _glWindowPos2d_ptr = (PFN_GLWINDOWPOS2D)_getPrivateProcAddress(_name);
        if (!_glWindowPos2d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2d_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2DV)(const GLdouble * v);
static PFN_GLWINDOWPOS2DV _glWindowPos2dv_ptr = NULL;

static inline void APIENTRY _glWindowPos2dv(const GLdouble * v) {
    const char *_name = "glWindowPos2dv";
    if (!_glWindowPos2dv_ptr) {
        _glWindowPos2dv_ptr = (PFN_GLWINDOWPOS2DV)_getPrivateProcAddress(_name);
        if (!_glWindowPos2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2F)(GLfloat x, GLfloat y);
static PFN_GLWINDOWPOS2F _glWindowPos2f_ptr = NULL;

static inline void APIENTRY _glWindowPos2f(GLfloat x, GLfloat y) {
    const char *_name = "glWindowPos2f";
    if (!_glWindowPos2f_ptr) {
        _glWindowPos2f_ptr = (PFN_GLWINDOWPOS2F)_getPrivateProcAddress(_name);
        if (!_glWindowPos2f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2f_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2FV)(const GLfloat * v);
static PFN_GLWINDOWPOS2FV _glWindowPos2fv_ptr = NULL;

static inline void APIENTRY _glWindowPos2fv(const GLfloat * v) {
    const char *_name = "glWindowPos2fv";
    if (!_glWindowPos2fv_ptr) {
        _glWindowPos2fv_ptr = (PFN_GLWINDOWPOS2FV)_getPrivateProcAddress(_name);
        if (!_glWindowPos2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2I)(GLint x, GLint y);
static PFN_GLWINDOWPOS2I _glWindowPos2i_ptr = NULL;

static inline void APIENTRY _glWindowPos2i(GLint x, GLint y) {
    const char *_name = "glWindowPos2i";
    if (!_glWindowPos2i_ptr) {
        _glWindowPos2i_ptr = (PFN_GLWINDOWPOS2I)_getPrivateProcAddress(_name);
        if (!_glWindowPos2i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2i_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2IV)(const GLint * v);
static PFN_GLWINDOWPOS2IV _glWindowPos2iv_ptr = NULL;

static inline void APIENTRY _glWindowPos2iv(const GLint * v) {
    const char *_name = "glWindowPos2iv";
    if (!_glWindowPos2iv_ptr) {
        _glWindowPos2iv_ptr = (PFN_GLWINDOWPOS2IV)_getPrivateProcAddress(_name);
        if (!_glWindowPos2iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2S)(GLshort x, GLshort y);
static PFN_GLWINDOWPOS2S _glWindowPos2s_ptr = NULL;

static inline void APIENTRY _glWindowPos2s(GLshort x, GLshort y) {
    const char *_name = "glWindowPos2s";
    if (!_glWindowPos2s_ptr) {
        _glWindowPos2s_ptr = (PFN_GLWINDOWPOS2S)_getPrivateProcAddress(_name);
        if (!_glWindowPos2s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2s_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2SV)(const GLshort * v);
static PFN_GLWINDOWPOS2SV _glWindowPos2sv_ptr = NULL;

static inline void APIENTRY _glWindowPos2sv(const GLshort * v) {
    const char *_name = "glWindowPos2sv";
    if (!_glWindowPos2sv_ptr) {
        _glWindowPos2sv_ptr = (PFN_GLWINDOWPOS2SV)_getPrivateProcAddress(_name);
        if (!_glWindowPos2sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3D)(GLdouble x, GLdouble y, GLdouble z);
static PFN_GLWINDOWPOS3D _glWindowPos3d_ptr = NULL;

static inline void APIENTRY _glWindowPos3d(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glWindowPos3d";
    if (!_glWindowPos3d_ptr) {
        _glWindowPos3d_ptr = (PFN_GLWINDOWPOS3D)_getPrivateProcAddress(_name);
        if (!_glWindowPos3d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3d_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3DV)(const GLdouble * v);
static PFN_GLWINDOWPOS3DV _glWindowPos3dv_ptr = NULL;

static inline void APIENTRY _glWindowPos3dv(const GLdouble * v) {
    const char *_name = "glWindowPos3dv";
    if (!_glWindowPos3dv_ptr) {
        _glWindowPos3dv_ptr = (PFN_GLWINDOWPOS3DV)_getPrivateProcAddress(_name);
        if (!_glWindowPos3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3dv_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3F)(GLfloat x, GLfloat y, GLfloat z);
static PFN_GLWINDOWPOS3F _glWindowPos3f_ptr = NULL;

static inline void APIENTRY _glWindowPos3f(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glWindowPos3f";
    if (!_glWindowPos3f_ptr) {
        _glWindowPos3f_ptr = (PFN_GLWINDOWPOS3F)_getPrivateProcAddress(_name);
        if (!_glWindowPos3f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3f_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3FV)(const GLfloat * v);
static PFN_GLWINDOWPOS3FV _glWindowPos3fv_ptr = NULL;

static inline void APIENTRY _glWindowPos3fv(const GLfloat * v) {
    const char *_name = "glWindowPos3fv";
    if (!_glWindowPos3fv_ptr) {
        _glWindowPos3fv_ptr = (PFN_GLWINDOWPOS3FV)_getPrivateProcAddress(_name);
        if (!_glWindowPos3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3fv_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3I)(GLint x, GLint y, GLint z);
static PFN_GLWINDOWPOS3I _glWindowPos3i_ptr = NULL;

static inline void APIENTRY _glWindowPos3i(GLint x, GLint y, GLint z) {
    const char *_name = "glWindowPos3i";
    if (!_glWindowPos3i_ptr) {
        _glWindowPos3i_ptr = (PFN_GLWINDOWPOS3I)_getPrivateProcAddress(_name);
        if (!_glWindowPos3i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3i_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3IV)(const GLint * v);
static PFN_GLWINDOWPOS3IV _glWindowPos3iv_ptr = NULL;

static inline void APIENTRY _glWindowPos3iv(const GLint * v) {
    const char *_name = "glWindowPos3iv";
    if (!_glWindowPos3iv_ptr) {
        _glWindowPos3iv_ptr = (PFN_GLWINDOWPOS3IV)_getPrivateProcAddress(_name);
        if (!_glWindowPos3iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3iv_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3S)(GLshort x, GLshort y, GLshort z);
static PFN_GLWINDOWPOS3S _glWindowPos3s_ptr = NULL;

static inline void APIENTRY _glWindowPos3s(GLshort x, GLshort y, GLshort z) {
    const char *_name = "glWindowPos3s";
    if (!_glWindowPos3s_ptr) {
        _glWindowPos3s_ptr = (PFN_GLWINDOWPOS3S)_getPrivateProcAddress(_name);
        if (!_glWindowPos3s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3s_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3SV)(const GLshort * v);
static PFN_GLWINDOWPOS3SV _glWindowPos3sv_ptr = NULL;

static inline void APIENTRY _glWindowPos3sv(const GLshort * v) {
    const char *_name = "glWindowPos3sv";
    if (!_glWindowPos3sv_ptr) {
        _glWindowPos3sv_ptr = (PFN_GLWINDOWPOS3SV)_getPrivateProcAddress(_name);
        if (!_glWindowPos3sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3sv_ptr(v);
}

typedef void (APIENTRY * PFN_GLGENQUERIES)(GLsizei n, GLuint * ids);
static PFN_GLGENQUERIES _glGenQueries_ptr = NULL;

static inline void APIENTRY _glGenQueries(GLsizei n, GLuint * ids) {
    const char *_name = "glGenQueries";
    if (!_glGenQueries_ptr) {
        _glGenQueries_ptr = (PFN_GLGENQUERIES)_getPrivateProcAddress(_name);
        if (!_glGenQueries_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenQueries_ptr(n, ids);
}

typedef void (APIENTRY * PFN_GLDELETEQUERIES)(GLsizei n, const GLuint * ids);
static PFN_GLDELETEQUERIES _glDeleteQueries_ptr = NULL;

static inline void APIENTRY _glDeleteQueries(GLsizei n, const GLuint * ids) {
    const char *_name = "glDeleteQueries";
    if (!_glDeleteQueries_ptr) {
        _glDeleteQueries_ptr = (PFN_GLDELETEQUERIES)_getPrivateProcAddress(_name);
        if (!_glDeleteQueries_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteQueries_ptr(n, ids);
}

typedef GLboolean (APIENTRY * PFN_GLISQUERY)(GLuint id);
static PFN_GLISQUERY _glIsQuery_ptr = NULL;

static inline GLboolean APIENTRY _glIsQuery(GLuint id) {
    const char *_name = "glIsQuery";
    if (!_glIsQuery_ptr) {
        _glIsQuery_ptr = (PFN_GLISQUERY)_getPrivateProcAddress(_name);
        if (!_glIsQuery_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsQuery_ptr(id);
}

typedef void (APIENTRY * PFN_GLBEGINQUERY)(GLenum target, GLuint id);
static PFN_GLBEGINQUERY _glBeginQuery_ptr = NULL;

static inline void APIENTRY _glBeginQuery(GLenum target, GLuint id) {
    const char *_name = "glBeginQuery";
    if (!_glBeginQuery_ptr) {
        _glBeginQuery_ptr = (PFN_GLBEGINQUERY)_getPrivateProcAddress(_name);
        if (!_glBeginQuery_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginQuery_ptr(target, id);
}

typedef void (APIENTRY * PFN_GLENDQUERY)(GLenum target);
static PFN_GLENDQUERY _glEndQuery_ptr = NULL;

static inline void APIENTRY _glEndQuery(GLenum target) {
    const char *_name = "glEndQuery";
    if (!_glEndQuery_ptr) {
        _glEndQuery_ptr = (PFN_GLENDQUERY)_getPrivateProcAddress(_name);
        if (!_glEndQuery_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndQuery_ptr(target);
}

typedef void (APIENTRY * PFN_GLGETQUERYIV)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETQUERYIV _glGetQueryiv_ptr = NULL;

static inline void APIENTRY _glGetQueryiv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryiv";
    if (!_glGetQueryiv_ptr) {
        _glGetQueryiv_ptr = (PFN_GLGETQUERYIV)_getPrivateProcAddress(_name);
        if (!_glGetQueryiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetQueryiv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETQUERYOBJECTIV)(GLuint id, GLenum pname, GLint * params);
static PFN_GLGETQUERYOBJECTIV _glGetQueryObjectiv_ptr = NULL;

static inline void APIENTRY _glGetQueryObjectiv(GLuint id, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryObjectiv";
    if (!_glGetQueryObjectiv_ptr) {
        _glGetQueryObjectiv_ptr = (PFN_GLGETQUERYOBJECTIV)_getPrivateProcAddress(_name);
        if (!_glGetQueryObjectiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetQueryObjectiv_ptr(id, pname, params);
}

typedef void (APIENTRY * PFN_GLGETQUERYOBJECTUIV)(GLuint id, GLenum pname, GLuint * params);
static PFN_GLGETQUERYOBJECTUIV _glGetQueryObjectuiv_ptr = NULL;

static inline void APIENTRY _glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params) {
    const char *_name = "glGetQueryObjectuiv";
    if (!_glGetQueryObjectuiv_ptr) {
        _glGetQueryObjectuiv_ptr = (PFN_GLGETQUERYOBJECTUIV)_getPrivateProcAddress(_name);
        if (!_glGetQueryObjectuiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetQueryObjectuiv_ptr(id, pname, params);
}

typedef void (APIENTRY * PFN_GLBINDBUFFER)(GLenum target, GLuint buffer);
static PFN_GLBINDBUFFER _glBindBuffer_ptr = NULL;

static inline void APIENTRY _glBindBuffer(GLenum target, GLuint buffer) {
    const char *_name = "glBindBuffer";
    if (!_glBindBuffer_ptr) {
        _glBindBuffer_ptr = (PFN_GLBINDBUFFER)_getPrivateProcAddress(_name);
        if (!_glBindBuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindBuffer_ptr(target, buffer);
}

typedef void (APIENTRY * PFN_GLDELETEBUFFERS)(GLsizei n, const GLuint * buffer);
static PFN_GLDELETEBUFFERS _glDeleteBuffers_ptr = NULL;

static inline void APIENTRY _glDeleteBuffers(GLsizei n, const GLuint * buffer) {
    const char *_name = "glDeleteBuffers";
    if (!_glDeleteBuffers_ptr) {
        _glDeleteBuffers_ptr = (PFN_GLDELETEBUFFERS)_getPrivateProcAddress(_name);
        if (!_glDeleteBuffers_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteBuffers_ptr(n, buffer);
}

typedef void (APIENTRY * PFN_GLGENBUFFERS)(GLsizei n, GLuint * buffer);
static PFN_GLGENBUFFERS _glGenBuffers_ptr = NULL;

static inline void APIENTRY _glGenBuffers(GLsizei n, GLuint * buffer) {
    const char *_name = "glGenBuffers";
    if (!_glGenBuffers_ptr) {
        _glGenBuffers_ptr = (PFN_GLGENBUFFERS)_getPrivateProcAddress(_name);
        if (!_glGenBuffers_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenBuffers_ptr(n, buffer);
}

typedef GLboolean (APIENTRY * PFN_GLISBUFFER)(GLuint buffer);
static PFN_GLISBUFFER _glIsBuffer_ptr = NULL;

static inline GLboolean APIENTRY _glIsBuffer(GLuint buffer) {
    const char *_name = "glIsBuffer";
    if (!_glIsBuffer_ptr) {
        _glIsBuffer_ptr = (PFN_GLISBUFFER)_getPrivateProcAddress(_name);
        if (!_glIsBuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsBuffer_ptr(buffer);
}

typedef void (APIENTRY * PFN_GLBUFFERDATA)(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage);
static PFN_GLBUFFERDATA _glBufferData_ptr = NULL;

static inline void APIENTRY _glBufferData(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage) {
    const char *_name = "glBufferData";
    if (!_glBufferData_ptr) {
        _glBufferData_ptr = (PFN_GLBUFFERDATA)_getPrivateProcAddress(_name);
        if (!_glBufferData_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBufferData_ptr(target, size, data, usage);
}

typedef void (APIENTRY * PFN_GLBUFFERSUBDATA)(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data);
static PFN_GLBUFFERSUBDATA _glBufferSubData_ptr = NULL;

static inline void APIENTRY _glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data) {
    const char *_name = "glBufferSubData";
    if (!_glBufferSubData_ptr) {
        _glBufferSubData_ptr = (PFN_GLBUFFERSUBDATA)_getPrivateProcAddress(_name);
        if (!_glBufferSubData_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBufferSubData_ptr(target, offset, size, data);
}

typedef void (APIENTRY * PFN_GLGETBUFFERSUBDATA)(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid * data);
static PFN_GLGETBUFFERSUBDATA _glGetBufferSubData_ptr = NULL;

static inline void APIENTRY _glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid * data) {
    const char *_name = "glGetBufferSubData";
    if (!_glGetBufferSubData_ptr) {
        _glGetBufferSubData_ptr = (PFN_GLGETBUFFERSUBDATA)_getPrivateProcAddress(_name);
        if (!_glGetBufferSubData_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetBufferSubData_ptr(target, offset, size, data);
}

typedef GLvoid * (APIENTRY * PFN_GLMAPBUFFER)(GLenum target, GLenum access);
static PFN_GLMAPBUFFER _glMapBuffer_ptr = NULL;

static inline GLvoid * APIENTRY _glMapBuffer(GLenum target, GLenum access) {
    const char *_name = "glMapBuffer";
    if (!_glMapBuffer_ptr) {
        _glMapBuffer_ptr = (PFN_GLMAPBUFFER)_getPrivateProcAddress(_name);
        if (!_glMapBuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glMapBuffer_ptr(target, access);
}

typedef GLboolean (APIENTRY * PFN_GLUNMAPBUFFER)(GLenum target);
static PFN_GLUNMAPBUFFER _glUnmapBuffer_ptr = NULL;

static inline GLboolean APIENTRY _glUnmapBuffer(GLenum target) {
    const char *_name = "glUnmapBuffer";
    if (!_glUnmapBuffer_ptr) {
        _glUnmapBuffer_ptr = (PFN_GLUNMAPBUFFER)_getPrivateProcAddress(_name);
        if (!_glUnmapBuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glUnmapBuffer_ptr(target);
}

typedef void (APIENTRY * PFN_GLGETBUFFERPARAMETERIV)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETBUFFERPARAMETERIV _glGetBufferParameteriv_ptr = NULL;

static inline void APIENTRY _glGetBufferParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetBufferParameteriv";
    if (!_glGetBufferParameteriv_ptr) {
        _glGetBufferParameteriv_ptr = (PFN_GLGETBUFFERPARAMETERIV)_getPrivateProcAddress(_name);
        if (!_glGetBufferParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetBufferParameteriv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETBUFFERPOINTERV)(GLenum target, GLenum pname, GLvoid * * params);
static PFN_GLGETBUFFERPOINTERV _glGetBufferPointerv_ptr = NULL;

static inline void APIENTRY _glGetBufferPointerv(GLenum target, GLenum pname, GLvoid * * params) {
    const char *_name = "glGetBufferPointerv";
    if (!_glGetBufferPointerv_ptr) {
        _glGetBufferPointerv_ptr = (PFN_GLGETBUFFERPOINTERV)_getPrivateProcAddress(_name);
        if (!_glGetBufferPointerv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetBufferPointerv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLBLENDEQUATIONSEPARATE)(GLenum modeRGB, GLenum modeAlpha);
static PFN_GLBLENDEQUATIONSEPARATE _glBlendEquationSeparate_ptr = NULL;

static inline void APIENTRY _glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha) {
    const char *_name = "glBlendEquationSeparate";
    if (!_glBlendEquationSeparate_ptr) {
        _glBlendEquationSeparate_ptr = (PFN_GLBLENDEQUATIONSEPARATE)_getPrivateProcAddress(_name);
        if (!_glBlendEquationSeparate_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendEquationSeparate_ptr(modeRGB, modeAlpha);
}

typedef void (APIENTRY * PFN_GLDRAWBUFFERS)(GLsizei n, const GLenum * bufs);
static PFN_GLDRAWBUFFERS _glDrawBuffers_ptr = NULL;

static inline void APIENTRY _glDrawBuffers(GLsizei n, const GLenum * bufs) {
    const char *_name = "glDrawBuffers";
    if (!_glDrawBuffers_ptr) {
        _glDrawBuffers_ptr = (PFN_GLDRAWBUFFERS)_getPrivateProcAddress(_name);
        if (!_glDrawBuffers_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawBuffers_ptr(n, bufs);
}

typedef void (APIENTRY * PFN_GLSTENCILOPSEPARATE)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
static PFN_GLSTENCILOPSEPARATE _glStencilOpSeparate_ptr = NULL;

static inline void APIENTRY _glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) {
    const char *_name = "glStencilOpSeparate";
    if (!_glStencilOpSeparate_ptr) {
        _glStencilOpSeparate_ptr = (PFN_GLSTENCILOPSEPARATE)_getPrivateProcAddress(_name);
        if (!_glStencilOpSeparate_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glStencilOpSeparate_ptr(face, sfail, dpfail, dppass);
}

typedef void (APIENTRY * PFN_GLSTENCILFUNCSEPARATE)(GLenum face, GLenum func, GLint ref, GLuint mask);
static PFN_GLSTENCILFUNCSEPARATE _glStencilFuncSeparate_ptr = NULL;

static inline void APIENTRY _glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask) {
    const char *_name = "glStencilFuncSeparate";
    if (!_glStencilFuncSeparate_ptr) {
        _glStencilFuncSeparate_ptr = (PFN_GLSTENCILFUNCSEPARATE)_getPrivateProcAddress(_name);
        if (!_glStencilFuncSeparate_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glStencilFuncSeparate_ptr(face, func, ref, mask);
}

typedef void (APIENTRY * PFN_GLSTENCILMASKSEPARATE)(GLenum face, GLuint mask);
static PFN_GLSTENCILMASKSEPARATE _glStencilMaskSeparate_ptr = NULL;

static inline void APIENTRY _glStencilMaskSeparate(GLenum face, GLuint mask) {
    const char *_name = "glStencilMaskSeparate";
    if (!_glStencilMaskSeparate_ptr) {
        _glStencilMaskSeparate_ptr = (PFN_GLSTENCILMASKSEPARATE)_getPrivateProcAddress(_name);
        if (!_glStencilMaskSeparate_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glStencilMaskSeparate_ptr(face, mask);
}

typedef void (APIENTRY * PFN_GLATTACHSHADER)(GLuint program, GLuint shader);
static PFN_GLATTACHSHADER _glAttachShader_ptr = NULL;

static inline void APIENTRY _glAttachShader(GLuint program, GLuint shader) {
    const char *_name = "glAttachShader";
    if (!_glAttachShader_ptr) {
        _glAttachShader_ptr = (PFN_GLATTACHSHADER)_getPrivateProcAddress(_name);
        if (!_glAttachShader_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glAttachShader_ptr(program, shader);
}

typedef void (APIENTRY * PFN_GLBINDATTRIBLOCATION)(GLuint program, GLuint index, const GLchar * name);
static PFN_GLBINDATTRIBLOCATION _glBindAttribLocation_ptr = NULL;

static inline void APIENTRY _glBindAttribLocation(GLuint program, GLuint index, const GLchar * name) {
    const char *_name = "glBindAttribLocation";
    if (!_glBindAttribLocation_ptr) {
        _glBindAttribLocation_ptr = (PFN_GLBINDATTRIBLOCATION)_getPrivateProcAddress(_name);
        if (!_glBindAttribLocation_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindAttribLocation_ptr(program, index, name);
}

typedef void (APIENTRY * PFN_GLCOMPILESHADER)(GLuint shader);
static PFN_GLCOMPILESHADER _glCompileShader_ptr = NULL;

static inline void APIENTRY _glCompileShader(GLuint shader) {
    const char *_name = "glCompileShader";
    if (!_glCompileShader_ptr) {
        _glCompileShader_ptr = (PFN_GLCOMPILESHADER)_getPrivateProcAddress(_name);
        if (!_glCompileShader_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompileShader_ptr(shader);
}

typedef GLuint (APIENTRY * PFN_GLCREATEPROGRAM)(void);
static PFN_GLCREATEPROGRAM _glCreateProgram_ptr = NULL;

static inline GLuint APIENTRY _glCreateProgram(void) {
    const char *_name = "glCreateProgram";
    if (!_glCreateProgram_ptr) {
        _glCreateProgram_ptr = (PFN_GLCREATEPROGRAM)_getPrivateProcAddress(_name);
        if (!_glCreateProgram_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glCreateProgram_ptr();
}

typedef GLuint (APIENTRY * PFN_GLCREATESHADER)(GLenum type);
static PFN_GLCREATESHADER _glCreateShader_ptr = NULL;

static inline GLuint APIENTRY _glCreateShader(GLenum type) {
    const char *_name = "glCreateShader";
    if (!_glCreateShader_ptr) {
        _glCreateShader_ptr = (PFN_GLCREATESHADER)_getPrivateProcAddress(_name);
        if (!_glCreateShader_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glCreateShader_ptr(type);
}

typedef void (APIENTRY * PFN_GLDELETEPROGRAM)(GLuint program);
static PFN_GLDELETEPROGRAM _glDeleteProgram_ptr = NULL;

static inline void APIENTRY _glDeleteProgram(GLuint program) {
    const char *_name = "glDeleteProgram";
    if (!_glDeleteProgram_ptr) {
        _glDeleteProgram_ptr = (PFN_GLDELETEPROGRAM)_getPrivateProcAddress(_name);
        if (!_glDeleteProgram_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteProgram_ptr(program);
}

typedef void (APIENTRY * PFN_GLDELETESHADER)(GLuint shader);
static PFN_GLDELETESHADER _glDeleteShader_ptr = NULL;

static inline void APIENTRY _glDeleteShader(GLuint shader) {
    const char *_name = "glDeleteShader";
    if (!_glDeleteShader_ptr) {
        _glDeleteShader_ptr = (PFN_GLDELETESHADER)_getPrivateProcAddress(_name);
        if (!_glDeleteShader_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteShader_ptr(shader);
}

typedef void (APIENTRY * PFN_GLDETACHSHADER)(GLuint program, GLuint shader);
static PFN_GLDETACHSHADER _glDetachShader_ptr = NULL;

static inline void APIENTRY _glDetachShader(GLuint program, GLuint shader) {
    const char *_name = "glDetachShader";
    if (!_glDetachShader_ptr) {
        _glDetachShader_ptr = (PFN_GLDETACHSHADER)_getPrivateProcAddress(_name);
        if (!_glDetachShader_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDetachShader_ptr(program, shader);
}

typedef void (APIENTRY * PFN_GLDISABLEVERTEXATTRIBARRAY)(GLuint index);
static PFN_GLDISABLEVERTEXATTRIBARRAY _glDisableVertexAttribArray_ptr = NULL;

static inline void APIENTRY _glDisableVertexAttribArray(GLuint index) {
    const char *_name = "glDisableVertexAttribArray";
    if (!_glDisableVertexAttribArray_ptr) {
        _glDisableVertexAttribArray_ptr = (PFN_GLDISABLEVERTEXATTRIBARRAY)_getPrivateProcAddress(_name);
        if (!_glDisableVertexAttribArray_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDisableVertexAttribArray_ptr(index);
}

typedef void (APIENTRY * PFN_GLENABLEVERTEXATTRIBARRAY)(GLuint index);
static PFN_GLENABLEVERTEXATTRIBARRAY _glEnableVertexAttribArray_ptr = NULL;

static inline void APIENTRY _glEnableVertexAttribArray(GLuint index) {
    const char *_name = "glEnableVertexAttribArray";
    if (!_glEnableVertexAttribArray_ptr) {
        _glEnableVertexAttribArray_ptr = (PFN_GLENABLEVERTEXATTRIBARRAY)_getPrivateProcAddress(_name);
        if (!_glEnableVertexAttribArray_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEnableVertexAttribArray_ptr(index);
}

typedef void (APIENTRY * PFN_GLGETACTIVEATTRIB)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
static PFN_GLGETACTIVEATTRIB _glGetActiveAttrib_ptr = NULL;

static inline void APIENTRY _glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name) {
    const char *_name = "glGetActiveAttrib";
    if (!_glGetActiveAttrib_ptr) {
        _glGetActiveAttrib_ptr = (PFN_GLGETACTIVEATTRIB)_getPrivateProcAddress(_name);
        if (!_glGetActiveAttrib_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetActiveAttrib_ptr(program, index, bufSize, length, size, type, name);
}

typedef void (APIENTRY * PFN_GLGETACTIVEUNIFORM)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
static PFN_GLGETACTIVEUNIFORM _glGetActiveUniform_ptr = NULL;

static inline void APIENTRY _glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name) {
    const char *_name = "glGetActiveUniform";
    if (!_glGetActiveUniform_ptr) {
        _glGetActiveUniform_ptr = (PFN_GLGETACTIVEUNIFORM)_getPrivateProcAddress(_name);
        if (!_glGetActiveUniform_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetActiveUniform_ptr(program, index, bufSize, length, size, type, name);
}

typedef void (APIENTRY * PFN_GLGETATTACHEDSHADERS)(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * obj);
static PFN_GLGETATTACHEDSHADERS _glGetAttachedShaders_ptr = NULL;

static inline void APIENTRY _glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * obj) {
    const char *_name = "glGetAttachedShaders";
    if (!_glGetAttachedShaders_ptr) {
        _glGetAttachedShaders_ptr = (PFN_GLGETATTACHEDSHADERS)_getPrivateProcAddress(_name);
        if (!_glGetAttachedShaders_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetAttachedShaders_ptr(program, maxCount, count, obj);
}

typedef GLint (APIENTRY * PFN_GLGETATTRIBLOCATION)(GLuint program, const GLchar * name);
static PFN_GLGETATTRIBLOCATION _glGetAttribLocation_ptr = NULL;

static inline GLint APIENTRY _glGetAttribLocation(GLuint program, const GLchar * name) {
    const char *_name = "glGetAttribLocation";
    if (!_glGetAttribLocation_ptr) {
        _glGetAttribLocation_ptr = (PFN_GLGETATTRIBLOCATION)_getPrivateProcAddress(_name);
        if (!_glGetAttribLocation_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetAttribLocation_ptr(program, name);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMIV)(GLuint program, GLenum pname, GLint * params);
static PFN_GLGETPROGRAMIV _glGetProgramiv_ptr = NULL;

static inline void APIENTRY _glGetProgramiv(GLuint program, GLenum pname, GLint * params) {
    const char *_name = "glGetProgramiv";
    if (!_glGetProgramiv_ptr) {
        _glGetProgramiv_ptr = (PFN_GLGETPROGRAMIV)_getPrivateProcAddress(_name);
        if (!_glGetProgramiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramiv_ptr(program, pname, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMINFOLOG)(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
static PFN_GLGETPROGRAMINFOLOG _glGetProgramInfoLog_ptr = NULL;

static inline void APIENTRY _glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog) {
    const char *_name = "glGetProgramInfoLog";
    if (!_glGetProgramInfoLog_ptr) {
        _glGetProgramInfoLog_ptr = (PFN_GLGETPROGRAMINFOLOG)_getPrivateProcAddress(_name);
        if (!_glGetProgramInfoLog_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramInfoLog_ptr(program, bufSize, length, infoLog);
}

typedef void (APIENTRY * PFN_GLGETSHADERIV)(GLuint shader, GLenum pname, GLint * params);
static PFN_GLGETSHADERIV _glGetShaderiv_ptr = NULL;

static inline void APIENTRY _glGetShaderiv(GLuint shader, GLenum pname, GLint * params) {
    const char *_name = "glGetShaderiv";
    if (!_glGetShaderiv_ptr) {
        _glGetShaderiv_ptr = (PFN_GLGETSHADERIV)_getPrivateProcAddress(_name);
        if (!_glGetShaderiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetShaderiv_ptr(shader, pname, params);
}

typedef void (APIENTRY * PFN_GLGETSHADERINFOLOG)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
static PFN_GLGETSHADERINFOLOG _glGetShaderInfoLog_ptr = NULL;

static inline void APIENTRY _glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog) {
    const char *_name = "glGetShaderInfoLog";
    if (!_glGetShaderInfoLog_ptr) {
        _glGetShaderInfoLog_ptr = (PFN_GLGETSHADERINFOLOG)_getPrivateProcAddress(_name);
        if (!_glGetShaderInfoLog_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetShaderInfoLog_ptr(shader, bufSize, length, infoLog);
}

typedef void (APIENTRY * PFN_GLGETSHADERSOURCE)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source);
static PFN_GLGETSHADERSOURCE _glGetShaderSource_ptr = NULL;

static inline void APIENTRY _glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source) {
    const char *_name = "glGetShaderSource";
    if (!_glGetShaderSource_ptr) {
        _glGetShaderSource_ptr = (PFN_GLGETSHADERSOURCE)_getPrivateProcAddress(_name);
        if (!_glGetShaderSource_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetShaderSource_ptr(shader, bufSize, length, source);
}

typedef GLint (APIENTRY * PFN_GLGETUNIFORMLOCATION)(GLuint program, const GLchar * name);
static PFN_GLGETUNIFORMLOCATION _glGetUniformLocation_ptr = NULL;

static inline GLint APIENTRY _glGetUniformLocation(GLuint program, const GLchar * name) {
    const char *_name = "glGetUniformLocation";
    if (!_glGetUniformLocation_ptr) {
        _glGetUniformLocation_ptr = (PFN_GLGETUNIFORMLOCATION)_getPrivateProcAddress(_name);
        if (!_glGetUniformLocation_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetUniformLocation_ptr(program, name);
}

typedef void (APIENTRY * PFN_GLGETUNIFORMFV)(GLuint program, GLint location, GLfloat * params);
static PFN_GLGETUNIFORMFV _glGetUniformfv_ptr = NULL;

static inline void APIENTRY _glGetUniformfv(GLuint program, GLint location, GLfloat * params) {
    const char *_name = "glGetUniformfv";
    if (!_glGetUniformfv_ptr) {
        _glGetUniformfv_ptr = (PFN_GLGETUNIFORMFV)_getPrivateProcAddress(_name);
        if (!_glGetUniformfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetUniformfv_ptr(program, location, params);
}

typedef void (APIENTRY * PFN_GLGETUNIFORMIV)(GLuint program, GLint location, GLint * params);
static PFN_GLGETUNIFORMIV _glGetUniformiv_ptr = NULL;

static inline void APIENTRY _glGetUniformiv(GLuint program, GLint location, GLint * params) {
    const char *_name = "glGetUniformiv";
    if (!_glGetUniformiv_ptr) {
        _glGetUniformiv_ptr = (PFN_GLGETUNIFORMIV)_getPrivateProcAddress(_name);
        if (!_glGetUniformiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetUniformiv_ptr(program, location, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBDV)(GLuint index, GLenum pname, GLdouble * params);
static PFN_GLGETVERTEXATTRIBDV _glGetVertexAttribdv_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble * params) {
    const char *_name = "glGetVertexAttribdv";
    if (!_glGetVertexAttribdv_ptr) {
        _glGetVertexAttribdv_ptr = (PFN_GLGETVERTEXATTRIBDV)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribdv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribdv_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBFV)(GLuint index, GLenum pname, GLfloat * params);
static PFN_GLGETVERTEXATTRIBFV _glGetVertexAttribfv_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat * params) {
    const char *_name = "glGetVertexAttribfv";
    if (!_glGetVertexAttribfv_ptr) {
        _glGetVertexAttribfv_ptr = (PFN_GLGETVERTEXATTRIBFV)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribfv_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBIV)(GLuint index, GLenum pname, GLint * params);
static PFN_GLGETVERTEXATTRIBIV _glGetVertexAttribiv_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribiv(GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetVertexAttribiv";
    if (!_glGetVertexAttribiv_ptr) {
        _glGetVertexAttribiv_ptr = (PFN_GLGETVERTEXATTRIBIV)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribiv_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBPOINTERV)(GLuint index, GLenum pname, GLvoid * * pointer);
static PFN_GLGETVERTEXATTRIBPOINTERV _glGetVertexAttribPointerv_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid * * pointer) {
    const char *_name = "glGetVertexAttribPointerv";
    if (!_glGetVertexAttribPointerv_ptr) {
        _glGetVertexAttribPointerv_ptr = (PFN_GLGETVERTEXATTRIBPOINTERV)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribPointerv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribPointerv_ptr(index, pname, pointer);
}

typedef GLboolean (APIENTRY * PFN_GLISPROGRAM)(GLuint program);
static PFN_GLISPROGRAM _glIsProgram_ptr = NULL;

static inline GLboolean APIENTRY _glIsProgram(GLuint program) {
    const char *_name = "glIsProgram";
    if (!_glIsProgram_ptr) {
        _glIsProgram_ptr = (PFN_GLISPROGRAM)_getPrivateProcAddress(_name);
        if (!_glIsProgram_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsProgram_ptr(program);
}

typedef GLboolean (APIENTRY * PFN_GLISSHADER)(GLuint shader);
static PFN_GLISSHADER _glIsShader_ptr = NULL;

static inline GLboolean APIENTRY _glIsShader(GLuint shader) {
    const char *_name = "glIsShader";
    if (!_glIsShader_ptr) {
        _glIsShader_ptr = (PFN_GLISSHADER)_getPrivateProcAddress(_name);
        if (!_glIsShader_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsShader_ptr(shader);
}

typedef void (APIENTRY * PFN_GLLINKPROGRAM)(GLuint program);
static PFN_GLLINKPROGRAM _glLinkProgram_ptr = NULL;

static inline void APIENTRY _glLinkProgram(GLuint program) {
    const char *_name = "glLinkProgram";
    if (!_glLinkProgram_ptr) {
        _glLinkProgram_ptr = (PFN_GLLINKPROGRAM)_getPrivateProcAddress(_name);
        if (!_glLinkProgram_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLinkProgram_ptr(program);
}

typedef void (APIENTRY * PFN_GLSHADERSOURCE)(GLuint shader, GLsizei count, const GLcharARB * const * string, const GLint * length);
static PFN_GLSHADERSOURCE _glShaderSource_ptr = NULL;

static inline void APIENTRY _glShaderSource(GLuint shader, GLsizei count, const GLcharARB * const * string, const GLint * length) {
    const char *_name = "glShaderSource";
    if (!_glShaderSource_ptr) {
        _glShaderSource_ptr = (PFN_GLSHADERSOURCE)_getPrivateProcAddress(_name);
        if (!_glShaderSource_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glShaderSource_ptr(shader, count, string, length);
}

typedef void (APIENTRY * PFN_GLUSEPROGRAM)(GLuint program);
static PFN_GLUSEPROGRAM _glUseProgram_ptr = NULL;

static inline void APIENTRY _glUseProgram(GLuint program) {
    const char *_name = "glUseProgram";
    if (!_glUseProgram_ptr) {
        _glUseProgram_ptr = (PFN_GLUSEPROGRAM)_getPrivateProcAddress(_name);
        if (!_glUseProgram_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUseProgram_ptr(program);
}

typedef void (APIENTRY * PFN_GLUNIFORM1F)(GLint location, GLfloat v0);
static PFN_GLUNIFORM1F _glUniform1f_ptr = NULL;

static inline void APIENTRY _glUniform1f(GLint location, GLfloat v0) {
    const char *_name = "glUniform1f";
    if (!_glUniform1f_ptr) {
        _glUniform1f_ptr = (PFN_GLUNIFORM1F)_getPrivateProcAddress(_name);
        if (!_glUniform1f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1f_ptr(location, v0);
}

typedef void (APIENTRY * PFN_GLUNIFORM2F)(GLint location, GLfloat v0, GLfloat v1);
static PFN_GLUNIFORM2F _glUniform2f_ptr = NULL;

static inline void APIENTRY _glUniform2f(GLint location, GLfloat v0, GLfloat v1) {
    const char *_name = "glUniform2f";
    if (!_glUniform2f_ptr) {
        _glUniform2f_ptr = (PFN_GLUNIFORM2F)_getPrivateProcAddress(_name);
        if (!_glUniform2f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2f_ptr(location, v0, v1);
}

typedef void (APIENTRY * PFN_GLUNIFORM3F)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
static PFN_GLUNIFORM3F _glUniform3f_ptr = NULL;

static inline void APIENTRY _glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
    const char *_name = "glUniform3f";
    if (!_glUniform3f_ptr) {
        _glUniform3f_ptr = (PFN_GLUNIFORM3F)_getPrivateProcAddress(_name);
        if (!_glUniform3f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3f_ptr(location, v0, v1, v2);
}

typedef void (APIENTRY * PFN_GLUNIFORM4F)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
static PFN_GLUNIFORM4F _glUniform4f_ptr = NULL;

static inline void APIENTRY _glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
    const char *_name = "glUniform4f";
    if (!_glUniform4f_ptr) {
        _glUniform4f_ptr = (PFN_GLUNIFORM4F)_getPrivateProcAddress(_name);
        if (!_glUniform4f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4f_ptr(location, v0, v1, v2, v3);
}

typedef void (APIENTRY * PFN_GLUNIFORM1I)(GLint location, GLint v0);
static PFN_GLUNIFORM1I _glUniform1i_ptr = NULL;

static inline void APIENTRY _glUniform1i(GLint location, GLint v0) {
    const char *_name = "glUniform1i";
    if (!_glUniform1i_ptr) {
        _glUniform1i_ptr = (PFN_GLUNIFORM1I)_getPrivateProcAddress(_name);
        if (!_glUniform1i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1i_ptr(location, v0);
}

typedef void (APIENTRY * PFN_GLUNIFORM2I)(GLint location, GLint v0, GLint v1);
static PFN_GLUNIFORM2I _glUniform2i_ptr = NULL;

static inline void APIENTRY _glUniform2i(GLint location, GLint v0, GLint v1) {
    const char *_name = "glUniform2i";
    if (!_glUniform2i_ptr) {
        _glUniform2i_ptr = (PFN_GLUNIFORM2I)_getPrivateProcAddress(_name);
        if (!_glUniform2i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2i_ptr(location, v0, v1);
}

typedef void (APIENTRY * PFN_GLUNIFORM3I)(GLint location, GLint v0, GLint v1, GLint v2);
static PFN_GLUNIFORM3I _glUniform3i_ptr = NULL;

static inline void APIENTRY _glUniform3i(GLint location, GLint v0, GLint v1, GLint v2) {
    const char *_name = "glUniform3i";
    if (!_glUniform3i_ptr) {
        _glUniform3i_ptr = (PFN_GLUNIFORM3I)_getPrivateProcAddress(_name);
        if (!_glUniform3i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3i_ptr(location, v0, v1, v2);
}

typedef void (APIENTRY * PFN_GLUNIFORM4I)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
static PFN_GLUNIFORM4I _glUniform4i_ptr = NULL;

static inline void APIENTRY _glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
    const char *_name = "glUniform4i";
    if (!_glUniform4i_ptr) {
        _glUniform4i_ptr = (PFN_GLUNIFORM4I)_getPrivateProcAddress(_name);
        if (!_glUniform4i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4i_ptr(location, v0, v1, v2, v3);
}

typedef void (APIENTRY * PFN_GLUNIFORM1FV)(GLint location, GLsizei count, const GLfloat * value);
static PFN_GLUNIFORM1FV _glUniform1fv_ptr = NULL;

static inline void APIENTRY _glUniform1fv(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform1fv";
    if (!_glUniform1fv_ptr) {
        _glUniform1fv_ptr = (PFN_GLUNIFORM1FV)_getPrivateProcAddress(_name);
        if (!_glUniform1fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1fv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM2FV)(GLint location, GLsizei count, const GLfloat * value);
static PFN_GLUNIFORM2FV _glUniform2fv_ptr = NULL;

static inline void APIENTRY _glUniform2fv(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform2fv";
    if (!_glUniform2fv_ptr) {
        _glUniform2fv_ptr = (PFN_GLUNIFORM2FV)_getPrivateProcAddress(_name);
        if (!_glUniform2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2fv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM3FV)(GLint location, GLsizei count, const GLfloat * value);
static PFN_GLUNIFORM3FV _glUniform3fv_ptr = NULL;

static inline void APIENTRY _glUniform3fv(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform3fv";
    if (!_glUniform3fv_ptr) {
        _glUniform3fv_ptr = (PFN_GLUNIFORM3FV)_getPrivateProcAddress(_name);
        if (!_glUniform3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3fv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM4FV)(GLint location, GLsizei count, const GLfloat * value);
static PFN_GLUNIFORM4FV _glUniform4fv_ptr = NULL;

static inline void APIENTRY _glUniform4fv(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform4fv";
    if (!_glUniform4fv_ptr) {
        _glUniform4fv_ptr = (PFN_GLUNIFORM4FV)_getPrivateProcAddress(_name);
        if (!_glUniform4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4fv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM1IV)(GLint location, GLsizei count, const GLint * value);
static PFN_GLUNIFORM1IV _glUniform1iv_ptr = NULL;

static inline void APIENTRY _glUniform1iv(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform1iv";
    if (!_glUniform1iv_ptr) {
        _glUniform1iv_ptr = (PFN_GLUNIFORM1IV)_getPrivateProcAddress(_name);
        if (!_glUniform1iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1iv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM2IV)(GLint location, GLsizei count, const GLint * value);
static PFN_GLUNIFORM2IV _glUniform2iv_ptr = NULL;

static inline void APIENTRY _glUniform2iv(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform2iv";
    if (!_glUniform2iv_ptr) {
        _glUniform2iv_ptr = (PFN_GLUNIFORM2IV)_getPrivateProcAddress(_name);
        if (!_glUniform2iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2iv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM3IV)(GLint location, GLsizei count, const GLint * value);
static PFN_GLUNIFORM3IV _glUniform3iv_ptr = NULL;

static inline void APIENTRY _glUniform3iv(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform3iv";
    if (!_glUniform3iv_ptr) {
        _glUniform3iv_ptr = (PFN_GLUNIFORM3IV)_getPrivateProcAddress(_name);
        if (!_glUniform3iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3iv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM4IV)(GLint location, GLsizei count, const GLint * value);
static PFN_GLUNIFORM4IV _glUniform4iv_ptr = NULL;

static inline void APIENTRY _glUniform4iv(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform4iv";
    if (!_glUniform4iv_ptr) {
        _glUniform4iv_ptr = (PFN_GLUNIFORM4IV)_getPrivateProcAddress(_name);
        if (!_glUniform4iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4iv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX2FV)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLUNIFORMMATRIX2FV _glUniformMatrix2fv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix2fv";
    if (!_glUniformMatrix2fv_ptr) {
        _glUniformMatrix2fv_ptr = (PFN_GLUNIFORMMATRIX2FV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix2fv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX3FV)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLUNIFORMMATRIX3FV _glUniformMatrix3fv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix3fv";
    if (!_glUniformMatrix3fv_ptr) {
        _glUniformMatrix3fv_ptr = (PFN_GLUNIFORMMATRIX3FV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix3fv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX4FV)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLUNIFORMMATRIX4FV _glUniformMatrix4fv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix4fv";
    if (!_glUniformMatrix4fv_ptr) {
        _glUniformMatrix4fv_ptr = (PFN_GLUNIFORMMATRIX4FV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix4fv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLVALIDATEPROGRAM)(GLuint program);
static PFN_GLVALIDATEPROGRAM _glValidateProgram_ptr = NULL;

static inline void APIENTRY _glValidateProgram(GLuint program) {
    const char *_name = "glValidateProgram";
    if (!_glValidateProgram_ptr) {
        _glValidateProgram_ptr = (PFN_GLVALIDATEPROGRAM)_getPrivateProcAddress(_name);
        if (!_glValidateProgram_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glValidateProgram_ptr(program);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1D)(GLuint index, GLdouble x);
static PFN_GLVERTEXATTRIB1D _glVertexAttrib1d_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1d(GLuint index, GLdouble x) {
    const char *_name = "glVertexAttrib1d";
    if (!_glVertexAttrib1d_ptr) {
        _glVertexAttrib1d_ptr = (PFN_GLVERTEXATTRIB1D)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1d_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1DV)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIB1DV _glVertexAttrib1dv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib1dv";
    if (!_glVertexAttrib1dv_ptr) {
        _glVertexAttrib1dv_ptr = (PFN_GLVERTEXATTRIB1DV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1dv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1F)(GLuint index, GLfloat x);
static PFN_GLVERTEXATTRIB1F _glVertexAttrib1f_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1f(GLuint index, GLfloat x) {
    const char *_name = "glVertexAttrib1f";
    if (!_glVertexAttrib1f_ptr) {
        _glVertexAttrib1f_ptr = (PFN_GLVERTEXATTRIB1F)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1f_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1FV)(GLuint index, const GLfloat * v);
static PFN_GLVERTEXATTRIB1FV _glVertexAttrib1fv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1fv(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib1fv";
    if (!_glVertexAttrib1fv_ptr) {
        _glVertexAttrib1fv_ptr = (PFN_GLVERTEXATTRIB1FV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1fv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1S)(GLuint index, GLshort x);
static PFN_GLVERTEXATTRIB1S _glVertexAttrib1s_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1s(GLuint index, GLshort x) {
    const char *_name = "glVertexAttrib1s";
    if (!_glVertexAttrib1s_ptr) {
        _glVertexAttrib1s_ptr = (PFN_GLVERTEXATTRIB1S)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1s_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1SV)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB1SV _glVertexAttrib1sv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1sv(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib1sv";
    if (!_glVertexAttrib1sv_ptr) {
        _glVertexAttrib1sv_ptr = (PFN_GLVERTEXATTRIB1SV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1sv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2D)(GLuint index, GLdouble x, GLdouble y);
static PFN_GLVERTEXATTRIB2D _glVertexAttrib2d_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y) {
    const char *_name = "glVertexAttrib2d";
    if (!_glVertexAttrib2d_ptr) {
        _glVertexAttrib2d_ptr = (PFN_GLVERTEXATTRIB2D)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2d_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2DV)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIB2DV _glVertexAttrib2dv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib2dv";
    if (!_glVertexAttrib2dv_ptr) {
        _glVertexAttrib2dv_ptr = (PFN_GLVERTEXATTRIB2DV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2dv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2F)(GLuint index, GLfloat x, GLfloat y);
static PFN_GLVERTEXATTRIB2F _glVertexAttrib2f_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y) {
    const char *_name = "glVertexAttrib2f";
    if (!_glVertexAttrib2f_ptr) {
        _glVertexAttrib2f_ptr = (PFN_GLVERTEXATTRIB2F)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2f_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2FV)(GLuint index, const GLfloat * v);
static PFN_GLVERTEXATTRIB2FV _glVertexAttrib2fv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2fv(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib2fv";
    if (!_glVertexAttrib2fv_ptr) {
        _glVertexAttrib2fv_ptr = (PFN_GLVERTEXATTRIB2FV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2fv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2S)(GLuint index, GLshort x, GLshort y);
static PFN_GLVERTEXATTRIB2S _glVertexAttrib2s_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2s(GLuint index, GLshort x, GLshort y) {
    const char *_name = "glVertexAttrib2s";
    if (!_glVertexAttrib2s_ptr) {
        _glVertexAttrib2s_ptr = (PFN_GLVERTEXATTRIB2S)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2s_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2SV)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB2SV _glVertexAttrib2sv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2sv(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib2sv";
    if (!_glVertexAttrib2sv_ptr) {
        _glVertexAttrib2sv_ptr = (PFN_GLVERTEXATTRIB2SV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2sv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3D)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
static PFN_GLVERTEXATTRIB3D _glVertexAttrib3d_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertexAttrib3d";
    if (!_glVertexAttrib3d_ptr) {
        _glVertexAttrib3d_ptr = (PFN_GLVERTEXATTRIB3D)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3d_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3DV)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIB3DV _glVertexAttrib3dv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib3dv";
    if (!_glVertexAttrib3dv_ptr) {
        _glVertexAttrib3dv_ptr = (PFN_GLVERTEXATTRIB3DV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3dv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3F)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLVERTEXATTRIB3F _glVertexAttrib3f_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glVertexAttrib3f";
    if (!_glVertexAttrib3f_ptr) {
        _glVertexAttrib3f_ptr = (PFN_GLVERTEXATTRIB3F)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3f_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3FV)(GLuint index, const GLfloat * v);
static PFN_GLVERTEXATTRIB3FV _glVertexAttrib3fv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3fv(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib3fv";
    if (!_glVertexAttrib3fv_ptr) {
        _glVertexAttrib3fv_ptr = (PFN_GLVERTEXATTRIB3FV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3fv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3S)(GLuint index, GLshort x, GLshort y, GLshort z);
static PFN_GLVERTEXATTRIB3S _glVertexAttrib3s_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z) {
    const char *_name = "glVertexAttrib3s";
    if (!_glVertexAttrib3s_ptr) {
        _glVertexAttrib3s_ptr = (PFN_GLVERTEXATTRIB3S)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3s_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3SV)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB3SV _glVertexAttrib3sv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3sv(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib3sv";
    if (!_glVertexAttrib3sv_ptr) {
        _glVertexAttrib3sv_ptr = (PFN_GLVERTEXATTRIB3SV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3sv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NBV)(GLuint index, const GLbyte * v);
static PFN_GLVERTEXATTRIB4NBV _glVertexAttrib4Nbv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4Nbv(GLuint index, const GLbyte * v) {
    const char *_name = "glVertexAttrib4Nbv";
    if (!_glVertexAttrib4Nbv_ptr) {
        _glVertexAttrib4Nbv_ptr = (PFN_GLVERTEXATTRIB4NBV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4Nbv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4Nbv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NIV)(GLuint index, const GLint * v);
static PFN_GLVERTEXATTRIB4NIV _glVertexAttrib4Niv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4Niv(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttrib4Niv";
    if (!_glVertexAttrib4Niv_ptr) {
        _glVertexAttrib4Niv_ptr = (PFN_GLVERTEXATTRIB4NIV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4Niv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4Niv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NSV)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB4NSV _glVertexAttrib4Nsv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4Nsv(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib4Nsv";
    if (!_glVertexAttrib4Nsv_ptr) {
        _glVertexAttrib4Nsv_ptr = (PFN_GLVERTEXATTRIB4NSV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4Nsv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4Nsv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NUB)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
static PFN_GLVERTEXATTRIB4NUB _glVertexAttrib4Nub_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) {
    const char *_name = "glVertexAttrib4Nub";
    if (!_glVertexAttrib4Nub_ptr) {
        _glVertexAttrib4Nub_ptr = (PFN_GLVERTEXATTRIB4NUB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4Nub_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4Nub_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NUBV)(GLuint index, const GLubyte * v);
static PFN_GLVERTEXATTRIB4NUBV _glVertexAttrib4Nubv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4Nubv(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttrib4Nubv";
    if (!_glVertexAttrib4Nubv_ptr) {
        _glVertexAttrib4Nubv_ptr = (PFN_GLVERTEXATTRIB4NUBV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4Nubv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4Nubv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NUIV)(GLuint index, const GLuint * v);
static PFN_GLVERTEXATTRIB4NUIV _glVertexAttrib4Nuiv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4Nuiv(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttrib4Nuiv";
    if (!_glVertexAttrib4Nuiv_ptr) {
        _glVertexAttrib4Nuiv_ptr = (PFN_GLVERTEXATTRIB4NUIV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4Nuiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4Nuiv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NUSV)(GLuint index, const GLushort * v);
static PFN_GLVERTEXATTRIB4NUSV _glVertexAttrib4Nusv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4Nusv(GLuint index, const GLushort * v) {
    const char *_name = "glVertexAttrib4Nusv";
    if (!_glVertexAttrib4Nusv_ptr) {
        _glVertexAttrib4Nusv_ptr = (PFN_GLVERTEXATTRIB4NUSV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4Nusv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4Nusv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4BV)(GLuint index, const GLbyte * v);
static PFN_GLVERTEXATTRIB4BV _glVertexAttrib4bv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4bv(GLuint index, const GLbyte * v) {
    const char *_name = "glVertexAttrib4bv";
    if (!_glVertexAttrib4bv_ptr) {
        _glVertexAttrib4bv_ptr = (PFN_GLVERTEXATTRIB4BV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4bv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4bv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4D)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLVERTEXATTRIB4D _glVertexAttrib4d_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertexAttrib4d";
    if (!_glVertexAttrib4d_ptr) {
        _glVertexAttrib4d_ptr = (PFN_GLVERTEXATTRIB4D)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4d_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4DV)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIB4DV _glVertexAttrib4dv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib4dv";
    if (!_glVertexAttrib4dv_ptr) {
        _glVertexAttrib4dv_ptr = (PFN_GLVERTEXATTRIB4DV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4dv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4F)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLVERTEXATTRIB4F _glVertexAttrib4f_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glVertexAttrib4f";
    if (!_glVertexAttrib4f_ptr) {
        _glVertexAttrib4f_ptr = (PFN_GLVERTEXATTRIB4F)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4f_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4FV)(GLuint index, const GLfloat * v);
static PFN_GLVERTEXATTRIB4FV _glVertexAttrib4fv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4fv(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib4fv";
    if (!_glVertexAttrib4fv_ptr) {
        _glVertexAttrib4fv_ptr = (PFN_GLVERTEXATTRIB4FV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4fv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4IV)(GLuint index, const GLint * v);
static PFN_GLVERTEXATTRIB4IV _glVertexAttrib4iv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4iv(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttrib4iv";
    if (!_glVertexAttrib4iv_ptr) {
        _glVertexAttrib4iv_ptr = (PFN_GLVERTEXATTRIB4IV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4iv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4S)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
static PFN_GLVERTEXATTRIB4S _glVertexAttrib4s_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glVertexAttrib4s";
    if (!_glVertexAttrib4s_ptr) {
        _glVertexAttrib4s_ptr = (PFN_GLVERTEXATTRIB4S)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4s_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4s_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4SV)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB4SV _glVertexAttrib4sv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4sv(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib4sv";
    if (!_glVertexAttrib4sv_ptr) {
        _glVertexAttrib4sv_ptr = (PFN_GLVERTEXATTRIB4SV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4sv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4UBV)(GLuint index, const GLubyte * v);
static PFN_GLVERTEXATTRIB4UBV _glVertexAttrib4ubv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4ubv(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttrib4ubv";
    if (!_glVertexAttrib4ubv_ptr) {
        _glVertexAttrib4ubv_ptr = (PFN_GLVERTEXATTRIB4UBV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4ubv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4ubv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4UIV)(GLuint index, const GLuint * v);
static PFN_GLVERTEXATTRIB4UIV _glVertexAttrib4uiv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4uiv(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttrib4uiv";
    if (!_glVertexAttrib4uiv_ptr) {
        _glVertexAttrib4uiv_ptr = (PFN_GLVERTEXATTRIB4UIV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4uiv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4USV)(GLuint index, const GLushort * v);
static PFN_GLVERTEXATTRIB4USV _glVertexAttrib4usv_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4usv(GLuint index, const GLushort * v) {
    const char *_name = "glVertexAttrib4usv";
    if (!_glVertexAttrib4usv_ptr) {
        _glVertexAttrib4usv_ptr = (PFN_GLVERTEXATTRIB4USV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4usv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4usv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBPOINTER)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer);
static PFN_GLVERTEXATTRIBPOINTER _glVertexAttribPointer_ptr = NULL;

static inline void APIENTRY _glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribPointer";
    if (!_glVertexAttribPointer_ptr) {
        _glVertexAttribPointer_ptr = (PFN_GLVERTEXATTRIBPOINTER)_getPrivateProcAddress(_name);
        if (!_glVertexAttribPointer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribPointer_ptr(index, size, type, normalized, stride, pointer);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX2X3FV)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLUNIFORMMATRIX2X3FV _glUniformMatrix2x3fv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix2x3fv";
    if (!_glUniformMatrix2x3fv_ptr) {
        _glUniformMatrix2x3fv_ptr = (PFN_GLUNIFORMMATRIX2X3FV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix2x3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix2x3fv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX3X2FV)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLUNIFORMMATRIX3X2FV _glUniformMatrix3x2fv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix3x2fv";
    if (!_glUniformMatrix3x2fv_ptr) {
        _glUniformMatrix3x2fv_ptr = (PFN_GLUNIFORMMATRIX3X2FV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix3x2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix3x2fv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX2X4FV)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLUNIFORMMATRIX2X4FV _glUniformMatrix2x4fv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix2x4fv";
    if (!_glUniformMatrix2x4fv_ptr) {
        _glUniformMatrix2x4fv_ptr = (PFN_GLUNIFORMMATRIX2X4FV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix2x4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix2x4fv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX4X2FV)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLUNIFORMMATRIX4X2FV _glUniformMatrix4x2fv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix4x2fv";
    if (!_glUniformMatrix4x2fv_ptr) {
        _glUniformMatrix4x2fv_ptr = (PFN_GLUNIFORMMATRIX4X2FV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix4x2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix4x2fv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX3X4FV)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLUNIFORMMATRIX3X4FV _glUniformMatrix3x4fv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix3x4fv";
    if (!_glUniformMatrix3x4fv_ptr) {
        _glUniformMatrix3x4fv_ptr = (PFN_GLUNIFORMMATRIX3X4FV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix3x4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix3x4fv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX4X3FV)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLUNIFORMMATRIX4X3FV _glUniformMatrix4x3fv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix4x3fv";
    if (!_glUniformMatrix4x3fv_ptr) {
        _glUniformMatrix4x3fv_ptr = (PFN_GLUNIFORMMATRIX4X3FV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix4x3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix4x3fv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLCOLORMASKI)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
static PFN_GLCOLORMASKI _glColorMaski_ptr = NULL;

static inline void APIENTRY _glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
    const char *_name = "glColorMaski";
    if (!_glColorMaski_ptr) {
        _glColorMaski_ptr = (PFN_GLCOLORMASKI)_getPrivateProcAddress(_name);
        if (!_glColorMaski_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorMaski_ptr(index, r, g, b, a);
}

typedef void (APIENTRY * PFN_GLGETBOOLEANI_V)(GLenum target, GLuint index, GLboolean * data);
static PFN_GLGETBOOLEANI_V _glGetBooleani_v_ptr = NULL;

static inline void APIENTRY _glGetBooleani_v(GLenum target, GLuint index, GLboolean * data) {
    const char *_name = "glGetBooleani_v";
    if (!_glGetBooleani_v_ptr) {
        _glGetBooleani_v_ptr = (PFN_GLGETBOOLEANI_V)_getPrivateProcAddress(_name);
        if (!_glGetBooleani_v_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetBooleani_v_ptr(target, index, data);
}

typedef void (APIENTRY * PFN_GLGETINTEGERI_V)(GLenum target, GLuint index, GLint * data);
static PFN_GLGETINTEGERI_V _glGetIntegeri_v_ptr = NULL;

static inline void APIENTRY _glGetIntegeri_v(GLenum target, GLuint index, GLint * data) {
    const char *_name = "glGetIntegeri_v";
    if (!_glGetIntegeri_v_ptr) {
        _glGetIntegeri_v_ptr = (PFN_GLGETINTEGERI_V)_getPrivateProcAddress(_name);
        if (!_glGetIntegeri_v_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetIntegeri_v_ptr(target, index, data);
}

typedef void (APIENTRY * PFN_GLENABLEI)(GLenum target, GLuint index);
static PFN_GLENABLEI _glEnablei_ptr = NULL;

static inline void APIENTRY _glEnablei(GLenum target, GLuint index) {
    const char *_name = "glEnablei";
    if (!_glEnablei_ptr) {
        _glEnablei_ptr = (PFN_GLENABLEI)_getPrivateProcAddress(_name);
        if (!_glEnablei_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEnablei_ptr(target, index);
}

typedef void (APIENTRY * PFN_GLDISABLEI)(GLenum target, GLuint index);
static PFN_GLDISABLEI _glDisablei_ptr = NULL;

static inline void APIENTRY _glDisablei(GLenum target, GLuint index) {
    const char *_name = "glDisablei";
    if (!_glDisablei_ptr) {
        _glDisablei_ptr = (PFN_GLDISABLEI)_getPrivateProcAddress(_name);
        if (!_glDisablei_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDisablei_ptr(target, index);
}

typedef GLboolean (APIENTRY * PFN_GLISENABLEDI)(GLenum target, GLuint index);
static PFN_GLISENABLEDI _glIsEnabledi_ptr = NULL;

static inline GLboolean APIENTRY _glIsEnabledi(GLenum target, GLuint index) {
    const char *_name = "glIsEnabledi";
    if (!_glIsEnabledi_ptr) {
        _glIsEnabledi_ptr = (PFN_GLISENABLEDI)_getPrivateProcAddress(_name);
        if (!_glIsEnabledi_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsEnabledi_ptr(target, index);
}

typedef void (APIENTRY * PFN_GLBEGINTRANSFORMFEEDBACK)(GLenum primitiveMode);
static PFN_GLBEGINTRANSFORMFEEDBACK _glBeginTransformFeedback_ptr = NULL;

static inline void APIENTRY _glBeginTransformFeedback(GLenum primitiveMode) {
    const char *_name = "glBeginTransformFeedback";
    if (!_glBeginTransformFeedback_ptr) {
        _glBeginTransformFeedback_ptr = (PFN_GLBEGINTRANSFORMFEEDBACK)_getPrivateProcAddress(_name);
        if (!_glBeginTransformFeedback_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginTransformFeedback_ptr(primitiveMode);
}

typedef void (APIENTRY * PFN_GLENDTRANSFORMFEEDBACK)(void);
static PFN_GLENDTRANSFORMFEEDBACK _glEndTransformFeedback_ptr = NULL;

static inline void APIENTRY _glEndTransformFeedback(void) {
    const char *_name = "glEndTransformFeedback";
    if (!_glEndTransformFeedback_ptr) {
        _glEndTransformFeedback_ptr = (PFN_GLENDTRANSFORMFEEDBACK)_getPrivateProcAddress(_name);
        if (!_glEndTransformFeedback_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndTransformFeedback_ptr();
}

typedef void (APIENTRY * PFN_GLBINDBUFFERRANGE)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
static PFN_GLBINDBUFFERRANGE _glBindBufferRange_ptr = NULL;

static inline void APIENTRY _glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glBindBufferRange";
    if (!_glBindBufferRange_ptr) {
        _glBindBufferRange_ptr = (PFN_GLBINDBUFFERRANGE)_getPrivateProcAddress(_name);
        if (!_glBindBufferRange_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindBufferRange_ptr(target, index, buffer, offset, size);
}

typedef void (APIENTRY * PFN_GLBINDBUFFERBASE)(GLenum target, GLuint index, GLuint buffer);
static PFN_GLBINDBUFFERBASE _glBindBufferBase_ptr = NULL;

static inline void APIENTRY _glBindBufferBase(GLenum target, GLuint index, GLuint buffer) {
    const char *_name = "glBindBufferBase";
    if (!_glBindBufferBase_ptr) {
        _glBindBufferBase_ptr = (PFN_GLBINDBUFFERBASE)_getPrivateProcAddress(_name);
        if (!_glBindBufferBase_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindBufferBase_ptr(target, index, buffer);
}

typedef void (APIENTRY * PFN_GLTRANSFORMFEEDBACKVARYINGS)(GLuint program, GLsizei count, const GLchar * const * varyings, GLenum bufferMode);
static PFN_GLTRANSFORMFEEDBACKVARYINGS _glTransformFeedbackVaryings_ptr = NULL;

static inline void APIENTRY _glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar * const * varyings, GLenum bufferMode) {
    const char *_name = "glTransformFeedbackVaryings";
    if (!_glTransformFeedbackVaryings_ptr) {
        _glTransformFeedbackVaryings_ptr = (PFN_GLTRANSFORMFEEDBACKVARYINGS)_getPrivateProcAddress(_name);
        if (!_glTransformFeedbackVaryings_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTransformFeedbackVaryings_ptr(program, count, varyings, bufferMode);
}

typedef void (APIENTRY * PFN_GLGETTRANSFORMFEEDBACKVARYING)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
static PFN_GLGETTRANSFORMFEEDBACKVARYING _glGetTransformFeedbackVarying_ptr = NULL;

static inline void APIENTRY _glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name) {
    const char *_name = "glGetTransformFeedbackVarying";
    if (!_glGetTransformFeedbackVarying_ptr) {
        _glGetTransformFeedbackVarying_ptr = (PFN_GLGETTRANSFORMFEEDBACKVARYING)_getPrivateProcAddress(_name);
        if (!_glGetTransformFeedbackVarying_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTransformFeedbackVarying_ptr(program, index, bufSize, length, size, type, name);
}

typedef void (APIENTRY * PFN_GLCLAMPCOLOR)(GLenum target, GLenum clamp);
static PFN_GLCLAMPCOLOR _glClampColor_ptr = NULL;

static inline void APIENTRY _glClampColor(GLenum target, GLenum clamp) {
    const char *_name = "glClampColor";
    if (!_glClampColor_ptr) {
        _glClampColor_ptr = (PFN_GLCLAMPCOLOR)_getPrivateProcAddress(_name);
        if (!_glClampColor_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClampColor_ptr(target, clamp);
}

typedef void (APIENTRY * PFN_GLBEGINCONDITIONALRENDER)(GLuint id, GLenum mode);
static PFN_GLBEGINCONDITIONALRENDER _glBeginConditionalRender_ptr = NULL;

static inline void APIENTRY _glBeginConditionalRender(GLuint id, GLenum mode) {
    const char *_name = "glBeginConditionalRender";
    if (!_glBeginConditionalRender_ptr) {
        _glBeginConditionalRender_ptr = (PFN_GLBEGINCONDITIONALRENDER)_getPrivateProcAddress(_name);
        if (!_glBeginConditionalRender_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginConditionalRender_ptr(id, mode);
}

typedef void (APIENTRY * PFN_GLENDCONDITIONALRENDER)(void);
static PFN_GLENDCONDITIONALRENDER _glEndConditionalRender_ptr = NULL;

static inline void APIENTRY _glEndConditionalRender(void) {
    const char *_name = "glEndConditionalRender";
    if (!_glEndConditionalRender_ptr) {
        _glEndConditionalRender_ptr = (PFN_GLENDCONDITIONALRENDER)_getPrivateProcAddress(_name);
        if (!_glEndConditionalRender_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndConditionalRender_ptr();
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBIPOINTER)(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLVERTEXATTRIBIPOINTER _glVertexAttribIPointer_ptr = NULL;

static inline void APIENTRY _glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribIPointer";
    if (!_glVertexAttribIPointer_ptr) {
        _glVertexAttribIPointer_ptr = (PFN_GLVERTEXATTRIBIPOINTER)_getPrivateProcAddress(_name);
        if (!_glVertexAttribIPointer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribIPointer_ptr(index, size, type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBIIV)(GLuint index, GLenum pname, GLint * params);
static PFN_GLGETVERTEXATTRIBIIV _glGetVertexAttribIiv_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribIiv(GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetVertexAttribIiv";
    if (!_glGetVertexAttribIiv_ptr) {
        _glGetVertexAttribIiv_ptr = (PFN_GLGETVERTEXATTRIBIIV)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribIiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribIiv_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBIUIV)(GLuint index, GLenum pname, GLuint * params);
static PFN_GLGETVERTEXATTRIBIUIV _glGetVertexAttribIuiv_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint * params) {
    const char *_name = "glGetVertexAttribIuiv";
    if (!_glGetVertexAttribIuiv_ptr) {
        _glGetVertexAttribIuiv_ptr = (PFN_GLGETVERTEXATTRIBIUIV)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribIuiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribIuiv_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI1I)(GLuint index, GLint x);
static PFN_GLVERTEXATTRIBI1I _glVertexAttribI1i_ptr = NULL;

static inline void APIENTRY _glVertexAttribI1i(GLuint index, GLint x) {
    const char *_name = "glVertexAttribI1i";
    if (!_glVertexAttribI1i_ptr) {
        _glVertexAttribI1i_ptr = (PFN_GLVERTEXATTRIBI1I)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI1i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI1i_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI2I)(GLuint index, GLint x, GLint y);
static PFN_GLVERTEXATTRIBI2I _glVertexAttribI2i_ptr = NULL;

static inline void APIENTRY _glVertexAttribI2i(GLuint index, GLint x, GLint y) {
    const char *_name = "glVertexAttribI2i";
    if (!_glVertexAttribI2i_ptr) {
        _glVertexAttribI2i_ptr = (PFN_GLVERTEXATTRIBI2I)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI2i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI2i_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI3I)(GLuint index, GLint x, GLint y, GLint z);
static PFN_GLVERTEXATTRIBI3I _glVertexAttribI3i_ptr = NULL;

static inline void APIENTRY _glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z) {
    const char *_name = "glVertexAttribI3i";
    if (!_glVertexAttribI3i_ptr) {
        _glVertexAttribI3i_ptr = (PFN_GLVERTEXATTRIBI3I)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI3i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI3i_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4I)(GLuint index, GLint x, GLint y, GLint z, GLint w);
static PFN_GLVERTEXATTRIBI4I _glVertexAttribI4i_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glVertexAttribI4i";
    if (!_glVertexAttribI4i_ptr) {
        _glVertexAttribI4i_ptr = (PFN_GLVERTEXATTRIBI4I)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4i_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI1UI)(GLuint index, GLuint x);
static PFN_GLVERTEXATTRIBI1UI _glVertexAttribI1ui_ptr = NULL;

static inline void APIENTRY _glVertexAttribI1ui(GLuint index, GLuint x) {
    const char *_name = "glVertexAttribI1ui";
    if (!_glVertexAttribI1ui_ptr) {
        _glVertexAttribI1ui_ptr = (PFN_GLVERTEXATTRIBI1UI)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI1ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI1ui_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI2UI)(GLuint index, GLuint x, GLuint y);
static PFN_GLVERTEXATTRIBI2UI _glVertexAttribI2ui_ptr = NULL;

static inline void APIENTRY _glVertexAttribI2ui(GLuint index, GLuint x, GLuint y) {
    const char *_name = "glVertexAttribI2ui";
    if (!_glVertexAttribI2ui_ptr) {
        _glVertexAttribI2ui_ptr = (PFN_GLVERTEXATTRIBI2UI)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI2ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI2ui_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI3UI)(GLuint index, GLuint x, GLuint y, GLuint z);
static PFN_GLVERTEXATTRIBI3UI _glVertexAttribI3ui_ptr = NULL;

static inline void APIENTRY _glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z) {
    const char *_name = "glVertexAttribI3ui";
    if (!_glVertexAttribI3ui_ptr) {
        _glVertexAttribI3ui_ptr = (PFN_GLVERTEXATTRIBI3UI)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI3ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI3ui_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4UI)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
static PFN_GLVERTEXATTRIBI4UI _glVertexAttribI4ui_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    const char *_name = "glVertexAttribI4ui";
    if (!_glVertexAttribI4ui_ptr) {
        _glVertexAttribI4ui_ptr = (PFN_GLVERTEXATTRIBI4UI)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4ui_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI1IV)(GLuint index, const GLint * v);
static PFN_GLVERTEXATTRIBI1IV _glVertexAttribI1iv_ptr = NULL;

static inline void APIENTRY _glVertexAttribI1iv(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI1iv";
    if (!_glVertexAttribI1iv_ptr) {
        _glVertexAttribI1iv_ptr = (PFN_GLVERTEXATTRIBI1IV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI1iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI1iv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI2IV)(GLuint index, const GLint * v);
static PFN_GLVERTEXATTRIBI2IV _glVertexAttribI2iv_ptr = NULL;

static inline void APIENTRY _glVertexAttribI2iv(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI2iv";
    if (!_glVertexAttribI2iv_ptr) {
        _glVertexAttribI2iv_ptr = (PFN_GLVERTEXATTRIBI2IV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI2iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI2iv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI3IV)(GLuint index, const GLint * v);
static PFN_GLVERTEXATTRIBI3IV _glVertexAttribI3iv_ptr = NULL;

static inline void APIENTRY _glVertexAttribI3iv(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI3iv";
    if (!_glVertexAttribI3iv_ptr) {
        _glVertexAttribI3iv_ptr = (PFN_GLVERTEXATTRIBI3IV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI3iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI3iv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4IV)(GLuint index, const GLint * v);
static PFN_GLVERTEXATTRIBI4IV _glVertexAttribI4iv_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4iv(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI4iv";
    if (!_glVertexAttribI4iv_ptr) {
        _glVertexAttribI4iv_ptr = (PFN_GLVERTEXATTRIBI4IV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4iv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI1UIV)(GLuint index, const GLuint * v);
static PFN_GLVERTEXATTRIBI1UIV _glVertexAttribI1uiv_ptr = NULL;

static inline void APIENTRY _glVertexAttribI1uiv(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI1uiv";
    if (!_glVertexAttribI1uiv_ptr) {
        _glVertexAttribI1uiv_ptr = (PFN_GLVERTEXATTRIBI1UIV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI1uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI1uiv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI2UIV)(GLuint index, const GLuint * v);
static PFN_GLVERTEXATTRIBI2UIV _glVertexAttribI2uiv_ptr = NULL;

static inline void APIENTRY _glVertexAttribI2uiv(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI2uiv";
    if (!_glVertexAttribI2uiv_ptr) {
        _glVertexAttribI2uiv_ptr = (PFN_GLVERTEXATTRIBI2UIV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI2uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI2uiv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI3UIV)(GLuint index, const GLuint * v);
static PFN_GLVERTEXATTRIBI3UIV _glVertexAttribI3uiv_ptr = NULL;

static inline void APIENTRY _glVertexAttribI3uiv(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI3uiv";
    if (!_glVertexAttribI3uiv_ptr) {
        _glVertexAttribI3uiv_ptr = (PFN_GLVERTEXATTRIBI3UIV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI3uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI3uiv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4UIV)(GLuint index, const GLuint * v);
static PFN_GLVERTEXATTRIBI4UIV _glVertexAttribI4uiv_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4uiv(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI4uiv";
    if (!_glVertexAttribI4uiv_ptr) {
        _glVertexAttribI4uiv_ptr = (PFN_GLVERTEXATTRIBI4UIV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4uiv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4BV)(GLuint index, const GLbyte * v);
static PFN_GLVERTEXATTRIBI4BV _glVertexAttribI4bv_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4bv(GLuint index, const GLbyte * v) {
    const char *_name = "glVertexAttribI4bv";
    if (!_glVertexAttribI4bv_ptr) {
        _glVertexAttribI4bv_ptr = (PFN_GLVERTEXATTRIBI4BV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4bv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4bv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4SV)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIBI4SV _glVertexAttribI4sv_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4sv(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttribI4sv";
    if (!_glVertexAttribI4sv_ptr) {
        _glVertexAttribI4sv_ptr = (PFN_GLVERTEXATTRIBI4SV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4sv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4sv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4UBV)(GLuint index, const GLubyte * v);
static PFN_GLVERTEXATTRIBI4UBV _glVertexAttribI4ubv_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4ubv(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttribI4ubv";
    if (!_glVertexAttribI4ubv_ptr) {
        _glVertexAttribI4ubv_ptr = (PFN_GLVERTEXATTRIBI4UBV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4ubv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4ubv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4USV)(GLuint index, const GLushort * v);
static PFN_GLVERTEXATTRIBI4USV _glVertexAttribI4usv_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4usv(GLuint index, const GLushort * v) {
    const char *_name = "glVertexAttribI4usv";
    if (!_glVertexAttribI4usv_ptr) {
        _glVertexAttribI4usv_ptr = (PFN_GLVERTEXATTRIBI4USV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4usv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4usv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLGETUNIFORMUIV)(GLuint program, GLint location, GLuint * params);
static PFN_GLGETUNIFORMUIV _glGetUniformuiv_ptr = NULL;

static inline void APIENTRY _glGetUniformuiv(GLuint program, GLint location, GLuint * params) {
    const char *_name = "glGetUniformuiv";
    if (!_glGetUniformuiv_ptr) {
        _glGetUniformuiv_ptr = (PFN_GLGETUNIFORMUIV)_getPrivateProcAddress(_name);
        if (!_glGetUniformuiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetUniformuiv_ptr(program, location, params);
}

typedef void (APIENTRY * PFN_GLBINDFRAGDATALOCATION)(GLuint program, GLuint color, const GLchar * name);
static PFN_GLBINDFRAGDATALOCATION _glBindFragDataLocation_ptr = NULL;

static inline void APIENTRY _glBindFragDataLocation(GLuint program, GLuint color, const GLchar * name) {
    const char *_name = "glBindFragDataLocation";
    if (!_glBindFragDataLocation_ptr) {
        _glBindFragDataLocation_ptr = (PFN_GLBINDFRAGDATALOCATION)_getPrivateProcAddress(_name);
        if (!_glBindFragDataLocation_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindFragDataLocation_ptr(program, color, name);
}

typedef GLint (APIENTRY * PFN_GLGETFRAGDATALOCATION)(GLuint program, const GLchar * name);
static PFN_GLGETFRAGDATALOCATION _glGetFragDataLocation_ptr = NULL;

static inline GLint APIENTRY _glGetFragDataLocation(GLuint program, const GLchar * name) {
    const char *_name = "glGetFragDataLocation";
    if (!_glGetFragDataLocation_ptr) {
        _glGetFragDataLocation_ptr = (PFN_GLGETFRAGDATALOCATION)_getPrivateProcAddress(_name);
        if (!_glGetFragDataLocation_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetFragDataLocation_ptr(program, name);
}

typedef void (APIENTRY * PFN_GLUNIFORM1UI)(GLint location, GLuint v0);
static PFN_GLUNIFORM1UI _glUniform1ui_ptr = NULL;

static inline void APIENTRY _glUniform1ui(GLint location, GLuint v0) {
    const char *_name = "glUniform1ui";
    if (!_glUniform1ui_ptr) {
        _glUniform1ui_ptr = (PFN_GLUNIFORM1UI)_getPrivateProcAddress(_name);
        if (!_glUniform1ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1ui_ptr(location, v0);
}

typedef void (APIENTRY * PFN_GLUNIFORM2UI)(GLint location, GLuint v0, GLuint v1);
static PFN_GLUNIFORM2UI _glUniform2ui_ptr = NULL;

static inline void APIENTRY _glUniform2ui(GLint location, GLuint v0, GLuint v1) {
    const char *_name = "glUniform2ui";
    if (!_glUniform2ui_ptr) {
        _glUniform2ui_ptr = (PFN_GLUNIFORM2UI)_getPrivateProcAddress(_name);
        if (!_glUniform2ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2ui_ptr(location, v0, v1);
}

typedef void (APIENTRY * PFN_GLUNIFORM3UI)(GLint location, GLuint v0, GLuint v1, GLuint v2);
static PFN_GLUNIFORM3UI _glUniform3ui_ptr = NULL;

static inline void APIENTRY _glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2) {
    const char *_name = "glUniform3ui";
    if (!_glUniform3ui_ptr) {
        _glUniform3ui_ptr = (PFN_GLUNIFORM3UI)_getPrivateProcAddress(_name);
        if (!_glUniform3ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3ui_ptr(location, v0, v1, v2);
}

typedef void (APIENTRY * PFN_GLUNIFORM4UI)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
static PFN_GLUNIFORM4UI _glUniform4ui_ptr = NULL;

static inline void APIENTRY _glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
    const char *_name = "glUniform4ui";
    if (!_glUniform4ui_ptr) {
        _glUniform4ui_ptr = (PFN_GLUNIFORM4UI)_getPrivateProcAddress(_name);
        if (!_glUniform4ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4ui_ptr(location, v0, v1, v2, v3);
}

typedef void (APIENTRY * PFN_GLUNIFORM1UIV)(GLint location, GLsizei count, const GLuint * value);
static PFN_GLUNIFORM1UIV _glUniform1uiv_ptr = NULL;

static inline void APIENTRY _glUniform1uiv(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform1uiv";
    if (!_glUniform1uiv_ptr) {
        _glUniform1uiv_ptr = (PFN_GLUNIFORM1UIV)_getPrivateProcAddress(_name);
        if (!_glUniform1uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1uiv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM2UIV)(GLint location, GLsizei count, const GLuint * value);
static PFN_GLUNIFORM2UIV _glUniform2uiv_ptr = NULL;

static inline void APIENTRY _glUniform2uiv(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform2uiv";
    if (!_glUniform2uiv_ptr) {
        _glUniform2uiv_ptr = (PFN_GLUNIFORM2UIV)_getPrivateProcAddress(_name);
        if (!_glUniform2uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2uiv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM3UIV)(GLint location, GLsizei count, const GLuint * value);
static PFN_GLUNIFORM3UIV _glUniform3uiv_ptr = NULL;

static inline void APIENTRY _glUniform3uiv(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform3uiv";
    if (!_glUniform3uiv_ptr) {
        _glUniform3uiv_ptr = (PFN_GLUNIFORM3UIV)_getPrivateProcAddress(_name);
        if (!_glUniform3uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3uiv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM4UIV)(GLint location, GLsizei count, const GLuint * value);
static PFN_GLUNIFORM4UIV _glUniform4uiv_ptr = NULL;

static inline void APIENTRY _glUniform4uiv(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform4uiv";
    if (!_glUniform4uiv_ptr) {
        _glUniform4uiv_ptr = (PFN_GLUNIFORM4UIV)_getPrivateProcAddress(_name);
        if (!_glUniform4uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4uiv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLTEXPARAMETERIIV)(GLenum target, GLenum pname, const GLint * params);
static PFN_GLTEXPARAMETERIIV _glTexParameterIiv_ptr = NULL;

static inline void APIENTRY _glTexParameterIiv(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glTexParameterIiv";
    if (!_glTexParameterIiv_ptr) {
        _glTexParameterIiv_ptr = (PFN_GLTEXPARAMETERIIV)_getPrivateProcAddress(_name);
        if (!_glTexParameterIiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexParameterIiv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLTEXPARAMETERIUIV)(GLenum target, GLenum pname, const GLuint * params);
static PFN_GLTEXPARAMETERIUIV _glTexParameterIuiv_ptr = NULL;

static inline void APIENTRY _glTexParameterIuiv(GLenum target, GLenum pname, const GLuint * params) {
    const char *_name = "glTexParameterIuiv";
    if (!_glTexParameterIuiv_ptr) {
        _glTexParameterIuiv_ptr = (PFN_GLTEXPARAMETERIUIV)_getPrivateProcAddress(_name);
        if (!_glTexParameterIuiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexParameterIuiv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXPARAMETERIIV)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETTEXPARAMETERIIV _glGetTexParameterIiv_ptr = NULL;

static inline void APIENTRY _glGetTexParameterIiv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetTexParameterIiv";
    if (!_glGetTexParameterIiv_ptr) {
        _glGetTexParameterIiv_ptr = (PFN_GLGETTEXPARAMETERIIV)_getPrivateProcAddress(_name);
        if (!_glGetTexParameterIiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexParameterIiv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXPARAMETERIUIV)(GLenum target, GLenum pname, GLuint * params);
static PFN_GLGETTEXPARAMETERIUIV _glGetTexParameterIuiv_ptr = NULL;

static inline void APIENTRY _glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint * params) {
    const char *_name = "glGetTexParameterIuiv";
    if (!_glGetTexParameterIuiv_ptr) {
        _glGetTexParameterIuiv_ptr = (PFN_GLGETTEXPARAMETERIUIV)_getPrivateProcAddress(_name);
        if (!_glGetTexParameterIuiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexParameterIuiv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCLEARBUFFERIV)(GLenum buffer, GLint drawbuffer, const GLint * value);
static PFN_GLCLEARBUFFERIV _glClearBufferiv_ptr = NULL;

static inline void APIENTRY _glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint * value) {
    const char *_name = "glClearBufferiv";
    if (!_glClearBufferiv_ptr) {
        _glClearBufferiv_ptr = (PFN_GLCLEARBUFFERIV)_getPrivateProcAddress(_name);
        if (!_glClearBufferiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearBufferiv_ptr(buffer, drawbuffer, value);
}

typedef void (APIENTRY * PFN_GLCLEARBUFFERUIV)(GLenum buffer, GLint drawbuffer, const GLuint * value);
static PFN_GLCLEARBUFFERUIV _glClearBufferuiv_ptr = NULL;

static inline void APIENTRY _glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint * value) {
    const char *_name = "glClearBufferuiv";
    if (!_glClearBufferuiv_ptr) {
        _glClearBufferuiv_ptr = (PFN_GLCLEARBUFFERUIV)_getPrivateProcAddress(_name);
        if (!_glClearBufferuiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearBufferuiv_ptr(buffer, drawbuffer, value);
}

typedef void (APIENTRY * PFN_GLCLEARBUFFERFV)(GLenum buffer, GLint drawbuffer, const GLfloat * value);
static PFN_GLCLEARBUFFERFV _glClearBufferfv_ptr = NULL;

static inline void APIENTRY _glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat * value) {
    const char *_name = "glClearBufferfv";
    if (!_glClearBufferfv_ptr) {
        _glClearBufferfv_ptr = (PFN_GLCLEARBUFFERFV)_getPrivateProcAddress(_name);
        if (!_glClearBufferfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearBufferfv_ptr(buffer, drawbuffer, value);
}

typedef void (APIENTRY * PFN_GLCLEARBUFFERFI)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
static PFN_GLCLEARBUFFERFI _glClearBufferfi_ptr = NULL;

static inline void APIENTRY _glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) {
    const char *_name = "glClearBufferfi";
    if (!_glClearBufferfi_ptr) {
        _glClearBufferfi_ptr = (PFN_GLCLEARBUFFERFI)_getPrivateProcAddress(_name);
        if (!_glClearBufferfi_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearBufferfi_ptr(buffer, drawbuffer, depth, stencil);
}

typedef const GLubyte * (APIENTRY * PFN_GLGETSTRINGI)(GLenum name, GLuint index);
static PFN_GLGETSTRINGI _glGetStringi_ptr = NULL;

static inline const GLubyte * APIENTRY _glGetStringi(GLenum name, GLuint index) {
    const char *_name = "glGetStringi";
    if (!_glGetStringi_ptr) {
        _glGetStringi_ptr = (PFN_GLGETSTRINGI)_getPrivateProcAddress(_name);
        if (!_glGetStringi_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetStringi_ptr(name, index);
}

typedef void (APIENTRY * PFN_GLDRAWARRAYSINSTANCED)(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
static PFN_GLDRAWARRAYSINSTANCED _glDrawArraysInstanced_ptr = NULL;

static inline void APIENTRY _glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount) {
    const char *_name = "glDrawArraysInstanced";
    if (!_glDrawArraysInstanced_ptr) {
        _glDrawArraysInstanced_ptr = (PFN_GLDRAWARRAYSINSTANCED)_getPrivateProcAddress(_name);
        if (!_glDrawArraysInstanced_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawArraysInstanced_ptr(mode, first, count, primcount);
}

typedef void (APIENTRY * PFN_GLDRAWELEMENTSINSTANCED)(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount);
static PFN_GLDRAWELEMENTSINSTANCED _glDrawElementsInstanced_ptr = NULL;

static inline void APIENTRY _glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount) {
    const char *_name = "glDrawElementsInstanced";
    if (!_glDrawElementsInstanced_ptr) {
        _glDrawElementsInstanced_ptr = (PFN_GLDRAWELEMENTSINSTANCED)_getPrivateProcAddress(_name);
        if (!_glDrawElementsInstanced_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawElementsInstanced_ptr(mode, count, type, indices, primcount);
}

typedef void (APIENTRY * PFN_GLTEXBUFFER)(GLenum target, GLenum internalformat, GLuint buffer);
static PFN_GLTEXBUFFER _glTexBuffer_ptr = NULL;

static inline void APIENTRY _glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer) {
    const char *_name = "glTexBuffer";
    if (!_glTexBuffer_ptr) {
        _glTexBuffer_ptr = (PFN_GLTEXBUFFER)_getPrivateProcAddress(_name);
        if (!_glTexBuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexBuffer_ptr(target, internalformat, buffer);
}

typedef void (APIENTRY * PFN_GLPRIMITIVERESTARTINDEX)(GLuint index);
static PFN_GLPRIMITIVERESTARTINDEX _glPrimitiveRestartIndex_ptr = NULL;

static inline void APIENTRY _glPrimitiveRestartIndex(GLuint index) {
    const char *_name = "glPrimitiveRestartIndex";
    if (!_glPrimitiveRestartIndex_ptr) {
        _glPrimitiveRestartIndex_ptr = (PFN_GLPRIMITIVERESTARTINDEX)_getPrivateProcAddress(_name);
        if (!_glPrimitiveRestartIndex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPrimitiveRestartIndex_ptr(index);
}

typedef void (APIENTRY * PFN_GLGETINTEGER64I_V)(GLenum target, GLuint index, GLint64 * data);
static PFN_GLGETINTEGER64I_V _glGetInteger64i_v_ptr = NULL;

static inline void APIENTRY _glGetInteger64i_v(GLenum target, GLuint index, GLint64 * data) {
    const char *_name = "glGetInteger64i_v";
    if (!_glGetInteger64i_v_ptr) {
        _glGetInteger64i_v_ptr = (PFN_GLGETINTEGER64I_V)_getPrivateProcAddress(_name);
        if (!_glGetInteger64i_v_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetInteger64i_v_ptr(target, index, data);
}

typedef void (APIENTRY * PFN_GLGETBUFFERPARAMETERI64V)(GLenum target, GLenum pname, GLint64 * params);
static PFN_GLGETBUFFERPARAMETERI64V _glGetBufferParameteri64v_ptr = NULL;

static inline void APIENTRY _glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64 * params) {
    const char *_name = "glGetBufferParameteri64v";
    if (!_glGetBufferParameteri64v_ptr) {
        _glGetBufferParameteri64v_ptr = (PFN_GLGETBUFFERPARAMETERI64V)_getPrivateProcAddress(_name);
        if (!_glGetBufferParameteri64v_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetBufferParameteri64v_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTURE)(GLenum target, GLenum attachment, GLuint texture, GLint level);
static PFN_GLFRAMEBUFFERTEXTURE _glFramebufferTexture_ptr = NULL;

static inline void APIENTRY _glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTexture";
    if (!_glFramebufferTexture_ptr) {
        _glFramebufferTexture_ptr = (PFN_GLFRAMEBUFFERTEXTURE)_getPrivateProcAddress(_name);
        if (!_glFramebufferTexture_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTexture_ptr(target, attachment, texture, level);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBDIVISOR)(GLuint index, GLuint divisor);
static PFN_GLVERTEXATTRIBDIVISOR _glVertexAttribDivisor_ptr = NULL;

static inline void APIENTRY _glVertexAttribDivisor(GLuint index, GLuint divisor) {
    const char *_name = "glVertexAttribDivisor";
    if (!_glVertexAttribDivisor_ptr) {
        _glVertexAttribDivisor_ptr = (PFN_GLVERTEXATTRIBDIVISOR)_getPrivateProcAddress(_name);
        if (!_glVertexAttribDivisor_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribDivisor_ptr(index, divisor);
}

typedef void (APIENTRY * PFN_GLMINSAMPLESHADING)(GLfloat value);
static PFN_GLMINSAMPLESHADING _glMinSampleShading_ptr = NULL;

static inline void APIENTRY _glMinSampleShading(GLfloat value) {
    const char *_name = "glMinSampleShading";
    if (!_glMinSampleShading_ptr) {
        _glMinSampleShading_ptr = (PFN_GLMINSAMPLESHADING)_getPrivateProcAddress(_name);
        if (!_glMinSampleShading_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMinSampleShading_ptr(value);
}

typedef void (APIENTRY * PFN_GLBLENDEQUATIONI)(GLuint buf, GLenum mode);
static PFN_GLBLENDEQUATIONI _glBlendEquationi_ptr = NULL;

static inline void APIENTRY _glBlendEquationi(GLuint buf, GLenum mode) {
    const char *_name = "glBlendEquationi";
    if (!_glBlendEquationi_ptr) {
        _glBlendEquationi_ptr = (PFN_GLBLENDEQUATIONI)_getPrivateProcAddress(_name);
        if (!_glBlendEquationi_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendEquationi_ptr(buf, mode);
}

typedef void (APIENTRY * PFN_GLBLENDEQUATIONSEPARATEI)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
static PFN_GLBLENDEQUATIONSEPARATEI _glBlendEquationSeparatei_ptr = NULL;

static inline void APIENTRY _glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha) {
    const char *_name = "glBlendEquationSeparatei";
    if (!_glBlendEquationSeparatei_ptr) {
        _glBlendEquationSeparatei_ptr = (PFN_GLBLENDEQUATIONSEPARATEI)_getPrivateProcAddress(_name);
        if (!_glBlendEquationSeparatei_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendEquationSeparatei_ptr(buf, modeRGB, modeAlpha);
}

typedef void (APIENTRY * PFN_GLBLENDFUNCI)(GLuint buf, GLenum src, GLenum dst);
static PFN_GLBLENDFUNCI _glBlendFunci_ptr = NULL;

static inline void APIENTRY _glBlendFunci(GLuint buf, GLenum src, GLenum dst) {
    const char *_name = "glBlendFunci";
    if (!_glBlendFunci_ptr) {
        _glBlendFunci_ptr = (PFN_GLBLENDFUNCI)_getPrivateProcAddress(_name);
        if (!_glBlendFunci_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendFunci_ptr(buf, src, dst);
}

typedef void (APIENTRY * PFN_GLBLENDFUNCSEPARATEI)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
static PFN_GLBLENDFUNCSEPARATEI _glBlendFuncSeparatei_ptr = NULL;

static inline void APIENTRY _glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) {
    const char *_name = "glBlendFuncSeparatei";
    if (!_glBlendFuncSeparatei_ptr) {
        _glBlendFuncSeparatei_ptr = (PFN_GLBLENDFUNCSEPARATEI)_getPrivateProcAddress(_name);
        if (!_glBlendFuncSeparatei_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendFuncSeparatei_ptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

typedef void (APIENTRY * PFN_GLACTIVETEXTUREARB)(GLenum texture);
static PFN_GLACTIVETEXTUREARB _glActiveTextureARB_ptr = NULL;

static inline void APIENTRY _glActiveTextureARB(GLenum texture) {
    const char *_name = "glActiveTextureARB";
    if (!_glActiveTextureARB_ptr) {
        _glActiveTextureARB_ptr = (PFN_GLACTIVETEXTUREARB)_getPrivateProcAddress(_name);
        if (!_glActiveTextureARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glActiveTextureARB_ptr(texture);
}

typedef void (APIENTRY * PFN_GLCLIENTACTIVETEXTUREARB)(GLenum texture);
static PFN_GLCLIENTACTIVETEXTUREARB _glClientActiveTextureARB_ptr = NULL;

static inline void APIENTRY _glClientActiveTextureARB(GLenum texture) {
    const char *_name = "glClientActiveTextureARB";
    if (!_glClientActiveTextureARB_ptr) {
        _glClientActiveTextureARB_ptr = (PFN_GLCLIENTACTIVETEXTUREARB)_getPrivateProcAddress(_name);
        if (!_glClientActiveTextureARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClientActiveTextureARB_ptr(texture);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1DARB)(GLenum target, GLdouble s);
static PFN_GLMULTITEXCOORD1DARB _glMultiTexCoord1dARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1dARB(GLenum target, GLdouble s) {
    const char *_name = "glMultiTexCoord1dARB";
    if (!_glMultiTexCoord1dARB_ptr) {
        _glMultiTexCoord1dARB_ptr = (PFN_GLMULTITEXCOORD1DARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1dARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1dARB_ptr(target, s);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1DVARB)(GLenum target, const GLdouble * v);
static PFN_GLMULTITEXCOORD1DVARB _glMultiTexCoord1dvARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1dvARB(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord1dvARB";
    if (!_glMultiTexCoord1dvARB_ptr) {
        _glMultiTexCoord1dvARB_ptr = (PFN_GLMULTITEXCOORD1DVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1dvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1dvARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1FARB)(GLenum target, GLfloat s);
static PFN_GLMULTITEXCOORD1FARB _glMultiTexCoord1fARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1fARB(GLenum target, GLfloat s) {
    const char *_name = "glMultiTexCoord1fARB";
    if (!_glMultiTexCoord1fARB_ptr) {
        _glMultiTexCoord1fARB_ptr = (PFN_GLMULTITEXCOORD1FARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1fARB_ptr(target, s);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1FVARB)(GLenum target, const GLfloat * v);
static PFN_GLMULTITEXCOORD1FVARB _glMultiTexCoord1fvARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1fvARB(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord1fvARB";
    if (!_glMultiTexCoord1fvARB_ptr) {
        _glMultiTexCoord1fvARB_ptr = (PFN_GLMULTITEXCOORD1FVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1fvARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1IARB)(GLenum target, GLint s);
static PFN_GLMULTITEXCOORD1IARB _glMultiTexCoord1iARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1iARB(GLenum target, GLint s) {
    const char *_name = "glMultiTexCoord1iARB";
    if (!_glMultiTexCoord1iARB_ptr) {
        _glMultiTexCoord1iARB_ptr = (PFN_GLMULTITEXCOORD1IARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1iARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1iARB_ptr(target, s);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1IVARB)(GLenum target, const GLint * v);
static PFN_GLMULTITEXCOORD1IVARB _glMultiTexCoord1ivARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1ivARB(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord1ivARB";
    if (!_glMultiTexCoord1ivARB_ptr) {
        _glMultiTexCoord1ivARB_ptr = (PFN_GLMULTITEXCOORD1IVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1ivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1ivARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1SARB)(GLenum target, GLshort s);
static PFN_GLMULTITEXCOORD1SARB _glMultiTexCoord1sARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1sARB(GLenum target, GLshort s) {
    const char *_name = "glMultiTexCoord1sARB";
    if (!_glMultiTexCoord1sARB_ptr) {
        _glMultiTexCoord1sARB_ptr = (PFN_GLMULTITEXCOORD1SARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1sARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1sARB_ptr(target, s);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1SVARB)(GLenum target, const GLshort * v);
static PFN_GLMULTITEXCOORD1SVARB _glMultiTexCoord1svARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1svARB(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord1svARB";
    if (!_glMultiTexCoord1svARB_ptr) {
        _glMultiTexCoord1svARB_ptr = (PFN_GLMULTITEXCOORD1SVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1svARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1svARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2DARB)(GLenum target, GLdouble s, GLdouble t);
static PFN_GLMULTITEXCOORD2DARB _glMultiTexCoord2dARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t) {
    const char *_name = "glMultiTexCoord2dARB";
    if (!_glMultiTexCoord2dARB_ptr) {
        _glMultiTexCoord2dARB_ptr = (PFN_GLMULTITEXCOORD2DARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2dARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2dARB_ptr(target, s, t);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2DVARB)(GLenum target, const GLdouble * v);
static PFN_GLMULTITEXCOORD2DVARB _glMultiTexCoord2dvARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2dvARB(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord2dvARB";
    if (!_glMultiTexCoord2dvARB_ptr) {
        _glMultiTexCoord2dvARB_ptr = (PFN_GLMULTITEXCOORD2DVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2dvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2dvARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2FARB)(GLenum target, GLfloat s, GLfloat t);
static PFN_GLMULTITEXCOORD2FARB _glMultiTexCoord2fARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t) {
    const char *_name = "glMultiTexCoord2fARB";
    if (!_glMultiTexCoord2fARB_ptr) {
        _glMultiTexCoord2fARB_ptr = (PFN_GLMULTITEXCOORD2FARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2fARB_ptr(target, s, t);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2FVARB)(GLenum target, const GLfloat * v);
static PFN_GLMULTITEXCOORD2FVARB _glMultiTexCoord2fvARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2fvARB(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord2fvARB";
    if (!_glMultiTexCoord2fvARB_ptr) {
        _glMultiTexCoord2fvARB_ptr = (PFN_GLMULTITEXCOORD2FVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2fvARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2IARB)(GLenum target, GLint s, GLint t);
static PFN_GLMULTITEXCOORD2IARB _glMultiTexCoord2iARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2iARB(GLenum target, GLint s, GLint t) {
    const char *_name = "glMultiTexCoord2iARB";
    if (!_glMultiTexCoord2iARB_ptr) {
        _glMultiTexCoord2iARB_ptr = (PFN_GLMULTITEXCOORD2IARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2iARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2iARB_ptr(target, s, t);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2IVARB)(GLenum target, const GLint * v);
static PFN_GLMULTITEXCOORD2IVARB _glMultiTexCoord2ivARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2ivARB(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord2ivARB";
    if (!_glMultiTexCoord2ivARB_ptr) {
        _glMultiTexCoord2ivARB_ptr = (PFN_GLMULTITEXCOORD2IVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2ivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2ivARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2SARB)(GLenum target, GLshort s, GLshort t);
static PFN_GLMULTITEXCOORD2SARB _glMultiTexCoord2sARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t) {
    const char *_name = "glMultiTexCoord2sARB";
    if (!_glMultiTexCoord2sARB_ptr) {
        _glMultiTexCoord2sARB_ptr = (PFN_GLMULTITEXCOORD2SARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2sARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2sARB_ptr(target, s, t);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2SVARB)(GLenum target, const GLshort * v);
static PFN_GLMULTITEXCOORD2SVARB _glMultiTexCoord2svARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2svARB(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord2svARB";
    if (!_glMultiTexCoord2svARB_ptr) {
        _glMultiTexCoord2svARB_ptr = (PFN_GLMULTITEXCOORD2SVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2svARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2svARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3DARB)(GLenum target, GLdouble s, GLdouble t, GLdouble r);
static PFN_GLMULTITEXCOORD3DARB _glMultiTexCoord3dARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r) {
    const char *_name = "glMultiTexCoord3dARB";
    if (!_glMultiTexCoord3dARB_ptr) {
        _glMultiTexCoord3dARB_ptr = (PFN_GLMULTITEXCOORD3DARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3dARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3dARB_ptr(target, s, t, r);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3DVARB)(GLenum target, const GLdouble * v);
static PFN_GLMULTITEXCOORD3DVARB _glMultiTexCoord3dvARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3dvARB(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord3dvARB";
    if (!_glMultiTexCoord3dvARB_ptr) {
        _glMultiTexCoord3dvARB_ptr = (PFN_GLMULTITEXCOORD3DVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3dvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3dvARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3FARB)(GLenum target, GLfloat s, GLfloat t, GLfloat r);
static PFN_GLMULTITEXCOORD3FARB _glMultiTexCoord3fARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r) {
    const char *_name = "glMultiTexCoord3fARB";
    if (!_glMultiTexCoord3fARB_ptr) {
        _glMultiTexCoord3fARB_ptr = (PFN_GLMULTITEXCOORD3FARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3fARB_ptr(target, s, t, r);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3FVARB)(GLenum target, const GLfloat * v);
static PFN_GLMULTITEXCOORD3FVARB _glMultiTexCoord3fvARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3fvARB(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord3fvARB";
    if (!_glMultiTexCoord3fvARB_ptr) {
        _glMultiTexCoord3fvARB_ptr = (PFN_GLMULTITEXCOORD3FVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3fvARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3IARB)(GLenum target, GLint s, GLint t, GLint r);
static PFN_GLMULTITEXCOORD3IARB _glMultiTexCoord3iARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r) {
    const char *_name = "glMultiTexCoord3iARB";
    if (!_glMultiTexCoord3iARB_ptr) {
        _glMultiTexCoord3iARB_ptr = (PFN_GLMULTITEXCOORD3IARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3iARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3iARB_ptr(target, s, t, r);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3IVARB)(GLenum target, const GLint * v);
static PFN_GLMULTITEXCOORD3IVARB _glMultiTexCoord3ivARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3ivARB(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord3ivARB";
    if (!_glMultiTexCoord3ivARB_ptr) {
        _glMultiTexCoord3ivARB_ptr = (PFN_GLMULTITEXCOORD3IVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3ivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3ivARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3SARB)(GLenum target, GLshort s, GLshort t, GLshort r);
static PFN_GLMULTITEXCOORD3SARB _glMultiTexCoord3sARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r) {
    const char *_name = "glMultiTexCoord3sARB";
    if (!_glMultiTexCoord3sARB_ptr) {
        _glMultiTexCoord3sARB_ptr = (PFN_GLMULTITEXCOORD3SARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3sARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3sARB_ptr(target, s, t, r);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3SVARB)(GLenum target, const GLshort * v);
static PFN_GLMULTITEXCOORD3SVARB _glMultiTexCoord3svARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3svARB(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord3svARB";
    if (!_glMultiTexCoord3svARB_ptr) {
        _glMultiTexCoord3svARB_ptr = (PFN_GLMULTITEXCOORD3SVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3svARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3svARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4DARB)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
static PFN_GLMULTITEXCOORD4DARB _glMultiTexCoord4dARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    const char *_name = "glMultiTexCoord4dARB";
    if (!_glMultiTexCoord4dARB_ptr) {
        _glMultiTexCoord4dARB_ptr = (PFN_GLMULTITEXCOORD4DARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4dARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4dARB_ptr(target, s, t, r, q);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4DVARB)(GLenum target, const GLdouble * v);
static PFN_GLMULTITEXCOORD4DVARB _glMultiTexCoord4dvARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4dvARB(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord4dvARB";
    if (!_glMultiTexCoord4dvARB_ptr) {
        _glMultiTexCoord4dvARB_ptr = (PFN_GLMULTITEXCOORD4DVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4dvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4dvARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4FARB)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
static PFN_GLMULTITEXCOORD4FARB _glMultiTexCoord4fARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    const char *_name = "glMultiTexCoord4fARB";
    if (!_glMultiTexCoord4fARB_ptr) {
        _glMultiTexCoord4fARB_ptr = (PFN_GLMULTITEXCOORD4FARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4fARB_ptr(target, s, t, r, q);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4FVARB)(GLenum target, const GLfloat * v);
static PFN_GLMULTITEXCOORD4FVARB _glMultiTexCoord4fvARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4fvARB(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord4fvARB";
    if (!_glMultiTexCoord4fvARB_ptr) {
        _glMultiTexCoord4fvARB_ptr = (PFN_GLMULTITEXCOORD4FVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4fvARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4IARB)(GLenum target, GLint s, GLint t, GLint r, GLint q);
static PFN_GLMULTITEXCOORD4IARB _glMultiTexCoord4iARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q) {
    const char *_name = "glMultiTexCoord4iARB";
    if (!_glMultiTexCoord4iARB_ptr) {
        _glMultiTexCoord4iARB_ptr = (PFN_GLMULTITEXCOORD4IARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4iARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4iARB_ptr(target, s, t, r, q);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4IVARB)(GLenum target, const GLint * v);
static PFN_GLMULTITEXCOORD4IVARB _glMultiTexCoord4ivARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4ivARB(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord4ivARB";
    if (!_glMultiTexCoord4ivARB_ptr) {
        _glMultiTexCoord4ivARB_ptr = (PFN_GLMULTITEXCOORD4IVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4ivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4ivARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4SARB)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
static PFN_GLMULTITEXCOORD4SARB _glMultiTexCoord4sARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) {
    const char *_name = "glMultiTexCoord4sARB";
    if (!_glMultiTexCoord4sARB_ptr) {
        _glMultiTexCoord4sARB_ptr = (PFN_GLMULTITEXCOORD4SARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4sARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4sARB_ptr(target, s, t, r, q);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4SVARB)(GLenum target, const GLshort * v);
static PFN_GLMULTITEXCOORD4SVARB _glMultiTexCoord4svARB_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4svARB(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord4svARB";
    if (!_glMultiTexCoord4svARB_ptr) {
        _glMultiTexCoord4svARB_ptr = (PFN_GLMULTITEXCOORD4SVARB)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4svARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4svARB_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLLOADTRANSPOSEMATRIXFARB)(const GLfloat * m);
static PFN_GLLOADTRANSPOSEMATRIXFARB _glLoadTransposeMatrixfARB_ptr = NULL;

static inline void APIENTRY _glLoadTransposeMatrixfARB(const GLfloat * m) {
    const char *_name = "glLoadTransposeMatrixfARB";
    if (!_glLoadTransposeMatrixfARB_ptr) {
        _glLoadTransposeMatrixfARB_ptr = (PFN_GLLOADTRANSPOSEMATRIXFARB)_getPrivateProcAddress(_name);
        if (!_glLoadTransposeMatrixfARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLoadTransposeMatrixfARB_ptr(m);
}

typedef void (APIENTRY * PFN_GLLOADTRANSPOSEMATRIXDARB)(const GLdouble * m);
static PFN_GLLOADTRANSPOSEMATRIXDARB _glLoadTransposeMatrixdARB_ptr = NULL;

static inline void APIENTRY _glLoadTransposeMatrixdARB(const GLdouble * m) {
    const char *_name = "glLoadTransposeMatrixdARB";
    if (!_glLoadTransposeMatrixdARB_ptr) {
        _glLoadTransposeMatrixdARB_ptr = (PFN_GLLOADTRANSPOSEMATRIXDARB)_getPrivateProcAddress(_name);
        if (!_glLoadTransposeMatrixdARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLoadTransposeMatrixdARB_ptr(m);
}

typedef void (APIENTRY * PFN_GLMULTTRANSPOSEMATRIXFARB)(const GLfloat * m);
static PFN_GLMULTTRANSPOSEMATRIXFARB _glMultTransposeMatrixfARB_ptr = NULL;

static inline void APIENTRY _glMultTransposeMatrixfARB(const GLfloat * m) {
    const char *_name = "glMultTransposeMatrixfARB";
    if (!_glMultTransposeMatrixfARB_ptr) {
        _glMultTransposeMatrixfARB_ptr = (PFN_GLMULTTRANSPOSEMATRIXFARB)_getPrivateProcAddress(_name);
        if (!_glMultTransposeMatrixfARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultTransposeMatrixfARB_ptr(m);
}

typedef void (APIENTRY * PFN_GLMULTTRANSPOSEMATRIXDARB)(const GLdouble * m);
static PFN_GLMULTTRANSPOSEMATRIXDARB _glMultTransposeMatrixdARB_ptr = NULL;

static inline void APIENTRY _glMultTransposeMatrixdARB(const GLdouble * m) {
    const char *_name = "glMultTransposeMatrixdARB";
    if (!_glMultTransposeMatrixdARB_ptr) {
        _glMultTransposeMatrixdARB_ptr = (PFN_GLMULTTRANSPOSEMATRIXDARB)_getPrivateProcAddress(_name);
        if (!_glMultTransposeMatrixdARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultTransposeMatrixdARB_ptr(m);
}

typedef void (APIENTRY * PFN_GLSAMPLECOVERAGEARB)(GLfloat value, GLboolean invert);
static PFN_GLSAMPLECOVERAGEARB _glSampleCoverageARB_ptr = NULL;

static inline void APIENTRY _glSampleCoverageARB(GLfloat value, GLboolean invert) {
    const char *_name = "glSampleCoverageARB";
    if (!_glSampleCoverageARB_ptr) {
        _glSampleCoverageARB_ptr = (PFN_GLSAMPLECOVERAGEARB)_getPrivateProcAddress(_name);
        if (!_glSampleCoverageARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSampleCoverageARB_ptr(value, invert);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXIMAGE3DARB)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXIMAGE3DARB _glCompressedTexImage3DARB_ptr = NULL;

static inline void APIENTRY _glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage3DARB";
    if (!_glCompressedTexImage3DARB_ptr) {
        _glCompressedTexImage3DARB_ptr = (PFN_GLCOMPRESSEDTEXIMAGE3DARB)_getPrivateProcAddress(_name);
        if (!_glCompressedTexImage3DARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexImage3DARB_ptr(target, level, internalformat, width, height, depth, border, imageSize, data);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXIMAGE2DARB)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXIMAGE2DARB _glCompressedTexImage2DARB_ptr = NULL;

static inline void APIENTRY _glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage2DARB";
    if (!_glCompressedTexImage2DARB_ptr) {
        _glCompressedTexImage2DARB_ptr = (PFN_GLCOMPRESSEDTEXIMAGE2DARB)_getPrivateProcAddress(_name);
        if (!_glCompressedTexImage2DARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexImage2DARB_ptr(target, level, internalformat, width, height, border, imageSize, data);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXIMAGE1DARB)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXIMAGE1DARB _glCompressedTexImage1DARB_ptr = NULL;

static inline void APIENTRY _glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage1DARB";
    if (!_glCompressedTexImage1DARB_ptr) {
        _glCompressedTexImage1DARB_ptr = (PFN_GLCOMPRESSEDTEXIMAGE1DARB)_getPrivateProcAddress(_name);
        if (!_glCompressedTexImage1DARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexImage1DARB_ptr(target, level, internalformat, width, border, imageSize, data);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXSUBIMAGE3DARB)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXSUBIMAGE3DARB _glCompressedTexSubImage3DARB_ptr = NULL;

static inline void APIENTRY _glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage3DARB";
    if (!_glCompressedTexSubImage3DARB_ptr) {
        _glCompressedTexSubImage3DARB_ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE3DARB)_getPrivateProcAddress(_name);
        if (!_glCompressedTexSubImage3DARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexSubImage3DARB_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXSUBIMAGE2DARB)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXSUBIMAGE2DARB _glCompressedTexSubImage2DARB_ptr = NULL;

static inline void APIENTRY _glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage2DARB";
    if (!_glCompressedTexSubImage2DARB_ptr) {
        _glCompressedTexSubImage2DARB_ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE2DARB)_getPrivateProcAddress(_name);
        if (!_glCompressedTexSubImage2DARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexSubImage2DARB_ptr(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXSUBIMAGE1DARB)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXSUBIMAGE1DARB _glCompressedTexSubImage1DARB_ptr = NULL;

static inline void APIENTRY _glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage1DARB";
    if (!_glCompressedTexSubImage1DARB_ptr) {
        _glCompressedTexSubImage1DARB_ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE1DARB)_getPrivateProcAddress(_name);
        if (!_glCompressedTexSubImage1DARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexSubImage1DARB_ptr(target, level, xoffset, width, format, imageSize, data);
}

typedef void (APIENTRY * PFN_GLGETCOMPRESSEDTEXIMAGEARB)(GLenum target, GLint level, GLvoid * img);
static PFN_GLGETCOMPRESSEDTEXIMAGEARB _glGetCompressedTexImageARB_ptr = NULL;

static inline void APIENTRY _glGetCompressedTexImageARB(GLenum target, GLint level, GLvoid * img) {
    const char *_name = "glGetCompressedTexImageARB";
    if (!_glGetCompressedTexImageARB_ptr) {
        _glGetCompressedTexImageARB_ptr = (PFN_GLGETCOMPRESSEDTEXIMAGEARB)_getPrivateProcAddress(_name);
        if (!_glGetCompressedTexImageARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetCompressedTexImageARB_ptr(target, level, img);
}

typedef void (APIENTRY * PFN_GLPOINTPARAMETERFARB)(GLenum pname, GLfloat param);
static PFN_GLPOINTPARAMETERFARB _glPointParameterfARB_ptr = NULL;

static inline void APIENTRY _glPointParameterfARB(GLenum pname, GLfloat param) {
    const char *_name = "glPointParameterfARB";
    if (!_glPointParameterfARB_ptr) {
        _glPointParameterfARB_ptr = (PFN_GLPOINTPARAMETERFARB)_getPrivateProcAddress(_name);
        if (!_glPointParameterfARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameterfARB_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLPOINTPARAMETERFVARB)(GLenum pname, const GLfloat * params);
static PFN_GLPOINTPARAMETERFVARB _glPointParameterfvARB_ptr = NULL;

static inline void APIENTRY _glPointParameterfvARB(GLenum pname, const GLfloat * params) {
    const char *_name = "glPointParameterfvARB";
    if (!_glPointParameterfvARB_ptr) {
        _glPointParameterfvARB_ptr = (PFN_GLPOINTPARAMETERFVARB)_getPrivateProcAddress(_name);
        if (!_glPointParameterfvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameterfvARB_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLWEIGHTBVARB)(GLint size, const GLbyte * weights);
static PFN_GLWEIGHTBVARB _glWeightbvARB_ptr = NULL;

static inline void APIENTRY _glWeightbvARB(GLint size, const GLbyte * weights) {
    const char *_name = "glWeightbvARB";
    if (!_glWeightbvARB_ptr) {
        _glWeightbvARB_ptr = (PFN_GLWEIGHTBVARB)_getPrivateProcAddress(_name);
        if (!_glWeightbvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWeightbvARB_ptr(size, weights);
}

typedef void (APIENTRY * PFN_GLWEIGHTSVARB)(GLint size, const GLshort * weights);
static PFN_GLWEIGHTSVARB _glWeightsvARB_ptr = NULL;

static inline void APIENTRY _glWeightsvARB(GLint size, const GLshort * weights) {
    const char *_name = "glWeightsvARB";
    if (!_glWeightsvARB_ptr) {
        _glWeightsvARB_ptr = (PFN_GLWEIGHTSVARB)_getPrivateProcAddress(_name);
        if (!_glWeightsvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWeightsvARB_ptr(size, weights);
}

typedef void (APIENTRY * PFN_GLWEIGHTIVARB)(GLint size, const GLint * weights);
static PFN_GLWEIGHTIVARB _glWeightivARB_ptr = NULL;

static inline void APIENTRY _glWeightivARB(GLint size, const GLint * weights) {
    const char *_name = "glWeightivARB";
    if (!_glWeightivARB_ptr) {
        _glWeightivARB_ptr = (PFN_GLWEIGHTIVARB)_getPrivateProcAddress(_name);
        if (!_glWeightivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWeightivARB_ptr(size, weights);
}

typedef void (APIENTRY * PFN_GLWEIGHTFVARB)(GLint size, const GLfloat * weights);
static PFN_GLWEIGHTFVARB _glWeightfvARB_ptr = NULL;

static inline void APIENTRY _glWeightfvARB(GLint size, const GLfloat * weights) {
    const char *_name = "glWeightfvARB";
    if (!_glWeightfvARB_ptr) {
        _glWeightfvARB_ptr = (PFN_GLWEIGHTFVARB)_getPrivateProcAddress(_name);
        if (!_glWeightfvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWeightfvARB_ptr(size, weights);
}

typedef void (APIENTRY * PFN_GLWEIGHTDVARB)(GLint size, const GLdouble * weights);
static PFN_GLWEIGHTDVARB _glWeightdvARB_ptr = NULL;

static inline void APIENTRY _glWeightdvARB(GLint size, const GLdouble * weights) {
    const char *_name = "glWeightdvARB";
    if (!_glWeightdvARB_ptr) {
        _glWeightdvARB_ptr = (PFN_GLWEIGHTDVARB)_getPrivateProcAddress(_name);
        if (!_glWeightdvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWeightdvARB_ptr(size, weights);
}

typedef void (APIENTRY * PFN_GLWEIGHTUBVARB)(GLint size, const GLubyte * weights);
static PFN_GLWEIGHTUBVARB _glWeightubvARB_ptr = NULL;

static inline void APIENTRY _glWeightubvARB(GLint size, const GLubyte * weights) {
    const char *_name = "glWeightubvARB";
    if (!_glWeightubvARB_ptr) {
        _glWeightubvARB_ptr = (PFN_GLWEIGHTUBVARB)_getPrivateProcAddress(_name);
        if (!_glWeightubvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWeightubvARB_ptr(size, weights);
}

typedef void (APIENTRY * PFN_GLWEIGHTUSVARB)(GLint size, const GLushort * weights);
static PFN_GLWEIGHTUSVARB _glWeightusvARB_ptr = NULL;

static inline void APIENTRY _glWeightusvARB(GLint size, const GLushort * weights) {
    const char *_name = "glWeightusvARB";
    if (!_glWeightusvARB_ptr) {
        _glWeightusvARB_ptr = (PFN_GLWEIGHTUSVARB)_getPrivateProcAddress(_name);
        if (!_glWeightusvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWeightusvARB_ptr(size, weights);
}

typedef void (APIENTRY * PFN_GLWEIGHTUIVARB)(GLint size, const GLuint * weights);
static PFN_GLWEIGHTUIVARB _glWeightuivARB_ptr = NULL;

static inline void APIENTRY _glWeightuivARB(GLint size, const GLuint * weights) {
    const char *_name = "glWeightuivARB";
    if (!_glWeightuivARB_ptr) {
        _glWeightuivARB_ptr = (PFN_GLWEIGHTUIVARB)_getPrivateProcAddress(_name);
        if (!_glWeightuivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWeightuivARB_ptr(size, weights);
}

typedef void (APIENTRY * PFN_GLWEIGHTPOINTERARB)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLWEIGHTPOINTERARB _glWeightPointerARB_ptr = NULL;

static inline void APIENTRY _glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glWeightPointerARB";
    if (!_glWeightPointerARB_ptr) {
        _glWeightPointerARB_ptr = (PFN_GLWEIGHTPOINTERARB)_getPrivateProcAddress(_name);
        if (!_glWeightPointerARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWeightPointerARB_ptr(size, type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLVERTEXBLENDARB)(GLint count);
static PFN_GLVERTEXBLENDARB _glVertexBlendARB_ptr = NULL;

static inline void APIENTRY _glVertexBlendARB(GLint count) {
    const char *_name = "glVertexBlendARB";
    if (!_glVertexBlendARB_ptr) {
        _glVertexBlendARB_ptr = (PFN_GLVERTEXBLENDARB)_getPrivateProcAddress(_name);
        if (!_glVertexBlendARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexBlendARB_ptr(count);
}

typedef void (APIENTRY * PFN_GLCURRENTPALETTEMATRIXARB)(GLint index);
static PFN_GLCURRENTPALETTEMATRIXARB _glCurrentPaletteMatrixARB_ptr = NULL;

static inline void APIENTRY _glCurrentPaletteMatrixARB(GLint index) {
    const char *_name = "glCurrentPaletteMatrixARB";
    if (!_glCurrentPaletteMatrixARB_ptr) {
        _glCurrentPaletteMatrixARB_ptr = (PFN_GLCURRENTPALETTEMATRIXARB)_getPrivateProcAddress(_name);
        if (!_glCurrentPaletteMatrixARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCurrentPaletteMatrixARB_ptr(index);
}

typedef void (APIENTRY * PFN_GLMATRIXINDEXUBVARB)(GLint size, const GLubyte * indices);
static PFN_GLMATRIXINDEXUBVARB _glMatrixIndexubvARB_ptr = NULL;

static inline void APIENTRY _glMatrixIndexubvARB(GLint size, const GLubyte * indices) {
    const char *_name = "glMatrixIndexubvARB";
    if (!_glMatrixIndexubvARB_ptr) {
        _glMatrixIndexubvARB_ptr = (PFN_GLMATRIXINDEXUBVARB)_getPrivateProcAddress(_name);
        if (!_glMatrixIndexubvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixIndexubvARB_ptr(size, indices);
}

typedef void (APIENTRY * PFN_GLMATRIXINDEXUSVARB)(GLint size, const GLushort * indices);
static PFN_GLMATRIXINDEXUSVARB _glMatrixIndexusvARB_ptr = NULL;

static inline void APIENTRY _glMatrixIndexusvARB(GLint size, const GLushort * indices) {
    const char *_name = "glMatrixIndexusvARB";
    if (!_glMatrixIndexusvARB_ptr) {
        _glMatrixIndexusvARB_ptr = (PFN_GLMATRIXINDEXUSVARB)_getPrivateProcAddress(_name);
        if (!_glMatrixIndexusvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixIndexusvARB_ptr(size, indices);
}

typedef void (APIENTRY * PFN_GLMATRIXINDEXUIVARB)(GLint size, const GLuint * indices);
static PFN_GLMATRIXINDEXUIVARB _glMatrixIndexuivARB_ptr = NULL;

static inline void APIENTRY _glMatrixIndexuivARB(GLint size, const GLuint * indices) {
    const char *_name = "glMatrixIndexuivARB";
    if (!_glMatrixIndexuivARB_ptr) {
        _glMatrixIndexuivARB_ptr = (PFN_GLMATRIXINDEXUIVARB)_getPrivateProcAddress(_name);
        if (!_glMatrixIndexuivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixIndexuivARB_ptr(size, indices);
}

typedef void (APIENTRY * PFN_GLMATRIXINDEXPOINTERARB)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLMATRIXINDEXPOINTERARB _glMatrixIndexPointerARB_ptr = NULL;

static inline void APIENTRY _glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glMatrixIndexPointerARB";
    if (!_glMatrixIndexPointerARB_ptr) {
        _glMatrixIndexPointerARB_ptr = (PFN_GLMATRIXINDEXPOINTERARB)_getPrivateProcAddress(_name);
        if (!_glMatrixIndexPointerARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixIndexPointerARB_ptr(size, type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2DARB)(GLdouble x, GLdouble y);
static PFN_GLWINDOWPOS2DARB _glWindowPos2dARB_ptr = NULL;

static inline void APIENTRY _glWindowPos2dARB(GLdouble x, GLdouble y) {
    const char *_name = "glWindowPos2dARB";
    if (!_glWindowPos2dARB_ptr) {
        _glWindowPos2dARB_ptr = (PFN_GLWINDOWPOS2DARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos2dARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2dARB_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2DVARB)(const GLdouble * v);
static PFN_GLWINDOWPOS2DVARB _glWindowPos2dvARB_ptr = NULL;

static inline void APIENTRY _glWindowPos2dvARB(const GLdouble * v) {
    const char *_name = "glWindowPos2dvARB";
    if (!_glWindowPos2dvARB_ptr) {
        _glWindowPos2dvARB_ptr = (PFN_GLWINDOWPOS2DVARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos2dvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2dvARB_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2FARB)(GLfloat x, GLfloat y);
static PFN_GLWINDOWPOS2FARB _glWindowPos2fARB_ptr = NULL;

static inline void APIENTRY _glWindowPos2fARB(GLfloat x, GLfloat y) {
    const char *_name = "glWindowPos2fARB";
    if (!_glWindowPos2fARB_ptr) {
        _glWindowPos2fARB_ptr = (PFN_GLWINDOWPOS2FARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos2fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2fARB_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2FVARB)(const GLfloat * v);
static PFN_GLWINDOWPOS2FVARB _glWindowPos2fvARB_ptr = NULL;

static inline void APIENTRY _glWindowPos2fvARB(const GLfloat * v) {
    const char *_name = "glWindowPos2fvARB";
    if (!_glWindowPos2fvARB_ptr) {
        _glWindowPos2fvARB_ptr = (PFN_GLWINDOWPOS2FVARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos2fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2fvARB_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2IARB)(GLint x, GLint y);
static PFN_GLWINDOWPOS2IARB _glWindowPos2iARB_ptr = NULL;

static inline void APIENTRY _glWindowPos2iARB(GLint x, GLint y) {
    const char *_name = "glWindowPos2iARB";
    if (!_glWindowPos2iARB_ptr) {
        _glWindowPos2iARB_ptr = (PFN_GLWINDOWPOS2IARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos2iARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2iARB_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2IVARB)(const GLint * v);
static PFN_GLWINDOWPOS2IVARB _glWindowPos2ivARB_ptr = NULL;

static inline void APIENTRY _glWindowPos2ivARB(const GLint * v) {
    const char *_name = "glWindowPos2ivARB";
    if (!_glWindowPos2ivARB_ptr) {
        _glWindowPos2ivARB_ptr = (PFN_GLWINDOWPOS2IVARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos2ivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2ivARB_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2SARB)(GLshort x, GLshort y);
static PFN_GLWINDOWPOS2SARB _glWindowPos2sARB_ptr = NULL;

static inline void APIENTRY _glWindowPos2sARB(GLshort x, GLshort y) {
    const char *_name = "glWindowPos2sARB";
    if (!_glWindowPos2sARB_ptr) {
        _glWindowPos2sARB_ptr = (PFN_GLWINDOWPOS2SARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos2sARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2sARB_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2SVARB)(const GLshort * v);
static PFN_GLWINDOWPOS2SVARB _glWindowPos2svARB_ptr = NULL;

static inline void APIENTRY _glWindowPos2svARB(const GLshort * v) {
    const char *_name = "glWindowPos2svARB";
    if (!_glWindowPos2svARB_ptr) {
        _glWindowPos2svARB_ptr = (PFN_GLWINDOWPOS2SVARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos2svARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2svARB_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3DARB)(GLdouble x, GLdouble y, GLdouble z);
static PFN_GLWINDOWPOS3DARB _glWindowPos3dARB_ptr = NULL;

static inline void APIENTRY _glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glWindowPos3dARB";
    if (!_glWindowPos3dARB_ptr) {
        _glWindowPos3dARB_ptr = (PFN_GLWINDOWPOS3DARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos3dARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3dARB_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3DVARB)(const GLdouble * v);
static PFN_GLWINDOWPOS3DVARB _glWindowPos3dvARB_ptr = NULL;

static inline void APIENTRY _glWindowPos3dvARB(const GLdouble * v) {
    const char *_name = "glWindowPos3dvARB";
    if (!_glWindowPos3dvARB_ptr) {
        _glWindowPos3dvARB_ptr = (PFN_GLWINDOWPOS3DVARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos3dvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3dvARB_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3FARB)(GLfloat x, GLfloat y, GLfloat z);
static PFN_GLWINDOWPOS3FARB _glWindowPos3fARB_ptr = NULL;

static inline void APIENTRY _glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glWindowPos3fARB";
    if (!_glWindowPos3fARB_ptr) {
        _glWindowPos3fARB_ptr = (PFN_GLWINDOWPOS3FARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos3fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3fARB_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3FVARB)(const GLfloat * v);
static PFN_GLWINDOWPOS3FVARB _glWindowPos3fvARB_ptr = NULL;

static inline void APIENTRY _glWindowPos3fvARB(const GLfloat * v) {
    const char *_name = "glWindowPos3fvARB";
    if (!_glWindowPos3fvARB_ptr) {
        _glWindowPos3fvARB_ptr = (PFN_GLWINDOWPOS3FVARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos3fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3fvARB_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3IARB)(GLint x, GLint y, GLint z);
static PFN_GLWINDOWPOS3IARB _glWindowPos3iARB_ptr = NULL;

static inline void APIENTRY _glWindowPos3iARB(GLint x, GLint y, GLint z) {
    const char *_name = "glWindowPos3iARB";
    if (!_glWindowPos3iARB_ptr) {
        _glWindowPos3iARB_ptr = (PFN_GLWINDOWPOS3IARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos3iARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3iARB_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3IVARB)(const GLint * v);
static PFN_GLWINDOWPOS3IVARB _glWindowPos3ivARB_ptr = NULL;

static inline void APIENTRY _glWindowPos3ivARB(const GLint * v) {
    const char *_name = "glWindowPos3ivARB";
    if (!_glWindowPos3ivARB_ptr) {
        _glWindowPos3ivARB_ptr = (PFN_GLWINDOWPOS3IVARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos3ivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3ivARB_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3SARB)(GLshort x, GLshort y, GLshort z);
static PFN_GLWINDOWPOS3SARB _glWindowPos3sARB_ptr = NULL;

static inline void APIENTRY _glWindowPos3sARB(GLshort x, GLshort y, GLshort z) {
    const char *_name = "glWindowPos3sARB";
    if (!_glWindowPos3sARB_ptr) {
        _glWindowPos3sARB_ptr = (PFN_GLWINDOWPOS3SARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos3sARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3sARB_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3SVARB)(const GLshort * v);
static PFN_GLWINDOWPOS3SVARB _glWindowPos3svARB_ptr = NULL;

static inline void APIENTRY _glWindowPos3svARB(const GLshort * v) {
    const char *_name = "glWindowPos3svARB";
    if (!_glWindowPos3svARB_ptr) {
        _glWindowPos3svARB_ptr = (PFN_GLWINDOWPOS3SVARB)_getPrivateProcAddress(_name);
        if (!_glWindowPos3svARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3svARB_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1DARB)(GLuint index, GLdouble x);
static PFN_GLVERTEXATTRIB1DARB _glVertexAttrib1dARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1dARB(GLuint index, GLdouble x) {
    const char *_name = "glVertexAttrib1dARB";
    if (!_glVertexAttrib1dARB_ptr) {
        _glVertexAttrib1dARB_ptr = (PFN_GLVERTEXATTRIB1DARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1dARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1dARB_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1DVARB)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIB1DVARB _glVertexAttrib1dvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1dvARB(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib1dvARB";
    if (!_glVertexAttrib1dvARB_ptr) {
        _glVertexAttrib1dvARB_ptr = (PFN_GLVERTEXATTRIB1DVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1dvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1dvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1FARB)(GLuint index, GLfloat x);
static PFN_GLVERTEXATTRIB1FARB _glVertexAttrib1fARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1fARB(GLuint index, GLfloat x) {
    const char *_name = "glVertexAttrib1fARB";
    if (!_glVertexAttrib1fARB_ptr) {
        _glVertexAttrib1fARB_ptr = (PFN_GLVERTEXATTRIB1FARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1fARB_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1FVARB)(GLuint index, const GLfloat * v);
static PFN_GLVERTEXATTRIB1FVARB _glVertexAttrib1fvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1fvARB(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib1fvARB";
    if (!_glVertexAttrib1fvARB_ptr) {
        _glVertexAttrib1fvARB_ptr = (PFN_GLVERTEXATTRIB1FVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1fvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1SARB)(GLuint index, GLshort x);
static PFN_GLVERTEXATTRIB1SARB _glVertexAttrib1sARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1sARB(GLuint index, GLshort x) {
    const char *_name = "glVertexAttrib1sARB";
    if (!_glVertexAttrib1sARB_ptr) {
        _glVertexAttrib1sARB_ptr = (PFN_GLVERTEXATTRIB1SARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1sARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1sARB_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1SVARB)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB1SVARB _glVertexAttrib1svARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1svARB(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib1svARB";
    if (!_glVertexAttrib1svARB_ptr) {
        _glVertexAttrib1svARB_ptr = (PFN_GLVERTEXATTRIB1SVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1svARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1svARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2DARB)(GLuint index, GLdouble x, GLdouble y);
static PFN_GLVERTEXATTRIB2DARB _glVertexAttrib2dARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y) {
    const char *_name = "glVertexAttrib2dARB";
    if (!_glVertexAttrib2dARB_ptr) {
        _glVertexAttrib2dARB_ptr = (PFN_GLVERTEXATTRIB2DARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2dARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2dARB_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2DVARB)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIB2DVARB _glVertexAttrib2dvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2dvARB(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib2dvARB";
    if (!_glVertexAttrib2dvARB_ptr) {
        _glVertexAttrib2dvARB_ptr = (PFN_GLVERTEXATTRIB2DVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2dvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2dvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2FARB)(GLuint index, GLfloat x, GLfloat y);
static PFN_GLVERTEXATTRIB2FARB _glVertexAttrib2fARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y) {
    const char *_name = "glVertexAttrib2fARB";
    if (!_glVertexAttrib2fARB_ptr) {
        _glVertexAttrib2fARB_ptr = (PFN_GLVERTEXATTRIB2FARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2fARB_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2FVARB)(GLuint index, const GLfloat * v);
static PFN_GLVERTEXATTRIB2FVARB _glVertexAttrib2fvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2fvARB(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib2fvARB";
    if (!_glVertexAttrib2fvARB_ptr) {
        _glVertexAttrib2fvARB_ptr = (PFN_GLVERTEXATTRIB2FVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2fvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2SARB)(GLuint index, GLshort x, GLshort y);
static PFN_GLVERTEXATTRIB2SARB _glVertexAttrib2sARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y) {
    const char *_name = "glVertexAttrib2sARB";
    if (!_glVertexAttrib2sARB_ptr) {
        _glVertexAttrib2sARB_ptr = (PFN_GLVERTEXATTRIB2SARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2sARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2sARB_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2SVARB)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB2SVARB _glVertexAttrib2svARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2svARB(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib2svARB";
    if (!_glVertexAttrib2svARB_ptr) {
        _glVertexAttrib2svARB_ptr = (PFN_GLVERTEXATTRIB2SVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2svARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2svARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3DARB)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
static PFN_GLVERTEXATTRIB3DARB _glVertexAttrib3dARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertexAttrib3dARB";
    if (!_glVertexAttrib3dARB_ptr) {
        _glVertexAttrib3dARB_ptr = (PFN_GLVERTEXATTRIB3DARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3dARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3dARB_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3DVARB)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIB3DVARB _glVertexAttrib3dvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3dvARB(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib3dvARB";
    if (!_glVertexAttrib3dvARB_ptr) {
        _glVertexAttrib3dvARB_ptr = (PFN_GLVERTEXATTRIB3DVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3dvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3dvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3FARB)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLVERTEXATTRIB3FARB _glVertexAttrib3fARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glVertexAttrib3fARB";
    if (!_glVertexAttrib3fARB_ptr) {
        _glVertexAttrib3fARB_ptr = (PFN_GLVERTEXATTRIB3FARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3fARB_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3FVARB)(GLuint index, const GLfloat * v);
static PFN_GLVERTEXATTRIB3FVARB _glVertexAttrib3fvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3fvARB(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib3fvARB";
    if (!_glVertexAttrib3fvARB_ptr) {
        _glVertexAttrib3fvARB_ptr = (PFN_GLVERTEXATTRIB3FVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3fvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3SARB)(GLuint index, GLshort x, GLshort y, GLshort z);
static PFN_GLVERTEXATTRIB3SARB _glVertexAttrib3sARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z) {
    const char *_name = "glVertexAttrib3sARB";
    if (!_glVertexAttrib3sARB_ptr) {
        _glVertexAttrib3sARB_ptr = (PFN_GLVERTEXATTRIB3SARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3sARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3sARB_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3SVARB)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB3SVARB _glVertexAttrib3svARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3svARB(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib3svARB";
    if (!_glVertexAttrib3svARB_ptr) {
        _glVertexAttrib3svARB_ptr = (PFN_GLVERTEXATTRIB3SVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3svARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3svARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NBVARB)(GLuint index, const GLbyte * v);
static PFN_GLVERTEXATTRIB4NBVARB _glVertexAttrib4NbvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4NbvARB(GLuint index, const GLbyte * v) {
    const char *_name = "glVertexAttrib4NbvARB";
    if (!_glVertexAttrib4NbvARB_ptr) {
        _glVertexAttrib4NbvARB_ptr = (PFN_GLVERTEXATTRIB4NBVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4NbvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4NbvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NIVARB)(GLuint index, const GLint * v);
static PFN_GLVERTEXATTRIB4NIVARB _glVertexAttrib4NivARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4NivARB(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttrib4NivARB";
    if (!_glVertexAttrib4NivARB_ptr) {
        _glVertexAttrib4NivARB_ptr = (PFN_GLVERTEXATTRIB4NIVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4NivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4NivARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NSVARB)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB4NSVARB _glVertexAttrib4NsvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4NsvARB(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib4NsvARB";
    if (!_glVertexAttrib4NsvARB_ptr) {
        _glVertexAttrib4NsvARB_ptr = (PFN_GLVERTEXATTRIB4NSVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4NsvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4NsvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NUBARB)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
static PFN_GLVERTEXATTRIB4NUBARB _glVertexAttrib4NubARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) {
    const char *_name = "glVertexAttrib4NubARB";
    if (!_glVertexAttrib4NubARB_ptr) {
        _glVertexAttrib4NubARB_ptr = (PFN_GLVERTEXATTRIB4NUBARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4NubARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4NubARB_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NUBVARB)(GLuint index, const GLubyte * v);
static PFN_GLVERTEXATTRIB4NUBVARB _glVertexAttrib4NubvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4NubvARB(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttrib4NubvARB";
    if (!_glVertexAttrib4NubvARB_ptr) {
        _glVertexAttrib4NubvARB_ptr = (PFN_GLVERTEXATTRIB4NUBVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4NubvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4NubvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NUIVARB)(GLuint index, const GLuint * v);
static PFN_GLVERTEXATTRIB4NUIVARB _glVertexAttrib4NuivARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4NuivARB(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttrib4NuivARB";
    if (!_glVertexAttrib4NuivARB_ptr) {
        _glVertexAttrib4NuivARB_ptr = (PFN_GLVERTEXATTRIB4NUIVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4NuivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4NuivARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4NUSVARB)(GLuint index, const GLushort * v);
static PFN_GLVERTEXATTRIB4NUSVARB _glVertexAttrib4NusvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4NusvARB(GLuint index, const GLushort * v) {
    const char *_name = "glVertexAttrib4NusvARB";
    if (!_glVertexAttrib4NusvARB_ptr) {
        _glVertexAttrib4NusvARB_ptr = (PFN_GLVERTEXATTRIB4NUSVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4NusvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4NusvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4BVARB)(GLuint index, const GLbyte * v);
static PFN_GLVERTEXATTRIB4BVARB _glVertexAttrib4bvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4bvARB(GLuint index, const GLbyte * v) {
    const char *_name = "glVertexAttrib4bvARB";
    if (!_glVertexAttrib4bvARB_ptr) {
        _glVertexAttrib4bvARB_ptr = (PFN_GLVERTEXATTRIB4BVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4bvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4bvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4DARB)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLVERTEXATTRIB4DARB _glVertexAttrib4dARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertexAttrib4dARB";
    if (!_glVertexAttrib4dARB_ptr) {
        _glVertexAttrib4dARB_ptr = (PFN_GLVERTEXATTRIB4DARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4dARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4dARB_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4DVARB)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIB4DVARB _glVertexAttrib4dvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4dvARB(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib4dvARB";
    if (!_glVertexAttrib4dvARB_ptr) {
        _glVertexAttrib4dvARB_ptr = (PFN_GLVERTEXATTRIB4DVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4dvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4dvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4FARB)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLVERTEXATTRIB4FARB _glVertexAttrib4fARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glVertexAttrib4fARB";
    if (!_glVertexAttrib4fARB_ptr) {
        _glVertexAttrib4fARB_ptr = (PFN_GLVERTEXATTRIB4FARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4fARB_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4FVARB)(GLuint index, const GLfloat * v);
static PFN_GLVERTEXATTRIB4FVARB _glVertexAttrib4fvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4fvARB(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib4fvARB";
    if (!_glVertexAttrib4fvARB_ptr) {
        _glVertexAttrib4fvARB_ptr = (PFN_GLVERTEXATTRIB4FVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4fvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4IVARB)(GLuint index, const GLint * v);
static PFN_GLVERTEXATTRIB4IVARB _glVertexAttrib4ivARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4ivARB(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttrib4ivARB";
    if (!_glVertexAttrib4ivARB_ptr) {
        _glVertexAttrib4ivARB_ptr = (PFN_GLVERTEXATTRIB4IVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4ivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4ivARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4SARB)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
static PFN_GLVERTEXATTRIB4SARB _glVertexAttrib4sARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glVertexAttrib4sARB";
    if (!_glVertexAttrib4sARB_ptr) {
        _glVertexAttrib4sARB_ptr = (PFN_GLVERTEXATTRIB4SARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4sARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4sARB_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4SVARB)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB4SVARB _glVertexAttrib4svARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4svARB(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib4svARB";
    if (!_glVertexAttrib4svARB_ptr) {
        _glVertexAttrib4svARB_ptr = (PFN_GLVERTEXATTRIB4SVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4svARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4svARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4UBVARB)(GLuint index, const GLubyte * v);
static PFN_GLVERTEXATTRIB4UBVARB _glVertexAttrib4ubvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4ubvARB(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttrib4ubvARB";
    if (!_glVertexAttrib4ubvARB_ptr) {
        _glVertexAttrib4ubvARB_ptr = (PFN_GLVERTEXATTRIB4UBVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4ubvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4ubvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4UIVARB)(GLuint index, const GLuint * v);
static PFN_GLVERTEXATTRIB4UIVARB _glVertexAttrib4uivARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4uivARB(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttrib4uivARB";
    if (!_glVertexAttrib4uivARB_ptr) {
        _glVertexAttrib4uivARB_ptr = (PFN_GLVERTEXATTRIB4UIVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4uivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4uivARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4USVARB)(GLuint index, const GLushort * v);
static PFN_GLVERTEXATTRIB4USVARB _glVertexAttrib4usvARB_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4usvARB(GLuint index, const GLushort * v) {
    const char *_name = "glVertexAttrib4usvARB";
    if (!_glVertexAttrib4usvARB_ptr) {
        _glVertexAttrib4usvARB_ptr = (PFN_GLVERTEXATTRIB4USVARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4usvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4usvARB_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBPOINTERARB)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer);
static PFN_GLVERTEXATTRIBPOINTERARB _glVertexAttribPointerARB_ptr = NULL;

static inline void APIENTRY _glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribPointerARB";
    if (!_glVertexAttribPointerARB_ptr) {
        _glVertexAttribPointerARB_ptr = (PFN_GLVERTEXATTRIBPOINTERARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttribPointerARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribPointerARB_ptr(index, size, type, normalized, stride, pointer);
}

typedef void (APIENTRY * PFN_GLENABLEVERTEXATTRIBARRAYARB)(GLuint index);
static PFN_GLENABLEVERTEXATTRIBARRAYARB _glEnableVertexAttribArrayARB_ptr = NULL;

static inline void APIENTRY _glEnableVertexAttribArrayARB(GLuint index) {
    const char *_name = "glEnableVertexAttribArrayARB";
    if (!_glEnableVertexAttribArrayARB_ptr) {
        _glEnableVertexAttribArrayARB_ptr = (PFN_GLENABLEVERTEXATTRIBARRAYARB)_getPrivateProcAddress(_name);
        if (!_glEnableVertexAttribArrayARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEnableVertexAttribArrayARB_ptr(index);
}

typedef void (APIENTRY * PFN_GLDISABLEVERTEXATTRIBARRAYARB)(GLuint index);
static PFN_GLDISABLEVERTEXATTRIBARRAYARB _glDisableVertexAttribArrayARB_ptr = NULL;

static inline void APIENTRY _glDisableVertexAttribArrayARB(GLuint index) {
    const char *_name = "glDisableVertexAttribArrayARB";
    if (!_glDisableVertexAttribArrayARB_ptr) {
        _glDisableVertexAttribArrayARB_ptr = (PFN_GLDISABLEVERTEXATTRIBARRAYARB)_getPrivateProcAddress(_name);
        if (!_glDisableVertexAttribArrayARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDisableVertexAttribArrayARB_ptr(index);
}

typedef void (APIENTRY * PFN_GLPROGRAMSTRINGARB)(GLenum target, GLenum format, GLsizei len, const void * string);
static PFN_GLPROGRAMSTRINGARB _glProgramStringARB_ptr = NULL;

static inline void APIENTRY _glProgramStringARB(GLenum target, GLenum format, GLsizei len, const void * string) {
    const char *_name = "glProgramStringARB";
    if (!_glProgramStringARB_ptr) {
        _glProgramStringARB_ptr = (PFN_GLPROGRAMSTRINGARB)_getPrivateProcAddress(_name);
        if (!_glProgramStringARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramStringARB_ptr(target, format, len, string);
}

typedef void (APIENTRY * PFN_GLBINDPROGRAMARB)(GLenum target, GLuint program);
static PFN_GLBINDPROGRAMARB _glBindProgramARB_ptr = NULL;

static inline void APIENTRY _glBindProgramARB(GLenum target, GLuint program) {
    const char *_name = "glBindProgramARB";
    if (!_glBindProgramARB_ptr) {
        _glBindProgramARB_ptr = (PFN_GLBINDPROGRAMARB)_getPrivateProcAddress(_name);
        if (!_glBindProgramARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindProgramARB_ptr(target, program);
}

typedef void (APIENTRY * PFN_GLDELETEPROGRAMSARB)(GLsizei n, const GLuint * programs);
static PFN_GLDELETEPROGRAMSARB _glDeleteProgramsARB_ptr = NULL;

static inline void APIENTRY _glDeleteProgramsARB(GLsizei n, const GLuint * programs) {
    const char *_name = "glDeleteProgramsARB";
    if (!_glDeleteProgramsARB_ptr) {
        _glDeleteProgramsARB_ptr = (PFN_GLDELETEPROGRAMSARB)_getPrivateProcAddress(_name);
        if (!_glDeleteProgramsARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteProgramsARB_ptr(n, programs);
}

typedef void (APIENTRY * PFN_GLGENPROGRAMSARB)(GLsizei n, GLuint * programs);
static PFN_GLGENPROGRAMSARB _glGenProgramsARB_ptr = NULL;

static inline void APIENTRY _glGenProgramsARB(GLsizei n, GLuint * programs) {
    const char *_name = "glGenProgramsARB";
    if (!_glGenProgramsARB_ptr) {
        _glGenProgramsARB_ptr = (PFN_GLGENPROGRAMSARB)_getPrivateProcAddress(_name);
        if (!_glGenProgramsARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenProgramsARB_ptr(n, programs);
}

typedef void (APIENTRY * PFN_GLPROGRAMENVPARAMETER4DARB)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLPROGRAMENVPARAMETER4DARB _glProgramEnvParameter4dARB_ptr = NULL;

static inline void APIENTRY _glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glProgramEnvParameter4dARB";
    if (!_glProgramEnvParameter4dARB_ptr) {
        _glProgramEnvParameter4dARB_ptr = (PFN_GLPROGRAMENVPARAMETER4DARB)_getPrivateProcAddress(_name);
        if (!_glProgramEnvParameter4dARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramEnvParameter4dARB_ptr(target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMENVPARAMETER4DVARB)(GLenum target, GLuint index, const GLdouble * params);
static PFN_GLPROGRAMENVPARAMETER4DVARB _glProgramEnvParameter4dvARB_ptr = NULL;

static inline void APIENTRY _glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble * params) {
    const char *_name = "glProgramEnvParameter4dvARB";
    if (!_glProgramEnvParameter4dvARB_ptr) {
        _glProgramEnvParameter4dvARB_ptr = (PFN_GLPROGRAMENVPARAMETER4DVARB)_getPrivateProcAddress(_name);
        if (!_glProgramEnvParameter4dvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramEnvParameter4dvARB_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMENVPARAMETER4FARB)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLPROGRAMENVPARAMETER4FARB _glProgramEnvParameter4fARB_ptr = NULL;

static inline void APIENTRY _glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glProgramEnvParameter4fARB";
    if (!_glProgramEnvParameter4fARB_ptr) {
        _glProgramEnvParameter4fARB_ptr = (PFN_GLPROGRAMENVPARAMETER4FARB)_getPrivateProcAddress(_name);
        if (!_glProgramEnvParameter4fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramEnvParameter4fARB_ptr(target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMENVPARAMETER4FVARB)(GLenum target, GLuint index, const GLfloat * params);
static PFN_GLPROGRAMENVPARAMETER4FVARB _glProgramEnvParameter4fvARB_ptr = NULL;

static inline void APIENTRY _glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat * params) {
    const char *_name = "glProgramEnvParameter4fvARB";
    if (!_glProgramEnvParameter4fvARB_ptr) {
        _glProgramEnvParameter4fvARB_ptr = (PFN_GLPROGRAMENVPARAMETER4FVARB)_getPrivateProcAddress(_name);
        if (!_glProgramEnvParameter4fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramEnvParameter4fvARB_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMLOCALPARAMETER4DARB)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLPROGRAMLOCALPARAMETER4DARB _glProgramLocalParameter4dARB_ptr = NULL;

static inline void APIENTRY _glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glProgramLocalParameter4dARB";
    if (!_glProgramLocalParameter4dARB_ptr) {
        _glProgramLocalParameter4dARB_ptr = (PFN_GLPROGRAMLOCALPARAMETER4DARB)_getPrivateProcAddress(_name);
        if (!_glProgramLocalParameter4dARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramLocalParameter4dARB_ptr(target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMLOCALPARAMETER4DVARB)(GLenum target, GLuint index, const GLdouble * params);
static PFN_GLPROGRAMLOCALPARAMETER4DVARB _glProgramLocalParameter4dvARB_ptr = NULL;

static inline void APIENTRY _glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble * params) {
    const char *_name = "glProgramLocalParameter4dvARB";
    if (!_glProgramLocalParameter4dvARB_ptr) {
        _glProgramLocalParameter4dvARB_ptr = (PFN_GLPROGRAMLOCALPARAMETER4DVARB)_getPrivateProcAddress(_name);
        if (!_glProgramLocalParameter4dvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramLocalParameter4dvARB_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMLOCALPARAMETER4FARB)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLPROGRAMLOCALPARAMETER4FARB _glProgramLocalParameter4fARB_ptr = NULL;

static inline void APIENTRY _glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glProgramLocalParameter4fARB";
    if (!_glProgramLocalParameter4fARB_ptr) {
        _glProgramLocalParameter4fARB_ptr = (PFN_GLPROGRAMLOCALPARAMETER4FARB)_getPrivateProcAddress(_name);
        if (!_glProgramLocalParameter4fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramLocalParameter4fARB_ptr(target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMLOCALPARAMETER4FVARB)(GLenum target, GLuint index, const GLfloat * params);
static PFN_GLPROGRAMLOCALPARAMETER4FVARB _glProgramLocalParameter4fvARB_ptr = NULL;

static inline void APIENTRY _glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat * params) {
    const char *_name = "glProgramLocalParameter4fvARB";
    if (!_glProgramLocalParameter4fvARB_ptr) {
        _glProgramLocalParameter4fvARB_ptr = (PFN_GLPROGRAMLOCALPARAMETER4FVARB)_getPrivateProcAddress(_name);
        if (!_glProgramLocalParameter4fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramLocalParameter4fvARB_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMENVPARAMETERDVARB)(GLenum target, GLuint index, GLdouble * params);
static PFN_GLGETPROGRAMENVPARAMETERDVARB _glGetProgramEnvParameterdvARB_ptr = NULL;

static inline void APIENTRY _glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble * params) {
    const char *_name = "glGetProgramEnvParameterdvARB";
    if (!_glGetProgramEnvParameterdvARB_ptr) {
        _glGetProgramEnvParameterdvARB_ptr = (PFN_GLGETPROGRAMENVPARAMETERDVARB)_getPrivateProcAddress(_name);
        if (!_glGetProgramEnvParameterdvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramEnvParameterdvARB_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMENVPARAMETERFVARB)(GLenum target, GLuint index, GLfloat * params);
static PFN_GLGETPROGRAMENVPARAMETERFVARB _glGetProgramEnvParameterfvARB_ptr = NULL;

static inline void APIENTRY _glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat * params) {
    const char *_name = "glGetProgramEnvParameterfvARB";
    if (!_glGetProgramEnvParameterfvARB_ptr) {
        _glGetProgramEnvParameterfvARB_ptr = (PFN_GLGETPROGRAMENVPARAMETERFVARB)_getPrivateProcAddress(_name);
        if (!_glGetProgramEnvParameterfvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramEnvParameterfvARB_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMLOCALPARAMETERDVARB)(GLenum target, GLuint index, GLdouble * params);
static PFN_GLGETPROGRAMLOCALPARAMETERDVARB _glGetProgramLocalParameterdvARB_ptr = NULL;

static inline void APIENTRY _glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble * params) {
    const char *_name = "glGetProgramLocalParameterdvARB";
    if (!_glGetProgramLocalParameterdvARB_ptr) {
        _glGetProgramLocalParameterdvARB_ptr = (PFN_GLGETPROGRAMLOCALPARAMETERDVARB)_getPrivateProcAddress(_name);
        if (!_glGetProgramLocalParameterdvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramLocalParameterdvARB_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMLOCALPARAMETERFVARB)(GLenum target, GLuint index, GLfloat * params);
static PFN_GLGETPROGRAMLOCALPARAMETERFVARB _glGetProgramLocalParameterfvARB_ptr = NULL;

static inline void APIENTRY _glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat * params) {
    const char *_name = "glGetProgramLocalParameterfvARB";
    if (!_glGetProgramLocalParameterfvARB_ptr) {
        _glGetProgramLocalParameterfvARB_ptr = (PFN_GLGETPROGRAMLOCALPARAMETERFVARB)_getPrivateProcAddress(_name);
        if (!_glGetProgramLocalParameterfvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramLocalParameterfvARB_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMIVARB)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETPROGRAMIVARB _glGetProgramivARB_ptr = NULL;

static inline void APIENTRY _glGetProgramivARB(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetProgramivARB";
    if (!_glGetProgramivARB_ptr) {
        _glGetProgramivARB_ptr = (PFN_GLGETPROGRAMIVARB)_getPrivateProcAddress(_name);
        if (!_glGetProgramivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramivARB_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMSTRINGARB)(GLenum target, GLenum pname, GLvoid * string);
static PFN_GLGETPROGRAMSTRINGARB _glGetProgramStringARB_ptr = NULL;

static inline void APIENTRY _glGetProgramStringARB(GLenum target, GLenum pname, GLvoid * string) {
    const char *_name = "glGetProgramStringARB";
    if (!_glGetProgramStringARB_ptr) {
        _glGetProgramStringARB_ptr = (PFN_GLGETPROGRAMSTRINGARB)_getPrivateProcAddress(_name);
        if (!_glGetProgramStringARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramStringARB_ptr(target, pname, string);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBDVARB)(GLuint index, GLenum pname, GLdouble * params);
static PFN_GLGETVERTEXATTRIBDVARB _glGetVertexAttribdvARB_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble * params) {
    const char *_name = "glGetVertexAttribdvARB";
    if (!_glGetVertexAttribdvARB_ptr) {
        _glGetVertexAttribdvARB_ptr = (PFN_GLGETVERTEXATTRIBDVARB)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribdvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribdvARB_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBFVARB)(GLuint index, GLenum pname, GLfloat * params);
static PFN_GLGETVERTEXATTRIBFVARB _glGetVertexAttribfvARB_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat * params) {
    const char *_name = "glGetVertexAttribfvARB";
    if (!_glGetVertexAttribfvARB_ptr) {
        _glGetVertexAttribfvARB_ptr = (PFN_GLGETVERTEXATTRIBFVARB)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribfvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribfvARB_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBIVARB)(GLuint index, GLenum pname, GLint * params);
static PFN_GLGETVERTEXATTRIBIVARB _glGetVertexAttribivARB_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribivARB(GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetVertexAttribivARB";
    if (!_glGetVertexAttribivARB_ptr) {
        _glGetVertexAttribivARB_ptr = (PFN_GLGETVERTEXATTRIBIVARB)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribivARB_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBPOINTERVARB)(GLuint index, GLenum pname, GLvoid * * pointer);
static PFN_GLGETVERTEXATTRIBPOINTERVARB _glGetVertexAttribPointervARB_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid * * pointer) {
    const char *_name = "glGetVertexAttribPointervARB";
    if (!_glGetVertexAttribPointervARB_ptr) {
        _glGetVertexAttribPointervARB_ptr = (PFN_GLGETVERTEXATTRIBPOINTERVARB)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribPointervARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribPointervARB_ptr(index, pname, pointer);
}

typedef GLboolean (APIENTRY * PFN_GLISPROGRAMARB)(GLuint program);
static PFN_GLISPROGRAMARB _glIsProgramARB_ptr = NULL;

static inline GLboolean APIENTRY _glIsProgramARB(GLuint program) {
    const char *_name = "glIsProgramARB";
    if (!_glIsProgramARB_ptr) {
        _glIsProgramARB_ptr = (PFN_GLISPROGRAMARB)_getPrivateProcAddress(_name);
        if (!_glIsProgramARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsProgramARB_ptr(program);
}

typedef void (APIENTRY * PFN_GLBINDBUFFERARB)(GLenum target, GLuint buffer);
static PFN_GLBINDBUFFERARB _glBindBufferARB_ptr = NULL;

static inline void APIENTRY _glBindBufferARB(GLenum target, GLuint buffer) {
    const char *_name = "glBindBufferARB";
    if (!_glBindBufferARB_ptr) {
        _glBindBufferARB_ptr = (PFN_GLBINDBUFFERARB)_getPrivateProcAddress(_name);
        if (!_glBindBufferARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindBufferARB_ptr(target, buffer);
}

typedef void (APIENTRY * PFN_GLDELETEBUFFERSARB)(GLsizei n, const GLuint * buffers);
static PFN_GLDELETEBUFFERSARB _glDeleteBuffersARB_ptr = NULL;

static inline void APIENTRY _glDeleteBuffersARB(GLsizei n, const GLuint * buffers) {
    const char *_name = "glDeleteBuffersARB";
    if (!_glDeleteBuffersARB_ptr) {
        _glDeleteBuffersARB_ptr = (PFN_GLDELETEBUFFERSARB)_getPrivateProcAddress(_name);
        if (!_glDeleteBuffersARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteBuffersARB_ptr(n, buffers);
}

typedef void (APIENTRY * PFN_GLGENBUFFERSARB)(GLsizei n, GLuint * buffers);
static PFN_GLGENBUFFERSARB _glGenBuffersARB_ptr = NULL;

static inline void APIENTRY _glGenBuffersARB(GLsizei n, GLuint * buffers) {
    const char *_name = "glGenBuffersARB";
    if (!_glGenBuffersARB_ptr) {
        _glGenBuffersARB_ptr = (PFN_GLGENBUFFERSARB)_getPrivateProcAddress(_name);
        if (!_glGenBuffersARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenBuffersARB_ptr(n, buffers);
}

typedef GLboolean (APIENTRY * PFN_GLISBUFFERARB)(GLuint buffer);
static PFN_GLISBUFFERARB _glIsBufferARB_ptr = NULL;

static inline GLboolean APIENTRY _glIsBufferARB(GLuint buffer) {
    const char *_name = "glIsBufferARB";
    if (!_glIsBufferARB_ptr) {
        _glIsBufferARB_ptr = (PFN_GLISBUFFERARB)_getPrivateProcAddress(_name);
        if (!_glIsBufferARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsBufferARB_ptr(buffer);
}

typedef void (APIENTRY * PFN_GLBUFFERDATAARB)(GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage);
static PFN_GLBUFFERDATAARB _glBufferDataARB_ptr = NULL;

static inline void APIENTRY _glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage) {
    const char *_name = "glBufferDataARB";
    if (!_glBufferDataARB_ptr) {
        _glBufferDataARB_ptr = (PFN_GLBUFFERDATAARB)_getPrivateProcAddress(_name);
        if (!_glBufferDataARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBufferDataARB_ptr(target, size, data, usage);
}

typedef void (APIENTRY * PFN_GLBUFFERSUBDATAARB)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data);
static PFN_GLBUFFERSUBDATAARB _glBufferSubDataARB_ptr = NULL;

static inline void APIENTRY _glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data) {
    const char *_name = "glBufferSubDataARB";
    if (!_glBufferSubDataARB_ptr) {
        _glBufferSubDataARB_ptr = (PFN_GLBUFFERSUBDATAARB)_getPrivateProcAddress(_name);
        if (!_glBufferSubDataARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBufferSubDataARB_ptr(target, offset, size, data);
}

typedef void (APIENTRY * PFN_GLGETBUFFERSUBDATAARB)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid * data);
static PFN_GLGETBUFFERSUBDATAARB _glGetBufferSubDataARB_ptr = NULL;

static inline void APIENTRY _glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid * data) {
    const char *_name = "glGetBufferSubDataARB";
    if (!_glGetBufferSubDataARB_ptr) {
        _glGetBufferSubDataARB_ptr = (PFN_GLGETBUFFERSUBDATAARB)_getPrivateProcAddress(_name);
        if (!_glGetBufferSubDataARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetBufferSubDataARB_ptr(target, offset, size, data);
}

typedef GLvoid * (APIENTRY * PFN_GLMAPBUFFERARB)(GLenum target, GLenum access);
static PFN_GLMAPBUFFERARB _glMapBufferARB_ptr = NULL;

static inline GLvoid * APIENTRY _glMapBufferARB(GLenum target, GLenum access) {
    const char *_name = "glMapBufferARB";
    if (!_glMapBufferARB_ptr) {
        _glMapBufferARB_ptr = (PFN_GLMAPBUFFERARB)_getPrivateProcAddress(_name);
        if (!_glMapBufferARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glMapBufferARB_ptr(target, access);
}

typedef GLboolean (APIENTRY * PFN_GLUNMAPBUFFERARB)(GLenum target);
static PFN_GLUNMAPBUFFERARB _glUnmapBufferARB_ptr = NULL;

static inline GLboolean APIENTRY _glUnmapBufferARB(GLenum target) {
    const char *_name = "glUnmapBufferARB";
    if (!_glUnmapBufferARB_ptr) {
        _glUnmapBufferARB_ptr = (PFN_GLUNMAPBUFFERARB)_getPrivateProcAddress(_name);
        if (!_glUnmapBufferARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glUnmapBufferARB_ptr(target);
}

typedef void (APIENTRY * PFN_GLGETBUFFERPARAMETERIVARB)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETBUFFERPARAMETERIVARB _glGetBufferParameterivARB_ptr = NULL;

static inline void APIENTRY _glGetBufferParameterivARB(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetBufferParameterivARB";
    if (!_glGetBufferParameterivARB_ptr) {
        _glGetBufferParameterivARB_ptr = (PFN_GLGETBUFFERPARAMETERIVARB)_getPrivateProcAddress(_name);
        if (!_glGetBufferParameterivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetBufferParameterivARB_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETBUFFERPOINTERVARB)(GLenum target, GLenum pname, GLvoid * * params);
static PFN_GLGETBUFFERPOINTERVARB _glGetBufferPointervARB_ptr = NULL;

static inline void APIENTRY _glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid * * params) {
    const char *_name = "glGetBufferPointervARB";
    if (!_glGetBufferPointervARB_ptr) {
        _glGetBufferPointervARB_ptr = (PFN_GLGETBUFFERPOINTERVARB)_getPrivateProcAddress(_name);
        if (!_glGetBufferPointervARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetBufferPointervARB_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGENQUERIESARB)(GLsizei n, GLuint * ids);
static PFN_GLGENQUERIESARB _glGenQueriesARB_ptr = NULL;

static inline void APIENTRY _glGenQueriesARB(GLsizei n, GLuint * ids) {
    const char *_name = "glGenQueriesARB";
    if (!_glGenQueriesARB_ptr) {
        _glGenQueriesARB_ptr = (PFN_GLGENQUERIESARB)_getPrivateProcAddress(_name);
        if (!_glGenQueriesARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenQueriesARB_ptr(n, ids);
}

typedef void (APIENTRY * PFN_GLDELETEQUERIESARB)(GLsizei n, const GLuint * ids);
static PFN_GLDELETEQUERIESARB _glDeleteQueriesARB_ptr = NULL;

static inline void APIENTRY _glDeleteQueriesARB(GLsizei n, const GLuint * ids) {
    const char *_name = "glDeleteQueriesARB";
    if (!_glDeleteQueriesARB_ptr) {
        _glDeleteQueriesARB_ptr = (PFN_GLDELETEQUERIESARB)_getPrivateProcAddress(_name);
        if (!_glDeleteQueriesARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteQueriesARB_ptr(n, ids);
}

typedef GLboolean (APIENTRY * PFN_GLISQUERYARB)(GLuint id);
static PFN_GLISQUERYARB _glIsQueryARB_ptr = NULL;

static inline GLboolean APIENTRY _glIsQueryARB(GLuint id) {
    const char *_name = "glIsQueryARB";
    if (!_glIsQueryARB_ptr) {
        _glIsQueryARB_ptr = (PFN_GLISQUERYARB)_getPrivateProcAddress(_name);
        if (!_glIsQueryARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsQueryARB_ptr(id);
}

typedef void (APIENTRY * PFN_GLBEGINQUERYARB)(GLenum target, GLuint id);
static PFN_GLBEGINQUERYARB _glBeginQueryARB_ptr = NULL;

static inline void APIENTRY _glBeginQueryARB(GLenum target, GLuint id) {
    const char *_name = "glBeginQueryARB";
    if (!_glBeginQueryARB_ptr) {
        _glBeginQueryARB_ptr = (PFN_GLBEGINQUERYARB)_getPrivateProcAddress(_name);
        if (!_glBeginQueryARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginQueryARB_ptr(target, id);
}

typedef void (APIENTRY * PFN_GLENDQUERYARB)(GLenum target);
static PFN_GLENDQUERYARB _glEndQueryARB_ptr = NULL;

static inline void APIENTRY _glEndQueryARB(GLenum target) {
    const char *_name = "glEndQueryARB";
    if (!_glEndQueryARB_ptr) {
        _glEndQueryARB_ptr = (PFN_GLENDQUERYARB)_getPrivateProcAddress(_name);
        if (!_glEndQueryARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndQueryARB_ptr(target);
}

typedef void (APIENTRY * PFN_GLGETQUERYIVARB)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETQUERYIVARB _glGetQueryivARB_ptr = NULL;

static inline void APIENTRY _glGetQueryivARB(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryivARB";
    if (!_glGetQueryivARB_ptr) {
        _glGetQueryivARB_ptr = (PFN_GLGETQUERYIVARB)_getPrivateProcAddress(_name);
        if (!_glGetQueryivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetQueryivARB_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETQUERYOBJECTIVARB)(GLuint id, GLenum pname, GLint * params);
static PFN_GLGETQUERYOBJECTIVARB _glGetQueryObjectivARB_ptr = NULL;

static inline void APIENTRY _glGetQueryObjectivARB(GLuint id, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryObjectivARB";
    if (!_glGetQueryObjectivARB_ptr) {
        _glGetQueryObjectivARB_ptr = (PFN_GLGETQUERYOBJECTIVARB)_getPrivateProcAddress(_name);
        if (!_glGetQueryObjectivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetQueryObjectivARB_ptr(id, pname, params);
}

typedef void (APIENTRY * PFN_GLGETQUERYOBJECTUIVARB)(GLuint id, GLenum pname, GLuint * params);
static PFN_GLGETQUERYOBJECTUIVARB _glGetQueryObjectuivARB_ptr = NULL;

static inline void APIENTRY _glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint * params) {
    const char *_name = "glGetQueryObjectuivARB";
    if (!_glGetQueryObjectuivARB_ptr) {
        _glGetQueryObjectuivARB_ptr = (PFN_GLGETQUERYOBJECTUIVARB)_getPrivateProcAddress(_name);
        if (!_glGetQueryObjectuivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetQueryObjectuivARB_ptr(id, pname, params);
}

typedef void (APIENTRY * PFN_GLDELETEOBJECTARB)(GLhandleARB obj);
static PFN_GLDELETEOBJECTARB _glDeleteObjectARB_ptr = NULL;

static inline void APIENTRY _glDeleteObjectARB(GLhandleARB obj) {
    const char *_name = "glDeleteObjectARB";
    if (!_glDeleteObjectARB_ptr) {
        _glDeleteObjectARB_ptr = (PFN_GLDELETEOBJECTARB)_getPrivateProcAddress(_name);
        if (!_glDeleteObjectARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteObjectARB_ptr(obj);
}

typedef GLhandleARB (APIENTRY * PFN_GLGETHANDLEARB)(GLenum pname);
static PFN_GLGETHANDLEARB _glGetHandleARB_ptr = NULL;

static inline GLhandleARB APIENTRY _glGetHandleARB(GLenum pname) {
    const char *_name = "glGetHandleARB";
    if (!_glGetHandleARB_ptr) {
        _glGetHandleARB_ptr = (PFN_GLGETHANDLEARB)_getPrivateProcAddress(_name);
        if (!_glGetHandleARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetHandleARB_ptr(pname);
}

typedef void (APIENTRY * PFN_GLDETACHOBJECTARB)(GLhandleARB containerObj, GLhandleARB attachedObj);
static PFN_GLDETACHOBJECTARB _glDetachObjectARB_ptr = NULL;

static inline void APIENTRY _glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj) {
    const char *_name = "glDetachObjectARB";
    if (!_glDetachObjectARB_ptr) {
        _glDetachObjectARB_ptr = (PFN_GLDETACHOBJECTARB)_getPrivateProcAddress(_name);
        if (!_glDetachObjectARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDetachObjectARB_ptr(containerObj, attachedObj);
}

typedef GLhandleARB (APIENTRY * PFN_GLCREATESHADEROBJECTARB)(GLenum shaderType);
static PFN_GLCREATESHADEROBJECTARB _glCreateShaderObjectARB_ptr = NULL;

static inline GLhandleARB APIENTRY _glCreateShaderObjectARB(GLenum shaderType) {
    const char *_name = "glCreateShaderObjectARB";
    if (!_glCreateShaderObjectARB_ptr) {
        _glCreateShaderObjectARB_ptr = (PFN_GLCREATESHADEROBJECTARB)_getPrivateProcAddress(_name);
        if (!_glCreateShaderObjectARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glCreateShaderObjectARB_ptr(shaderType);
}

typedef void (APIENTRY * PFN_GLSHADERSOURCEARB)(GLhandleARB shaderObj, GLsizei count, const GLcharARB * * const string, const GLint * length);
static PFN_GLSHADERSOURCEARB _glShaderSourceARB_ptr = NULL;

static inline void APIENTRY _glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB * * const string, const GLint * length) {
    const char *_name = "glShaderSourceARB";
    if (!_glShaderSourceARB_ptr) {
        _glShaderSourceARB_ptr = (PFN_GLSHADERSOURCEARB)_getPrivateProcAddress(_name);
        if (!_glShaderSourceARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glShaderSourceARB_ptr(shaderObj, count, string, length);
}

typedef void (APIENTRY * PFN_GLCOMPILESHADERARB)(GLhandleARB shaderObj);
static PFN_GLCOMPILESHADERARB _glCompileShaderARB_ptr = NULL;

static inline void APIENTRY _glCompileShaderARB(GLhandleARB shaderObj) {
    const char *_name = "glCompileShaderARB";
    if (!_glCompileShaderARB_ptr) {
        _glCompileShaderARB_ptr = (PFN_GLCOMPILESHADERARB)_getPrivateProcAddress(_name);
        if (!_glCompileShaderARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompileShaderARB_ptr(shaderObj);
}

typedef GLhandleARB (APIENTRY * PFN_GLCREATEPROGRAMOBJECTARB)(void);
static PFN_GLCREATEPROGRAMOBJECTARB _glCreateProgramObjectARB_ptr = NULL;

static inline GLhandleARB APIENTRY _glCreateProgramObjectARB(void) {
    const char *_name = "glCreateProgramObjectARB";
    if (!_glCreateProgramObjectARB_ptr) {
        _glCreateProgramObjectARB_ptr = (PFN_GLCREATEPROGRAMOBJECTARB)_getPrivateProcAddress(_name);
        if (!_glCreateProgramObjectARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glCreateProgramObjectARB_ptr();
}

typedef void (APIENTRY * PFN_GLATTACHOBJECTARB)(GLhandleARB containerObj, GLhandleARB obj);
static PFN_GLATTACHOBJECTARB _glAttachObjectARB_ptr = NULL;

static inline void APIENTRY _glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj) {
    const char *_name = "glAttachObjectARB";
    if (!_glAttachObjectARB_ptr) {
        _glAttachObjectARB_ptr = (PFN_GLATTACHOBJECTARB)_getPrivateProcAddress(_name);
        if (!_glAttachObjectARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glAttachObjectARB_ptr(containerObj, obj);
}

typedef void (APIENTRY * PFN_GLLINKPROGRAMARB)(GLhandleARB programObj);
static PFN_GLLINKPROGRAMARB _glLinkProgramARB_ptr = NULL;

static inline void APIENTRY _glLinkProgramARB(GLhandleARB programObj) {
    const char *_name = "glLinkProgramARB";
    if (!_glLinkProgramARB_ptr) {
        _glLinkProgramARB_ptr = (PFN_GLLINKPROGRAMARB)_getPrivateProcAddress(_name);
        if (!_glLinkProgramARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLinkProgramARB_ptr(programObj);
}

typedef void (APIENTRY * PFN_GLUSEPROGRAMOBJECTARB)(GLhandleARB programObj);
static PFN_GLUSEPROGRAMOBJECTARB _glUseProgramObjectARB_ptr = NULL;

static inline void APIENTRY _glUseProgramObjectARB(GLhandleARB programObj) {
    const char *_name = "glUseProgramObjectARB";
    if (!_glUseProgramObjectARB_ptr) {
        _glUseProgramObjectARB_ptr = (PFN_GLUSEPROGRAMOBJECTARB)_getPrivateProcAddress(_name);
        if (!_glUseProgramObjectARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUseProgramObjectARB_ptr(programObj);
}

typedef void (APIENTRY * PFN_GLVALIDATEPROGRAMARB)(GLhandleARB programObj);
static PFN_GLVALIDATEPROGRAMARB _glValidateProgramARB_ptr = NULL;

static inline void APIENTRY _glValidateProgramARB(GLhandleARB programObj) {
    const char *_name = "glValidateProgramARB";
    if (!_glValidateProgramARB_ptr) {
        _glValidateProgramARB_ptr = (PFN_GLVALIDATEPROGRAMARB)_getPrivateProcAddress(_name);
        if (!_glValidateProgramARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glValidateProgramARB_ptr(programObj);
}

typedef void (APIENTRY * PFN_GLUNIFORM1FARB)(GLint location, GLfloat v0);
static PFN_GLUNIFORM1FARB _glUniform1fARB_ptr = NULL;

static inline void APIENTRY _glUniform1fARB(GLint location, GLfloat v0) {
    const char *_name = "glUniform1fARB";
    if (!_glUniform1fARB_ptr) {
        _glUniform1fARB_ptr = (PFN_GLUNIFORM1FARB)_getPrivateProcAddress(_name);
        if (!_glUniform1fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1fARB_ptr(location, v0);
}

typedef void (APIENTRY * PFN_GLUNIFORM2FARB)(GLint location, GLfloat v0, GLfloat v1);
static PFN_GLUNIFORM2FARB _glUniform2fARB_ptr = NULL;

static inline void APIENTRY _glUniform2fARB(GLint location, GLfloat v0, GLfloat v1) {
    const char *_name = "glUniform2fARB";
    if (!_glUniform2fARB_ptr) {
        _glUniform2fARB_ptr = (PFN_GLUNIFORM2FARB)_getPrivateProcAddress(_name);
        if (!_glUniform2fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2fARB_ptr(location, v0, v1);
}

typedef void (APIENTRY * PFN_GLUNIFORM3FARB)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
static PFN_GLUNIFORM3FARB _glUniform3fARB_ptr = NULL;

static inline void APIENTRY _glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
    const char *_name = "glUniform3fARB";
    if (!_glUniform3fARB_ptr) {
        _glUniform3fARB_ptr = (PFN_GLUNIFORM3FARB)_getPrivateProcAddress(_name);
        if (!_glUniform3fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3fARB_ptr(location, v0, v1, v2);
}

typedef void (APIENTRY * PFN_GLUNIFORM4FARB)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
static PFN_GLUNIFORM4FARB _glUniform4fARB_ptr = NULL;

static inline void APIENTRY _glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
    const char *_name = "glUniform4fARB";
    if (!_glUniform4fARB_ptr) {
        _glUniform4fARB_ptr = (PFN_GLUNIFORM4FARB)_getPrivateProcAddress(_name);
        if (!_glUniform4fARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4fARB_ptr(location, v0, v1, v2, v3);
}

typedef void (APIENTRY * PFN_GLUNIFORM1IARB)(GLint location, GLint v0);
static PFN_GLUNIFORM1IARB _glUniform1iARB_ptr = NULL;

static inline void APIENTRY _glUniform1iARB(GLint location, GLint v0) {
    const char *_name = "glUniform1iARB";
    if (!_glUniform1iARB_ptr) {
        _glUniform1iARB_ptr = (PFN_GLUNIFORM1IARB)_getPrivateProcAddress(_name);
        if (!_glUniform1iARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1iARB_ptr(location, v0);
}

typedef void (APIENTRY * PFN_GLUNIFORM2IARB)(GLint location, GLint v0, GLint v1);
static PFN_GLUNIFORM2IARB _glUniform2iARB_ptr = NULL;

static inline void APIENTRY _glUniform2iARB(GLint location, GLint v0, GLint v1) {
    const char *_name = "glUniform2iARB";
    if (!_glUniform2iARB_ptr) {
        _glUniform2iARB_ptr = (PFN_GLUNIFORM2IARB)_getPrivateProcAddress(_name);
        if (!_glUniform2iARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2iARB_ptr(location, v0, v1);
}

typedef void (APIENTRY * PFN_GLUNIFORM3IARB)(GLint location, GLint v0, GLint v1, GLint v2);
static PFN_GLUNIFORM3IARB _glUniform3iARB_ptr = NULL;

static inline void APIENTRY _glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2) {
    const char *_name = "glUniform3iARB";
    if (!_glUniform3iARB_ptr) {
        _glUniform3iARB_ptr = (PFN_GLUNIFORM3IARB)_getPrivateProcAddress(_name);
        if (!_glUniform3iARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3iARB_ptr(location, v0, v1, v2);
}

typedef void (APIENTRY * PFN_GLUNIFORM4IARB)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
static PFN_GLUNIFORM4IARB _glUniform4iARB_ptr = NULL;

static inline void APIENTRY _glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
    const char *_name = "glUniform4iARB";
    if (!_glUniform4iARB_ptr) {
        _glUniform4iARB_ptr = (PFN_GLUNIFORM4IARB)_getPrivateProcAddress(_name);
        if (!_glUniform4iARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4iARB_ptr(location, v0, v1, v2, v3);
}

typedef void (APIENTRY * PFN_GLUNIFORM1FVARB)(GLint location, GLsizei count, const GLfloat * value);
static PFN_GLUNIFORM1FVARB _glUniform1fvARB_ptr = NULL;

static inline void APIENTRY _glUniform1fvARB(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform1fvARB";
    if (!_glUniform1fvARB_ptr) {
        _glUniform1fvARB_ptr = (PFN_GLUNIFORM1FVARB)_getPrivateProcAddress(_name);
        if (!_glUniform1fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1fvARB_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM2FVARB)(GLint location, GLsizei count, const GLfloat * value);
static PFN_GLUNIFORM2FVARB _glUniform2fvARB_ptr = NULL;

static inline void APIENTRY _glUniform2fvARB(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform2fvARB";
    if (!_glUniform2fvARB_ptr) {
        _glUniform2fvARB_ptr = (PFN_GLUNIFORM2FVARB)_getPrivateProcAddress(_name);
        if (!_glUniform2fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2fvARB_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM3FVARB)(GLint location, GLsizei count, const GLfloat * value);
static PFN_GLUNIFORM3FVARB _glUniform3fvARB_ptr = NULL;

static inline void APIENTRY _glUniform3fvARB(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform3fvARB";
    if (!_glUniform3fvARB_ptr) {
        _glUniform3fvARB_ptr = (PFN_GLUNIFORM3FVARB)_getPrivateProcAddress(_name);
        if (!_glUniform3fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3fvARB_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM4FVARB)(GLint location, GLsizei count, const GLfloat * value);
static PFN_GLUNIFORM4FVARB _glUniform4fvARB_ptr = NULL;

static inline void APIENTRY _glUniform4fvARB(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform4fvARB";
    if (!_glUniform4fvARB_ptr) {
        _glUniform4fvARB_ptr = (PFN_GLUNIFORM4FVARB)_getPrivateProcAddress(_name);
        if (!_glUniform4fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4fvARB_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM1IVARB)(GLint location, GLsizei count, const GLint * value);
static PFN_GLUNIFORM1IVARB _glUniform1ivARB_ptr = NULL;

static inline void APIENTRY _glUniform1ivARB(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform1ivARB";
    if (!_glUniform1ivARB_ptr) {
        _glUniform1ivARB_ptr = (PFN_GLUNIFORM1IVARB)_getPrivateProcAddress(_name);
        if (!_glUniform1ivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1ivARB_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM2IVARB)(GLint location, GLsizei count, const GLint * value);
static PFN_GLUNIFORM2IVARB _glUniform2ivARB_ptr = NULL;

static inline void APIENTRY _glUniform2ivARB(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform2ivARB";
    if (!_glUniform2ivARB_ptr) {
        _glUniform2ivARB_ptr = (PFN_GLUNIFORM2IVARB)_getPrivateProcAddress(_name);
        if (!_glUniform2ivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2ivARB_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM3IVARB)(GLint location, GLsizei count, const GLint * value);
static PFN_GLUNIFORM3IVARB _glUniform3ivARB_ptr = NULL;

static inline void APIENTRY _glUniform3ivARB(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform3ivARB";
    if (!_glUniform3ivARB_ptr) {
        _glUniform3ivARB_ptr = (PFN_GLUNIFORM3IVARB)_getPrivateProcAddress(_name);
        if (!_glUniform3ivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3ivARB_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM4IVARB)(GLint location, GLsizei count, const GLint * value);
static PFN_GLUNIFORM4IVARB _glUniform4ivARB_ptr = NULL;

static inline void APIENTRY _glUniform4ivARB(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform4ivARB";
    if (!_glUniform4ivARB_ptr) {
        _glUniform4ivARB_ptr = (PFN_GLUNIFORM4IVARB)_getPrivateProcAddress(_name);
        if (!_glUniform4ivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4ivARB_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX2FVARB)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLUNIFORMMATRIX2FVARB _glUniformMatrix2fvARB_ptr = NULL;

static inline void APIENTRY _glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix2fvARB";
    if (!_glUniformMatrix2fvARB_ptr) {
        _glUniformMatrix2fvARB_ptr = (PFN_GLUNIFORMMATRIX2FVARB)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix2fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix2fvARB_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX3FVARB)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLUNIFORMMATRIX3FVARB _glUniformMatrix3fvARB_ptr = NULL;

static inline void APIENTRY _glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix3fvARB";
    if (!_glUniformMatrix3fvARB_ptr) {
        _glUniformMatrix3fvARB_ptr = (PFN_GLUNIFORMMATRIX3FVARB)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix3fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix3fvARB_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX4FVARB)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLUNIFORMMATRIX4FVARB _glUniformMatrix4fvARB_ptr = NULL;

static inline void APIENTRY _glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix4fvARB";
    if (!_glUniformMatrix4fvARB_ptr) {
        _glUniformMatrix4fvARB_ptr = (PFN_GLUNIFORMMATRIX4FVARB)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix4fvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix4fvARB_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLGETOBJECTPARAMETERFVARB)(GLhandleARB obj, GLenum pname, GLfloat * params);
static PFN_GLGETOBJECTPARAMETERFVARB _glGetObjectParameterfvARB_ptr = NULL;

static inline void APIENTRY _glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat * params) {
    const char *_name = "glGetObjectParameterfvARB";
    if (!_glGetObjectParameterfvARB_ptr) {
        _glGetObjectParameterfvARB_ptr = (PFN_GLGETOBJECTPARAMETERFVARB)_getPrivateProcAddress(_name);
        if (!_glGetObjectParameterfvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetObjectParameterfvARB_ptr(obj, pname, params);
}

typedef void (APIENTRY * PFN_GLGETOBJECTPARAMETERIVARB)(GLhandleARB obj, GLenum pname, GLint * params);
static PFN_GLGETOBJECTPARAMETERIVARB _glGetObjectParameterivARB_ptr = NULL;

static inline void APIENTRY _glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint * params) {
    const char *_name = "glGetObjectParameterivARB";
    if (!_glGetObjectParameterivARB_ptr) {
        _glGetObjectParameterivARB_ptr = (PFN_GLGETOBJECTPARAMETERIVARB)_getPrivateProcAddress(_name);
        if (!_glGetObjectParameterivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetObjectParameterivARB_ptr(obj, pname, params);
}

typedef void (APIENTRY * PFN_GLGETINFOLOGARB)(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog);
static PFN_GLGETINFOLOGARB _glGetInfoLogARB_ptr = NULL;

static inline void APIENTRY _glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog) {
    const char *_name = "glGetInfoLogARB";
    if (!_glGetInfoLogARB_ptr) {
        _glGetInfoLogARB_ptr = (PFN_GLGETINFOLOGARB)_getPrivateProcAddress(_name);
        if (!_glGetInfoLogARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetInfoLogARB_ptr(obj, maxLength, length, infoLog);
}

typedef void (APIENTRY * PFN_GLGETATTACHEDOBJECTSARB)(GLhandleARB containerObj, GLsizei maxCount, GLsizei * count, GLhandleARB * obj);
static PFN_GLGETATTACHEDOBJECTSARB _glGetAttachedObjectsARB_ptr = NULL;

static inline void APIENTRY _glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei * count, GLhandleARB * obj) {
    const char *_name = "glGetAttachedObjectsARB";
    if (!_glGetAttachedObjectsARB_ptr) {
        _glGetAttachedObjectsARB_ptr = (PFN_GLGETATTACHEDOBJECTSARB)_getPrivateProcAddress(_name);
        if (!_glGetAttachedObjectsARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetAttachedObjectsARB_ptr(containerObj, maxCount, count, obj);
}

typedef GLint (APIENTRY * PFN_GLGETUNIFORMLOCATIONARB)(GLhandleARB programObj, const GLcharARB * name);
static PFN_GLGETUNIFORMLOCATIONARB _glGetUniformLocationARB_ptr = NULL;

static inline GLint APIENTRY _glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB * name) {
    const char *_name = "glGetUniformLocationARB";
    if (!_glGetUniformLocationARB_ptr) {
        _glGetUniformLocationARB_ptr = (PFN_GLGETUNIFORMLOCATIONARB)_getPrivateProcAddress(_name);
        if (!_glGetUniformLocationARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetUniformLocationARB_ptr(programObj, name);
}

typedef void (APIENTRY * PFN_GLGETACTIVEUNIFORMARB)(GLhandleARB programObj, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name);
static PFN_GLGETACTIVEUNIFORMARB _glGetActiveUniformARB_ptr = NULL;

static inline void APIENTRY _glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name) {
    const char *_name = "glGetActiveUniformARB";
    if (!_glGetActiveUniformARB_ptr) {
        _glGetActiveUniformARB_ptr = (PFN_GLGETACTIVEUNIFORMARB)_getPrivateProcAddress(_name);
        if (!_glGetActiveUniformARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetActiveUniformARB_ptr(programObj, index, bufSize, length, size, type, name);
}

typedef void (APIENTRY * PFN_GLGETUNIFORMFVARB)(GLhandleARB programObj, GLint location, GLfloat * params);
static PFN_GLGETUNIFORMFVARB _glGetUniformfvARB_ptr = NULL;

static inline void APIENTRY _glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat * params) {
    const char *_name = "glGetUniformfvARB";
    if (!_glGetUniformfvARB_ptr) {
        _glGetUniformfvARB_ptr = (PFN_GLGETUNIFORMFVARB)_getPrivateProcAddress(_name);
        if (!_glGetUniformfvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetUniformfvARB_ptr(programObj, location, params);
}

typedef void (APIENTRY * PFN_GLGETUNIFORMIVARB)(GLhandleARB programObj, GLint location, GLint * params);
static PFN_GLGETUNIFORMIVARB _glGetUniformivARB_ptr = NULL;

static inline void APIENTRY _glGetUniformivARB(GLhandleARB programObj, GLint location, GLint * params) {
    const char *_name = "glGetUniformivARB";
    if (!_glGetUniformivARB_ptr) {
        _glGetUniformivARB_ptr = (PFN_GLGETUNIFORMIVARB)_getPrivateProcAddress(_name);
        if (!_glGetUniformivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetUniformivARB_ptr(programObj, location, params);
}

typedef void (APIENTRY * PFN_GLGETSHADERSOURCEARB)(GLhandleARB obj, GLsizei bufSize, GLsizei * length, GLcharARB * source);
static PFN_GLGETSHADERSOURCEARB _glGetShaderSourceARB_ptr = NULL;

static inline void APIENTRY _glGetShaderSourceARB(GLhandleARB obj, GLsizei bufSize, GLsizei * length, GLcharARB * source) {
    const char *_name = "glGetShaderSourceARB";
    if (!_glGetShaderSourceARB_ptr) {
        _glGetShaderSourceARB_ptr = (PFN_GLGETSHADERSOURCEARB)_getPrivateProcAddress(_name);
        if (!_glGetShaderSourceARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetShaderSourceARB_ptr(obj, bufSize, length, source);
}

typedef void (APIENTRY * PFN_GLBINDATTRIBLOCATIONARB)(GLhandleARB programObj, GLuint index, const GLcharARB * name);
static PFN_GLBINDATTRIBLOCATIONARB _glBindAttribLocationARB_ptr = NULL;

static inline void APIENTRY _glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB * name) {
    const char *_name = "glBindAttribLocationARB";
    if (!_glBindAttribLocationARB_ptr) {
        _glBindAttribLocationARB_ptr = (PFN_GLBINDATTRIBLOCATIONARB)_getPrivateProcAddress(_name);
        if (!_glBindAttribLocationARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindAttribLocationARB_ptr(programObj, index, name);
}

typedef void (APIENTRY * PFN_GLGETACTIVEATTRIBARB)(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name);
static PFN_GLGETACTIVEATTRIBARB _glGetActiveAttribARB_ptr = NULL;

static inline void APIENTRY _glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name) {
    const char *_name = "glGetActiveAttribARB";
    if (!_glGetActiveAttribARB_ptr) {
        _glGetActiveAttribARB_ptr = (PFN_GLGETACTIVEATTRIBARB)_getPrivateProcAddress(_name);
        if (!_glGetActiveAttribARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetActiveAttribARB_ptr(programObj, index, maxLength, length, size, type, name);
}

typedef GLint (APIENTRY * PFN_GLGETATTRIBLOCATIONARB)(GLhandleARB programObj, const GLcharARB * name);
static PFN_GLGETATTRIBLOCATIONARB _glGetAttribLocationARB_ptr = NULL;

static inline GLint APIENTRY _glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB * name) {
    const char *_name = "glGetAttribLocationARB";
    if (!_glGetAttribLocationARB_ptr) {
        _glGetAttribLocationARB_ptr = (PFN_GLGETATTRIBLOCATIONARB)_getPrivateProcAddress(_name);
        if (!_glGetAttribLocationARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetAttribLocationARB_ptr(programObj, name);
}

typedef void (APIENTRY * PFN_GLDRAWBUFFERSARB)(GLsizei n, const GLenum * bufs);
static PFN_GLDRAWBUFFERSARB _glDrawBuffersARB_ptr = NULL;

static inline void APIENTRY _glDrawBuffersARB(GLsizei n, const GLenum * bufs) {
    const char *_name = "glDrawBuffersARB";
    if (!_glDrawBuffersARB_ptr) {
        _glDrawBuffersARB_ptr = (PFN_GLDRAWBUFFERSARB)_getPrivateProcAddress(_name);
        if (!_glDrawBuffersARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawBuffersARB_ptr(n, bufs);
}

typedef void (APIENTRY * PFN_GLCLAMPCOLORARB)(GLenum target, GLenum clamp);
static PFN_GLCLAMPCOLORARB _glClampColorARB_ptr = NULL;

static inline void APIENTRY _glClampColorARB(GLenum target, GLenum clamp) {
    const char *_name = "glClampColorARB";
    if (!_glClampColorARB_ptr) {
        _glClampColorARB_ptr = (PFN_GLCLAMPCOLORARB)_getPrivateProcAddress(_name);
        if (!_glClampColorARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClampColorARB_ptr(target, clamp);
}

typedef void (APIENTRY * PFN_GLDRAWARRAYSINSTANCEDARB)(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
static PFN_GLDRAWARRAYSINSTANCEDARB _glDrawArraysInstancedARB_ptr = NULL;

static inline void APIENTRY _glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount) {
    const char *_name = "glDrawArraysInstancedARB";
    if (!_glDrawArraysInstancedARB_ptr) {
        _glDrawArraysInstancedARB_ptr = (PFN_GLDRAWARRAYSINSTANCEDARB)_getPrivateProcAddress(_name);
        if (!_glDrawArraysInstancedARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawArraysInstancedARB_ptr(mode, first, count, primcount);
}

typedef void (APIENTRY * PFN_GLDRAWELEMENTSINSTANCEDARB)(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount);
static PFN_GLDRAWELEMENTSINSTANCEDARB _glDrawElementsInstancedARB_ptr = NULL;

static inline void APIENTRY _glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount) {
    const char *_name = "glDrawElementsInstancedARB";
    if (!_glDrawElementsInstancedARB_ptr) {
        _glDrawElementsInstancedARB_ptr = (PFN_GLDRAWELEMENTSINSTANCEDARB)_getPrivateProcAddress(_name);
        if (!_glDrawElementsInstancedARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawElementsInstancedARB_ptr(mode, count, type, indices, primcount);
}

typedef GLboolean (APIENTRY * PFN_GLISRENDERBUFFER)(GLuint renderbuffer);
static PFN_GLISRENDERBUFFER _glIsRenderbuffer_ptr = NULL;

static inline GLboolean APIENTRY _glIsRenderbuffer(GLuint renderbuffer) {
    const char *_name = "glIsRenderbuffer";
    if (!_glIsRenderbuffer_ptr) {
        _glIsRenderbuffer_ptr = (PFN_GLISRENDERBUFFER)_getPrivateProcAddress(_name);
        if (!_glIsRenderbuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsRenderbuffer_ptr(renderbuffer);
}

typedef void (APIENTRY * PFN_GLBINDRENDERBUFFER)(GLenum target, GLuint renderbuffer);
static PFN_GLBINDRENDERBUFFER _glBindRenderbuffer_ptr = NULL;

static inline void APIENTRY _glBindRenderbuffer(GLenum target, GLuint renderbuffer) {
    const char *_name = "glBindRenderbuffer";
    if (!_glBindRenderbuffer_ptr) {
        _glBindRenderbuffer_ptr = (PFN_GLBINDRENDERBUFFER)_getPrivateProcAddress(_name);
        if (!_glBindRenderbuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindRenderbuffer_ptr(target, renderbuffer);
}

typedef void (APIENTRY * PFN_GLDELETERENDERBUFFERS)(GLsizei n, const GLuint * renderbuffers);
static PFN_GLDELETERENDERBUFFERS _glDeleteRenderbuffers_ptr = NULL;

static inline void APIENTRY _glDeleteRenderbuffers(GLsizei n, const GLuint * renderbuffers) {
    const char *_name = "glDeleteRenderbuffers";
    if (!_glDeleteRenderbuffers_ptr) {
        _glDeleteRenderbuffers_ptr = (PFN_GLDELETERENDERBUFFERS)_getPrivateProcAddress(_name);
        if (!_glDeleteRenderbuffers_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteRenderbuffers_ptr(n, renderbuffers);
}

typedef void (APIENTRY * PFN_GLGENRENDERBUFFERS)(GLsizei n, GLuint * renderbuffers);
static PFN_GLGENRENDERBUFFERS _glGenRenderbuffers_ptr = NULL;

static inline void APIENTRY _glGenRenderbuffers(GLsizei n, GLuint * renderbuffers) {
    const char *_name = "glGenRenderbuffers";
    if (!_glGenRenderbuffers_ptr) {
        _glGenRenderbuffers_ptr = (PFN_GLGENRENDERBUFFERS)_getPrivateProcAddress(_name);
        if (!_glGenRenderbuffers_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenRenderbuffers_ptr(n, renderbuffers);
}

typedef void (APIENTRY * PFN_GLRENDERBUFFERSTORAGE)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLRENDERBUFFERSTORAGE _glRenderbufferStorage_ptr = NULL;

static inline void APIENTRY _glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorage";
    if (!_glRenderbufferStorage_ptr) {
        _glRenderbufferStorage_ptr = (PFN_GLRENDERBUFFERSTORAGE)_getPrivateProcAddress(_name);
        if (!_glRenderbufferStorage_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRenderbufferStorage_ptr(target, internalformat, width, height);
}

typedef void (APIENTRY * PFN_GLGETRENDERBUFFERPARAMETERIV)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETRENDERBUFFERPARAMETERIV _glGetRenderbufferParameteriv_ptr = NULL;

static inline void APIENTRY _glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetRenderbufferParameteriv";
    if (!_glGetRenderbufferParameteriv_ptr) {
        _glGetRenderbufferParameteriv_ptr = (PFN_GLGETRENDERBUFFERPARAMETERIV)_getPrivateProcAddress(_name);
        if (!_glGetRenderbufferParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetRenderbufferParameteriv_ptr(target, pname, params);
}

typedef GLboolean (APIENTRY * PFN_GLISFRAMEBUFFER)(GLuint framebuffer);
static PFN_GLISFRAMEBUFFER _glIsFramebuffer_ptr = NULL;

static inline GLboolean APIENTRY _glIsFramebuffer(GLuint framebuffer) {
    const char *_name = "glIsFramebuffer";
    if (!_glIsFramebuffer_ptr) {
        _glIsFramebuffer_ptr = (PFN_GLISFRAMEBUFFER)_getPrivateProcAddress(_name);
        if (!_glIsFramebuffer_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsFramebuffer_ptr(framebuffer);
}

typedef void (APIENTRY * PFN_GLBINDFRAMEBUFFER)(GLenum target, GLuint framebuffer);
static PFN_GLBINDFRAMEBUFFER _glBindFramebuffer_ptr = NULL;

static inline void APIENTRY _glBindFramebuffer(GLenum target, GLuint framebuffer) {
    const char *_name = "glBindFramebuffer";
    if (!_glBindFramebuffer_ptr) {
        _glBindFramebuffer_ptr = (PFN_GLBINDFRAMEBUFFER)_getPrivateProcAddress(_name);
        if (!_glBindFramebuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindFramebuffer_ptr(target, framebuffer);
}

typedef void (APIENTRY * PFN_GLDELETEFRAMEBUFFERS)(GLsizei n, const GLuint * framebuffers);
static PFN_GLDELETEFRAMEBUFFERS _glDeleteFramebuffers_ptr = NULL;

static inline void APIENTRY _glDeleteFramebuffers(GLsizei n, const GLuint * framebuffers) {
    const char *_name = "glDeleteFramebuffers";
    if (!_glDeleteFramebuffers_ptr) {
        _glDeleteFramebuffers_ptr = (PFN_GLDELETEFRAMEBUFFERS)_getPrivateProcAddress(_name);
        if (!_glDeleteFramebuffers_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteFramebuffers_ptr(n, framebuffers);
}

typedef void (APIENTRY * PFN_GLGENFRAMEBUFFERS)(GLsizei n, GLuint * framebuffers);
static PFN_GLGENFRAMEBUFFERS _glGenFramebuffers_ptr = NULL;

static inline void APIENTRY _glGenFramebuffers(GLsizei n, GLuint * framebuffers) {
    const char *_name = "glGenFramebuffers";
    if (!_glGenFramebuffers_ptr) {
        _glGenFramebuffers_ptr = (PFN_GLGENFRAMEBUFFERS)_getPrivateProcAddress(_name);
        if (!_glGenFramebuffers_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenFramebuffers_ptr(n, framebuffers);
}

typedef GLenum (APIENTRY * PFN_GLCHECKFRAMEBUFFERSTATUS)(GLenum target);
static PFN_GLCHECKFRAMEBUFFERSTATUS _glCheckFramebufferStatus_ptr = NULL;

static inline GLenum APIENTRY _glCheckFramebufferStatus(GLenum target) {
    const char *_name = "glCheckFramebufferStatus";
    if (!_glCheckFramebufferStatus_ptr) {
        _glCheckFramebufferStatus_ptr = (PFN_GLCHECKFRAMEBUFFERSTATUS)_getPrivateProcAddress(_name);
        if (!_glCheckFramebufferStatus_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glCheckFramebufferStatus_ptr(target);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTURE1D)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
static PFN_GLFRAMEBUFFERTEXTURE1D _glFramebufferTexture1D_ptr = NULL;

static inline void APIENTRY _glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTexture1D";
    if (!_glFramebufferTexture1D_ptr) {
        _glFramebufferTexture1D_ptr = (PFN_GLFRAMEBUFFERTEXTURE1D)_getPrivateProcAddress(_name);
        if (!_glFramebufferTexture1D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTexture1D_ptr(target, attachment, textarget, texture, level);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTURE2D)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
static PFN_GLFRAMEBUFFERTEXTURE2D _glFramebufferTexture2D_ptr = NULL;

static inline void APIENTRY _glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTexture2D";
    if (!_glFramebufferTexture2D_ptr) {
        _glFramebufferTexture2D_ptr = (PFN_GLFRAMEBUFFERTEXTURE2D)_getPrivateProcAddress(_name);
        if (!_glFramebufferTexture2D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTexture2D_ptr(target, attachment, textarget, texture, level);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTURE3D)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
static PFN_GLFRAMEBUFFERTEXTURE3D _glFramebufferTexture3D_ptr = NULL;

static inline void APIENTRY _glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
    const char *_name = "glFramebufferTexture3D";
    if (!_glFramebufferTexture3D_ptr) {
        _glFramebufferTexture3D_ptr = (PFN_GLFRAMEBUFFERTEXTURE3D)_getPrivateProcAddress(_name);
        if (!_glFramebufferTexture3D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTexture3D_ptr(target, attachment, textarget, texture, level, zoffset);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERRENDERBUFFER)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
static PFN_GLFRAMEBUFFERRENDERBUFFER _glFramebufferRenderbuffer_ptr = NULL;

static inline void APIENTRY _glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    const char *_name = "glFramebufferRenderbuffer";
    if (!_glFramebufferRenderbuffer_ptr) {
        _glFramebufferRenderbuffer_ptr = (PFN_GLFRAMEBUFFERRENDERBUFFER)_getPrivateProcAddress(_name);
        if (!_glFramebufferRenderbuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferRenderbuffer_ptr(target, attachment, renderbuffertarget, renderbuffer);
}

typedef void (APIENTRY * PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIV)(GLenum target, GLenum attachment, GLenum pname, GLint * params);
static PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIV _glGetFramebufferAttachmentParameteriv_ptr = NULL;

static inline void APIENTRY _glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint * params) {
    const char *_name = "glGetFramebufferAttachmentParameteriv";
    if (!_glGetFramebufferAttachmentParameteriv_ptr) {
        _glGetFramebufferAttachmentParameteriv_ptr = (PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIV)_getPrivateProcAddress(_name);
        if (!_glGetFramebufferAttachmentParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFramebufferAttachmentParameteriv_ptr(target, attachment, pname, params);
}

typedef void (APIENTRY * PFN_GLGENERATEMIPMAP)(GLenum target);
static PFN_GLGENERATEMIPMAP _glGenerateMipmap_ptr = NULL;

static inline void APIENTRY _glGenerateMipmap(GLenum target) {
    const char *_name = "glGenerateMipmap";
    if (!_glGenerateMipmap_ptr) {
        _glGenerateMipmap_ptr = (PFN_GLGENERATEMIPMAP)_getPrivateProcAddress(_name);
        if (!_glGenerateMipmap_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenerateMipmap_ptr(target);
}

typedef void (APIENTRY * PFN_GLBLITFRAMEBUFFER)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
static PFN_GLBLITFRAMEBUFFER _glBlitFramebuffer_ptr = NULL;

static inline void APIENTRY _glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    const char *_name = "glBlitFramebuffer";
    if (!_glBlitFramebuffer_ptr) {
        _glBlitFramebuffer_ptr = (PFN_GLBLITFRAMEBUFFER)_getPrivateProcAddress(_name);
        if (!_glBlitFramebuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlitFramebuffer_ptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

typedef void (APIENTRY * PFN_GLRENDERBUFFERSTORAGEMULTISAMPLE)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLRENDERBUFFERSTORAGEMULTISAMPLE _glRenderbufferStorageMultisample_ptr = NULL;

static inline void APIENTRY _glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageMultisample";
    if (!_glRenderbufferStorageMultisample_ptr) {
        _glRenderbufferStorageMultisample_ptr = (PFN_GLRENDERBUFFERSTORAGEMULTISAMPLE)_getPrivateProcAddress(_name);
        if (!_glRenderbufferStorageMultisample_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRenderbufferStorageMultisample_ptr(target, samples, internalformat, width, height);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTURELAYER)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
static PFN_GLFRAMEBUFFERTEXTURELAYER _glFramebufferTextureLayer_ptr = NULL;

static inline void APIENTRY _glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    const char *_name = "glFramebufferTextureLayer";
    if (!_glFramebufferTextureLayer_ptr) {
        _glFramebufferTextureLayer_ptr = (PFN_GLFRAMEBUFFERTEXTURELAYER)_getPrivateProcAddress(_name);
        if (!_glFramebufferTextureLayer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTextureLayer_ptr(target, attachment, texture, level, layer);
}

typedef void (APIENTRY * PFN_GLPROGRAMPARAMETERIARB)(GLuint program, GLenum pname, GLint value);
static PFN_GLPROGRAMPARAMETERIARB _glProgramParameteriARB_ptr = NULL;

static inline void APIENTRY _glProgramParameteriARB(GLuint program, GLenum pname, GLint value) {
    const char *_name = "glProgramParameteriARB";
    if (!_glProgramParameteriARB_ptr) {
        _glProgramParameteriARB_ptr = (PFN_GLPROGRAMPARAMETERIARB)_getPrivateProcAddress(_name);
        if (!_glProgramParameteriARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramParameteriARB_ptr(program, pname, value);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTUREARB)(GLenum target, GLenum attachment, GLuint texture, GLint level);
static PFN_GLFRAMEBUFFERTEXTUREARB _glFramebufferTextureARB_ptr = NULL;

static inline void APIENTRY _glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTextureARB";
    if (!_glFramebufferTextureARB_ptr) {
        _glFramebufferTextureARB_ptr = (PFN_GLFRAMEBUFFERTEXTUREARB)_getPrivateProcAddress(_name);
        if (!_glFramebufferTextureARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTextureARB_ptr(target, attachment, texture, level);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTURELAYERARB)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
static PFN_GLFRAMEBUFFERTEXTURELAYERARB _glFramebufferTextureLayerARB_ptr = NULL;

static inline void APIENTRY _glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    const char *_name = "glFramebufferTextureLayerARB";
    if (!_glFramebufferTextureLayerARB_ptr) {
        _glFramebufferTextureLayerARB_ptr = (PFN_GLFRAMEBUFFERTEXTURELAYERARB)_getPrivateProcAddress(_name);
        if (!_glFramebufferTextureLayerARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTextureLayerARB_ptr(target, attachment, texture, level, layer);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTUREFACEARB)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
static PFN_GLFRAMEBUFFERTEXTUREFACEARB _glFramebufferTextureFaceARB_ptr = NULL;

static inline void APIENTRY _glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) {
    const char *_name = "glFramebufferTextureFaceARB";
    if (!_glFramebufferTextureFaceARB_ptr) {
        _glFramebufferTextureFaceARB_ptr = (PFN_GLFRAMEBUFFERTEXTUREFACEARB)_getPrivateProcAddress(_name);
        if (!_glFramebufferTextureFaceARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTextureFaceARB_ptr(target, attachment, texture, level, face);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBDIVISORARB)(GLuint index, GLuint divisor);
static PFN_GLVERTEXATTRIBDIVISORARB _glVertexAttribDivisorARB_ptr = NULL;

static inline void APIENTRY _glVertexAttribDivisorARB(GLuint index, GLuint divisor) {
    const char *_name = "glVertexAttribDivisorARB";
    if (!_glVertexAttribDivisorARB_ptr) {
        _glVertexAttribDivisorARB_ptr = (PFN_GLVERTEXATTRIBDIVISORARB)_getPrivateProcAddress(_name);
        if (!_glVertexAttribDivisorARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribDivisorARB_ptr(index, divisor);
}

typedef GLvoid * (APIENTRY * PFN_GLMAPBUFFERRANGE)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
static PFN_GLMAPBUFFERRANGE _glMapBufferRange_ptr = NULL;

static inline GLvoid * APIENTRY _glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) {
    const char *_name = "glMapBufferRange";
    if (!_glMapBufferRange_ptr) {
        _glMapBufferRange_ptr = (PFN_GLMAPBUFFERRANGE)_getPrivateProcAddress(_name);
        if (!_glMapBufferRange_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glMapBufferRange_ptr(target, offset, length, access);
}

typedef void (APIENTRY * PFN_GLFLUSHMAPPEDBUFFERRANGE)(GLenum target, GLintptr offset, GLsizeiptr length);
static PFN_GLFLUSHMAPPEDBUFFERRANGE _glFlushMappedBufferRange_ptr = NULL;

static inline void APIENTRY _glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length) {
    const char *_name = "glFlushMappedBufferRange";
    if (!_glFlushMappedBufferRange_ptr) {
        _glFlushMappedBufferRange_ptr = (PFN_GLFLUSHMAPPEDBUFFERRANGE)_getPrivateProcAddress(_name);
        if (!_glFlushMappedBufferRange_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFlushMappedBufferRange_ptr(target, offset, length);
}

typedef void (APIENTRY * PFN_GLTEXBUFFERARB)(GLenum target, GLenum internalformat, GLuint buffer);
static PFN_GLTEXBUFFERARB _glTexBufferARB_ptr = NULL;

static inline void APIENTRY _glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer) {
    const char *_name = "glTexBufferARB";
    if (!_glTexBufferARB_ptr) {
        _glTexBufferARB_ptr = (PFN_GLTEXBUFFERARB)_getPrivateProcAddress(_name);
        if (!_glTexBufferARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexBufferARB_ptr(target, internalformat, buffer);
}

typedef void (APIENTRY * PFN_GLBINDVERTEXARRAY)(GLuint array);
static PFN_GLBINDVERTEXARRAY _glBindVertexArray_ptr = NULL;

static inline void APIENTRY _glBindVertexArray(GLuint array) {
    const char *_name = "glBindVertexArray";
    if (!_glBindVertexArray_ptr) {
        _glBindVertexArray_ptr = (PFN_GLBINDVERTEXARRAY)_getPrivateProcAddress(_name);
        if (!_glBindVertexArray_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindVertexArray_ptr(array);
}

typedef void (APIENTRY * PFN_GLDELETEVERTEXARRAYS)(GLsizei n, const GLuint * arrays);
static PFN_GLDELETEVERTEXARRAYS _glDeleteVertexArrays_ptr = NULL;

static inline void APIENTRY _glDeleteVertexArrays(GLsizei n, const GLuint * arrays) {
    const char *_name = "glDeleteVertexArrays";
    if (!_glDeleteVertexArrays_ptr) {
        _glDeleteVertexArrays_ptr = (PFN_GLDELETEVERTEXARRAYS)_getPrivateProcAddress(_name);
        if (!_glDeleteVertexArrays_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteVertexArrays_ptr(n, arrays);
}

typedef void (APIENTRY * PFN_GLGENVERTEXARRAYS)(GLsizei n, GLuint * arrays);
static PFN_GLGENVERTEXARRAYS _glGenVertexArrays_ptr = NULL;

static inline void APIENTRY _glGenVertexArrays(GLsizei n, GLuint * arrays) {
    const char *_name = "glGenVertexArrays";
    if (!_glGenVertexArrays_ptr) {
        _glGenVertexArrays_ptr = (PFN_GLGENVERTEXARRAYS)_getPrivateProcAddress(_name);
        if (!_glGenVertexArrays_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenVertexArrays_ptr(n, arrays);
}

typedef GLboolean (APIENTRY * PFN_GLISVERTEXARRAY)(GLuint array);
static PFN_GLISVERTEXARRAY _glIsVertexArray_ptr = NULL;

static inline GLboolean APIENTRY _glIsVertexArray(GLuint array) {
    const char *_name = "glIsVertexArray";
    if (!_glIsVertexArray_ptr) {
        _glIsVertexArray_ptr = (PFN_GLISVERTEXARRAY)_getPrivateProcAddress(_name);
        if (!_glIsVertexArray_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsVertexArray_ptr(array);
}

typedef void (APIENTRY * PFN_GLGETUNIFORMINDICES)(GLuint program, GLsizei uniformCount, const GLchar * const * uniformNames, GLuint * uniformIndices);
static PFN_GLGETUNIFORMINDICES _glGetUniformIndices_ptr = NULL;

static inline void APIENTRY _glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar * const * uniformNames, GLuint * uniformIndices) {
    const char *_name = "glGetUniformIndices";
    if (!_glGetUniformIndices_ptr) {
        _glGetUniformIndices_ptr = (PFN_GLGETUNIFORMINDICES)_getPrivateProcAddress(_name);
        if (!_glGetUniformIndices_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetUniformIndices_ptr(program, uniformCount, uniformNames, uniformIndices);
}

typedef void (APIENTRY * PFN_GLGETACTIVEUNIFORMSIV)(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params);
static PFN_GLGETACTIVEUNIFORMSIV _glGetActiveUniformsiv_ptr = NULL;

static inline void APIENTRY _glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params) {
    const char *_name = "glGetActiveUniformsiv";
    if (!_glGetActiveUniformsiv_ptr) {
        _glGetActiveUniformsiv_ptr = (PFN_GLGETACTIVEUNIFORMSIV)_getPrivateProcAddress(_name);
        if (!_glGetActiveUniformsiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetActiveUniformsiv_ptr(program, uniformCount, uniformIndices, pname, params);
}

typedef void (APIENTRY * PFN_GLGETACTIVEUNIFORMNAME)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName);
static PFN_GLGETACTIVEUNIFORMNAME _glGetActiveUniformName_ptr = NULL;

static inline void APIENTRY _glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName) {
    const char *_name = "glGetActiveUniformName";
    if (!_glGetActiveUniformName_ptr) {
        _glGetActiveUniformName_ptr = (PFN_GLGETACTIVEUNIFORMNAME)_getPrivateProcAddress(_name);
        if (!_glGetActiveUniformName_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetActiveUniformName_ptr(program, uniformIndex, bufSize, length, uniformName);
}

typedef GLuint (APIENTRY * PFN_GLGETUNIFORMBLOCKINDEX)(GLuint program, const GLchar * uniformBlockName);
static PFN_GLGETUNIFORMBLOCKINDEX _glGetUniformBlockIndex_ptr = NULL;

static inline GLuint APIENTRY _glGetUniformBlockIndex(GLuint program, const GLchar * uniformBlockName) {
    const char *_name = "glGetUniformBlockIndex";
    if (!_glGetUniformBlockIndex_ptr) {
        _glGetUniformBlockIndex_ptr = (PFN_GLGETUNIFORMBLOCKINDEX)_getPrivateProcAddress(_name);
        if (!_glGetUniformBlockIndex_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetUniformBlockIndex_ptr(program, uniformBlockName);
}

typedef void (APIENTRY * PFN_GLGETACTIVEUNIFORMBLOCKIV)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params);
static PFN_GLGETACTIVEUNIFORMBLOCKIV _glGetActiveUniformBlockiv_ptr = NULL;

static inline void APIENTRY _glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params) {
    const char *_name = "glGetActiveUniformBlockiv";
    if (!_glGetActiveUniformBlockiv_ptr) {
        _glGetActiveUniformBlockiv_ptr = (PFN_GLGETACTIVEUNIFORMBLOCKIV)_getPrivateProcAddress(_name);
        if (!_glGetActiveUniformBlockiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetActiveUniformBlockiv_ptr(program, uniformBlockIndex, pname, params);
}

typedef void (APIENTRY * PFN_GLGETACTIVEUNIFORMBLOCKNAME)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName);
static PFN_GLGETACTIVEUNIFORMBLOCKNAME _glGetActiveUniformBlockName_ptr = NULL;

static inline void APIENTRY _glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName) {
    const char *_name = "glGetActiveUniformBlockName";
    if (!_glGetActiveUniformBlockName_ptr) {
        _glGetActiveUniformBlockName_ptr = (PFN_GLGETACTIVEUNIFORMBLOCKNAME)_getPrivateProcAddress(_name);
        if (!_glGetActiveUniformBlockName_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetActiveUniformBlockName_ptr(program, uniformBlockIndex, bufSize, length, uniformBlockName);
}

typedef void (APIENTRY * PFN_GLUNIFORMBLOCKBINDING)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
static PFN_GLUNIFORMBLOCKBINDING _glUniformBlockBinding_ptr = NULL;

static inline void APIENTRY _glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) {
    const char *_name = "glUniformBlockBinding";
    if (!_glUniformBlockBinding_ptr) {
        _glUniformBlockBinding_ptr = (PFN_GLUNIFORMBLOCKBINDING)_getPrivateProcAddress(_name);
        if (!_glUniformBlockBinding_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformBlockBinding_ptr(program, uniformBlockIndex, uniformBlockBinding);
}

typedef void (APIENTRY * PFN_GLCOPYBUFFERSUBDATA)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
static PFN_GLCOPYBUFFERSUBDATA _glCopyBufferSubData_ptr = NULL;

static inline void APIENTRY _glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
    const char *_name = "glCopyBufferSubData";
    if (!_glCopyBufferSubData_ptr) {
        _glCopyBufferSubData_ptr = (PFN_GLCOPYBUFFERSUBDATA)_getPrivateProcAddress(_name);
        if (!_glCopyBufferSubData_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyBufferSubData_ptr(readTarget, writeTarget, readOffset, writeOffset, size);
}

typedef void (APIENTRY * PFN_GLDRAWELEMENTSBASEVERTEX)(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex);
static PFN_GLDRAWELEMENTSBASEVERTEX _glDrawElementsBaseVertex_ptr = NULL;

static inline void APIENTRY _glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex) {
    const char *_name = "glDrawElementsBaseVertex";
    if (!_glDrawElementsBaseVertex_ptr) {
        _glDrawElementsBaseVertex_ptr = (PFN_GLDRAWELEMENTSBASEVERTEX)_getPrivateProcAddress(_name);
        if (!_glDrawElementsBaseVertex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawElementsBaseVertex_ptr(mode, count, type, indices, basevertex);
}

typedef void (APIENTRY * PFN_GLDRAWRANGEELEMENTSBASEVERTEX)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex);
static PFN_GLDRAWRANGEELEMENTSBASEVERTEX _glDrawRangeElementsBaseVertex_ptr = NULL;

static inline void APIENTRY _glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex) {
    const char *_name = "glDrawRangeElementsBaseVertex";
    if (!_glDrawRangeElementsBaseVertex_ptr) {
        _glDrawRangeElementsBaseVertex_ptr = (PFN_GLDRAWRANGEELEMENTSBASEVERTEX)_getPrivateProcAddress(_name);
        if (!_glDrawRangeElementsBaseVertex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawRangeElementsBaseVertex_ptr(mode, start, end, count, type, indices, basevertex);
}

typedef void (APIENTRY * PFN_GLDRAWELEMENTSINSTANCEDBASEVERTEX)(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount, GLint basevertex);
static PFN_GLDRAWELEMENTSINSTANCEDBASEVERTEX _glDrawElementsInstancedBaseVertex_ptr = NULL;

static inline void APIENTRY _glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount, GLint basevertex) {
    const char *_name = "glDrawElementsInstancedBaseVertex";
    if (!_glDrawElementsInstancedBaseVertex_ptr) {
        _glDrawElementsInstancedBaseVertex_ptr = (PFN_GLDRAWELEMENTSINSTANCEDBASEVERTEX)_getPrivateProcAddress(_name);
        if (!_glDrawElementsInstancedBaseVertex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawElementsInstancedBaseVertex_ptr(mode, count, type, indices, primcount, basevertex);
}

typedef void (APIENTRY * PFN_GLMULTIDRAWELEMENTSBASEVERTEX)(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei drawcount, const GLint * basevertex);
static PFN_GLMULTIDRAWELEMENTSBASEVERTEX _glMultiDrawElementsBaseVertex_ptr = NULL;

static inline void APIENTRY _glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei drawcount, const GLint * basevertex) {
    const char *_name = "glMultiDrawElementsBaseVertex";
    if (!_glMultiDrawElementsBaseVertex_ptr) {
        _glMultiDrawElementsBaseVertex_ptr = (PFN_GLMULTIDRAWELEMENTSBASEVERTEX)_getPrivateProcAddress(_name);
        if (!_glMultiDrawElementsBaseVertex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiDrawElementsBaseVertex_ptr(mode, count, type, indices, drawcount, basevertex);
}

typedef void (APIENTRY * PFN_GLPROVOKINGVERTEX)(GLenum mode);
static PFN_GLPROVOKINGVERTEX _glProvokingVertex_ptr = NULL;

static inline void APIENTRY _glProvokingVertex(GLenum mode) {
    const char *_name = "glProvokingVertex";
    if (!_glProvokingVertex_ptr) {
        _glProvokingVertex_ptr = (PFN_GLPROVOKINGVERTEX)_getPrivateProcAddress(_name);
        if (!_glProvokingVertex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProvokingVertex_ptr(mode);
}

typedef GLsync (APIENTRY * PFN_GLFENCESYNC)(GLenum condition, GLbitfield flags);
static PFN_GLFENCESYNC _glFenceSync_ptr = NULL;

static inline GLsync APIENTRY _glFenceSync(GLenum condition, GLbitfield flags) {
    const char *_name = "glFenceSync";
    if (!_glFenceSync_ptr) {
        _glFenceSync_ptr = (PFN_GLFENCESYNC)_getPrivateProcAddress(_name);
        if (!_glFenceSync_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glFenceSync_ptr(condition, flags);
}

typedef GLboolean (APIENTRY * PFN_GLISSYNC)(GLsync sync);
static PFN_GLISSYNC _glIsSync_ptr = NULL;

static inline GLboolean APIENTRY _glIsSync(GLsync sync) {
    const char *_name = "glIsSync";
    if (!_glIsSync_ptr) {
        _glIsSync_ptr = (PFN_GLISSYNC)_getPrivateProcAddress(_name);
        if (!_glIsSync_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsSync_ptr(sync);
}

typedef void (APIENTRY * PFN_GLDELETESYNC)(GLsync sync);
static PFN_GLDELETESYNC _glDeleteSync_ptr = NULL;

static inline void APIENTRY _glDeleteSync(GLsync sync) {
    const char *_name = "glDeleteSync";
    if (!_glDeleteSync_ptr) {
        _glDeleteSync_ptr = (PFN_GLDELETESYNC)_getPrivateProcAddress(_name);
        if (!_glDeleteSync_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteSync_ptr(sync);
}

typedef GLenum (APIENTRY * PFN_GLCLIENTWAITSYNC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
static PFN_GLCLIENTWAITSYNC _glClientWaitSync_ptr = NULL;

static inline GLenum APIENTRY _glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) {
    const char *_name = "glClientWaitSync";
    if (!_glClientWaitSync_ptr) {
        _glClientWaitSync_ptr = (PFN_GLCLIENTWAITSYNC)_getPrivateProcAddress(_name);
        if (!_glClientWaitSync_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glClientWaitSync_ptr(sync, flags, timeout);
}

typedef void (APIENTRY * PFN_GLWAITSYNC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
static PFN_GLWAITSYNC _glWaitSync_ptr = NULL;

static inline void APIENTRY _glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) {
    const char *_name = "glWaitSync";
    if (!_glWaitSync_ptr) {
        _glWaitSync_ptr = (PFN_GLWAITSYNC)_getPrivateProcAddress(_name);
        if (!_glWaitSync_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWaitSync_ptr(sync, flags, timeout);
}

typedef void (APIENTRY * PFN_GLGETINTEGER64V)(GLenum pname, GLint64 * params);
static PFN_GLGETINTEGER64V _glGetInteger64v_ptr = NULL;

static inline void APIENTRY _glGetInteger64v(GLenum pname, GLint64 * params) {
    const char *_name = "glGetInteger64v";
    if (!_glGetInteger64v_ptr) {
        _glGetInteger64v_ptr = (PFN_GLGETINTEGER64V)_getPrivateProcAddress(_name);
        if (!_glGetInteger64v_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetInteger64v_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLGETSYNCIV)(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values);
static PFN_GLGETSYNCIV _glGetSynciv_ptr = NULL;

static inline void APIENTRY _glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values) {
    const char *_name = "glGetSynciv";
    if (!_glGetSynciv_ptr) {
        _glGetSynciv_ptr = (PFN_GLGETSYNCIV)_getPrivateProcAddress(_name);
        if (!_glGetSynciv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetSynciv_ptr(sync, pname, bufSize, length, values);
}

typedef void (APIENTRY * PFN_GLTEXIMAGE2DMULTISAMPLE)(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
static PFN_GLTEXIMAGE2DMULTISAMPLE _glTexImage2DMultisample_ptr = NULL;

static inline void APIENTRY _glTexImage2DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
    const char *_name = "glTexImage2DMultisample";
    if (!_glTexImage2DMultisample_ptr) {
        _glTexImage2DMultisample_ptr = (PFN_GLTEXIMAGE2DMULTISAMPLE)_getPrivateProcAddress(_name);
        if (!_glTexImage2DMultisample_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexImage2DMultisample_ptr(target, samples, internalformat, width, height, fixedsamplelocations);
}

typedef void (APIENTRY * PFN_GLTEXIMAGE3DMULTISAMPLE)(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
static PFN_GLTEXIMAGE3DMULTISAMPLE _glTexImage3DMultisample_ptr = NULL;

static inline void APIENTRY _glTexImage3DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
    const char *_name = "glTexImage3DMultisample";
    if (!_glTexImage3DMultisample_ptr) {
        _glTexImage3DMultisample_ptr = (PFN_GLTEXIMAGE3DMULTISAMPLE)_getPrivateProcAddress(_name);
        if (!_glTexImage3DMultisample_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexImage3DMultisample_ptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

typedef void (APIENTRY * PFN_GLGETMULTISAMPLEFV)(GLenum pname, GLuint index, GLfloat * val);
static PFN_GLGETMULTISAMPLEFV _glGetMultisamplefv_ptr = NULL;

static inline void APIENTRY _glGetMultisamplefv(GLenum pname, GLuint index, GLfloat * val) {
    const char *_name = "glGetMultisamplefv";
    if (!_glGetMultisamplefv_ptr) {
        _glGetMultisamplefv_ptr = (PFN_GLGETMULTISAMPLEFV)_getPrivateProcAddress(_name);
        if (!_glGetMultisamplefv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultisamplefv_ptr(pname, index, val);
}

typedef void (APIENTRY * PFN_GLSAMPLEMASKI)(GLuint index, GLbitfield mask);
static PFN_GLSAMPLEMASKI _glSampleMaski_ptr = NULL;

static inline void APIENTRY _glSampleMaski(GLuint index, GLbitfield mask) {
    const char *_name = "glSampleMaski";
    if (!_glSampleMaski_ptr) {
        _glSampleMaski_ptr = (PFN_GLSAMPLEMASKI)_getPrivateProcAddress(_name);
        if (!_glSampleMaski_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSampleMaski_ptr(index, mask);
}

typedef void (APIENTRY * PFN_GLBLENDEQUATIONIARB)(GLuint buf, GLenum mode);
static PFN_GLBLENDEQUATIONIARB _glBlendEquationiARB_ptr = NULL;

static inline void APIENTRY _glBlendEquationiARB(GLuint buf, GLenum mode) {
    const char *_name = "glBlendEquationiARB";
    if (!_glBlendEquationiARB_ptr) {
        _glBlendEquationiARB_ptr = (PFN_GLBLENDEQUATIONIARB)_getPrivateProcAddress(_name);
        if (!_glBlendEquationiARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendEquationiARB_ptr(buf, mode);
}

typedef void (APIENTRY * PFN_GLBLENDEQUATIONSEPARATEIARB)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
static PFN_GLBLENDEQUATIONSEPARATEIARB _glBlendEquationSeparateiARB_ptr = NULL;

static inline void APIENTRY _glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha) {
    const char *_name = "glBlendEquationSeparateiARB";
    if (!_glBlendEquationSeparateiARB_ptr) {
        _glBlendEquationSeparateiARB_ptr = (PFN_GLBLENDEQUATIONSEPARATEIARB)_getPrivateProcAddress(_name);
        if (!_glBlendEquationSeparateiARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendEquationSeparateiARB_ptr(buf, modeRGB, modeAlpha);
}

typedef void (APIENTRY * PFN_GLBLENDFUNCIARB)(GLuint buf, GLenum src, GLenum dst);
static PFN_GLBLENDFUNCIARB _glBlendFunciARB_ptr = NULL;

static inline void APIENTRY _glBlendFunciARB(GLuint buf, GLenum src, GLenum dst) {
    const char *_name = "glBlendFunciARB";
    if (!_glBlendFunciARB_ptr) {
        _glBlendFunciARB_ptr = (PFN_GLBLENDFUNCIARB)_getPrivateProcAddress(_name);
        if (!_glBlendFunciARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendFunciARB_ptr(buf, src, dst);
}

typedef void (APIENTRY * PFN_GLBLENDFUNCSEPARATEIARB)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
static PFN_GLBLENDFUNCSEPARATEIARB _glBlendFuncSeparateiARB_ptr = NULL;

static inline void APIENTRY _glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) {
    const char *_name = "glBlendFuncSeparateiARB";
    if (!_glBlendFuncSeparateiARB_ptr) {
        _glBlendFuncSeparateiARB_ptr = (PFN_GLBLENDFUNCSEPARATEIARB)_getPrivateProcAddress(_name);
        if (!_glBlendFuncSeparateiARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendFuncSeparateiARB_ptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

typedef void (APIENTRY * PFN_GLMINSAMPLESHADINGARB)(GLfloat value);
static PFN_GLMINSAMPLESHADINGARB _glMinSampleShadingARB_ptr = NULL;

static inline void APIENTRY _glMinSampleShadingARB(GLfloat value) {
    const char *_name = "glMinSampleShadingARB";
    if (!_glMinSampleShadingARB_ptr) {
        _glMinSampleShadingARB_ptr = (PFN_GLMINSAMPLESHADINGARB)_getPrivateProcAddress(_name);
        if (!_glMinSampleShadingARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMinSampleShadingARB_ptr(value);
}

typedef void (APIENTRY * PFN_GLNAMEDSTRINGARB)(GLenum type, GLint namelen, const GLchar * name, GLint stringlen, const GLchar * string);
static PFN_GLNAMEDSTRINGARB _glNamedStringARB_ptr = NULL;

static inline void APIENTRY _glNamedStringARB(GLenum type, GLint namelen, const GLchar * name, GLint stringlen, const GLchar * string) {
    const char *_name = "glNamedStringARB";
    if (!_glNamedStringARB_ptr) {
        _glNamedStringARB_ptr = (PFN_GLNAMEDSTRINGARB)_getPrivateProcAddress(_name);
        if (!_glNamedStringARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedStringARB_ptr(type, namelen, name, stringlen, string);
}

typedef void (APIENTRY * PFN_GLDELETENAMEDSTRINGARB)(GLint namelen, const GLchar * name);
static PFN_GLDELETENAMEDSTRINGARB _glDeleteNamedStringARB_ptr = NULL;

static inline void APIENTRY _glDeleteNamedStringARB(GLint namelen, const GLchar * name) {
    const char *_name = "glDeleteNamedStringARB";
    if (!_glDeleteNamedStringARB_ptr) {
        _glDeleteNamedStringARB_ptr = (PFN_GLDELETENAMEDSTRINGARB)_getPrivateProcAddress(_name);
        if (!_glDeleteNamedStringARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteNamedStringARB_ptr(namelen, name);
}

typedef void (APIENTRY * PFN_GLCOMPILESHADERINCLUDEARB)(GLuint shader, GLsizei count, const GLchar * * path, const GLint * length);
static PFN_GLCOMPILESHADERINCLUDEARB _glCompileShaderIncludeARB_ptr = NULL;

static inline void APIENTRY _glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar * * path, const GLint * length) {
    const char *_name = "glCompileShaderIncludeARB";
    if (!_glCompileShaderIncludeARB_ptr) {
        _glCompileShaderIncludeARB_ptr = (PFN_GLCOMPILESHADERINCLUDEARB)_getPrivateProcAddress(_name);
        if (!_glCompileShaderIncludeARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompileShaderIncludeARB_ptr(shader, count, path, length);
}

typedef GLboolean (APIENTRY * PFN_GLISNAMEDSTRINGARB)(GLint namelen, const GLchar * name);
static PFN_GLISNAMEDSTRINGARB _glIsNamedStringARB_ptr = NULL;

static inline GLboolean APIENTRY _glIsNamedStringARB(GLint namelen, const GLchar * name) {
    const char *_name = "glIsNamedStringARB";
    if (!_glIsNamedStringARB_ptr) {
        _glIsNamedStringARB_ptr = (PFN_GLISNAMEDSTRINGARB)_getPrivateProcAddress(_name);
        if (!_glIsNamedStringARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsNamedStringARB_ptr(namelen, name);
}

typedef void (APIENTRY * PFN_GLGETNAMEDSTRINGARB)(GLint namelen, const GLchar * name, GLsizei bufSize, GLint * stringlen, GLchar * string);
static PFN_GLGETNAMEDSTRINGARB _glGetNamedStringARB_ptr = NULL;

static inline void APIENTRY _glGetNamedStringARB(GLint namelen, const GLchar * name, GLsizei bufSize, GLint * stringlen, GLchar * string) {
    const char *_name = "glGetNamedStringARB";
    if (!_glGetNamedStringARB_ptr) {
        _glGetNamedStringARB_ptr = (PFN_GLGETNAMEDSTRINGARB)_getPrivateProcAddress(_name);
        if (!_glGetNamedStringARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedStringARB_ptr(namelen, name, bufSize, stringlen, string);
}

typedef void (APIENTRY * PFN_GLGETNAMEDSTRINGIVARB)(GLint namelen, const GLchar * name, GLenum pname, GLint * params);
static PFN_GLGETNAMEDSTRINGIVARB _glGetNamedStringivARB_ptr = NULL;

static inline void APIENTRY _glGetNamedStringivARB(GLint namelen, const GLchar * name, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedStringivARB";
    if (!_glGetNamedStringivARB_ptr) {
        _glGetNamedStringivARB_ptr = (PFN_GLGETNAMEDSTRINGIVARB)_getPrivateProcAddress(_name);
        if (!_glGetNamedStringivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedStringivARB_ptr(namelen, name, pname, params);
}

typedef void (APIENTRY * PFN_GLBINDFRAGDATALOCATIONINDEXED)(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
static PFN_GLBINDFRAGDATALOCATIONINDEXED _glBindFragDataLocationIndexed_ptr = NULL;

static inline void APIENTRY _glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name) {
    const char *_name = "glBindFragDataLocationIndexed";
    if (!_glBindFragDataLocationIndexed_ptr) {
        _glBindFragDataLocationIndexed_ptr = (PFN_GLBINDFRAGDATALOCATIONINDEXED)_getPrivateProcAddress(_name);
        if (!_glBindFragDataLocationIndexed_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindFragDataLocationIndexed_ptr(program, colorNumber, index, name);
}

typedef GLint (APIENTRY * PFN_GLGETFRAGDATAINDEX)(GLuint program, const GLchar * name);
static PFN_GLGETFRAGDATAINDEX _glGetFragDataIndex_ptr = NULL;

static inline GLint APIENTRY _glGetFragDataIndex(GLuint program, const GLchar * name) {
    const char *_name = "glGetFragDataIndex";
    if (!_glGetFragDataIndex_ptr) {
        _glGetFragDataIndex_ptr = (PFN_GLGETFRAGDATAINDEX)_getPrivateProcAddress(_name);
        if (!_glGetFragDataIndex_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetFragDataIndex_ptr(program, name);
}

typedef void (APIENTRY * PFN_GLGENSAMPLERS)(GLsizei count, GLuint * samplers);
static PFN_GLGENSAMPLERS _glGenSamplers_ptr = NULL;

static inline void APIENTRY _glGenSamplers(GLsizei count, GLuint * samplers) {
    const char *_name = "glGenSamplers";
    if (!_glGenSamplers_ptr) {
        _glGenSamplers_ptr = (PFN_GLGENSAMPLERS)_getPrivateProcAddress(_name);
        if (!_glGenSamplers_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenSamplers_ptr(count, samplers);
}

typedef void (APIENTRY * PFN_GLDELETESAMPLERS)(GLsizei count, const GLuint * samplers);
static PFN_GLDELETESAMPLERS _glDeleteSamplers_ptr = NULL;

static inline void APIENTRY _glDeleteSamplers(GLsizei count, const GLuint * samplers) {
    const char *_name = "glDeleteSamplers";
    if (!_glDeleteSamplers_ptr) {
        _glDeleteSamplers_ptr = (PFN_GLDELETESAMPLERS)_getPrivateProcAddress(_name);
        if (!_glDeleteSamplers_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteSamplers_ptr(count, samplers);
}

typedef GLboolean (APIENTRY * PFN_GLISSAMPLER)(GLuint sampler);
static PFN_GLISSAMPLER _glIsSampler_ptr = NULL;

static inline GLboolean APIENTRY _glIsSampler(GLuint sampler) {
    const char *_name = "glIsSampler";
    if (!_glIsSampler_ptr) {
        _glIsSampler_ptr = (PFN_GLISSAMPLER)_getPrivateProcAddress(_name);
        if (!_glIsSampler_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsSampler_ptr(sampler);
}

typedef void (APIENTRY * PFN_GLBINDSAMPLER)(GLuint unit, GLuint sampler);
static PFN_GLBINDSAMPLER _glBindSampler_ptr = NULL;

static inline void APIENTRY _glBindSampler(GLuint unit, GLuint sampler) {
    const char *_name = "glBindSampler";
    if (!_glBindSampler_ptr) {
        _glBindSampler_ptr = (PFN_GLBINDSAMPLER)_getPrivateProcAddress(_name);
        if (!_glBindSampler_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindSampler_ptr(unit, sampler);
}

typedef void (APIENTRY * PFN_GLSAMPLERPARAMETERI)(GLuint sampler, GLenum pname, GLint param);
static PFN_GLSAMPLERPARAMETERI _glSamplerParameteri_ptr = NULL;

static inline void APIENTRY _glSamplerParameteri(GLuint sampler, GLenum pname, GLint param) {
    const char *_name = "glSamplerParameteri";
    if (!_glSamplerParameteri_ptr) {
        _glSamplerParameteri_ptr = (PFN_GLSAMPLERPARAMETERI)_getPrivateProcAddress(_name);
        if (!_glSamplerParameteri_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSamplerParameteri_ptr(sampler, pname, param);
}

typedef void (APIENTRY * PFN_GLSAMPLERPARAMETERIV)(GLuint sampler, GLenum pname, const GLint * param);
static PFN_GLSAMPLERPARAMETERIV _glSamplerParameteriv_ptr = NULL;

static inline void APIENTRY _glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * param) {
    const char *_name = "glSamplerParameteriv";
    if (!_glSamplerParameteriv_ptr) {
        _glSamplerParameteriv_ptr = (PFN_GLSAMPLERPARAMETERIV)_getPrivateProcAddress(_name);
        if (!_glSamplerParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSamplerParameteriv_ptr(sampler, pname, param);
}

typedef void (APIENTRY * PFN_GLSAMPLERPARAMETERF)(GLuint sampler, GLenum pname, GLfloat param);
static PFN_GLSAMPLERPARAMETERF _glSamplerParameterf_ptr = NULL;

static inline void APIENTRY _glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param) {
    const char *_name = "glSamplerParameterf";
    if (!_glSamplerParameterf_ptr) {
        _glSamplerParameterf_ptr = (PFN_GLSAMPLERPARAMETERF)_getPrivateProcAddress(_name);
        if (!_glSamplerParameterf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSamplerParameterf_ptr(sampler, pname, param);
}

typedef void (APIENTRY * PFN_GLSAMPLERPARAMETERFV)(GLuint sampler, GLenum pname, const GLfloat * param);
static PFN_GLSAMPLERPARAMETERFV _glSamplerParameterfv_ptr = NULL;

static inline void APIENTRY _glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * param) {
    const char *_name = "glSamplerParameterfv";
    if (!_glSamplerParameterfv_ptr) {
        _glSamplerParameterfv_ptr = (PFN_GLSAMPLERPARAMETERFV)_getPrivateProcAddress(_name);
        if (!_glSamplerParameterfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSamplerParameterfv_ptr(sampler, pname, param);
}

typedef void (APIENTRY * PFN_GLSAMPLERPARAMETERIIV)(GLuint sampler, GLenum pname, const GLint * param);
static PFN_GLSAMPLERPARAMETERIIV _glSamplerParameterIiv_ptr = NULL;

static inline void APIENTRY _glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint * param) {
    const char *_name = "glSamplerParameterIiv";
    if (!_glSamplerParameterIiv_ptr) {
        _glSamplerParameterIiv_ptr = (PFN_GLSAMPLERPARAMETERIIV)_getPrivateProcAddress(_name);
        if (!_glSamplerParameterIiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSamplerParameterIiv_ptr(sampler, pname, param);
}

typedef void (APIENTRY * PFN_GLSAMPLERPARAMETERIUIV)(GLuint sampler, GLenum pname, const GLuint * param);
static PFN_GLSAMPLERPARAMETERIUIV _glSamplerParameterIuiv_ptr = NULL;

static inline void APIENTRY _glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint * param) {
    const char *_name = "glSamplerParameterIuiv";
    if (!_glSamplerParameterIuiv_ptr) {
        _glSamplerParameterIuiv_ptr = (PFN_GLSAMPLERPARAMETERIUIV)_getPrivateProcAddress(_name);
        if (!_glSamplerParameterIuiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSamplerParameterIuiv_ptr(sampler, pname, param);
}

typedef void (APIENTRY * PFN_GLGETSAMPLERPARAMETERIV)(GLuint sampler, GLenum pname, GLint * params);
static PFN_GLGETSAMPLERPARAMETERIV _glGetSamplerParameteriv_ptr = NULL;

static inline void APIENTRY _glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params) {
    const char *_name = "glGetSamplerParameteriv";
    if (!_glGetSamplerParameteriv_ptr) {
        _glGetSamplerParameteriv_ptr = (PFN_GLGETSAMPLERPARAMETERIV)_getPrivateProcAddress(_name);
        if (!_glGetSamplerParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetSamplerParameteriv_ptr(sampler, pname, params);
}

typedef void (APIENTRY * PFN_GLGETSAMPLERPARAMETERIIV)(GLuint sampler, GLenum pname, GLint * params);
static PFN_GLGETSAMPLERPARAMETERIIV _glGetSamplerParameterIiv_ptr = NULL;

static inline void APIENTRY _glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint * params) {
    const char *_name = "glGetSamplerParameterIiv";
    if (!_glGetSamplerParameterIiv_ptr) {
        _glGetSamplerParameterIiv_ptr = (PFN_GLGETSAMPLERPARAMETERIIV)_getPrivateProcAddress(_name);
        if (!_glGetSamplerParameterIiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetSamplerParameterIiv_ptr(sampler, pname, params);
}

typedef void (APIENTRY * PFN_GLGETSAMPLERPARAMETERFV)(GLuint sampler, GLenum pname, GLfloat * params);
static PFN_GLGETSAMPLERPARAMETERFV _glGetSamplerParameterfv_ptr = NULL;

static inline void APIENTRY _glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params) {
    const char *_name = "glGetSamplerParameterfv";
    if (!_glGetSamplerParameterfv_ptr) {
        _glGetSamplerParameterfv_ptr = (PFN_GLGETSAMPLERPARAMETERFV)_getPrivateProcAddress(_name);
        if (!_glGetSamplerParameterfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetSamplerParameterfv_ptr(sampler, pname, params);
}

typedef void (APIENTRY * PFN_GLGETSAMPLERPARAMETERIUIV)(GLuint sampler, GLenum pname, GLuint * params);
static PFN_GLGETSAMPLERPARAMETERIUIV _glGetSamplerParameterIuiv_ptr = NULL;

static inline void APIENTRY _glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint * params) {
    const char *_name = "glGetSamplerParameterIuiv";
    if (!_glGetSamplerParameterIuiv_ptr) {
        _glGetSamplerParameterIuiv_ptr = (PFN_GLGETSAMPLERPARAMETERIUIV)_getPrivateProcAddress(_name);
        if (!_glGetSamplerParameterIuiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetSamplerParameterIuiv_ptr(sampler, pname, params);
}

typedef void (APIENTRY * PFN_GLQUERYCOUNTER)(GLuint id, GLenum target);
static PFN_GLQUERYCOUNTER _glQueryCounter_ptr = NULL;

static inline void APIENTRY _glQueryCounter(GLuint id, GLenum target) {
    const char *_name = "glQueryCounter";
    if (!_glQueryCounter_ptr) {
        _glQueryCounter_ptr = (PFN_GLQUERYCOUNTER)_getPrivateProcAddress(_name);
        if (!_glQueryCounter_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glQueryCounter_ptr(id, target);
}

typedef void (APIENTRY * PFN_GLGETQUERYOBJECTI64V)(GLuint id, GLenum pname, GLint64 * params);
static PFN_GLGETQUERYOBJECTI64V _glGetQueryObjecti64v_ptr = NULL;

static inline void APIENTRY _glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 * params) {
    const char *_name = "glGetQueryObjecti64v";
    if (!_glGetQueryObjecti64v_ptr) {
        _glGetQueryObjecti64v_ptr = (PFN_GLGETQUERYOBJECTI64V)_getPrivateProcAddress(_name);
        if (!_glGetQueryObjecti64v_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetQueryObjecti64v_ptr(id, pname, params);
}

typedef void (APIENTRY * PFN_GLGETQUERYOBJECTUI64V)(GLuint id, GLenum pname, GLuint64 * params);
static PFN_GLGETQUERYOBJECTUI64V _glGetQueryObjectui64v_ptr = NULL;

static inline void APIENTRY _glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 * params) {
    const char *_name = "glGetQueryObjectui64v";
    if (!_glGetQueryObjectui64v_ptr) {
        _glGetQueryObjectui64v_ptr = (PFN_GLGETQUERYOBJECTUI64V)_getPrivateProcAddress(_name);
        if (!_glGetQueryObjectui64v_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetQueryObjectui64v_ptr(id, pname, params);
}

typedef void (APIENTRY * PFN_GLVERTEXP2UI)(GLenum type, GLuint value);
static PFN_GLVERTEXP2UI _glVertexP2ui_ptr = NULL;

static inline void APIENTRY _glVertexP2ui(GLenum type, GLuint value) {
    const char *_name = "glVertexP2ui";
    if (!_glVertexP2ui_ptr) {
        _glVertexP2ui_ptr = (PFN_GLVERTEXP2UI)_getPrivateProcAddress(_name);
        if (!_glVertexP2ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexP2ui_ptr(type, value);
}

typedef void (APIENTRY * PFN_GLVERTEXP2UIV)(GLenum type, const GLuint * value);
static PFN_GLVERTEXP2UIV _glVertexP2uiv_ptr = NULL;

static inline void APIENTRY _glVertexP2uiv(GLenum type, const GLuint * value) {
    const char *_name = "glVertexP2uiv";
    if (!_glVertexP2uiv_ptr) {
        _glVertexP2uiv_ptr = (PFN_GLVERTEXP2UIV)_getPrivateProcAddress(_name);
        if (!_glVertexP2uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexP2uiv_ptr(type, value);
}

typedef void (APIENTRY * PFN_GLVERTEXP3UI)(GLenum type, GLuint value);
static PFN_GLVERTEXP3UI _glVertexP3ui_ptr = NULL;

static inline void APIENTRY _glVertexP3ui(GLenum type, GLuint value) {
    const char *_name = "glVertexP3ui";
    if (!_glVertexP3ui_ptr) {
        _glVertexP3ui_ptr = (PFN_GLVERTEXP3UI)_getPrivateProcAddress(_name);
        if (!_glVertexP3ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexP3ui_ptr(type, value);
}

typedef void (APIENTRY * PFN_GLVERTEXP3UIV)(GLenum type, const GLuint * value);
static PFN_GLVERTEXP3UIV _glVertexP3uiv_ptr = NULL;

static inline void APIENTRY _glVertexP3uiv(GLenum type, const GLuint * value) {
    const char *_name = "glVertexP3uiv";
    if (!_glVertexP3uiv_ptr) {
        _glVertexP3uiv_ptr = (PFN_GLVERTEXP3UIV)_getPrivateProcAddress(_name);
        if (!_glVertexP3uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexP3uiv_ptr(type, value);
}

typedef void (APIENTRY * PFN_GLVERTEXP4UI)(GLenum type, GLuint value);
static PFN_GLVERTEXP4UI _glVertexP4ui_ptr = NULL;

static inline void APIENTRY _glVertexP4ui(GLenum type, GLuint value) {
    const char *_name = "glVertexP4ui";
    if (!_glVertexP4ui_ptr) {
        _glVertexP4ui_ptr = (PFN_GLVERTEXP4UI)_getPrivateProcAddress(_name);
        if (!_glVertexP4ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexP4ui_ptr(type, value);
}

typedef void (APIENTRY * PFN_GLVERTEXP4UIV)(GLenum type, const GLuint * value);
static PFN_GLVERTEXP4UIV _glVertexP4uiv_ptr = NULL;

static inline void APIENTRY _glVertexP4uiv(GLenum type, const GLuint * value) {
    const char *_name = "glVertexP4uiv";
    if (!_glVertexP4uiv_ptr) {
        _glVertexP4uiv_ptr = (PFN_GLVERTEXP4UIV)_getPrivateProcAddress(_name);
        if (!_glVertexP4uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexP4uiv_ptr(type, value);
}

typedef void (APIENTRY * PFN_GLTEXCOORDP1UI)(GLenum type, GLuint coords);
static PFN_GLTEXCOORDP1UI _glTexCoordP1ui_ptr = NULL;

static inline void APIENTRY _glTexCoordP1ui(GLenum type, GLuint coords) {
    const char *_name = "glTexCoordP1ui";
    if (!_glTexCoordP1ui_ptr) {
        _glTexCoordP1ui_ptr = (PFN_GLTEXCOORDP1UI)_getPrivateProcAddress(_name);
        if (!_glTexCoordP1ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoordP1ui_ptr(type, coords);
}

typedef void (APIENTRY * PFN_GLTEXCOORDP1UIV)(GLenum type, const GLuint * coords);
static PFN_GLTEXCOORDP1UIV _glTexCoordP1uiv_ptr = NULL;

static inline void APIENTRY _glTexCoordP1uiv(GLenum type, const GLuint * coords) {
    const char *_name = "glTexCoordP1uiv";
    if (!_glTexCoordP1uiv_ptr) {
        _glTexCoordP1uiv_ptr = (PFN_GLTEXCOORDP1UIV)_getPrivateProcAddress(_name);
        if (!_glTexCoordP1uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoordP1uiv_ptr(type, coords);
}

typedef void (APIENTRY * PFN_GLTEXCOORDP2UI)(GLenum type, GLuint coords);
static PFN_GLTEXCOORDP2UI _glTexCoordP2ui_ptr = NULL;

static inline void APIENTRY _glTexCoordP2ui(GLenum type, GLuint coords) {
    const char *_name = "glTexCoordP2ui";
    if (!_glTexCoordP2ui_ptr) {
        _glTexCoordP2ui_ptr = (PFN_GLTEXCOORDP2UI)_getPrivateProcAddress(_name);
        if (!_glTexCoordP2ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoordP2ui_ptr(type, coords);
}

typedef void (APIENTRY * PFN_GLTEXCOORDP2UIV)(GLenum type, const GLuint * coords);
static PFN_GLTEXCOORDP2UIV _glTexCoordP2uiv_ptr = NULL;

static inline void APIENTRY _glTexCoordP2uiv(GLenum type, const GLuint * coords) {
    const char *_name = "glTexCoordP2uiv";
    if (!_glTexCoordP2uiv_ptr) {
        _glTexCoordP2uiv_ptr = (PFN_GLTEXCOORDP2UIV)_getPrivateProcAddress(_name);
        if (!_glTexCoordP2uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoordP2uiv_ptr(type, coords);
}

typedef void (APIENTRY * PFN_GLTEXCOORDP3UI)(GLenum type, GLuint coords);
static PFN_GLTEXCOORDP3UI _glTexCoordP3ui_ptr = NULL;

static inline void APIENTRY _glTexCoordP3ui(GLenum type, GLuint coords) {
    const char *_name = "glTexCoordP3ui";
    if (!_glTexCoordP3ui_ptr) {
        _glTexCoordP3ui_ptr = (PFN_GLTEXCOORDP3UI)_getPrivateProcAddress(_name);
        if (!_glTexCoordP3ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoordP3ui_ptr(type, coords);
}

typedef void (APIENTRY * PFN_GLTEXCOORDP3UIV)(GLenum type, const GLuint * coords);
static PFN_GLTEXCOORDP3UIV _glTexCoordP3uiv_ptr = NULL;

static inline void APIENTRY _glTexCoordP3uiv(GLenum type, const GLuint * coords) {
    const char *_name = "glTexCoordP3uiv";
    if (!_glTexCoordP3uiv_ptr) {
        _glTexCoordP3uiv_ptr = (PFN_GLTEXCOORDP3UIV)_getPrivateProcAddress(_name);
        if (!_glTexCoordP3uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoordP3uiv_ptr(type, coords);
}

typedef void (APIENTRY * PFN_GLTEXCOORDP4UI)(GLenum type, GLuint coords);
static PFN_GLTEXCOORDP4UI _glTexCoordP4ui_ptr = NULL;

static inline void APIENTRY _glTexCoordP4ui(GLenum type, GLuint coords) {
    const char *_name = "glTexCoordP4ui";
    if (!_glTexCoordP4ui_ptr) {
        _glTexCoordP4ui_ptr = (PFN_GLTEXCOORDP4UI)_getPrivateProcAddress(_name);
        if (!_glTexCoordP4ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoordP4ui_ptr(type, coords);
}

typedef void (APIENTRY * PFN_GLTEXCOORDP4UIV)(GLenum type, const GLuint * coords);
static PFN_GLTEXCOORDP4UIV _glTexCoordP4uiv_ptr = NULL;

static inline void APIENTRY _glTexCoordP4uiv(GLenum type, const GLuint * coords) {
    const char *_name = "glTexCoordP4uiv";
    if (!_glTexCoordP4uiv_ptr) {
        _glTexCoordP4uiv_ptr = (PFN_GLTEXCOORDP4UIV)_getPrivateProcAddress(_name);
        if (!_glTexCoordP4uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoordP4uiv_ptr(type, coords);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORDP1UI)(GLenum texture, GLenum type, GLuint coords);
static PFN_GLMULTITEXCOORDP1UI _glMultiTexCoordP1ui_ptr = NULL;

static inline void APIENTRY _glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords) {
    const char *_name = "glMultiTexCoordP1ui";
    if (!_glMultiTexCoordP1ui_ptr) {
        _glMultiTexCoordP1ui_ptr = (PFN_GLMULTITEXCOORDP1UI)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoordP1ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoordP1ui_ptr(texture, type, coords);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORDP1UIV)(GLenum texture, GLenum type, const GLuint * coords);
static PFN_GLMULTITEXCOORDP1UIV _glMultiTexCoordP1uiv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint * coords) {
    const char *_name = "glMultiTexCoordP1uiv";
    if (!_glMultiTexCoordP1uiv_ptr) {
        _glMultiTexCoordP1uiv_ptr = (PFN_GLMULTITEXCOORDP1UIV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoordP1uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoordP1uiv_ptr(texture, type, coords);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORDP2UI)(GLenum texture, GLenum type, GLuint coords);
static PFN_GLMULTITEXCOORDP2UI _glMultiTexCoordP2ui_ptr = NULL;

static inline void APIENTRY _glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords) {
    const char *_name = "glMultiTexCoordP2ui";
    if (!_glMultiTexCoordP2ui_ptr) {
        _glMultiTexCoordP2ui_ptr = (PFN_GLMULTITEXCOORDP2UI)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoordP2ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoordP2ui_ptr(texture, type, coords);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORDP2UIV)(GLenum texture, GLenum type, const GLuint * coords);
static PFN_GLMULTITEXCOORDP2UIV _glMultiTexCoordP2uiv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint * coords) {
    const char *_name = "glMultiTexCoordP2uiv";
    if (!_glMultiTexCoordP2uiv_ptr) {
        _glMultiTexCoordP2uiv_ptr = (PFN_GLMULTITEXCOORDP2UIV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoordP2uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoordP2uiv_ptr(texture, type, coords);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORDP3UI)(GLenum texture, GLenum type, GLuint coords);
static PFN_GLMULTITEXCOORDP3UI _glMultiTexCoordP3ui_ptr = NULL;

static inline void APIENTRY _glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords) {
    const char *_name = "glMultiTexCoordP3ui";
    if (!_glMultiTexCoordP3ui_ptr) {
        _glMultiTexCoordP3ui_ptr = (PFN_GLMULTITEXCOORDP3UI)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoordP3ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoordP3ui_ptr(texture, type, coords);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORDP3UIV)(GLenum texture, GLenum type, const GLuint * coords);
static PFN_GLMULTITEXCOORDP3UIV _glMultiTexCoordP3uiv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint * coords) {
    const char *_name = "glMultiTexCoordP3uiv";
    if (!_glMultiTexCoordP3uiv_ptr) {
        _glMultiTexCoordP3uiv_ptr = (PFN_GLMULTITEXCOORDP3UIV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoordP3uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoordP3uiv_ptr(texture, type, coords);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORDP4UI)(GLenum texture, GLenum type, GLuint coords);
static PFN_GLMULTITEXCOORDP4UI _glMultiTexCoordP4ui_ptr = NULL;

static inline void APIENTRY _glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords) {
    const char *_name = "glMultiTexCoordP4ui";
    if (!_glMultiTexCoordP4ui_ptr) {
        _glMultiTexCoordP4ui_ptr = (PFN_GLMULTITEXCOORDP4UI)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoordP4ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoordP4ui_ptr(texture, type, coords);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORDP4UIV)(GLenum texture, GLenum type, const GLuint * coords);
static PFN_GLMULTITEXCOORDP4UIV _glMultiTexCoordP4uiv_ptr = NULL;

static inline void APIENTRY _glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint * coords) {
    const char *_name = "glMultiTexCoordP4uiv";
    if (!_glMultiTexCoordP4uiv_ptr) {
        _glMultiTexCoordP4uiv_ptr = (PFN_GLMULTITEXCOORDP4UIV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoordP4uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoordP4uiv_ptr(texture, type, coords);
}

typedef void (APIENTRY * PFN_GLNORMALP3UI)(GLenum type, GLuint coords);
static PFN_GLNORMALP3UI _glNormalP3ui_ptr = NULL;

static inline void APIENTRY _glNormalP3ui(GLenum type, GLuint coords) {
    const char *_name = "glNormalP3ui";
    if (!_glNormalP3ui_ptr) {
        _glNormalP3ui_ptr = (PFN_GLNORMALP3UI)_getPrivateProcAddress(_name);
        if (!_glNormalP3ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalP3ui_ptr(type, coords);
}

typedef void (APIENTRY * PFN_GLNORMALP3UIV)(GLenum type, const GLuint * coords);
static PFN_GLNORMALP3UIV _glNormalP3uiv_ptr = NULL;

static inline void APIENTRY _glNormalP3uiv(GLenum type, const GLuint * coords) {
    const char *_name = "glNormalP3uiv";
    if (!_glNormalP3uiv_ptr) {
        _glNormalP3uiv_ptr = (PFN_GLNORMALP3UIV)_getPrivateProcAddress(_name);
        if (!_glNormalP3uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalP3uiv_ptr(type, coords);
}

typedef void (APIENTRY * PFN_GLCOLORP3UI)(GLenum type, GLuint color);
static PFN_GLCOLORP3UI _glColorP3ui_ptr = NULL;

static inline void APIENTRY _glColorP3ui(GLenum type, GLuint color) {
    const char *_name = "glColorP3ui";
    if (!_glColorP3ui_ptr) {
        _glColorP3ui_ptr = (PFN_GLCOLORP3UI)_getPrivateProcAddress(_name);
        if (!_glColorP3ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorP3ui_ptr(type, color);
}

typedef void (APIENTRY * PFN_GLCOLORP3UIV)(GLenum type, const GLuint * color);
static PFN_GLCOLORP3UIV _glColorP3uiv_ptr = NULL;

static inline void APIENTRY _glColorP3uiv(GLenum type, const GLuint * color) {
    const char *_name = "glColorP3uiv";
    if (!_glColorP3uiv_ptr) {
        _glColorP3uiv_ptr = (PFN_GLCOLORP3UIV)_getPrivateProcAddress(_name);
        if (!_glColorP3uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorP3uiv_ptr(type, color);
}

typedef void (APIENTRY * PFN_GLCOLORP4UI)(GLenum type, GLuint color);
static PFN_GLCOLORP4UI _glColorP4ui_ptr = NULL;

static inline void APIENTRY _glColorP4ui(GLenum type, GLuint color) {
    const char *_name = "glColorP4ui";
    if (!_glColorP4ui_ptr) {
        _glColorP4ui_ptr = (PFN_GLCOLORP4UI)_getPrivateProcAddress(_name);
        if (!_glColorP4ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorP4ui_ptr(type, color);
}

typedef void (APIENTRY * PFN_GLCOLORP4UIV)(GLenum type, const GLuint * color);
static PFN_GLCOLORP4UIV _glColorP4uiv_ptr = NULL;

static inline void APIENTRY _glColorP4uiv(GLenum type, const GLuint * color) {
    const char *_name = "glColorP4uiv";
    if (!_glColorP4uiv_ptr) {
        _glColorP4uiv_ptr = (PFN_GLCOLORP4UIV)_getPrivateProcAddress(_name);
        if (!_glColorP4uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorP4uiv_ptr(type, color);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLORP3UI)(GLenum type, GLuint color);
static PFN_GLSECONDARYCOLORP3UI _glSecondaryColorP3ui_ptr = NULL;

static inline void APIENTRY _glSecondaryColorP3ui(GLenum type, GLuint color) {
    const char *_name = "glSecondaryColorP3ui";
    if (!_glSecondaryColorP3ui_ptr) {
        _glSecondaryColorP3ui_ptr = (PFN_GLSECONDARYCOLORP3UI)_getPrivateProcAddress(_name);
        if (!_glSecondaryColorP3ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColorP3ui_ptr(type, color);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLORP3UIV)(GLenum type, const GLuint * color);
static PFN_GLSECONDARYCOLORP3UIV _glSecondaryColorP3uiv_ptr = NULL;

static inline void APIENTRY _glSecondaryColorP3uiv(GLenum type, const GLuint * color) {
    const char *_name = "glSecondaryColorP3uiv";
    if (!_glSecondaryColorP3uiv_ptr) {
        _glSecondaryColorP3uiv_ptr = (PFN_GLSECONDARYCOLORP3UIV)_getPrivateProcAddress(_name);
        if (!_glSecondaryColorP3uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColorP3uiv_ptr(type, color);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBP1UI)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
static PFN_GLVERTEXATTRIBP1UI _glVertexAttribP1ui_ptr = NULL;

static inline void APIENTRY _glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
    const char *_name = "glVertexAttribP1ui";
    if (!_glVertexAttribP1ui_ptr) {
        _glVertexAttribP1ui_ptr = (PFN_GLVERTEXATTRIBP1UI)_getPrivateProcAddress(_name);
        if (!_glVertexAttribP1ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribP1ui_ptr(index, type, normalized, value);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBP1UIV)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
static PFN_GLVERTEXATTRIBP1UIV _glVertexAttribP1uiv_ptr = NULL;

static inline void APIENTRY _glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value) {
    const char *_name = "glVertexAttribP1uiv";
    if (!_glVertexAttribP1uiv_ptr) {
        _glVertexAttribP1uiv_ptr = (PFN_GLVERTEXATTRIBP1UIV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribP1uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribP1uiv_ptr(index, type, normalized, value);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBP2UI)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
static PFN_GLVERTEXATTRIBP2UI _glVertexAttribP2ui_ptr = NULL;

static inline void APIENTRY _glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
    const char *_name = "glVertexAttribP2ui";
    if (!_glVertexAttribP2ui_ptr) {
        _glVertexAttribP2ui_ptr = (PFN_GLVERTEXATTRIBP2UI)_getPrivateProcAddress(_name);
        if (!_glVertexAttribP2ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribP2ui_ptr(index, type, normalized, value);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBP2UIV)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
static PFN_GLVERTEXATTRIBP2UIV _glVertexAttribP2uiv_ptr = NULL;

static inline void APIENTRY _glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value) {
    const char *_name = "glVertexAttribP2uiv";
    if (!_glVertexAttribP2uiv_ptr) {
        _glVertexAttribP2uiv_ptr = (PFN_GLVERTEXATTRIBP2UIV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribP2uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribP2uiv_ptr(index, type, normalized, value);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBP3UI)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
static PFN_GLVERTEXATTRIBP3UI _glVertexAttribP3ui_ptr = NULL;

static inline void APIENTRY _glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
    const char *_name = "glVertexAttribP3ui";
    if (!_glVertexAttribP3ui_ptr) {
        _glVertexAttribP3ui_ptr = (PFN_GLVERTEXATTRIBP3UI)_getPrivateProcAddress(_name);
        if (!_glVertexAttribP3ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribP3ui_ptr(index, type, normalized, value);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBP3UIV)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
static PFN_GLVERTEXATTRIBP3UIV _glVertexAttribP3uiv_ptr = NULL;

static inline void APIENTRY _glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value) {
    const char *_name = "glVertexAttribP3uiv";
    if (!_glVertexAttribP3uiv_ptr) {
        _glVertexAttribP3uiv_ptr = (PFN_GLVERTEXATTRIBP3UIV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribP3uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribP3uiv_ptr(index, type, normalized, value);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBP4UI)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
static PFN_GLVERTEXATTRIBP4UI _glVertexAttribP4ui_ptr = NULL;

static inline void APIENTRY _glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
    const char *_name = "glVertexAttribP4ui";
    if (!_glVertexAttribP4ui_ptr) {
        _glVertexAttribP4ui_ptr = (PFN_GLVERTEXATTRIBP4UI)_getPrivateProcAddress(_name);
        if (!_glVertexAttribP4ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribP4ui_ptr(index, type, normalized, value);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBP4UIV)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
static PFN_GLVERTEXATTRIBP4UIV _glVertexAttribP4uiv_ptr = NULL;

static inline void APIENTRY _glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value) {
    const char *_name = "glVertexAttribP4uiv";
    if (!_glVertexAttribP4uiv_ptr) {
        _glVertexAttribP4uiv_ptr = (PFN_GLVERTEXATTRIBP4UIV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribP4uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribP4uiv_ptr(index, type, normalized, value);
}

typedef void (APIENTRY * PFN_GLDRAWARRAYSINDIRECT)(GLenum mode, const GLvoid * indirect);
static PFN_GLDRAWARRAYSINDIRECT _glDrawArraysIndirect_ptr = NULL;

static inline void APIENTRY _glDrawArraysIndirect(GLenum mode, const GLvoid * indirect) {
    const char *_name = "glDrawArraysIndirect";
    if (!_glDrawArraysIndirect_ptr) {
        _glDrawArraysIndirect_ptr = (PFN_GLDRAWARRAYSINDIRECT)_getPrivateProcAddress(_name);
        if (!_glDrawArraysIndirect_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawArraysIndirect_ptr(mode, indirect);
}

typedef void (APIENTRY * PFN_GLDRAWELEMENTSINDIRECT)(GLenum mode, GLenum type, const GLvoid * indirect);
static PFN_GLDRAWELEMENTSINDIRECT _glDrawElementsIndirect_ptr = NULL;

static inline void APIENTRY _glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid * indirect) {
    const char *_name = "glDrawElementsIndirect";
    if (!_glDrawElementsIndirect_ptr) {
        _glDrawElementsIndirect_ptr = (PFN_GLDRAWELEMENTSINDIRECT)_getPrivateProcAddress(_name);
        if (!_glDrawElementsIndirect_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawElementsIndirect_ptr(mode, type, indirect);
}

typedef void (APIENTRY * PFN_GLUNIFORM1D)(GLint location, GLdouble x);
static PFN_GLUNIFORM1D _glUniform1d_ptr = NULL;

static inline void APIENTRY _glUniform1d(GLint location, GLdouble x) {
    const char *_name = "glUniform1d";
    if (!_glUniform1d_ptr) {
        _glUniform1d_ptr = (PFN_GLUNIFORM1D)_getPrivateProcAddress(_name);
        if (!_glUniform1d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1d_ptr(location, x);
}

typedef void (APIENTRY * PFN_GLUNIFORM2D)(GLint location, GLdouble x, GLdouble y);
static PFN_GLUNIFORM2D _glUniform2d_ptr = NULL;

static inline void APIENTRY _glUniform2d(GLint location, GLdouble x, GLdouble y) {
    const char *_name = "glUniform2d";
    if (!_glUniform2d_ptr) {
        _glUniform2d_ptr = (PFN_GLUNIFORM2D)_getPrivateProcAddress(_name);
        if (!_glUniform2d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2d_ptr(location, x, y);
}

typedef void (APIENTRY * PFN_GLUNIFORM3D)(GLint location, GLdouble x, GLdouble y, GLdouble z);
static PFN_GLUNIFORM3D _glUniform3d_ptr = NULL;

static inline void APIENTRY _glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glUniform3d";
    if (!_glUniform3d_ptr) {
        _glUniform3d_ptr = (PFN_GLUNIFORM3D)_getPrivateProcAddress(_name);
        if (!_glUniform3d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3d_ptr(location, x, y, z);
}

typedef void (APIENTRY * PFN_GLUNIFORM4D)(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLUNIFORM4D _glUniform4d_ptr = NULL;

static inline void APIENTRY _glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glUniform4d";
    if (!_glUniform4d_ptr) {
        _glUniform4d_ptr = (PFN_GLUNIFORM4D)_getPrivateProcAddress(_name);
        if (!_glUniform4d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4d_ptr(location, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLUNIFORM1DV)(GLint location, GLsizei count, const GLdouble * value);
static PFN_GLUNIFORM1DV _glUniform1dv_ptr = NULL;

static inline void APIENTRY _glUniform1dv(GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glUniform1dv";
    if (!_glUniform1dv_ptr) {
        _glUniform1dv_ptr = (PFN_GLUNIFORM1DV)_getPrivateProcAddress(_name);
        if (!_glUniform1dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1dv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM2DV)(GLint location, GLsizei count, const GLdouble * value);
static PFN_GLUNIFORM2DV _glUniform2dv_ptr = NULL;

static inline void APIENTRY _glUniform2dv(GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glUniform2dv";
    if (!_glUniform2dv_ptr) {
        _glUniform2dv_ptr = (PFN_GLUNIFORM2DV)_getPrivateProcAddress(_name);
        if (!_glUniform2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2dv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM3DV)(GLint location, GLsizei count, const GLdouble * value);
static PFN_GLUNIFORM3DV _glUniform3dv_ptr = NULL;

static inline void APIENTRY _glUniform3dv(GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glUniform3dv";
    if (!_glUniform3dv_ptr) {
        _glUniform3dv_ptr = (PFN_GLUNIFORM3DV)_getPrivateProcAddress(_name);
        if (!_glUniform3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3dv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM4DV)(GLint location, GLsizei count, const GLdouble * value);
static PFN_GLUNIFORM4DV _glUniform4dv_ptr = NULL;

static inline void APIENTRY _glUniform4dv(GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glUniform4dv";
    if (!_glUniform4dv_ptr) {
        _glUniform4dv_ptr = (PFN_GLUNIFORM4DV)_getPrivateProcAddress(_name);
        if (!_glUniform4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4dv_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX2DV)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLUNIFORMMATRIX2DV _glUniformMatrix2dv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix2dv";
    if (!_glUniformMatrix2dv_ptr) {
        _glUniformMatrix2dv_ptr = (PFN_GLUNIFORMMATRIX2DV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix2dv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX3DV)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLUNIFORMMATRIX3DV _glUniformMatrix3dv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix3dv";
    if (!_glUniformMatrix3dv_ptr) {
        _glUniformMatrix3dv_ptr = (PFN_GLUNIFORMMATRIX3DV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix3dv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX4DV)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLUNIFORMMATRIX4DV _glUniformMatrix4dv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix4dv";
    if (!_glUniformMatrix4dv_ptr) {
        _glUniformMatrix4dv_ptr = (PFN_GLUNIFORMMATRIX4DV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix4dv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX2X3DV)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLUNIFORMMATRIX2X3DV _glUniformMatrix2x3dv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix2x3dv";
    if (!_glUniformMatrix2x3dv_ptr) {
        _glUniformMatrix2x3dv_ptr = (PFN_GLUNIFORMMATRIX2X3DV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix2x3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix2x3dv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX2X4DV)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLUNIFORMMATRIX2X4DV _glUniformMatrix2x4dv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix2x4dv";
    if (!_glUniformMatrix2x4dv_ptr) {
        _glUniformMatrix2x4dv_ptr = (PFN_GLUNIFORMMATRIX2X4DV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix2x4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix2x4dv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX3X2DV)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLUNIFORMMATRIX3X2DV _glUniformMatrix3x2dv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix3x2dv";
    if (!_glUniformMatrix3x2dv_ptr) {
        _glUniformMatrix3x2dv_ptr = (PFN_GLUNIFORMMATRIX3X2DV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix3x2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix3x2dv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX3X4DV)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLUNIFORMMATRIX3X4DV _glUniformMatrix3x4dv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix3x4dv";
    if (!_glUniformMatrix3x4dv_ptr) {
        _glUniformMatrix3x4dv_ptr = (PFN_GLUNIFORMMATRIX3X4DV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix3x4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix3x4dv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX4X2DV)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLUNIFORMMATRIX4X2DV _glUniformMatrix4x2dv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix4x2dv";
    if (!_glUniformMatrix4x2dv_ptr) {
        _glUniformMatrix4x2dv_ptr = (PFN_GLUNIFORMMATRIX4X2DV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix4x2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix4x2dv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMMATRIX4X3DV)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLUNIFORMMATRIX4X3DV _glUniformMatrix4x3dv_ptr = NULL;

static inline void APIENTRY _glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix4x3dv";
    if (!_glUniformMatrix4x3dv_ptr) {
        _glUniformMatrix4x3dv_ptr = (PFN_GLUNIFORMMATRIX4X3DV)_getPrivateProcAddress(_name);
        if (!_glUniformMatrix4x3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformMatrix4x3dv_ptr(location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLGETUNIFORMDV)(GLuint program, GLint location, GLdouble * params);
static PFN_GLGETUNIFORMDV _glGetUniformdv_ptr = NULL;

static inline void APIENTRY _glGetUniformdv(GLuint program, GLint location, GLdouble * params) {
    const char *_name = "glGetUniformdv";
    if (!_glGetUniformdv_ptr) {
        _glGetUniformdv_ptr = (PFN_GLGETUNIFORMDV)_getPrivateProcAddress(_name);
        if (!_glGetUniformdv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetUniformdv_ptr(program, location, params);
}

typedef GLint (APIENTRY * PFN_GLGETSUBROUTINEUNIFORMLOCATION)(GLuint program, GLenum shadertype, const GLchar * name);
static PFN_GLGETSUBROUTINEUNIFORMLOCATION _glGetSubroutineUniformLocation_ptr = NULL;

static inline GLint APIENTRY _glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar * name) {
    const char *_name = "glGetSubroutineUniformLocation";
    if (!_glGetSubroutineUniformLocation_ptr) {
        _glGetSubroutineUniformLocation_ptr = (PFN_GLGETSUBROUTINEUNIFORMLOCATION)_getPrivateProcAddress(_name);
        if (!_glGetSubroutineUniformLocation_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetSubroutineUniformLocation_ptr(program, shadertype, name);
}

typedef GLuint (APIENTRY * PFN_GLGETSUBROUTINEINDEX)(GLuint program, GLenum shadertype, const GLchar * name);
static PFN_GLGETSUBROUTINEINDEX _glGetSubroutineIndex_ptr = NULL;

static inline GLuint APIENTRY _glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar * name) {
    const char *_name = "glGetSubroutineIndex";
    if (!_glGetSubroutineIndex_ptr) {
        _glGetSubroutineIndex_ptr = (PFN_GLGETSUBROUTINEINDEX)_getPrivateProcAddress(_name);
        if (!_glGetSubroutineIndex_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetSubroutineIndex_ptr(program, shadertype, name);
}

typedef void (APIENTRY * PFN_GLGETACTIVESUBROUTINEUNIFORMIV)(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values);
static PFN_GLGETACTIVESUBROUTINEUNIFORMIV _glGetActiveSubroutineUniformiv_ptr = NULL;

static inline void APIENTRY _glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values) {
    const char *_name = "glGetActiveSubroutineUniformiv";
    if (!_glGetActiveSubroutineUniformiv_ptr) {
        _glGetActiveSubroutineUniformiv_ptr = (PFN_GLGETACTIVESUBROUTINEUNIFORMIV)_getPrivateProcAddress(_name);
        if (!_glGetActiveSubroutineUniformiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetActiveSubroutineUniformiv_ptr(program, shadertype, index, pname, values);
}

typedef void (APIENTRY * PFN_GLGETACTIVESUBROUTINEUNIFORMNAME)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name);
static PFN_GLGETACTIVESUBROUTINEUNIFORMNAME _glGetActiveSubroutineUniformName_ptr = NULL;

static inline void APIENTRY _glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name) {
    const char *_name = "glGetActiveSubroutineUniformName";
    if (!_glGetActiveSubroutineUniformName_ptr) {
        _glGetActiveSubroutineUniformName_ptr = (PFN_GLGETACTIVESUBROUTINEUNIFORMNAME)_getPrivateProcAddress(_name);
        if (!_glGetActiveSubroutineUniformName_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetActiveSubroutineUniformName_ptr(program, shadertype, index, bufsize, length, name);
}

typedef void (APIENTRY * PFN_GLGETACTIVESUBROUTINENAME)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name);
static PFN_GLGETACTIVESUBROUTINENAME _glGetActiveSubroutineName_ptr = NULL;

static inline void APIENTRY _glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name) {
    const char *_name = "glGetActiveSubroutineName";
    if (!_glGetActiveSubroutineName_ptr) {
        _glGetActiveSubroutineName_ptr = (PFN_GLGETACTIVESUBROUTINENAME)_getPrivateProcAddress(_name);
        if (!_glGetActiveSubroutineName_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetActiveSubroutineName_ptr(program, shadertype, index, bufsize, length, name);
}

typedef void (APIENTRY * PFN_GLUNIFORMSUBROUTINESUIV)(GLenum shadertype, GLsizei count, const GLuint * indices);
static PFN_GLUNIFORMSUBROUTINESUIV _glUniformSubroutinesuiv_ptr = NULL;

static inline void APIENTRY _glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint * indices) {
    const char *_name = "glUniformSubroutinesuiv";
    if (!_glUniformSubroutinesuiv_ptr) {
        _glUniformSubroutinesuiv_ptr = (PFN_GLUNIFORMSUBROUTINESUIV)_getPrivateProcAddress(_name);
        if (!_glUniformSubroutinesuiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformSubroutinesuiv_ptr(shadertype, count, indices);
}

typedef void (APIENTRY * PFN_GLGETUNIFORMSUBROUTINEUIV)(GLenum shadertype, GLint location, GLuint * params);
static PFN_GLGETUNIFORMSUBROUTINEUIV _glGetUniformSubroutineuiv_ptr = NULL;

static inline void APIENTRY _glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint * params) {
    const char *_name = "glGetUniformSubroutineuiv";
    if (!_glGetUniformSubroutineuiv_ptr) {
        _glGetUniformSubroutineuiv_ptr = (PFN_GLGETUNIFORMSUBROUTINEUIV)_getPrivateProcAddress(_name);
        if (!_glGetUniformSubroutineuiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetUniformSubroutineuiv_ptr(shadertype, location, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMSTAGEIV)(GLuint program, GLenum shadertype, GLenum pname, GLint * values);
static PFN_GLGETPROGRAMSTAGEIV _glGetProgramStageiv_ptr = NULL;

static inline void APIENTRY _glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint * values) {
    const char *_name = "glGetProgramStageiv";
    if (!_glGetProgramStageiv_ptr) {
        _glGetProgramStageiv_ptr = (PFN_GLGETPROGRAMSTAGEIV)_getPrivateProcAddress(_name);
        if (!_glGetProgramStageiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramStageiv_ptr(program, shadertype, pname, values);
}

typedef void (APIENTRY * PFN_GLPATCHPARAMETERI)(GLenum pname, GLint value);
static PFN_GLPATCHPARAMETERI _glPatchParameteri_ptr = NULL;

static inline void APIENTRY _glPatchParameteri(GLenum pname, GLint value) {
    const char *_name = "glPatchParameteri";
    if (!_glPatchParameteri_ptr) {
        _glPatchParameteri_ptr = (PFN_GLPATCHPARAMETERI)_getPrivateProcAddress(_name);
        if (!_glPatchParameteri_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPatchParameteri_ptr(pname, value);
}

typedef void (APIENTRY * PFN_GLPATCHPARAMETERFV)(GLenum pname, const GLfloat * values);
static PFN_GLPATCHPARAMETERFV _glPatchParameterfv_ptr = NULL;

static inline void APIENTRY _glPatchParameterfv(GLenum pname, const GLfloat * values) {
    const char *_name = "glPatchParameterfv";
    if (!_glPatchParameterfv_ptr) {
        _glPatchParameterfv_ptr = (PFN_GLPATCHPARAMETERFV)_getPrivateProcAddress(_name);
        if (!_glPatchParameterfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPatchParameterfv_ptr(pname, values);
}

typedef void (APIENTRY * PFN_GLBINDTRANSFORMFEEDBACK)(GLenum target, GLuint id);
static PFN_GLBINDTRANSFORMFEEDBACK _glBindTransformFeedback_ptr = NULL;

static inline void APIENTRY _glBindTransformFeedback(GLenum target, GLuint id) {
    const char *_name = "glBindTransformFeedback";
    if (!_glBindTransformFeedback_ptr) {
        _glBindTransformFeedback_ptr = (PFN_GLBINDTRANSFORMFEEDBACK)_getPrivateProcAddress(_name);
        if (!_glBindTransformFeedback_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindTransformFeedback_ptr(target, id);
}

typedef void (APIENTRY * PFN_GLDELETETRANSFORMFEEDBACKS)(GLsizei n, const GLuint * ids);
static PFN_GLDELETETRANSFORMFEEDBACKS _glDeleteTransformFeedbacks_ptr = NULL;

static inline void APIENTRY _glDeleteTransformFeedbacks(GLsizei n, const GLuint * ids) {
    const char *_name = "glDeleteTransformFeedbacks";
    if (!_glDeleteTransformFeedbacks_ptr) {
        _glDeleteTransformFeedbacks_ptr = (PFN_GLDELETETRANSFORMFEEDBACKS)_getPrivateProcAddress(_name);
        if (!_glDeleteTransformFeedbacks_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteTransformFeedbacks_ptr(n, ids);
}

typedef void (APIENTRY * PFN_GLGENTRANSFORMFEEDBACKS)(GLsizei n, GLuint * ids);
static PFN_GLGENTRANSFORMFEEDBACKS _glGenTransformFeedbacks_ptr = NULL;

static inline void APIENTRY _glGenTransformFeedbacks(GLsizei n, GLuint * ids) {
    const char *_name = "glGenTransformFeedbacks";
    if (!_glGenTransformFeedbacks_ptr) {
        _glGenTransformFeedbacks_ptr = (PFN_GLGENTRANSFORMFEEDBACKS)_getPrivateProcAddress(_name);
        if (!_glGenTransformFeedbacks_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenTransformFeedbacks_ptr(n, ids);
}

typedef GLboolean (APIENTRY * PFN_GLISTRANSFORMFEEDBACK)(GLuint id);
static PFN_GLISTRANSFORMFEEDBACK _glIsTransformFeedback_ptr = NULL;

static inline GLboolean APIENTRY _glIsTransformFeedback(GLuint id) {
    const char *_name = "glIsTransformFeedback";
    if (!_glIsTransformFeedback_ptr) {
        _glIsTransformFeedback_ptr = (PFN_GLISTRANSFORMFEEDBACK)_getPrivateProcAddress(_name);
        if (!_glIsTransformFeedback_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsTransformFeedback_ptr(id);
}

typedef void (APIENTRY * PFN_GLPAUSETRANSFORMFEEDBACK)(void);
static PFN_GLPAUSETRANSFORMFEEDBACK _glPauseTransformFeedback_ptr = NULL;

static inline void APIENTRY _glPauseTransformFeedback(void) {
    const char *_name = "glPauseTransformFeedback";
    if (!_glPauseTransformFeedback_ptr) {
        _glPauseTransformFeedback_ptr = (PFN_GLPAUSETRANSFORMFEEDBACK)_getPrivateProcAddress(_name);
        if (!_glPauseTransformFeedback_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPauseTransformFeedback_ptr();
}

typedef void (APIENTRY * PFN_GLRESUMETRANSFORMFEEDBACK)(void);
static PFN_GLRESUMETRANSFORMFEEDBACK _glResumeTransformFeedback_ptr = NULL;

static inline void APIENTRY _glResumeTransformFeedback(void) {
    const char *_name = "glResumeTransformFeedback";
    if (!_glResumeTransformFeedback_ptr) {
        _glResumeTransformFeedback_ptr = (PFN_GLRESUMETRANSFORMFEEDBACK)_getPrivateProcAddress(_name);
        if (!_glResumeTransformFeedback_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glResumeTransformFeedback_ptr();
}

typedef void (APIENTRY * PFN_GLDRAWTRANSFORMFEEDBACK)(GLenum mode, GLuint id);
static PFN_GLDRAWTRANSFORMFEEDBACK _glDrawTransformFeedback_ptr = NULL;

static inline void APIENTRY _glDrawTransformFeedback(GLenum mode, GLuint id) {
    const char *_name = "glDrawTransformFeedback";
    if (!_glDrawTransformFeedback_ptr) {
        _glDrawTransformFeedback_ptr = (PFN_GLDRAWTRANSFORMFEEDBACK)_getPrivateProcAddress(_name);
        if (!_glDrawTransformFeedback_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawTransformFeedback_ptr(mode, id);
}

typedef void (APIENTRY * PFN_GLDRAWTRANSFORMFEEDBACKSTREAM)(GLenum mode, GLuint id, GLuint stream);
static PFN_GLDRAWTRANSFORMFEEDBACKSTREAM _glDrawTransformFeedbackStream_ptr = NULL;

static inline void APIENTRY _glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream) {
    const char *_name = "glDrawTransformFeedbackStream";
    if (!_glDrawTransformFeedbackStream_ptr) {
        _glDrawTransformFeedbackStream_ptr = (PFN_GLDRAWTRANSFORMFEEDBACKSTREAM)_getPrivateProcAddress(_name);
        if (!_glDrawTransformFeedbackStream_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawTransformFeedbackStream_ptr(mode, id, stream);
}

typedef void (APIENTRY * PFN_GLBEGINQUERYINDEXED)(GLenum target, GLuint index, GLuint id);
static PFN_GLBEGINQUERYINDEXED _glBeginQueryIndexed_ptr = NULL;

static inline void APIENTRY _glBeginQueryIndexed(GLenum target, GLuint index, GLuint id) {
    const char *_name = "glBeginQueryIndexed";
    if (!_glBeginQueryIndexed_ptr) {
        _glBeginQueryIndexed_ptr = (PFN_GLBEGINQUERYINDEXED)_getPrivateProcAddress(_name);
        if (!_glBeginQueryIndexed_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginQueryIndexed_ptr(target, index, id);
}

typedef void (APIENTRY * PFN_GLENDQUERYINDEXED)(GLenum target, GLuint index);
static PFN_GLENDQUERYINDEXED _glEndQueryIndexed_ptr = NULL;

static inline void APIENTRY _glEndQueryIndexed(GLenum target, GLuint index) {
    const char *_name = "glEndQueryIndexed";
    if (!_glEndQueryIndexed_ptr) {
        _glEndQueryIndexed_ptr = (PFN_GLENDQUERYINDEXED)_getPrivateProcAddress(_name);
        if (!_glEndQueryIndexed_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndQueryIndexed_ptr(target, index);
}

typedef void (APIENTRY * PFN_GLGETQUERYINDEXEDIV)(GLenum target, GLuint index, GLenum pname, GLint * params);
static PFN_GLGETQUERYINDEXEDIV _glGetQueryIndexediv_ptr = NULL;

static inline void APIENTRY _glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryIndexediv";
    if (!_glGetQueryIndexediv_ptr) {
        _glGetQueryIndexediv_ptr = (PFN_GLGETQUERYINDEXEDIV)_getPrivateProcAddress(_name);
        if (!_glGetQueryIndexediv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetQueryIndexediv_ptr(target, index, pname, params);
}

typedef void (APIENTRY * PFN_GLRELEASESHADERCOMPILER)(void);
static PFN_GLRELEASESHADERCOMPILER _glReleaseShaderCompiler_ptr = NULL;

static inline void APIENTRY _glReleaseShaderCompiler(void) {
    const char *_name = "glReleaseShaderCompiler";
    if (!_glReleaseShaderCompiler_ptr) {
        _glReleaseShaderCompiler_ptr = (PFN_GLRELEASESHADERCOMPILER)_getPrivateProcAddress(_name);
        if (!_glReleaseShaderCompiler_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReleaseShaderCompiler_ptr();
}

typedef void (APIENTRY * PFN_GLSHADERBINARY)(GLsizei count, const GLuint * shaders, GLenum binaryformat, const GLvoid * binary, GLsizei length);
static PFN_GLSHADERBINARY _glShaderBinary_ptr = NULL;

static inline void APIENTRY _glShaderBinary(GLsizei count, const GLuint * shaders, GLenum binaryformat, const GLvoid * binary, GLsizei length) {
    const char *_name = "glShaderBinary";
    if (!_glShaderBinary_ptr) {
        _glShaderBinary_ptr = (PFN_GLSHADERBINARY)_getPrivateProcAddress(_name);
        if (!_glShaderBinary_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glShaderBinary_ptr(count, shaders, binaryformat, binary, length);
}

typedef void (APIENTRY * PFN_GLGETSHADERPRECISIONFORMAT)(GLenum shadertype, GLenum precisiontype, GLint * range, GLint * precision);
static PFN_GLGETSHADERPRECISIONFORMAT _glGetShaderPrecisionFormat_ptr = NULL;

static inline void APIENTRY _glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint * range, GLint * precision) {
    const char *_name = "glGetShaderPrecisionFormat";
    if (!_glGetShaderPrecisionFormat_ptr) {
        _glGetShaderPrecisionFormat_ptr = (PFN_GLGETSHADERPRECISIONFORMAT)_getPrivateProcAddress(_name);
        if (!_glGetShaderPrecisionFormat_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetShaderPrecisionFormat_ptr(shadertype, precisiontype, range, precision);
}

typedef void (APIENTRY * PFN_GLDEPTHRANGEF)(GLfloat n, GLfloat f);
static PFN_GLDEPTHRANGEF _glDepthRangef_ptr = NULL;

static inline void APIENTRY _glDepthRangef(GLfloat n, GLfloat f) {
    const char *_name = "glDepthRangef";
    if (!_glDepthRangef_ptr) {
        _glDepthRangef_ptr = (PFN_GLDEPTHRANGEF)_getPrivateProcAddress(_name);
        if (!_glDepthRangef_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDepthRangef_ptr(n, f);
}

typedef void (APIENTRY * PFN_GLCLEARDEPTHF)(GLfloat d);
static PFN_GLCLEARDEPTHF _glClearDepthf_ptr = NULL;

static inline void APIENTRY _glClearDepthf(GLfloat d) {
    const char *_name = "glClearDepthf";
    if (!_glClearDepthf_ptr) {
        _glClearDepthf_ptr = (PFN_GLCLEARDEPTHF)_getPrivateProcAddress(_name);
        if (!_glClearDepthf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearDepthf_ptr(d);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMBINARY)(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, GLvoid * binary);
static PFN_GLGETPROGRAMBINARY _glGetProgramBinary_ptr = NULL;

static inline void APIENTRY _glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, GLvoid * binary) {
    const char *_name = "glGetProgramBinary";
    if (!_glGetProgramBinary_ptr) {
        _glGetProgramBinary_ptr = (PFN_GLGETPROGRAMBINARY)_getPrivateProcAddress(_name);
        if (!_glGetProgramBinary_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramBinary_ptr(program, bufSize, length, binaryFormat, binary);
}

typedef void (APIENTRY * PFN_GLPROGRAMBINARY)(GLuint program, GLenum binaryFormat, const GLvoid * binary, GLsizei length);
static PFN_GLPROGRAMBINARY _glProgramBinary_ptr = NULL;

static inline void APIENTRY _glProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid * binary, GLsizei length) {
    const char *_name = "glProgramBinary";
    if (!_glProgramBinary_ptr) {
        _glProgramBinary_ptr = (PFN_GLPROGRAMBINARY)_getPrivateProcAddress(_name);
        if (!_glProgramBinary_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramBinary_ptr(program, binaryFormat, binary, length);
}

typedef void (APIENTRY * PFN_GLPROGRAMPARAMETERI)(GLuint program, GLenum pname, GLint value);
static PFN_GLPROGRAMPARAMETERI _glProgramParameteri_ptr = NULL;

static inline void APIENTRY _glProgramParameteri(GLuint program, GLenum pname, GLint value) {
    const char *_name = "glProgramParameteri";
    if (!_glProgramParameteri_ptr) {
        _glProgramParameteri_ptr = (PFN_GLPROGRAMPARAMETERI)_getPrivateProcAddress(_name);
        if (!_glProgramParameteri_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramParameteri_ptr(program, pname, value);
}

typedef void (APIENTRY * PFN_GLUSEPROGRAMSTAGES)(GLuint pipeline, GLbitfield stages, GLuint program);
static PFN_GLUSEPROGRAMSTAGES _glUseProgramStages_ptr = NULL;

static inline void APIENTRY _glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program) {
    const char *_name = "glUseProgramStages";
    if (!_glUseProgramStages_ptr) {
        _glUseProgramStages_ptr = (PFN_GLUSEPROGRAMSTAGES)_getPrivateProcAddress(_name);
        if (!_glUseProgramStages_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUseProgramStages_ptr(pipeline, stages, program);
}

typedef void (APIENTRY * PFN_GLACTIVESHADERPROGRAM)(GLuint pipeline, GLuint program);
static PFN_GLACTIVESHADERPROGRAM _glActiveShaderProgram_ptr = NULL;

static inline void APIENTRY _glActiveShaderProgram(GLuint pipeline, GLuint program) {
    const char *_name = "glActiveShaderProgram";
    if (!_glActiveShaderProgram_ptr) {
        _glActiveShaderProgram_ptr = (PFN_GLACTIVESHADERPROGRAM)_getPrivateProcAddress(_name);
        if (!_glActiveShaderProgram_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glActiveShaderProgram_ptr(pipeline, program);
}

typedef GLuint (APIENTRY * PFN_GLCREATESHADERPROGRAMV)(GLenum type, GLsizei count, const GLchar * const * strings);
static PFN_GLCREATESHADERPROGRAMV _glCreateShaderProgramv_ptr = NULL;

static inline GLuint APIENTRY _glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar * const * strings) {
    const char *_name = "glCreateShaderProgramv";
    if (!_glCreateShaderProgramv_ptr) {
        _glCreateShaderProgramv_ptr = (PFN_GLCREATESHADERPROGRAMV)_getPrivateProcAddress(_name);
        if (!_glCreateShaderProgramv_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glCreateShaderProgramv_ptr(type, count, strings);
}

typedef void (APIENTRY * PFN_GLBINDPROGRAMPIPELINE)(GLuint pipeline);
static PFN_GLBINDPROGRAMPIPELINE _glBindProgramPipeline_ptr = NULL;

static inline void APIENTRY _glBindProgramPipeline(GLuint pipeline) {
    const char *_name = "glBindProgramPipeline";
    if (!_glBindProgramPipeline_ptr) {
        _glBindProgramPipeline_ptr = (PFN_GLBINDPROGRAMPIPELINE)_getPrivateProcAddress(_name);
        if (!_glBindProgramPipeline_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindProgramPipeline_ptr(pipeline);
}

typedef void (APIENTRY * PFN_GLDELETEPROGRAMPIPELINES)(GLsizei n, const GLuint * pipelines);
static PFN_GLDELETEPROGRAMPIPELINES _glDeleteProgramPipelines_ptr = NULL;

static inline void APIENTRY _glDeleteProgramPipelines(GLsizei n, const GLuint * pipelines) {
    const char *_name = "glDeleteProgramPipelines";
    if (!_glDeleteProgramPipelines_ptr) {
        _glDeleteProgramPipelines_ptr = (PFN_GLDELETEPROGRAMPIPELINES)_getPrivateProcAddress(_name);
        if (!_glDeleteProgramPipelines_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteProgramPipelines_ptr(n, pipelines);
}

typedef void (APIENTRY * PFN_GLGENPROGRAMPIPELINES)(GLsizei n, GLuint * pipelines);
static PFN_GLGENPROGRAMPIPELINES _glGenProgramPipelines_ptr = NULL;

static inline void APIENTRY _glGenProgramPipelines(GLsizei n, GLuint * pipelines) {
    const char *_name = "glGenProgramPipelines";
    if (!_glGenProgramPipelines_ptr) {
        _glGenProgramPipelines_ptr = (PFN_GLGENPROGRAMPIPELINES)_getPrivateProcAddress(_name);
        if (!_glGenProgramPipelines_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenProgramPipelines_ptr(n, pipelines);
}

typedef GLboolean (APIENTRY * PFN_GLISPROGRAMPIPELINE)(GLuint pipeline);
static PFN_GLISPROGRAMPIPELINE _glIsProgramPipeline_ptr = NULL;

static inline GLboolean APIENTRY _glIsProgramPipeline(GLuint pipeline) {
    const char *_name = "glIsProgramPipeline";
    if (!_glIsProgramPipeline_ptr) {
        _glIsProgramPipeline_ptr = (PFN_GLISPROGRAMPIPELINE)_getPrivateProcAddress(_name);
        if (!_glIsProgramPipeline_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsProgramPipeline_ptr(pipeline);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMPIPELINEIV)(GLuint pipeline, GLenum pname, GLint * params);
static PFN_GLGETPROGRAMPIPELINEIV _glGetProgramPipelineiv_ptr = NULL;

static inline void APIENTRY _glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint * params) {
    const char *_name = "glGetProgramPipelineiv";
    if (!_glGetProgramPipelineiv_ptr) {
        _glGetProgramPipelineiv_ptr = (PFN_GLGETPROGRAMPIPELINEIV)_getPrivateProcAddress(_name);
        if (!_glGetProgramPipelineiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramPipelineiv_ptr(pipeline, pname, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1I)(GLuint program, GLint location, GLint v0);
static PFN_GLPROGRAMUNIFORM1I _glProgramUniform1i_ptr = NULL;

static inline void APIENTRY _glProgramUniform1i(GLuint program, GLint location, GLint v0) {
    const char *_name = "glProgramUniform1i";
    if (!_glProgramUniform1i_ptr) {
        _glProgramUniform1i_ptr = (PFN_GLPROGRAMUNIFORM1I)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1i_ptr(program, location, v0);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1IV)(GLuint program, GLint location, GLsizei count, const GLint * value);
static PFN_GLPROGRAMUNIFORM1IV _glProgramUniform1iv_ptr = NULL;

static inline void APIENTRY _glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform1iv";
    if (!_glProgramUniform1iv_ptr) {
        _glProgramUniform1iv_ptr = (PFN_GLPROGRAMUNIFORM1IV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1iv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1F)(GLuint program, GLint location, GLfloat v0);
static PFN_GLPROGRAMUNIFORM1F _glProgramUniform1f_ptr = NULL;

static inline void APIENTRY _glProgramUniform1f(GLuint program, GLint location, GLfloat v0) {
    const char *_name = "glProgramUniform1f";
    if (!_glProgramUniform1f_ptr) {
        _glProgramUniform1f_ptr = (PFN_GLPROGRAMUNIFORM1F)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1f_ptr(program, location, v0);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1FV)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
static PFN_GLPROGRAMUNIFORM1FV _glProgramUniform1fv_ptr = NULL;

static inline void APIENTRY _glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform1fv";
    if (!_glProgramUniform1fv_ptr) {
        _glProgramUniform1fv_ptr = (PFN_GLPROGRAMUNIFORM1FV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1fv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1D)(GLuint program, GLint location, GLdouble v0);
static PFN_GLPROGRAMUNIFORM1D _glProgramUniform1d_ptr = NULL;

static inline void APIENTRY _glProgramUniform1d(GLuint program, GLint location, GLdouble v0) {
    const char *_name = "glProgramUniform1d";
    if (!_glProgramUniform1d_ptr) {
        _glProgramUniform1d_ptr = (PFN_GLPROGRAMUNIFORM1D)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1d_ptr(program, location, v0);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1DV)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
static PFN_GLPROGRAMUNIFORM1DV _glProgramUniform1dv_ptr = NULL;

static inline void APIENTRY _glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform1dv";
    if (!_glProgramUniform1dv_ptr) {
        _glProgramUniform1dv_ptr = (PFN_GLPROGRAMUNIFORM1DV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1dv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1UI)(GLuint program, GLint location, GLuint v0);
static PFN_GLPROGRAMUNIFORM1UI _glProgramUniform1ui_ptr = NULL;

static inline void APIENTRY _glProgramUniform1ui(GLuint program, GLint location, GLuint v0) {
    const char *_name = "glProgramUniform1ui";
    if (!_glProgramUniform1ui_ptr) {
        _glProgramUniform1ui_ptr = (PFN_GLPROGRAMUNIFORM1UI)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1ui_ptr(program, location, v0);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1UIV)(GLuint program, GLint location, GLsizei count, const GLuint * value);
static PFN_GLPROGRAMUNIFORM1UIV _glProgramUniform1uiv_ptr = NULL;

static inline void APIENTRY _glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform1uiv";
    if (!_glProgramUniform1uiv_ptr) {
        _glProgramUniform1uiv_ptr = (PFN_GLPROGRAMUNIFORM1UIV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1uiv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2I)(GLuint program, GLint location, GLint v0, GLint v1);
static PFN_GLPROGRAMUNIFORM2I _glProgramUniform2i_ptr = NULL;

static inline void APIENTRY _glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1) {
    const char *_name = "glProgramUniform2i";
    if (!_glProgramUniform2i_ptr) {
        _glProgramUniform2i_ptr = (PFN_GLPROGRAMUNIFORM2I)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2i_ptr(program, location, v0, v1);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2IV)(GLuint program, GLint location, GLsizei count, const GLint * value);
static PFN_GLPROGRAMUNIFORM2IV _glProgramUniform2iv_ptr = NULL;

static inline void APIENTRY _glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform2iv";
    if (!_glProgramUniform2iv_ptr) {
        _glProgramUniform2iv_ptr = (PFN_GLPROGRAMUNIFORM2IV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2iv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2F)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
static PFN_GLPROGRAMUNIFORM2F _glProgramUniform2f_ptr = NULL;

static inline void APIENTRY _glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1) {
    const char *_name = "glProgramUniform2f";
    if (!_glProgramUniform2f_ptr) {
        _glProgramUniform2f_ptr = (PFN_GLPROGRAMUNIFORM2F)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2f_ptr(program, location, v0, v1);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2FV)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
static PFN_GLPROGRAMUNIFORM2FV _glProgramUniform2fv_ptr = NULL;

static inline void APIENTRY _glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform2fv";
    if (!_glProgramUniform2fv_ptr) {
        _glProgramUniform2fv_ptr = (PFN_GLPROGRAMUNIFORM2FV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2fv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2D)(GLuint program, GLint location, GLdouble v0, GLdouble v1);
static PFN_GLPROGRAMUNIFORM2D _glProgramUniform2d_ptr = NULL;

static inline void APIENTRY _glProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1) {
    const char *_name = "glProgramUniform2d";
    if (!_glProgramUniform2d_ptr) {
        _glProgramUniform2d_ptr = (PFN_GLPROGRAMUNIFORM2D)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2d_ptr(program, location, v0, v1);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2DV)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
static PFN_GLPROGRAMUNIFORM2DV _glProgramUniform2dv_ptr = NULL;

static inline void APIENTRY _glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform2dv";
    if (!_glProgramUniform2dv_ptr) {
        _glProgramUniform2dv_ptr = (PFN_GLPROGRAMUNIFORM2DV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2dv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2UI)(GLuint program, GLint location, GLuint v0, GLuint v1);
static PFN_GLPROGRAMUNIFORM2UI _glProgramUniform2ui_ptr = NULL;

static inline void APIENTRY _glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1) {
    const char *_name = "glProgramUniform2ui";
    if (!_glProgramUniform2ui_ptr) {
        _glProgramUniform2ui_ptr = (PFN_GLPROGRAMUNIFORM2UI)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2ui_ptr(program, location, v0, v1);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2UIV)(GLuint program, GLint location, GLsizei count, const GLuint * value);
static PFN_GLPROGRAMUNIFORM2UIV _glProgramUniform2uiv_ptr = NULL;

static inline void APIENTRY _glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform2uiv";
    if (!_glProgramUniform2uiv_ptr) {
        _glProgramUniform2uiv_ptr = (PFN_GLPROGRAMUNIFORM2UIV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2uiv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3I)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
static PFN_GLPROGRAMUNIFORM3I _glProgramUniform3i_ptr = NULL;

static inline void APIENTRY _glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) {
    const char *_name = "glProgramUniform3i";
    if (!_glProgramUniform3i_ptr) {
        _glProgramUniform3i_ptr = (PFN_GLPROGRAMUNIFORM3I)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3i_ptr(program, location, v0, v1, v2);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3IV)(GLuint program, GLint location, GLsizei count, const GLint * value);
static PFN_GLPROGRAMUNIFORM3IV _glProgramUniform3iv_ptr = NULL;

static inline void APIENTRY _glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform3iv";
    if (!_glProgramUniform3iv_ptr) {
        _glProgramUniform3iv_ptr = (PFN_GLPROGRAMUNIFORM3IV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3iv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3F)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
static PFN_GLPROGRAMUNIFORM3F _glProgramUniform3f_ptr = NULL;

static inline void APIENTRY _glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
    const char *_name = "glProgramUniform3f";
    if (!_glProgramUniform3f_ptr) {
        _glProgramUniform3f_ptr = (PFN_GLPROGRAMUNIFORM3F)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3f_ptr(program, location, v0, v1, v2);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3FV)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
static PFN_GLPROGRAMUNIFORM3FV _glProgramUniform3fv_ptr = NULL;

static inline void APIENTRY _glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform3fv";
    if (!_glProgramUniform3fv_ptr) {
        _glProgramUniform3fv_ptr = (PFN_GLPROGRAMUNIFORM3FV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3fv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3D)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
static PFN_GLPROGRAMUNIFORM3D _glProgramUniform3d_ptr = NULL;

static inline void APIENTRY _glProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2) {
    const char *_name = "glProgramUniform3d";
    if (!_glProgramUniform3d_ptr) {
        _glProgramUniform3d_ptr = (PFN_GLPROGRAMUNIFORM3D)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3d_ptr(program, location, v0, v1, v2);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3DV)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
static PFN_GLPROGRAMUNIFORM3DV _glProgramUniform3dv_ptr = NULL;

static inline void APIENTRY _glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform3dv";
    if (!_glProgramUniform3dv_ptr) {
        _glProgramUniform3dv_ptr = (PFN_GLPROGRAMUNIFORM3DV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3dv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3UI)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
static PFN_GLPROGRAMUNIFORM3UI _glProgramUniform3ui_ptr = NULL;

static inline void APIENTRY _glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) {
    const char *_name = "glProgramUniform3ui";
    if (!_glProgramUniform3ui_ptr) {
        _glProgramUniform3ui_ptr = (PFN_GLPROGRAMUNIFORM3UI)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3ui_ptr(program, location, v0, v1, v2);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3UIV)(GLuint program, GLint location, GLsizei count, const GLuint * value);
static PFN_GLPROGRAMUNIFORM3UIV _glProgramUniform3uiv_ptr = NULL;

static inline void APIENTRY _glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform3uiv";
    if (!_glProgramUniform3uiv_ptr) {
        _glProgramUniform3uiv_ptr = (PFN_GLPROGRAMUNIFORM3UIV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3uiv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4I)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
static PFN_GLPROGRAMUNIFORM4I _glProgramUniform4i_ptr = NULL;

static inline void APIENTRY _glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
    const char *_name = "glProgramUniform4i";
    if (!_glProgramUniform4i_ptr) {
        _glProgramUniform4i_ptr = (PFN_GLPROGRAMUNIFORM4I)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4i_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4i_ptr(program, location, v0, v1, v2, v3);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4IV)(GLuint program, GLint location, GLsizei count, const GLint * value);
static PFN_GLPROGRAMUNIFORM4IV _glProgramUniform4iv_ptr = NULL;

static inline void APIENTRY _glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform4iv";
    if (!_glProgramUniform4iv_ptr) {
        _glProgramUniform4iv_ptr = (PFN_GLPROGRAMUNIFORM4IV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4iv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4iv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4F)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
static PFN_GLPROGRAMUNIFORM4F _glProgramUniform4f_ptr = NULL;

static inline void APIENTRY _glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
    const char *_name = "glProgramUniform4f";
    if (!_glProgramUniform4f_ptr) {
        _glProgramUniform4f_ptr = (PFN_GLPROGRAMUNIFORM4F)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4f_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4f_ptr(program, location, v0, v1, v2, v3);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4FV)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
static PFN_GLPROGRAMUNIFORM4FV _glProgramUniform4fv_ptr = NULL;

static inline void APIENTRY _glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform4fv";
    if (!_glProgramUniform4fv_ptr) {
        _glProgramUniform4fv_ptr = (PFN_GLPROGRAMUNIFORM4FV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4fv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4D)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
static PFN_GLPROGRAMUNIFORM4D _glProgramUniform4d_ptr = NULL;

static inline void APIENTRY _glProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) {
    const char *_name = "glProgramUniform4d";
    if (!_glProgramUniform4d_ptr) {
        _glProgramUniform4d_ptr = (PFN_GLPROGRAMUNIFORM4D)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4d_ptr(program, location, v0, v1, v2, v3);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4DV)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
static PFN_GLPROGRAMUNIFORM4DV _glProgramUniform4dv_ptr = NULL;

static inline void APIENTRY _glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform4dv";
    if (!_glProgramUniform4dv_ptr) {
        _glProgramUniform4dv_ptr = (PFN_GLPROGRAMUNIFORM4DV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4dv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4UI)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
static PFN_GLPROGRAMUNIFORM4UI _glProgramUniform4ui_ptr = NULL;

static inline void APIENTRY _glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
    const char *_name = "glProgramUniform4ui";
    if (!_glProgramUniform4ui_ptr) {
        _glProgramUniform4ui_ptr = (PFN_GLPROGRAMUNIFORM4UI)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4ui_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4ui_ptr(program, location, v0, v1, v2, v3);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4UIV)(GLuint program, GLint location, GLsizei count, const GLuint * value);
static PFN_GLPROGRAMUNIFORM4UIV _glProgramUniform4uiv_ptr = NULL;

static inline void APIENTRY _glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform4uiv";
    if (!_glProgramUniform4uiv_ptr) {
        _glProgramUniform4uiv_ptr = (PFN_GLPROGRAMUNIFORM4UIV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4uiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4uiv_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX2FV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX2FV _glProgramUniformMatrix2fv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix2fv";
    if (!_glProgramUniformMatrix2fv_ptr) {
        _glProgramUniformMatrix2fv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX2FV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix2fv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX3FV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX3FV _glProgramUniformMatrix3fv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix3fv";
    if (!_glProgramUniformMatrix3fv_ptr) {
        _glProgramUniformMatrix3fv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX3FV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix3fv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX4FV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX4FV _glProgramUniformMatrix4fv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix4fv";
    if (!_glProgramUniformMatrix4fv_ptr) {
        _glProgramUniformMatrix4fv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX4FV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix4fv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX2DV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX2DV _glProgramUniformMatrix2dv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix2dv";
    if (!_glProgramUniformMatrix2dv_ptr) {
        _glProgramUniformMatrix2dv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX2DV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix2dv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX3DV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX3DV _glProgramUniformMatrix3dv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix3dv";
    if (!_glProgramUniformMatrix3dv_ptr) {
        _glProgramUniformMatrix3dv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX3DV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix3dv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX4DV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX4DV _glProgramUniformMatrix4dv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix4dv";
    if (!_glProgramUniformMatrix4dv_ptr) {
        _glProgramUniformMatrix4dv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX4DV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix4dv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX2X3FV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX2X3FV _glProgramUniformMatrix2x3fv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix2x3fv";
    if (!_glProgramUniformMatrix2x3fv_ptr) {
        _glProgramUniformMatrix2x3fv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X3FV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix2x3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix2x3fv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX3X2FV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX3X2FV _glProgramUniformMatrix3x2fv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix3x2fv";
    if (!_glProgramUniformMatrix3x2fv_ptr) {
        _glProgramUniformMatrix3x2fv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X2FV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix3x2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix3x2fv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX2X4FV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX2X4FV _glProgramUniformMatrix2x4fv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix2x4fv";
    if (!_glProgramUniformMatrix2x4fv_ptr) {
        _glProgramUniformMatrix2x4fv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X4FV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix2x4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix2x4fv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX4X2FV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX4X2FV _glProgramUniformMatrix4x2fv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix4x2fv";
    if (!_glProgramUniformMatrix4x2fv_ptr) {
        _glProgramUniformMatrix4x2fv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X2FV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix4x2fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix4x2fv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX3X4FV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX3X4FV _glProgramUniformMatrix3x4fv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix3x4fv";
    if (!_glProgramUniformMatrix3x4fv_ptr) {
        _glProgramUniformMatrix3x4fv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X4FV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix3x4fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix3x4fv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX4X3FV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX4X3FV _glProgramUniformMatrix4x3fv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix4x3fv";
    if (!_glProgramUniformMatrix4x3fv_ptr) {
        _glProgramUniformMatrix4x3fv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X3FV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix4x3fv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix4x3fv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX2X3DV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX2X3DV _glProgramUniformMatrix2x3dv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix2x3dv";
    if (!_glProgramUniformMatrix2x3dv_ptr) {
        _glProgramUniformMatrix2x3dv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X3DV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix2x3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix2x3dv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX3X2DV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX3X2DV _glProgramUniformMatrix3x2dv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix3x2dv";
    if (!_glProgramUniformMatrix3x2dv_ptr) {
        _glProgramUniformMatrix3x2dv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X2DV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix3x2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix3x2dv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX2X4DV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX2X4DV _glProgramUniformMatrix2x4dv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix2x4dv";
    if (!_glProgramUniformMatrix2x4dv_ptr) {
        _glProgramUniformMatrix2x4dv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X4DV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix2x4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix2x4dv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX4X2DV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX4X2DV _glProgramUniformMatrix4x2dv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix4x2dv";
    if (!_glProgramUniformMatrix4x2dv_ptr) {
        _glProgramUniformMatrix4x2dv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X2DV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix4x2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix4x2dv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX3X4DV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX3X4DV _glProgramUniformMatrix3x4dv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix3x4dv";
    if (!_glProgramUniformMatrix3x4dv_ptr) {
        _glProgramUniformMatrix3x4dv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X4DV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix3x4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix3x4dv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX4X3DV)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX4X3DV _glProgramUniformMatrix4x3dv_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix4x3dv";
    if (!_glProgramUniformMatrix4x3dv_ptr) {
        _glProgramUniformMatrix4x3dv_ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X3DV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix4x3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix4x3dv_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLVALIDATEPROGRAMPIPELINE)(GLuint pipeline);
static PFN_GLVALIDATEPROGRAMPIPELINE _glValidateProgramPipeline_ptr = NULL;

static inline void APIENTRY _glValidateProgramPipeline(GLuint pipeline) {
    const char *_name = "glValidateProgramPipeline";
    if (!_glValidateProgramPipeline_ptr) {
        _glValidateProgramPipeline_ptr = (PFN_GLVALIDATEPROGRAMPIPELINE)_getPrivateProcAddress(_name);
        if (!_glValidateProgramPipeline_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glValidateProgramPipeline_ptr(pipeline);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMPIPELINEINFOLOG)(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
static PFN_GLGETPROGRAMPIPELINEINFOLOG _glGetProgramPipelineInfoLog_ptr = NULL;

static inline void APIENTRY _glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog) {
    const char *_name = "glGetProgramPipelineInfoLog";
    if (!_glGetProgramPipelineInfoLog_ptr) {
        _glGetProgramPipelineInfoLog_ptr = (PFN_GLGETPROGRAMPIPELINEINFOLOG)_getPrivateProcAddress(_name);
        if (!_glGetProgramPipelineInfoLog_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramPipelineInfoLog_ptr(pipeline, bufSize, length, infoLog);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL1D)(GLuint index, GLdouble x);
static PFN_GLVERTEXATTRIBL1D _glVertexAttribL1d_ptr = NULL;

static inline void APIENTRY _glVertexAttribL1d(GLuint index, GLdouble x) {
    const char *_name = "glVertexAttribL1d";
    if (!_glVertexAttribL1d_ptr) {
        _glVertexAttribL1d_ptr = (PFN_GLVERTEXATTRIBL1D)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL1d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL1d_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL2D)(GLuint index, GLdouble x, GLdouble y);
static PFN_GLVERTEXATTRIBL2D _glVertexAttribL2d_ptr = NULL;

static inline void APIENTRY _glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y) {
    const char *_name = "glVertexAttribL2d";
    if (!_glVertexAttribL2d_ptr) {
        _glVertexAttribL2d_ptr = (PFN_GLVERTEXATTRIBL2D)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL2d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL2d_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL3D)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
static PFN_GLVERTEXATTRIBL3D _glVertexAttribL3d_ptr = NULL;

static inline void APIENTRY _glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertexAttribL3d";
    if (!_glVertexAttribL3d_ptr) {
        _glVertexAttribL3d_ptr = (PFN_GLVERTEXATTRIBL3D)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL3d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL3d_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL4D)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLVERTEXATTRIBL4D _glVertexAttribL4d_ptr = NULL;

static inline void APIENTRY _glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertexAttribL4d";
    if (!_glVertexAttribL4d_ptr) {
        _glVertexAttribL4d_ptr = (PFN_GLVERTEXATTRIBL4D)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL4d_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL4d_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL1DV)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIBL1DV _glVertexAttribL1dv_ptr = NULL;

static inline void APIENTRY _glVertexAttribL1dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL1dv";
    if (!_glVertexAttribL1dv_ptr) {
        _glVertexAttribL1dv_ptr = (PFN_GLVERTEXATTRIBL1DV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL1dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL1dv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL2DV)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIBL2DV _glVertexAttribL2dv_ptr = NULL;

static inline void APIENTRY _glVertexAttribL2dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL2dv";
    if (!_glVertexAttribL2dv_ptr) {
        _glVertexAttribL2dv_ptr = (PFN_GLVERTEXATTRIBL2DV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL2dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL2dv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL3DV)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIBL3DV _glVertexAttribL3dv_ptr = NULL;

static inline void APIENTRY _glVertexAttribL3dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL3dv";
    if (!_glVertexAttribL3dv_ptr) {
        _glVertexAttribL3dv_ptr = (PFN_GLVERTEXATTRIBL3DV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL3dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL3dv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL4DV)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIBL4DV _glVertexAttribL4dv_ptr = NULL;

static inline void APIENTRY _glVertexAttribL4dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL4dv";
    if (!_glVertexAttribL4dv_ptr) {
        _glVertexAttribL4dv_ptr = (PFN_GLVERTEXATTRIBL4DV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL4dv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL4dv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBLPOINTER)(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLVERTEXATTRIBLPOINTER _glVertexAttribLPointer_ptr = NULL;

static inline void APIENTRY _glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribLPointer";
    if (!_glVertexAttribLPointer_ptr) {
        _glVertexAttribLPointer_ptr = (PFN_GLVERTEXATTRIBLPOINTER)_getPrivateProcAddress(_name);
        if (!_glVertexAttribLPointer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribLPointer_ptr(index, size, type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBLDV)(GLuint index, GLenum pname, GLdouble * params);
static PFN_GLGETVERTEXATTRIBLDV _glGetVertexAttribLdv_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble * params) {
    const char *_name = "glGetVertexAttribLdv";
    if (!_glGetVertexAttribLdv_ptr) {
        _glGetVertexAttribLdv_ptr = (PFN_GLGETVERTEXATTRIBLDV)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribLdv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribLdv_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLVIEWPORTARRAYV)(GLuint first, GLsizei count, const GLfloat * v);
static PFN_GLVIEWPORTARRAYV _glViewportArrayv_ptr = NULL;

static inline void APIENTRY _glViewportArrayv(GLuint first, GLsizei count, const GLfloat * v) {
    const char *_name = "glViewportArrayv";
    if (!_glViewportArrayv_ptr) {
        _glViewportArrayv_ptr = (PFN_GLVIEWPORTARRAYV)_getPrivateProcAddress(_name);
        if (!_glViewportArrayv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glViewportArrayv_ptr(first, count, v);
}

typedef void (APIENTRY * PFN_GLVIEWPORTINDEXEDF)(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
static PFN_GLVIEWPORTINDEXEDF _glViewportIndexedf_ptr = NULL;

static inline void APIENTRY _glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) {
    const char *_name = "glViewportIndexedf";
    if (!_glViewportIndexedf_ptr) {
        _glViewportIndexedf_ptr = (PFN_GLVIEWPORTINDEXEDF)_getPrivateProcAddress(_name);
        if (!_glViewportIndexedf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glViewportIndexedf_ptr(index, x, y, w, h);
}

typedef void (APIENTRY * PFN_GLVIEWPORTINDEXEDFV)(GLuint index, const GLfloat * v);
static PFN_GLVIEWPORTINDEXEDFV _glViewportIndexedfv_ptr = NULL;

static inline void APIENTRY _glViewportIndexedfv(GLuint index, const GLfloat * v) {
    const char *_name = "glViewportIndexedfv";
    if (!_glViewportIndexedfv_ptr) {
        _glViewportIndexedfv_ptr = (PFN_GLVIEWPORTINDEXEDFV)_getPrivateProcAddress(_name);
        if (!_glViewportIndexedfv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glViewportIndexedfv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLSCISSORARRAYV)(GLuint first, GLsizei count, const GLint * v);
static PFN_GLSCISSORARRAYV _glScissorArrayv_ptr = NULL;

static inline void APIENTRY _glScissorArrayv(GLuint first, GLsizei count, const GLint * v) {
    const char *_name = "glScissorArrayv";
    if (!_glScissorArrayv_ptr) {
        _glScissorArrayv_ptr = (PFN_GLSCISSORARRAYV)_getPrivateProcAddress(_name);
        if (!_glScissorArrayv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glScissorArrayv_ptr(first, count, v);
}

typedef void (APIENTRY * PFN_GLSCISSORINDEXED)(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
static PFN_GLSCISSORINDEXED _glScissorIndexed_ptr = NULL;

static inline void APIENTRY _glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) {
    const char *_name = "glScissorIndexed";
    if (!_glScissorIndexed_ptr) {
        _glScissorIndexed_ptr = (PFN_GLSCISSORINDEXED)_getPrivateProcAddress(_name);
        if (!_glScissorIndexed_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glScissorIndexed_ptr(index, left, bottom, width, height);
}

typedef void (APIENTRY * PFN_GLSCISSORINDEXEDV)(GLuint index, const GLint * v);
static PFN_GLSCISSORINDEXEDV _glScissorIndexedv_ptr = NULL;

static inline void APIENTRY _glScissorIndexedv(GLuint index, const GLint * v) {
    const char *_name = "glScissorIndexedv";
    if (!_glScissorIndexedv_ptr) {
        _glScissorIndexedv_ptr = (PFN_GLSCISSORINDEXEDV)_getPrivateProcAddress(_name);
        if (!_glScissorIndexedv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glScissorIndexedv_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLDEPTHRANGEARRAYV)(GLuint first, GLsizei count, const GLdouble * v);
static PFN_GLDEPTHRANGEARRAYV _glDepthRangeArrayv_ptr = NULL;

static inline void APIENTRY _glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble * v) {
    const char *_name = "glDepthRangeArrayv";
    if (!_glDepthRangeArrayv_ptr) {
        _glDepthRangeArrayv_ptr = (PFN_GLDEPTHRANGEARRAYV)_getPrivateProcAddress(_name);
        if (!_glDepthRangeArrayv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDepthRangeArrayv_ptr(first, count, v);
}

typedef void (APIENTRY * PFN_GLDEPTHRANGEINDEXED)(GLuint index, GLdouble n, GLdouble f);
static PFN_GLDEPTHRANGEINDEXED _glDepthRangeIndexed_ptr = NULL;

static inline void APIENTRY _glDepthRangeIndexed(GLuint index, GLdouble n, GLdouble f) {
    const char *_name = "glDepthRangeIndexed";
    if (!_glDepthRangeIndexed_ptr) {
        _glDepthRangeIndexed_ptr = (PFN_GLDEPTHRANGEINDEXED)_getPrivateProcAddress(_name);
        if (!_glDepthRangeIndexed_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDepthRangeIndexed_ptr(index, n, f);
}

typedef void (APIENTRY * PFN_GLGETFLOATI_V)(GLenum target, GLuint index, GLfloat * data);
static PFN_GLGETFLOATI_V _glGetFloati_v_ptr = NULL;

static inline void APIENTRY _glGetFloati_v(GLenum target, GLuint index, GLfloat * data) {
    const char *_name = "glGetFloati_v";
    if (!_glGetFloati_v_ptr) {
        _glGetFloati_v_ptr = (PFN_GLGETFLOATI_V)_getPrivateProcAddress(_name);
        if (!_glGetFloati_v_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFloati_v_ptr(target, index, data);
}

typedef void (APIENTRY * PFN_GLGETDOUBLEI_V)(GLenum target, GLuint index, GLdouble * data);
static PFN_GLGETDOUBLEI_V _glGetDoublei_v_ptr = NULL;

static inline void APIENTRY _glGetDoublei_v(GLenum target, GLuint index, GLdouble * data) {
    const char *_name = "glGetDoublei_v";
    if (!_glGetDoublei_v_ptr) {
        _glGetDoublei_v_ptr = (PFN_GLGETDOUBLEI_V)_getPrivateProcAddress(_name);
        if (!_glGetDoublei_v_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetDoublei_v_ptr(target, index, data);
}

typedef void (APIENTRY * PFN_GLDEBUGMESSAGECONTROLARB)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);
static PFN_GLDEBUGMESSAGECONTROLARB _glDebugMessageControlARB_ptr = NULL;

static inline void APIENTRY _glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled) {
    const char *_name = "glDebugMessageControlARB";
    if (!_glDebugMessageControlARB_ptr) {
        _glDebugMessageControlARB_ptr = (PFN_GLDEBUGMESSAGECONTROLARB)_getPrivateProcAddress(_name);
        if (!_glDebugMessageControlARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDebugMessageControlARB_ptr(source, type, severity, count, ids, enabled);
}

typedef void (APIENTRY * PFN_GLDEBUGMESSAGEINSERTARB)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf);
static PFN_GLDEBUGMESSAGEINSERTARB _glDebugMessageInsertARB_ptr = NULL;

static inline void APIENTRY _glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf) {
    const char *_name = "glDebugMessageInsertARB";
    if (!_glDebugMessageInsertARB_ptr) {
        _glDebugMessageInsertARB_ptr = (PFN_GLDEBUGMESSAGEINSERTARB)_getPrivateProcAddress(_name);
        if (!_glDebugMessageInsertARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDebugMessageInsertARB_ptr(source, type, id, severity, length, buf);
}

typedef void (APIENTRY * PFN_GLDEBUGMESSAGECALLBACKARB)(GLDEBUGPROCARB callback, const GLvoid * userParam);
static PFN_GLDEBUGMESSAGECALLBACKARB _glDebugMessageCallbackARB_ptr = NULL;

static inline void APIENTRY _glDebugMessageCallbackARB(GLDEBUGPROCARB callback, const GLvoid * userParam) {
    const char *_name = "glDebugMessageCallbackARB";
    if (!_glDebugMessageCallbackARB_ptr) {
        _glDebugMessageCallbackARB_ptr = (PFN_GLDEBUGMESSAGECALLBACKARB)_getPrivateProcAddress(_name);
        if (!_glDebugMessageCallbackARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDebugMessageCallbackARB_ptr(callback, userParam);
}

typedef GLuint (APIENTRY * PFN_GLGETDEBUGMESSAGELOGARB)(GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);
static PFN_GLGETDEBUGMESSAGELOGARB _glGetDebugMessageLogARB_ptr = NULL;

static inline GLuint APIENTRY _glGetDebugMessageLogARB(GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog) {
    const char *_name = "glGetDebugMessageLogARB";
    if (!_glGetDebugMessageLogARB_ptr) {
        _glGetDebugMessageLogARB_ptr = (PFN_GLGETDEBUGMESSAGELOGARB)_getPrivateProcAddress(_name);
        if (!_glGetDebugMessageLogARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetDebugMessageLogARB_ptr(count, bufsize, sources, types, ids, severities, lengths, messageLog);
}

typedef GLenum (APIENTRY * PFN_GLGETGRAPHICSRESETSTATUSARB)(void);
static PFN_GLGETGRAPHICSRESETSTATUSARB _glGetGraphicsResetStatusARB_ptr = NULL;

static inline GLenum APIENTRY _glGetGraphicsResetStatusARB(void) {
    const char *_name = "glGetGraphicsResetStatusARB";
    if (!_glGetGraphicsResetStatusARB_ptr) {
        _glGetGraphicsResetStatusARB_ptr = (PFN_GLGETGRAPHICSRESETSTATUSARB)_getPrivateProcAddress(_name);
        if (!_glGetGraphicsResetStatusARB_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetGraphicsResetStatusARB_ptr();
}

typedef void (APIENTRY * PFN_GLGETNMAPDVARB)(GLenum target, GLenum query, GLsizei bufSize, GLdouble * v);
static PFN_GLGETNMAPDVARB _glGetnMapdvARB_ptr = NULL;

static inline void APIENTRY _glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble * v) {
    const char *_name = "glGetnMapdvARB";
    if (!_glGetnMapdvARB_ptr) {
        _glGetnMapdvARB_ptr = (PFN_GLGETNMAPDVARB)_getPrivateProcAddress(_name);
        if (!_glGetnMapdvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnMapdvARB_ptr(target, query, bufSize, v);
}

typedef void (APIENTRY * PFN_GLGETNMAPFVARB)(GLenum target, GLenum query, GLsizei bufSize, GLfloat * v);
static PFN_GLGETNMAPFVARB _glGetnMapfvARB_ptr = NULL;

static inline void APIENTRY _glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat * v) {
    const char *_name = "glGetnMapfvARB";
    if (!_glGetnMapfvARB_ptr) {
        _glGetnMapfvARB_ptr = (PFN_GLGETNMAPFVARB)_getPrivateProcAddress(_name);
        if (!_glGetnMapfvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnMapfvARB_ptr(target, query, bufSize, v);
}

typedef void (APIENTRY * PFN_GLGETNMAPIVARB)(GLenum target, GLenum query, GLsizei bufSize, GLint * v);
static PFN_GLGETNMAPIVARB _glGetnMapivARB_ptr = NULL;

static inline void APIENTRY _glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint * v) {
    const char *_name = "glGetnMapivARB";
    if (!_glGetnMapivARB_ptr) {
        _glGetnMapivARB_ptr = (PFN_GLGETNMAPIVARB)_getPrivateProcAddress(_name);
        if (!_glGetnMapivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnMapivARB_ptr(target, query, bufSize, v);
}

typedef void (APIENTRY * PFN_GLGETNPIXELMAPFVARB)(GLenum map, GLsizei bufSize, GLfloat * values);
static PFN_GLGETNPIXELMAPFVARB _glGetnPixelMapfvARB_ptr = NULL;

static inline void APIENTRY _glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat * values) {
    const char *_name = "glGetnPixelMapfvARB";
    if (!_glGetnPixelMapfvARB_ptr) {
        _glGetnPixelMapfvARB_ptr = (PFN_GLGETNPIXELMAPFVARB)_getPrivateProcAddress(_name);
        if (!_glGetnPixelMapfvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnPixelMapfvARB_ptr(map, bufSize, values);
}

typedef void (APIENTRY * PFN_GLGETNPIXELMAPUIVARB)(GLenum map, GLsizei bufSize, GLuint * values);
static PFN_GLGETNPIXELMAPUIVARB _glGetnPixelMapuivARB_ptr = NULL;

static inline void APIENTRY _glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint * values) {
    const char *_name = "glGetnPixelMapuivARB";
    if (!_glGetnPixelMapuivARB_ptr) {
        _glGetnPixelMapuivARB_ptr = (PFN_GLGETNPIXELMAPUIVARB)_getPrivateProcAddress(_name);
        if (!_glGetnPixelMapuivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnPixelMapuivARB_ptr(map, bufSize, values);
}

typedef void (APIENTRY * PFN_GLGETNPIXELMAPUSVARB)(GLenum map, GLsizei bufSize, GLushort * values);
static PFN_GLGETNPIXELMAPUSVARB _glGetnPixelMapusvARB_ptr = NULL;

static inline void APIENTRY _glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort * values) {
    const char *_name = "glGetnPixelMapusvARB";
    if (!_glGetnPixelMapusvARB_ptr) {
        _glGetnPixelMapusvARB_ptr = (PFN_GLGETNPIXELMAPUSVARB)_getPrivateProcAddress(_name);
        if (!_glGetnPixelMapusvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnPixelMapusvARB_ptr(map, bufSize, values);
}

typedef void (APIENTRY * PFN_GLGETNPOLYGONSTIPPLEARB)(GLsizei bufSize, GLubyte * pattern);
static PFN_GLGETNPOLYGONSTIPPLEARB _glGetnPolygonStippleARB_ptr = NULL;

static inline void APIENTRY _glGetnPolygonStippleARB(GLsizei bufSize, GLubyte * pattern) {
    const char *_name = "glGetnPolygonStippleARB";
    if (!_glGetnPolygonStippleARB_ptr) {
        _glGetnPolygonStippleARB_ptr = (PFN_GLGETNPOLYGONSTIPPLEARB)_getPrivateProcAddress(_name);
        if (!_glGetnPolygonStippleARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnPolygonStippleARB_ptr(bufSize, pattern);
}

typedef void (APIENTRY * PFN_GLGETNCOLORTABLEARB)(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * table);
static PFN_GLGETNCOLORTABLEARB _glGetnColorTableARB_ptr = NULL;

static inline void APIENTRY _glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * table) {
    const char *_name = "glGetnColorTableARB";
    if (!_glGetnColorTableARB_ptr) {
        _glGetnColorTableARB_ptr = (PFN_GLGETNCOLORTABLEARB)_getPrivateProcAddress(_name);
        if (!_glGetnColorTableARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnColorTableARB_ptr(target, format, type, bufSize, table);
}

typedef void (APIENTRY * PFN_GLGETNCONVOLUTIONFILTERARB)(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * image);
static PFN_GLGETNCONVOLUTIONFILTERARB _glGetnConvolutionFilterARB_ptr = NULL;

static inline void APIENTRY _glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * image) {
    const char *_name = "glGetnConvolutionFilterARB";
    if (!_glGetnConvolutionFilterARB_ptr) {
        _glGetnConvolutionFilterARB_ptr = (PFN_GLGETNCONVOLUTIONFILTERARB)_getPrivateProcAddress(_name);
        if (!_glGetnConvolutionFilterARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnConvolutionFilterARB_ptr(target, format, type, bufSize, image);
}

typedef void (APIENTRY * PFN_GLGETNSEPARABLEFILTERARB)(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid * row, GLsizei columnBufSize, GLvoid * column, GLvoid * span);
static PFN_GLGETNSEPARABLEFILTERARB _glGetnSeparableFilterARB_ptr = NULL;

static inline void APIENTRY _glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid * row, GLsizei columnBufSize, GLvoid * column, GLvoid * span) {
    const char *_name = "glGetnSeparableFilterARB";
    if (!_glGetnSeparableFilterARB_ptr) {
        _glGetnSeparableFilterARB_ptr = (PFN_GLGETNSEPARABLEFILTERARB)_getPrivateProcAddress(_name);
        if (!_glGetnSeparableFilterARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnSeparableFilterARB_ptr(target, format, type, rowBufSize, row, columnBufSize, column, span);
}

typedef void (APIENTRY * PFN_GLGETNHISTOGRAMARB)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values);
static PFN_GLGETNHISTOGRAMARB _glGetnHistogramARB_ptr = NULL;

static inline void APIENTRY _glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values) {
    const char *_name = "glGetnHistogramARB";
    if (!_glGetnHistogramARB_ptr) {
        _glGetnHistogramARB_ptr = (PFN_GLGETNHISTOGRAMARB)_getPrivateProcAddress(_name);
        if (!_glGetnHistogramARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnHistogramARB_ptr(target, reset, format, type, bufSize, values);
}

typedef void (APIENTRY * PFN_GLGETNMINMAXARB)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values);
static PFN_GLGETNMINMAXARB _glGetnMinmaxARB_ptr = NULL;

static inline void APIENTRY _glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values) {
    const char *_name = "glGetnMinmaxARB";
    if (!_glGetnMinmaxARB_ptr) {
        _glGetnMinmaxARB_ptr = (PFN_GLGETNMINMAXARB)_getPrivateProcAddress(_name);
        if (!_glGetnMinmaxARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnMinmaxARB_ptr(target, reset, format, type, bufSize, values);
}

typedef void (APIENTRY * PFN_GLGETNTEXIMAGEARB)(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid * img);
static PFN_GLGETNTEXIMAGEARB _glGetnTexImageARB_ptr = NULL;

static inline void APIENTRY _glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid * img) {
    const char *_name = "glGetnTexImageARB";
    if (!_glGetnTexImageARB_ptr) {
        _glGetnTexImageARB_ptr = (PFN_GLGETNTEXIMAGEARB)_getPrivateProcAddress(_name);
        if (!_glGetnTexImageARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnTexImageARB_ptr(target, level, format, type, bufSize, img);
}

typedef void (APIENTRY * PFN_GLREADNPIXELSARB)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid * data);
static PFN_GLREADNPIXELSARB _glReadnPixelsARB_ptr = NULL;

static inline void APIENTRY _glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid * data) {
    const char *_name = "glReadnPixelsARB";
    if (!_glReadnPixelsARB_ptr) {
        _glReadnPixelsARB_ptr = (PFN_GLREADNPIXELSARB)_getPrivateProcAddress(_name);
        if (!_glReadnPixelsARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReadnPixelsARB_ptr(x, y, width, height, format, type, bufSize, data);
}

typedef void (APIENTRY * PFN_GLGETNCOMPRESSEDTEXIMAGEARB)(GLenum target, GLint lod, GLsizei bufSize, GLvoid * img);
static PFN_GLGETNCOMPRESSEDTEXIMAGEARB _glGetnCompressedTexImageARB_ptr = NULL;

static inline void APIENTRY _glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, GLvoid * img) {
    const char *_name = "glGetnCompressedTexImageARB";
    if (!_glGetnCompressedTexImageARB_ptr) {
        _glGetnCompressedTexImageARB_ptr = (PFN_GLGETNCOMPRESSEDTEXIMAGEARB)_getPrivateProcAddress(_name);
        if (!_glGetnCompressedTexImageARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnCompressedTexImageARB_ptr(target, lod, bufSize, img);
}

typedef void (APIENTRY * PFN_GLGETNUNIFORMFVARB)(GLuint program, GLint location, GLsizei bufSize, GLfloat * params);
static PFN_GLGETNUNIFORMFVARB _glGetnUniformfvARB_ptr = NULL;

static inline void APIENTRY _glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat * params) {
    const char *_name = "glGetnUniformfvARB";
    if (!_glGetnUniformfvARB_ptr) {
        _glGetnUniformfvARB_ptr = (PFN_GLGETNUNIFORMFVARB)_getPrivateProcAddress(_name);
        if (!_glGetnUniformfvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnUniformfvARB_ptr(program, location, bufSize, params);
}

typedef void (APIENTRY * PFN_GLGETNUNIFORMIVARB)(GLuint program, GLint location, GLsizei bufSize, GLint * params);
static PFN_GLGETNUNIFORMIVARB _glGetnUniformivARB_ptr = NULL;

static inline void APIENTRY _glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint * params) {
    const char *_name = "glGetnUniformivARB";
    if (!_glGetnUniformivARB_ptr) {
        _glGetnUniformivARB_ptr = (PFN_GLGETNUNIFORMIVARB)_getPrivateProcAddress(_name);
        if (!_glGetnUniformivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnUniformivARB_ptr(program, location, bufSize, params);
}

typedef void (APIENTRY * PFN_GLGETNUNIFORMUIVARB)(GLuint program, GLint location, GLsizei bufSize, GLuint * params);
static PFN_GLGETNUNIFORMUIVARB _glGetnUniformuivARB_ptr = NULL;

static inline void APIENTRY _glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint * params) {
    const char *_name = "glGetnUniformuivARB";
    if (!_glGetnUniformuivARB_ptr) {
        _glGetnUniformuivARB_ptr = (PFN_GLGETNUNIFORMUIVARB)_getPrivateProcAddress(_name);
        if (!_glGetnUniformuivARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnUniformuivARB_ptr(program, location, bufSize, params);
}

typedef void (APIENTRY * PFN_GLGETNUNIFORMDVARB)(GLuint program, GLint location, GLsizei bufSize, GLdouble * params);
static PFN_GLGETNUNIFORMDVARB _glGetnUniformdvARB_ptr = NULL;

static inline void APIENTRY _glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble * params) {
    const char *_name = "glGetnUniformdvARB";
    if (!_glGetnUniformdvARB_ptr) {
        _glGetnUniformdvARB_ptr = (PFN_GLGETNUNIFORMDVARB)_getPrivateProcAddress(_name);
        if (!_glGetnUniformdvARB_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetnUniformdvARB_ptr(program, location, bufSize, params);
}

typedef void (APIENTRY * PFN_GLDRAWARRAYSINSTANCEDBASEINSTANCE)(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
static PFN_GLDRAWARRAYSINSTANCEDBASEINSTANCE _glDrawArraysInstancedBaseInstance_ptr = NULL;

static inline void APIENTRY _glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance) {
    const char *_name = "glDrawArraysInstancedBaseInstance";
    if (!_glDrawArraysInstancedBaseInstance_ptr) {
        _glDrawArraysInstancedBaseInstance_ptr = (PFN_GLDRAWARRAYSINSTANCEDBASEINSTANCE)_getPrivateProcAddress(_name);
        if (!_glDrawArraysInstancedBaseInstance_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawArraysInstancedBaseInstance_ptr(mode, first, count, primcount, baseinstance);
}

typedef void (APIENTRY * PFN_GLDRAWELEMENTSINSTANCEDBASEINSTANCE)(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount, GLuint baseinstance);
static PFN_GLDRAWELEMENTSINSTANCEDBASEINSTANCE _glDrawElementsInstancedBaseInstance_ptr = NULL;

static inline void APIENTRY _glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount, GLuint baseinstance) {
    const char *_name = "glDrawElementsInstancedBaseInstance";
    if (!_glDrawElementsInstancedBaseInstance_ptr) {
        _glDrawElementsInstancedBaseInstance_ptr = (PFN_GLDRAWELEMENTSINSTANCEDBASEINSTANCE)_getPrivateProcAddress(_name);
        if (!_glDrawElementsInstancedBaseInstance_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawElementsInstancedBaseInstance_ptr(mode, count, type, indices, primcount, baseinstance);
}

typedef void (APIENTRY * PFN_GLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCE)(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);
static PFN_GLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCE _glDrawElementsInstancedBaseVertexBaseInstance_ptr = NULL;

static inline void APIENTRY _glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount, GLint basevertex, GLuint baseinstance) {
    const char *_name = "glDrawElementsInstancedBaseVertexBaseInstance";
    if (!_glDrawElementsInstancedBaseVertexBaseInstance_ptr) {
        _glDrawElementsInstancedBaseVertexBaseInstance_ptr = (PFN_GLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCE)_getPrivateProcAddress(_name);
        if (!_glDrawElementsInstancedBaseVertexBaseInstance_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawElementsInstancedBaseVertexBaseInstance_ptr(mode, count, type, indices, primcount, basevertex, baseinstance);
}

typedef void (APIENTRY * PFN_GLDRAWTRANSFORMFEEDBACKINSTANCED)(GLenum mode, GLuint id, GLsizei primcount);
static PFN_GLDRAWTRANSFORMFEEDBACKINSTANCED _glDrawTransformFeedbackInstanced_ptr = NULL;

static inline void APIENTRY _glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount) {
    const char *_name = "glDrawTransformFeedbackInstanced";
    if (!_glDrawTransformFeedbackInstanced_ptr) {
        _glDrawTransformFeedbackInstanced_ptr = (PFN_GLDRAWTRANSFORMFEEDBACKINSTANCED)_getPrivateProcAddress(_name);
        if (!_glDrawTransformFeedbackInstanced_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawTransformFeedbackInstanced_ptr(mode, id, primcount);
}

typedef void (APIENTRY * PFN_GLDRAWTRANSFORMFEEDBACKSTREAMINSTANCED)(GLenum mode, GLuint id, GLuint stream, GLsizei primcount);
static PFN_GLDRAWTRANSFORMFEEDBACKSTREAMINSTANCED _glDrawTransformFeedbackStreamInstanced_ptr = NULL;

static inline void APIENTRY _glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount) {
    const char *_name = "glDrawTransformFeedbackStreamInstanced";
    if (!_glDrawTransformFeedbackStreamInstanced_ptr) {
        _glDrawTransformFeedbackStreamInstanced_ptr = (PFN_GLDRAWTRANSFORMFEEDBACKSTREAMINSTANCED)_getPrivateProcAddress(_name);
        if (!_glDrawTransformFeedbackStreamInstanced_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawTransformFeedbackStreamInstanced_ptr(mode, id, stream, primcount);
}

typedef void (APIENTRY * PFN_GLGETINTERNALFORMATIV)(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint * params);
static PFN_GLGETINTERNALFORMATIV _glGetInternalformativ_ptr = NULL;

static inline void APIENTRY _glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint * params) {
    const char *_name = "glGetInternalformativ";
    if (!_glGetInternalformativ_ptr) {
        _glGetInternalformativ_ptr = (PFN_GLGETINTERNALFORMATIV)_getPrivateProcAddress(_name);
        if (!_glGetInternalformativ_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetInternalformativ_ptr(target, internalformat, pname, bufSize, params);
}

typedef void (APIENTRY * PFN_GLGETACTIVEATOMICCOUNTERBUFFERIV)(GLuint program, GLuint bufferIndex, GLenum pname, GLint * params);
static PFN_GLGETACTIVEATOMICCOUNTERBUFFERIV _glGetActiveAtomicCounterBufferiv_ptr = NULL;

static inline void APIENTRY _glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint * params) {
    const char *_name = "glGetActiveAtomicCounterBufferiv";
    if (!_glGetActiveAtomicCounterBufferiv_ptr) {
        _glGetActiveAtomicCounterBufferiv_ptr = (PFN_GLGETACTIVEATOMICCOUNTERBUFFERIV)_getPrivateProcAddress(_name);
        if (!_glGetActiveAtomicCounterBufferiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetActiveAtomicCounterBufferiv_ptr(program, bufferIndex, pname, params);
}

typedef void (APIENTRY * PFN_GLBINDIMAGETEXTURE)(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
static PFN_GLBINDIMAGETEXTURE _glBindImageTexture_ptr = NULL;

static inline void APIENTRY _glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format) {
    const char *_name = "glBindImageTexture";
    if (!_glBindImageTexture_ptr) {
        _glBindImageTexture_ptr = (PFN_GLBINDIMAGETEXTURE)_getPrivateProcAddress(_name);
        if (!_glBindImageTexture_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindImageTexture_ptr(unit, texture, level, layered, layer, access, format);
}

typedef void (APIENTRY * PFN_GLMEMORYBARRIER)(GLbitfield barriers);
static PFN_GLMEMORYBARRIER _glMemoryBarrier_ptr = NULL;

static inline void APIENTRY _glMemoryBarrier(GLbitfield barriers) {
    const char *_name = "glMemoryBarrier";
    if (!_glMemoryBarrier_ptr) {
        _glMemoryBarrier_ptr = (PFN_GLMEMORYBARRIER)_getPrivateProcAddress(_name);
        if (!_glMemoryBarrier_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMemoryBarrier_ptr(barriers);
}

typedef void (APIENTRY * PFN_GLTEXSTORAGE1D)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
static PFN_GLTEXSTORAGE1D _glTexStorage1D_ptr = NULL;

static inline void APIENTRY _glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) {
    const char *_name = "glTexStorage1D";
    if (!_glTexStorage1D_ptr) {
        _glTexStorage1D_ptr = (PFN_GLTEXSTORAGE1D)_getPrivateProcAddress(_name);
        if (!_glTexStorage1D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexStorage1D_ptr(target, levels, internalformat, width);
}

typedef void (APIENTRY * PFN_GLTEXSTORAGE2D)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLTEXSTORAGE2D _glTexStorage2D_ptr = NULL;

static inline void APIENTRY _glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glTexStorage2D";
    if (!_glTexStorage2D_ptr) {
        _glTexStorage2D_ptr = (PFN_GLTEXSTORAGE2D)_getPrivateProcAddress(_name);
        if (!_glTexStorage2D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexStorage2D_ptr(target, levels, internalformat, width, height);
}

typedef void (APIENTRY * PFN_GLTEXSTORAGE3D)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
static PFN_GLTEXSTORAGE3D _glTexStorage3D_ptr = NULL;

static inline void APIENTRY _glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
    const char *_name = "glTexStorage3D";
    if (!_glTexStorage3D_ptr) {
        _glTexStorage3D_ptr = (PFN_GLTEXSTORAGE3D)_getPrivateProcAddress(_name);
        if (!_glTexStorage3D_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexStorage3D_ptr(target, levels, internalformat, width, height, depth);
}

typedef void (APIENTRY * PFN_GLTEXTURESTORAGE1DEXT)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
static PFN_GLTEXTURESTORAGE1DEXT _glTextureStorage1DEXT_ptr = NULL;

static inline void APIENTRY _glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) {
    const char *_name = "glTextureStorage1DEXT";
    if (!_glTextureStorage1DEXT_ptr) {
        _glTextureStorage1DEXT_ptr = (PFN_GLTEXTURESTORAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glTextureStorage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureStorage1DEXT_ptr(texture, target, levels, internalformat, width);
}

typedef void (APIENTRY * PFN_GLTEXTURESTORAGE2DEXT)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLTEXTURESTORAGE2DEXT _glTextureStorage2DEXT_ptr = NULL;

static inline void APIENTRY _glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glTextureStorage2DEXT";
    if (!_glTextureStorage2DEXT_ptr) {
        _glTextureStorage2DEXT_ptr = (PFN_GLTEXTURESTORAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glTextureStorage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureStorage2DEXT_ptr(texture, target, levels, internalformat, width, height);
}

typedef void (APIENTRY * PFN_GLTEXTURESTORAGE3DEXT)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
static PFN_GLTEXTURESTORAGE3DEXT _glTextureStorage3DEXT_ptr = NULL;

static inline void APIENTRY _glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
    const char *_name = "glTextureStorage3DEXT";
    if (!_glTextureStorage3DEXT_ptr) {
        _glTextureStorage3DEXT_ptr = (PFN_GLTEXTURESTORAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glTextureStorage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureStorage3DEXT_ptr(texture, target, levels, internalformat, width, height, depth);
}

typedef void (APIENTRY * PFN_GLDEBUGMESSAGECONTROL)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);
static PFN_GLDEBUGMESSAGECONTROL _glDebugMessageControl_ptr = NULL;

static inline void APIENTRY _glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled) {
    const char *_name = "glDebugMessageControl";
    if (!_glDebugMessageControl_ptr) {
        _glDebugMessageControl_ptr = (PFN_GLDEBUGMESSAGECONTROL)_getPrivateProcAddress(_name);
        if (!_glDebugMessageControl_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDebugMessageControl_ptr(source, type, severity, count, ids, enabled);
}

typedef void (APIENTRY * PFN_GLDEBUGMESSAGEINSERT)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf);
static PFN_GLDEBUGMESSAGEINSERT _glDebugMessageInsert_ptr = NULL;

static inline void APIENTRY _glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf) {
    const char *_name = "glDebugMessageInsert";
    if (!_glDebugMessageInsert_ptr) {
        _glDebugMessageInsert_ptr = (PFN_GLDEBUGMESSAGEINSERT)_getPrivateProcAddress(_name);
        if (!_glDebugMessageInsert_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDebugMessageInsert_ptr(source, type, id, severity, length, buf);
}

typedef void (APIENTRY * PFN_GLDEBUGMESSAGECALLBACK)(GLDEBUGPROC callback, const void * userParam);
static PFN_GLDEBUGMESSAGECALLBACK _glDebugMessageCallback_ptr = NULL;

static inline void APIENTRY _glDebugMessageCallback(GLDEBUGPROC callback, const void * userParam) {
    const char *_name = "glDebugMessageCallback";
    if (!_glDebugMessageCallback_ptr) {
        _glDebugMessageCallback_ptr = (PFN_GLDEBUGMESSAGECALLBACK)_getPrivateProcAddress(_name);
        if (!_glDebugMessageCallback_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDebugMessageCallback_ptr(callback, userParam);
}

typedef GLuint (APIENTRY * PFN_GLGETDEBUGMESSAGELOG)(GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);
static PFN_GLGETDEBUGMESSAGELOG _glGetDebugMessageLog_ptr = NULL;

static inline GLuint APIENTRY _glGetDebugMessageLog(GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog) {
    const char *_name = "glGetDebugMessageLog";
    if (!_glGetDebugMessageLog_ptr) {
        _glGetDebugMessageLog_ptr = (PFN_GLGETDEBUGMESSAGELOG)_getPrivateProcAddress(_name);
        if (!_glGetDebugMessageLog_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetDebugMessageLog_ptr(count, bufsize, sources, types, ids, severities, lengths, messageLog);
}

typedef void (APIENTRY * PFN_GLPUSHDEBUGGROUP)(GLenum source, GLuint id, GLsizei length, const GLchar * message);
static PFN_GLPUSHDEBUGGROUP _glPushDebugGroup_ptr = NULL;

static inline void APIENTRY _glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar * message) {
    const char *_name = "glPushDebugGroup";
    if (!_glPushDebugGroup_ptr) {
        _glPushDebugGroup_ptr = (PFN_GLPUSHDEBUGGROUP)_getPrivateProcAddress(_name);
        if (!_glPushDebugGroup_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPushDebugGroup_ptr(source, id, length, message);
}

typedef void (APIENTRY * PFN_GLPOPDEBUGGROUP)(void);
static PFN_GLPOPDEBUGGROUP _glPopDebugGroup_ptr = NULL;

static inline void APIENTRY _glPopDebugGroup(void) {
    const char *_name = "glPopDebugGroup";
    if (!_glPopDebugGroup_ptr) {
        _glPopDebugGroup_ptr = (PFN_GLPOPDEBUGGROUP)_getPrivateProcAddress(_name);
        if (!_glPopDebugGroup_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPopDebugGroup_ptr();
}

typedef void (APIENTRY * PFN_GLOBJECTLABEL)(GLenum identifier, GLuint name, GLsizei length, const GLchar * label);
static PFN_GLOBJECTLABEL _glObjectLabel_ptr = NULL;

static inline void APIENTRY _glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar * label) {
    const char *_name = "glObjectLabel";
    if (!_glObjectLabel_ptr) {
        _glObjectLabel_ptr = (PFN_GLOBJECTLABEL)_getPrivateProcAddress(_name);
        if (!_glObjectLabel_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glObjectLabel_ptr(identifier, name, length, label);
}

typedef void (APIENTRY * PFN_GLGETOBJECTLABEL)(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label);
static PFN_GLGETOBJECTLABEL _glGetObjectLabel_ptr = NULL;

static inline void APIENTRY _glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label) {
    const char *_name = "glGetObjectLabel";
    if (!_glGetObjectLabel_ptr) {
        _glGetObjectLabel_ptr = (PFN_GLGETOBJECTLABEL)_getPrivateProcAddress(_name);
        if (!_glGetObjectLabel_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetObjectLabel_ptr(identifier, name, bufSize, length, label);
}

typedef void (APIENTRY * PFN_GLOBJECTPTRLABEL)(const void * ptr, GLsizei length, const GLchar * label);
static PFN_GLOBJECTPTRLABEL _glObjectPtrLabel_ptr = NULL;

static inline void APIENTRY _glObjectPtrLabel(const void * ptr, GLsizei length, const GLchar * label) {
    const char *_name = "glObjectPtrLabel";
    if (!_glObjectPtrLabel_ptr) {
        _glObjectPtrLabel_ptr = (PFN_GLOBJECTPTRLABEL)_getPrivateProcAddress(_name);
        if (!_glObjectPtrLabel_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glObjectPtrLabel_ptr(ptr, length, label);
}

typedef void (APIENTRY * PFN_GLGETOBJECTPTRLABEL)(const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label);
static PFN_GLGETOBJECTPTRLABEL _glGetObjectPtrLabel_ptr = NULL;

static inline void APIENTRY _glGetObjectPtrLabel(const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label) {
    const char *_name = "glGetObjectPtrLabel";
    if (!_glGetObjectPtrLabel_ptr) {
        _glGetObjectPtrLabel_ptr = (PFN_GLGETOBJECTPTRLABEL)_getPrivateProcAddress(_name);
        if (!_glGetObjectPtrLabel_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetObjectPtrLabel_ptr(ptr, bufSize, length, label);
}

typedef void (APIENTRY * PFN_GLCLEARBUFFERDATA)(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data);
static PFN_GLCLEARBUFFERDATA _glClearBufferData_ptr = NULL;

static inline void APIENTRY _glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data) {
    const char *_name = "glClearBufferData";
    if (!_glClearBufferData_ptr) {
        _glClearBufferData_ptr = (PFN_GLCLEARBUFFERDATA)_getPrivateProcAddress(_name);
        if (!_glClearBufferData_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearBufferData_ptr(target, internalformat, format, type, data);
}

typedef void (APIENTRY * PFN_GLCLEARBUFFERSUBDATA)(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);
static PFN_GLCLEARBUFFERSUBDATA _glClearBufferSubData_ptr = NULL;

static inline void APIENTRY _glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data) {
    const char *_name = "glClearBufferSubData";
    if (!_glClearBufferSubData_ptr) {
        _glClearBufferSubData_ptr = (PFN_GLCLEARBUFFERSUBDATA)_getPrivateProcAddress(_name);
        if (!_glClearBufferSubData_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearBufferSubData_ptr(target, internalformat, offset, size, format, type, data);
}

typedef void (APIENTRY * PFN_GLCLEARNAMEDBUFFERDATAEXT)(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data);
static PFN_GLCLEARNAMEDBUFFERDATAEXT _glClearNamedBufferDataEXT_ptr = NULL;

static inline void APIENTRY _glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data) {
    const char *_name = "glClearNamedBufferDataEXT";
    if (!_glClearNamedBufferDataEXT_ptr) {
        _glClearNamedBufferDataEXT_ptr = (PFN_GLCLEARNAMEDBUFFERDATAEXT)_getPrivateProcAddress(_name);
        if (!_glClearNamedBufferDataEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearNamedBufferDataEXT_ptr(buffer, internalformat, format, type, data);
}

typedef void (APIENTRY * PFN_GLCLEARNAMEDBUFFERSUBDATAEXT)(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, GLsizeiptr offset, GLsizeiptr size, const void * data);
static PFN_GLCLEARNAMEDBUFFERSUBDATAEXT _glClearNamedBufferSubDataEXT_ptr = NULL;

static inline void APIENTRY _glClearNamedBufferSubDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, GLsizeiptr offset, GLsizeiptr size, const void * data) {
    const char *_name = "glClearNamedBufferSubDataEXT";
    if (!_glClearNamedBufferSubDataEXT_ptr) {
        _glClearNamedBufferSubDataEXT_ptr = (PFN_GLCLEARNAMEDBUFFERSUBDATAEXT)_getPrivateProcAddress(_name);
        if (!_glClearNamedBufferSubDataEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearNamedBufferSubDataEXT_ptr(buffer, internalformat, format, type, offset, size, data);
}

typedef void (APIENTRY * PFN_GLDISPATCHCOMPUTE)(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
static PFN_GLDISPATCHCOMPUTE _glDispatchCompute_ptr = NULL;

static inline void APIENTRY _glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) {
    const char *_name = "glDispatchCompute";
    if (!_glDispatchCompute_ptr) {
        _glDispatchCompute_ptr = (PFN_GLDISPATCHCOMPUTE)_getPrivateProcAddress(_name);
        if (!_glDispatchCompute_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDispatchCompute_ptr(num_groups_x, num_groups_y, num_groups_z);
}

typedef void (APIENTRY * PFN_GLDISPATCHCOMPUTEINDIRECT)(GLintptr indirect);
static PFN_GLDISPATCHCOMPUTEINDIRECT _glDispatchComputeIndirect_ptr = NULL;

static inline void APIENTRY _glDispatchComputeIndirect(GLintptr indirect) {
    const char *_name = "glDispatchComputeIndirect";
    if (!_glDispatchComputeIndirect_ptr) {
        _glDispatchComputeIndirect_ptr = (PFN_GLDISPATCHCOMPUTEINDIRECT)_getPrivateProcAddress(_name);
        if (!_glDispatchComputeIndirect_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDispatchComputeIndirect_ptr(indirect);
}

typedef void (APIENTRY * PFN_GLCOPYIMAGESUBDATA)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
static PFN_GLCOPYIMAGESUBDATA _glCopyImageSubData_ptr = NULL;

static inline void APIENTRY _glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) {
    const char *_name = "glCopyImageSubData";
    if (!_glCopyImageSubData_ptr) {
        _glCopyImageSubData_ptr = (PFN_GLCOPYIMAGESUBDATA)_getPrivateProcAddress(_name);
        if (!_glCopyImageSubData_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyImageSubData_ptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERPARAMETERI)(GLenum target, GLenum pname, GLint param);
static PFN_GLFRAMEBUFFERPARAMETERI _glFramebufferParameteri_ptr = NULL;

static inline void APIENTRY _glFramebufferParameteri(GLenum target, GLenum pname, GLint param) {
    const char *_name = "glFramebufferParameteri";
    if (!_glFramebufferParameteri_ptr) {
        _glFramebufferParameteri_ptr = (PFN_GLFRAMEBUFFERPARAMETERI)_getPrivateProcAddress(_name);
        if (!_glFramebufferParameteri_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferParameteri_ptr(target, pname, param);
}

typedef void (APIENTRY * PFN_GLGETFRAMEBUFFERPARAMETERIV)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETFRAMEBUFFERPARAMETERIV _glGetFramebufferParameteriv_ptr = NULL;

static inline void APIENTRY _glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetFramebufferParameteriv";
    if (!_glGetFramebufferParameteriv_ptr) {
        _glGetFramebufferParameteriv_ptr = (PFN_GLGETFRAMEBUFFERPARAMETERIV)_getPrivateProcAddress(_name);
        if (!_glGetFramebufferParameteriv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFramebufferParameteriv_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLNAMEDFRAMEBUFFERPARAMETERIEXT)(GLuint framebuffer, GLenum pname, GLint param);
static PFN_GLNAMEDFRAMEBUFFERPARAMETERIEXT _glNamedFramebufferParameteriEXT_ptr = NULL;

static inline void APIENTRY _glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param) {
    const char *_name = "glNamedFramebufferParameteriEXT";
    if (!_glNamedFramebufferParameteriEXT_ptr) {
        _glNamedFramebufferParameteriEXT_ptr = (PFN_GLNAMEDFRAMEBUFFERPARAMETERIEXT)_getPrivateProcAddress(_name);
        if (!_glNamedFramebufferParameteriEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedFramebufferParameteriEXT_ptr(framebuffer, pname, param);
}

typedef void (APIENTRY * PFN_GLGETNAMEDFRAMEBUFFERPARAMETERIVEXT)(GLuint framebuffer, GLenum pname, GLint * params);
static PFN_GLGETNAMEDFRAMEBUFFERPARAMETERIVEXT _glGetNamedFramebufferParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedFramebufferParameterivEXT";
    if (!_glGetNamedFramebufferParameterivEXT_ptr) {
        _glGetNamedFramebufferParameterivEXT_ptr = (PFN_GLGETNAMEDFRAMEBUFFERPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetNamedFramebufferParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedFramebufferParameterivEXT_ptr(framebuffer, pname, params);
}

typedef void (APIENTRY * PFN_GLGETINTERNALFORMATI64V)(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 * params);
static PFN_GLGETINTERNALFORMATI64V _glGetInternalformati64v_ptr = NULL;

static inline void APIENTRY _glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 * params) {
    const char *_name = "glGetInternalformati64v";
    if (!_glGetInternalformati64v_ptr) {
        _glGetInternalformati64v_ptr = (PFN_GLGETINTERNALFORMATI64V)_getPrivateProcAddress(_name);
        if (!_glGetInternalformati64v_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetInternalformati64v_ptr(target, internalformat, pname, bufSize, params);
}

typedef void (APIENTRY * PFN_GLINVALIDATETEXSUBIMAGE)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
static PFN_GLINVALIDATETEXSUBIMAGE _glInvalidateTexSubImage_ptr = NULL;

static inline void APIENTRY _glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth) {
    const char *_name = "glInvalidateTexSubImage";
    if (!_glInvalidateTexSubImage_ptr) {
        _glInvalidateTexSubImage_ptr = (PFN_GLINVALIDATETEXSUBIMAGE)_getPrivateProcAddress(_name);
        if (!_glInvalidateTexSubImage_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glInvalidateTexSubImage_ptr(texture, level, xoffset, yoffset, zoffset, width, height, depth);
}

typedef void (APIENTRY * PFN_GLINVALIDATETEXIMAGE)(GLuint texture, GLint level);
static PFN_GLINVALIDATETEXIMAGE _glInvalidateTexImage_ptr = NULL;

static inline void APIENTRY _glInvalidateTexImage(GLuint texture, GLint level) {
    const char *_name = "glInvalidateTexImage";
    if (!_glInvalidateTexImage_ptr) {
        _glInvalidateTexImage_ptr = (PFN_GLINVALIDATETEXIMAGE)_getPrivateProcAddress(_name);
        if (!_glInvalidateTexImage_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glInvalidateTexImage_ptr(texture, level);
}

typedef void (APIENTRY * PFN_GLINVALIDATEBUFFERSUBDATA)(GLuint buffer, GLintptr offset, GLsizeiptr length);
static PFN_GLINVALIDATEBUFFERSUBDATA _glInvalidateBufferSubData_ptr = NULL;

static inline void APIENTRY _glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length) {
    const char *_name = "glInvalidateBufferSubData";
    if (!_glInvalidateBufferSubData_ptr) {
        _glInvalidateBufferSubData_ptr = (PFN_GLINVALIDATEBUFFERSUBDATA)_getPrivateProcAddress(_name);
        if (!_glInvalidateBufferSubData_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glInvalidateBufferSubData_ptr(buffer, offset, length);
}

typedef void (APIENTRY * PFN_GLINVALIDATEBUFFERDATA)(GLuint buffer);
static PFN_GLINVALIDATEBUFFERDATA _glInvalidateBufferData_ptr = NULL;

static inline void APIENTRY _glInvalidateBufferData(GLuint buffer) {
    const char *_name = "glInvalidateBufferData";
    if (!_glInvalidateBufferData_ptr) {
        _glInvalidateBufferData_ptr = (PFN_GLINVALIDATEBUFFERDATA)_getPrivateProcAddress(_name);
        if (!_glInvalidateBufferData_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glInvalidateBufferData_ptr(buffer);
}

typedef void (APIENTRY * PFN_GLINVALIDATEFRAMEBUFFER)(GLenum target, GLsizei numAttachments, const GLenum * attachments);
static PFN_GLINVALIDATEFRAMEBUFFER _glInvalidateFramebuffer_ptr = NULL;

static inline void APIENTRY _glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments) {
    const char *_name = "glInvalidateFramebuffer";
    if (!_glInvalidateFramebuffer_ptr) {
        _glInvalidateFramebuffer_ptr = (PFN_GLINVALIDATEFRAMEBUFFER)_getPrivateProcAddress(_name);
        if (!_glInvalidateFramebuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glInvalidateFramebuffer_ptr(target, numAttachments, attachments);
}

typedef void (APIENTRY * PFN_GLINVALIDATESUBFRAMEBUFFER)(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLINVALIDATESUBFRAMEBUFFER _glInvalidateSubFramebuffer_ptr = NULL;

static inline void APIENTRY _glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glInvalidateSubFramebuffer";
    if (!_glInvalidateSubFramebuffer_ptr) {
        _glInvalidateSubFramebuffer_ptr = (PFN_GLINVALIDATESUBFRAMEBUFFER)_getPrivateProcAddress(_name);
        if (!_glInvalidateSubFramebuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glInvalidateSubFramebuffer_ptr(target, numAttachments, attachments, x, y, width, height);
}

typedef void (APIENTRY * PFN_GLMULTIDRAWARRAYSINDIRECT)(GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride);
static PFN_GLMULTIDRAWARRAYSINDIRECT _glMultiDrawArraysIndirect_ptr = NULL;

static inline void APIENTRY _glMultiDrawArraysIndirect(GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride) {
    const char *_name = "glMultiDrawArraysIndirect";
    if (!_glMultiDrawArraysIndirect_ptr) {
        _glMultiDrawArraysIndirect_ptr = (PFN_GLMULTIDRAWARRAYSINDIRECT)_getPrivateProcAddress(_name);
        if (!_glMultiDrawArraysIndirect_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiDrawArraysIndirect_ptr(mode, indirect, drawcount, stride);
}

typedef void (APIENTRY * PFN_GLMULTIDRAWELEMENTSINDIRECT)(GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride);
static PFN_GLMULTIDRAWELEMENTSINDIRECT _glMultiDrawElementsIndirect_ptr = NULL;

static inline void APIENTRY _glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride) {
    const char *_name = "glMultiDrawElementsIndirect";
    if (!_glMultiDrawElementsIndirect_ptr) {
        _glMultiDrawElementsIndirect_ptr = (PFN_GLMULTIDRAWELEMENTSINDIRECT)_getPrivateProcAddress(_name);
        if (!_glMultiDrawElementsIndirect_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiDrawElementsIndirect_ptr(mode, type, indirect, drawcount, stride);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMINTERFACEIV)(GLuint program, GLenum programInterface, GLenum pname, GLint * params);
static PFN_GLGETPROGRAMINTERFACEIV _glGetProgramInterfaceiv_ptr = NULL;

static inline void APIENTRY _glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint * params) {
    const char *_name = "glGetProgramInterfaceiv";
    if (!_glGetProgramInterfaceiv_ptr) {
        _glGetProgramInterfaceiv_ptr = (PFN_GLGETPROGRAMINTERFACEIV)_getPrivateProcAddress(_name);
        if (!_glGetProgramInterfaceiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramInterfaceiv_ptr(program, programInterface, pname, params);
}

typedef GLuint (APIENTRY * PFN_GLGETPROGRAMRESOURCEINDEX)(GLuint program, GLenum programInterface, const GLchar * name);
static PFN_GLGETPROGRAMRESOURCEINDEX _glGetProgramResourceIndex_ptr = NULL;

static inline GLuint APIENTRY _glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar * name) {
    const char *_name = "glGetProgramResourceIndex";
    if (!_glGetProgramResourceIndex_ptr) {
        _glGetProgramResourceIndex_ptr = (PFN_GLGETPROGRAMRESOURCEINDEX)_getPrivateProcAddress(_name);
        if (!_glGetProgramResourceIndex_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetProgramResourceIndex_ptr(program, programInterface, name);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMRESOURCENAME)(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
static PFN_GLGETPROGRAMRESOURCENAME _glGetProgramResourceName_ptr = NULL;

static inline void APIENTRY _glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name) {
    const char *_name = "glGetProgramResourceName";
    if (!_glGetProgramResourceName_ptr) {
        _glGetProgramResourceName_ptr = (PFN_GLGETPROGRAMRESOURCENAME)_getPrivateProcAddress(_name);
        if (!_glGetProgramResourceName_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramResourceName_ptr(program, programInterface, index, bufSize, length, name);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMRESOURCEIV)(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params);
static PFN_GLGETPROGRAMRESOURCEIV _glGetProgramResourceiv_ptr = NULL;

static inline void APIENTRY _glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params) {
    const char *_name = "glGetProgramResourceiv";
    if (!_glGetProgramResourceiv_ptr) {
        _glGetProgramResourceiv_ptr = (PFN_GLGETPROGRAMRESOURCEIV)_getPrivateProcAddress(_name);
        if (!_glGetProgramResourceiv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramResourceiv_ptr(program, programInterface, index, propCount, props, bufSize, length, params);
}

typedef GLint (APIENTRY * PFN_GLGETPROGRAMRESOURCELOCATION)(GLuint program, GLenum programInterface, const GLchar * name);
static PFN_GLGETPROGRAMRESOURCELOCATION _glGetProgramResourceLocation_ptr = NULL;

static inline GLint APIENTRY _glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar * name) {
    const char *_name = "glGetProgramResourceLocation";
    if (!_glGetProgramResourceLocation_ptr) {
        _glGetProgramResourceLocation_ptr = (PFN_GLGETPROGRAMRESOURCELOCATION)_getPrivateProcAddress(_name);
        if (!_glGetProgramResourceLocation_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetProgramResourceLocation_ptr(program, programInterface, name);
}

typedef GLint (APIENTRY * PFN_GLGETPROGRAMRESOURCELOCATIONINDEX)(GLuint program, GLenum programInterface, const GLchar * name);
static PFN_GLGETPROGRAMRESOURCELOCATIONINDEX _glGetProgramResourceLocationIndex_ptr = NULL;

static inline GLint APIENTRY _glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar * name) {
    const char *_name = "glGetProgramResourceLocationIndex";
    if (!_glGetProgramResourceLocationIndex_ptr) {
        _glGetProgramResourceLocationIndex_ptr = (PFN_GLGETPROGRAMRESOURCELOCATIONINDEX)_getPrivateProcAddress(_name);
        if (!_glGetProgramResourceLocationIndex_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetProgramResourceLocationIndex_ptr(program, programInterface, name);
}

typedef void (APIENTRY * PFN_GLSHADERSTORAGEBLOCKBINDING)(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
static PFN_GLSHADERSTORAGEBLOCKBINDING _glShaderStorageBlockBinding_ptr = NULL;

static inline void APIENTRY _glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding) {
    const char *_name = "glShaderStorageBlockBinding";
    if (!_glShaderStorageBlockBinding_ptr) {
        _glShaderStorageBlockBinding_ptr = (PFN_GLSHADERSTORAGEBLOCKBINDING)_getPrivateProcAddress(_name);
        if (!_glShaderStorageBlockBinding_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glShaderStorageBlockBinding_ptr(program, storageBlockIndex, storageBlockBinding);
}

typedef void (APIENTRY * PFN_GLTEXBUFFERRANGE)(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
static PFN_GLTEXBUFFERRANGE _glTexBufferRange_ptr = NULL;

static inline void APIENTRY _glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glTexBufferRange";
    if (!_glTexBufferRange_ptr) {
        _glTexBufferRange_ptr = (PFN_GLTEXBUFFERRANGE)_getPrivateProcAddress(_name);
        if (!_glTexBufferRange_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexBufferRange_ptr(target, internalformat, buffer, offset, size);
}

typedef void (APIENTRY * PFN_GLTEXTUREBUFFERRANGEEXT)(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
static PFN_GLTEXTUREBUFFERRANGEEXT _glTextureBufferRangeEXT_ptr = NULL;

static inline void APIENTRY _glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glTextureBufferRangeEXT";
    if (!_glTextureBufferRangeEXT_ptr) {
        _glTextureBufferRangeEXT_ptr = (PFN_GLTEXTUREBUFFERRANGEEXT)_getPrivateProcAddress(_name);
        if (!_glTextureBufferRangeEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureBufferRangeEXT_ptr(texture, target, internalformat, buffer, offset, size);
}

typedef void (APIENTRY * PFN_GLTEXSTORAGE2DMULTISAMPLE)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
static PFN_GLTEXSTORAGE2DMULTISAMPLE _glTexStorage2DMultisample_ptr = NULL;

static inline void APIENTRY _glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
    const char *_name = "glTexStorage2DMultisample";
    if (!_glTexStorage2DMultisample_ptr) {
        _glTexStorage2DMultisample_ptr = (PFN_GLTEXSTORAGE2DMULTISAMPLE)_getPrivateProcAddress(_name);
        if (!_glTexStorage2DMultisample_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexStorage2DMultisample_ptr(target, samples, internalformat, width, height, fixedsamplelocations);
}

typedef void (APIENTRY * PFN_GLTEXSTORAGE3DMULTISAMPLE)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
static PFN_GLTEXSTORAGE3DMULTISAMPLE _glTexStorage3DMultisample_ptr = NULL;

static inline void APIENTRY _glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
    const char *_name = "glTexStorage3DMultisample";
    if (!_glTexStorage3DMultisample_ptr) {
        _glTexStorage3DMultisample_ptr = (PFN_GLTEXSTORAGE3DMULTISAMPLE)_getPrivateProcAddress(_name);
        if (!_glTexStorage3DMultisample_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexStorage3DMultisample_ptr(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

typedef void (APIENTRY * PFN_GLTEXTURESTORAGE2DMULTISAMPLEEXT)(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
static PFN_GLTEXTURESTORAGE2DMULTISAMPLEEXT _glTextureStorage2DMultisampleEXT_ptr = NULL;

static inline void APIENTRY _glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
    const char *_name = "glTextureStorage2DMultisampleEXT";
    if (!_glTextureStorage2DMultisampleEXT_ptr) {
        _glTextureStorage2DMultisampleEXT_ptr = (PFN_GLTEXTURESTORAGE2DMULTISAMPLEEXT)_getPrivateProcAddress(_name);
        if (!_glTextureStorage2DMultisampleEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureStorage2DMultisampleEXT_ptr(texture, target, samples, internalformat, width, height, fixedsamplelocations);
}

typedef void (APIENTRY * PFN_GLTEXTURESTORAGE3DMULTISAMPLEEXT)(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
static PFN_GLTEXTURESTORAGE3DMULTISAMPLEEXT _glTextureStorage3DMultisampleEXT_ptr = NULL;

static inline void APIENTRY _glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
    const char *_name = "glTextureStorage3DMultisampleEXT";
    if (!_glTextureStorage3DMultisampleEXT_ptr) {
        _glTextureStorage3DMultisampleEXT_ptr = (PFN_GLTEXTURESTORAGE3DMULTISAMPLEEXT)_getPrivateProcAddress(_name);
        if (!_glTextureStorage3DMultisampleEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureStorage3DMultisampleEXT_ptr(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

typedef void (APIENTRY * PFN_GLTEXTUREVIEW)(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
static PFN_GLTEXTUREVIEW _glTextureView_ptr = NULL;

static inline void APIENTRY _glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) {
    const char *_name = "glTextureView";
    if (!_glTextureView_ptr) {
        _glTextureView_ptr = (PFN_GLTEXTUREVIEW)_getPrivateProcAddress(_name);
        if (!_glTextureView_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureView_ptr(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
}

typedef void (APIENTRY * PFN_GLBINDVERTEXBUFFER)(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
static PFN_GLBINDVERTEXBUFFER _glBindVertexBuffer_ptr = NULL;

static inline void APIENTRY _glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) {
    const char *_name = "glBindVertexBuffer";
    if (!_glBindVertexBuffer_ptr) {
        _glBindVertexBuffer_ptr = (PFN_GLBINDVERTEXBUFFER)_getPrivateProcAddress(_name);
        if (!_glBindVertexBuffer_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindVertexBuffer_ptr(bindingindex, buffer, offset, stride);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBFORMAT)(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
static PFN_GLVERTEXATTRIBFORMAT _glVertexAttribFormat_ptr = NULL;

static inline void APIENTRY _glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) {
    const char *_name = "glVertexAttribFormat";
    if (!_glVertexAttribFormat_ptr) {
        _glVertexAttribFormat_ptr = (PFN_GLVERTEXATTRIBFORMAT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribFormat_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribFormat_ptr(attribindex, size, type, normalized, relativeoffset);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBIFORMAT)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
static PFN_GLVERTEXATTRIBIFORMAT _glVertexAttribIFormat_ptr = NULL;

static inline void APIENTRY _glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    const char *_name = "glVertexAttribIFormat";
    if (!_glVertexAttribIFormat_ptr) {
        _glVertexAttribIFormat_ptr = (PFN_GLVERTEXATTRIBIFORMAT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribIFormat_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribIFormat_ptr(attribindex, size, type, relativeoffset);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBLFORMAT)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
static PFN_GLVERTEXATTRIBLFORMAT _glVertexAttribLFormat_ptr = NULL;

static inline void APIENTRY _glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    const char *_name = "glVertexAttribLFormat";
    if (!_glVertexAttribLFormat_ptr) {
        _glVertexAttribLFormat_ptr = (PFN_GLVERTEXATTRIBLFORMAT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribLFormat_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribLFormat_ptr(attribindex, size, type, relativeoffset);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBBINDING)(GLuint attribindex, GLuint bindingindex);
static PFN_GLVERTEXATTRIBBINDING _glVertexAttribBinding_ptr = NULL;

static inline void APIENTRY _glVertexAttribBinding(GLuint attribindex, GLuint bindingindex) {
    const char *_name = "glVertexAttribBinding";
    if (!_glVertexAttribBinding_ptr) {
        _glVertexAttribBinding_ptr = (PFN_GLVERTEXATTRIBBINDING)_getPrivateProcAddress(_name);
        if (!_glVertexAttribBinding_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribBinding_ptr(attribindex, bindingindex);
}

typedef void (APIENTRY * PFN_GLVERTEXBINDINGDIVISOR)(GLuint bindingindex, GLuint divisor);
static PFN_GLVERTEXBINDINGDIVISOR _glVertexBindingDivisor_ptr = NULL;

static inline void APIENTRY _glVertexBindingDivisor(GLuint bindingindex, GLuint divisor) {
    const char *_name = "glVertexBindingDivisor";
    if (!_glVertexBindingDivisor_ptr) {
        _glVertexBindingDivisor_ptr = (PFN_GLVERTEXBINDINGDIVISOR)_getPrivateProcAddress(_name);
        if (!_glVertexBindingDivisor_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexBindingDivisor_ptr(bindingindex, divisor);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYBINDVERTEXBUFFEREXT)(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
static PFN_GLVERTEXARRAYBINDVERTEXBUFFEREXT _glVertexArrayBindVertexBufferEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayBindVertexBufferEXT(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) {
    const char *_name = "glVertexArrayBindVertexBufferEXT";
    if (!_glVertexArrayBindVertexBufferEXT_ptr) {
        _glVertexArrayBindVertexBufferEXT_ptr = (PFN_GLVERTEXARRAYBINDVERTEXBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayBindVertexBufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayBindVertexBufferEXT_ptr(vaobj, bindingindex, buffer, offset, stride);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYVERTEXATTRIBFORMATEXT)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
static PFN_GLVERTEXARRAYVERTEXATTRIBFORMATEXT _glVertexArrayVertexAttribFormatEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayVertexAttribFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) {
    const char *_name = "glVertexArrayVertexAttribFormatEXT";
    if (!_glVertexArrayVertexAttribFormatEXT_ptr) {
        _glVertexArrayVertexAttribFormatEXT_ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBFORMATEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayVertexAttribFormatEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayVertexAttribFormatEXT_ptr(vaobj, attribindex, size, type, normalized, relativeoffset);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYVERTEXATTRIBIFORMATEXT)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
static PFN_GLVERTEXARRAYVERTEXATTRIBIFORMATEXT _glVertexArrayVertexAttribIFormatEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayVertexAttribIFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    const char *_name = "glVertexArrayVertexAttribIFormatEXT";
    if (!_glVertexArrayVertexAttribIFormatEXT_ptr) {
        _glVertexArrayVertexAttribIFormatEXT_ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBIFORMATEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayVertexAttribIFormatEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayVertexAttribIFormatEXT_ptr(vaobj, attribindex, size, type, relativeoffset);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYVERTEXATTRIBLFORMATEXT)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
static PFN_GLVERTEXARRAYVERTEXATTRIBLFORMATEXT _glVertexArrayVertexAttribLFormatEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayVertexAttribLFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    const char *_name = "glVertexArrayVertexAttribLFormatEXT";
    if (!_glVertexArrayVertexAttribLFormatEXT_ptr) {
        _glVertexArrayVertexAttribLFormatEXT_ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBLFORMATEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayVertexAttribLFormatEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayVertexAttribLFormatEXT_ptr(vaobj, attribindex, size, type, relativeoffset);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYVERTEXATTRIBBINDINGEXT)(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
static PFN_GLVERTEXARRAYVERTEXATTRIBBINDINGEXT _glVertexArrayVertexAttribBindingEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayVertexAttribBindingEXT(GLuint vaobj, GLuint attribindex, GLuint bindingindex) {
    const char *_name = "glVertexArrayVertexAttribBindingEXT";
    if (!_glVertexArrayVertexAttribBindingEXT_ptr) {
        _glVertexArrayVertexAttribBindingEXT_ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBBINDINGEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayVertexAttribBindingEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayVertexAttribBindingEXT_ptr(vaobj, attribindex, bindingindex);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYVERTEXBINDINGDIVISOREXT)(GLuint vaobj, GLuint bindingindex, GLuint divisor);
static PFN_GLVERTEXARRAYVERTEXBINDINGDIVISOREXT _glVertexArrayVertexBindingDivisorEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayVertexBindingDivisorEXT(GLuint vaobj, GLuint bindingindex, GLuint divisor) {
    const char *_name = "glVertexArrayVertexBindingDivisorEXT";
    if (!_glVertexArrayVertexBindingDivisorEXT_ptr) {
        _glVertexArrayVertexBindingDivisorEXT_ptr = (PFN_GLVERTEXARRAYVERTEXBINDINGDIVISOREXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayVertexBindingDivisorEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayVertexBindingDivisorEXT_ptr(vaobj, bindingindex, divisor);
}

typedef void (APIENTRY * PFN_GLBLENDCOLOREXT)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
static PFN_GLBLENDCOLOREXT _glBlendColorEXT_ptr = NULL;

static inline void APIENTRY _glBlendColorEXT(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    const char *_name = "glBlendColorEXT";
    if (!_glBlendColorEXT_ptr) {
        _glBlendColorEXT_ptr = (PFN_GLBLENDCOLOREXT)_getPrivateProcAddress(_name);
        if (!_glBlendColorEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendColorEXT_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLPOLYGONOFFSETEXT)(GLfloat factor, GLfloat bias);
static PFN_GLPOLYGONOFFSETEXT _glPolygonOffsetEXT_ptr = NULL;

static inline void APIENTRY _glPolygonOffsetEXT(GLfloat factor, GLfloat bias) {
    const char *_name = "glPolygonOffsetEXT";
    if (!_glPolygonOffsetEXT_ptr) {
        _glPolygonOffsetEXT_ptr = (PFN_GLPOLYGONOFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glPolygonOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPolygonOffsetEXT_ptr(factor, bias);
}

typedef void (APIENTRY * PFN_GLTEXIMAGE3DEXT)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXIMAGE3DEXT _glTexImage3DEXT_ptr = NULL;

static inline void APIENTRY _glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexImage3DEXT";
    if (!_glTexImage3DEXT_ptr) {
        _glTexImage3DEXT_ptr = (PFN_GLTEXIMAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glTexImage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexImage3DEXT_ptr(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLTEXSUBIMAGE3DEXT)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXSUBIMAGE3DEXT _glTexSubImage3DEXT_ptr = NULL;

static inline void APIENTRY _glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage3DEXT";
    if (!_glTexSubImage3DEXT_ptr) {
        _glTexSubImage3DEXT_ptr = (PFN_GLTEXSUBIMAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glTexSubImage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexSubImage3DEXT_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLGETTEXFILTERFUNCSGIS)(GLenum target, GLenum filter, GLfloat * weights);
static PFN_GLGETTEXFILTERFUNCSGIS _glGetTexFilterFuncSGIS_ptr = NULL;

static inline void APIENTRY _glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat * weights) {
    const char *_name = "glGetTexFilterFuncSGIS";
    if (!_glGetTexFilterFuncSGIS_ptr) {
        _glGetTexFilterFuncSGIS_ptr = (PFN_GLGETTEXFILTERFUNCSGIS)_getPrivateProcAddress(_name);
        if (!_glGetTexFilterFuncSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexFilterFuncSGIS_ptr(target, filter, weights);
}

typedef void (APIENTRY * PFN_GLTEXFILTERFUNCSGIS)(GLenum target, GLenum filter, GLsizei n, const GLfloat * weights);
static PFN_GLTEXFILTERFUNCSGIS _glTexFilterFuncSGIS_ptr = NULL;

static inline void APIENTRY _glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat * weights) {
    const char *_name = "glTexFilterFuncSGIS";
    if (!_glTexFilterFuncSGIS_ptr) {
        _glTexFilterFuncSGIS_ptr = (PFN_GLTEXFILTERFUNCSGIS)_getPrivateProcAddress(_name);
        if (!_glTexFilterFuncSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexFilterFuncSGIS_ptr(target, filter, n, weights);
}

typedef void (APIENTRY * PFN_GLTEXSUBIMAGE1DEXT)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXSUBIMAGE1DEXT _glTexSubImage1DEXT_ptr = NULL;

static inline void APIENTRY _glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage1DEXT";
    if (!_glTexSubImage1DEXT_ptr) {
        _glTexSubImage1DEXT_ptr = (PFN_GLTEXSUBIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glTexSubImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexSubImage1DEXT_ptr(target, level, xoffset, width, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLTEXSUBIMAGE2DEXT)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXSUBIMAGE2DEXT _glTexSubImage2DEXT_ptr = NULL;

static inline void APIENTRY _glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage2DEXT";
    if (!_glTexSubImage2DEXT_ptr) {
        _glTexSubImage2DEXT_ptr = (PFN_GLTEXSUBIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glTexSubImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexSubImage2DEXT_ptr(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLCOPYTEXIMAGE1DEXT)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
static PFN_GLCOPYTEXIMAGE1DEXT _glCopyTexImage1DEXT_ptr = NULL;

static inline void APIENTRY _glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    const char *_name = "glCopyTexImage1DEXT";
    if (!_glCopyTexImage1DEXT_ptr) {
        _glCopyTexImage1DEXT_ptr = (PFN_GLCOPYTEXIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyTexImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTexImage1DEXT_ptr(target, level, internalformat, x, y, width, border);
}

typedef void (APIENTRY * PFN_GLCOPYTEXIMAGE2DEXT)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
static PFN_GLCOPYTEXIMAGE2DEXT _glCopyTexImage2DEXT_ptr = NULL;

static inline void APIENTRY _glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    const char *_name = "glCopyTexImage2DEXT";
    if (!_glCopyTexImage2DEXT_ptr) {
        _glCopyTexImage2DEXT_ptr = (PFN_GLCOPYTEXIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyTexImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTexImage2DEXT_ptr(target, level, internalformat, x, y, width, height, border);
}

typedef void (APIENTRY * PFN_GLCOPYTEXSUBIMAGE1DEXT)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
static PFN_GLCOPYTEXSUBIMAGE1DEXT _glCopyTexSubImage1DEXT_ptr = NULL;

static inline void APIENTRY _glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyTexSubImage1DEXT";
    if (!_glCopyTexSubImage1DEXT_ptr) {
        _glCopyTexSubImage1DEXT_ptr = (PFN_GLCOPYTEXSUBIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyTexSubImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTexSubImage1DEXT_ptr(target, level, xoffset, x, y, width);
}

typedef void (APIENTRY * PFN_GLCOPYTEXSUBIMAGE2DEXT)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLCOPYTEXSUBIMAGE2DEXT _glCopyTexSubImage2DEXT_ptr = NULL;

static inline void APIENTRY _glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTexSubImage2DEXT";
    if (!_glCopyTexSubImage2DEXT_ptr) {
        _glCopyTexSubImage2DEXT_ptr = (PFN_GLCOPYTEXSUBIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyTexSubImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTexSubImage2DEXT_ptr(target, level, xoffset, yoffset, x, y, width, height);
}

typedef void (APIENTRY * PFN_GLCOPYTEXSUBIMAGE3DEXT)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLCOPYTEXSUBIMAGE3DEXT _glCopyTexSubImage3DEXT_ptr = NULL;

static inline void APIENTRY _glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTexSubImage3DEXT";
    if (!_glCopyTexSubImage3DEXT_ptr) {
        _glCopyTexSubImage3DEXT_ptr = (PFN_GLCOPYTEXSUBIMAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyTexSubImage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTexSubImage3DEXT_ptr(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

typedef void (APIENTRY * PFN_GLGETHISTOGRAMEXT)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values);
static PFN_GLGETHISTOGRAMEXT _glGetHistogramEXT_ptr = NULL;

static inline void APIENTRY _glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values) {
    const char *_name = "glGetHistogramEXT";
    if (!_glGetHistogramEXT_ptr) {
        _glGetHistogramEXT_ptr = (PFN_GLGETHISTOGRAMEXT)_getPrivateProcAddress(_name);
        if (!_glGetHistogramEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetHistogramEXT_ptr(target, reset, format, type, values);
}

typedef void (APIENTRY * PFN_GLGETHISTOGRAMPARAMETERFVEXT)(GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETHISTOGRAMPARAMETERFVEXT _glGetHistogramParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetHistogramParameterfvEXT";
    if (!_glGetHistogramParameterfvEXT_ptr) {
        _glGetHistogramParameterfvEXT_ptr = (PFN_GLGETHISTOGRAMPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glGetHistogramParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetHistogramParameterfvEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETHISTOGRAMPARAMETERIVEXT)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETHISTOGRAMPARAMETERIVEXT _glGetHistogramParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetHistogramParameterivEXT";
    if (!_glGetHistogramParameterivEXT_ptr) {
        _glGetHistogramParameterivEXT_ptr = (PFN_GLGETHISTOGRAMPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetHistogramParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetHistogramParameterivEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMINMAXEXT)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values);
static PFN_GLGETMINMAXEXT _glGetMinmaxEXT_ptr = NULL;

static inline void APIENTRY _glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values) {
    const char *_name = "glGetMinmaxEXT";
    if (!_glGetMinmaxEXT_ptr) {
        _glGetMinmaxEXT_ptr = (PFN_GLGETMINMAXEXT)_getPrivateProcAddress(_name);
        if (!_glGetMinmaxEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMinmaxEXT_ptr(target, reset, format, type, values);
}

typedef void (APIENTRY * PFN_GLGETMINMAXPARAMETERFVEXT)(GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETMINMAXPARAMETERFVEXT _glGetMinmaxParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMinmaxParameterfvEXT";
    if (!_glGetMinmaxParameterfvEXT_ptr) {
        _glGetMinmaxParameterfvEXT_ptr = (PFN_GLGETMINMAXPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glGetMinmaxParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMinmaxParameterfvEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMINMAXPARAMETERIVEXT)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETMINMAXPARAMETERIVEXT _glGetMinmaxParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetMinmaxParameterivEXT";
    if (!_glGetMinmaxParameterivEXT_ptr) {
        _glGetMinmaxParameterivEXT_ptr = (PFN_GLGETMINMAXPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetMinmaxParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMinmaxParameterivEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLHISTOGRAMEXT)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
static PFN_GLHISTOGRAMEXT _glHistogramEXT_ptr = NULL;

static inline void APIENTRY _glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {
    const char *_name = "glHistogramEXT";
    if (!_glHistogramEXT_ptr) {
        _glHistogramEXT_ptr = (PFN_GLHISTOGRAMEXT)_getPrivateProcAddress(_name);
        if (!_glHistogramEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glHistogramEXT_ptr(target, width, internalformat, sink);
}

typedef void (APIENTRY * PFN_GLMINMAXEXT)(GLenum target, GLenum internalformat, GLboolean sink);
static PFN_GLMINMAXEXT _glMinmaxEXT_ptr = NULL;

static inline void APIENTRY _glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink) {
    const char *_name = "glMinmaxEXT";
    if (!_glMinmaxEXT_ptr) {
        _glMinmaxEXT_ptr = (PFN_GLMINMAXEXT)_getPrivateProcAddress(_name);
        if (!_glMinmaxEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMinmaxEXT_ptr(target, internalformat, sink);
}

typedef void (APIENTRY * PFN_GLRESETHISTOGRAMEXT)(GLenum target);
static PFN_GLRESETHISTOGRAMEXT _glResetHistogramEXT_ptr = NULL;

static inline void APIENTRY _glResetHistogramEXT(GLenum target) {
    const char *_name = "glResetHistogramEXT";
    if (!_glResetHistogramEXT_ptr) {
        _glResetHistogramEXT_ptr = (PFN_GLRESETHISTOGRAMEXT)_getPrivateProcAddress(_name);
        if (!_glResetHistogramEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glResetHistogramEXT_ptr(target);
}

typedef void (APIENTRY * PFN_GLRESETMINMAXEXT)(GLenum target);
static PFN_GLRESETMINMAXEXT _glResetMinmaxEXT_ptr = NULL;

static inline void APIENTRY _glResetMinmaxEXT(GLenum target) {
    const char *_name = "glResetMinmaxEXT";
    if (!_glResetMinmaxEXT_ptr) {
        _glResetMinmaxEXT_ptr = (PFN_GLRESETMINMAXEXT)_getPrivateProcAddress(_name);
        if (!_glResetMinmaxEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glResetMinmaxEXT_ptr(target);
}

typedef void (APIENTRY * PFN_GLCONVOLUTIONFILTER1DEXT)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image);
static PFN_GLCONVOLUTIONFILTER1DEXT _glConvolutionFilter1DEXT_ptr = NULL;

static inline void APIENTRY _glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image) {
    const char *_name = "glConvolutionFilter1DEXT";
    if (!_glConvolutionFilter1DEXT_ptr) {
        _glConvolutionFilter1DEXT_ptr = (PFN_GLCONVOLUTIONFILTER1DEXT)_getPrivateProcAddress(_name);
        if (!_glConvolutionFilter1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glConvolutionFilter1DEXT_ptr(target, internalformat, width, format, type, image);
}

typedef void (APIENTRY * PFN_GLCONVOLUTIONFILTER2DEXT)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image);
static PFN_GLCONVOLUTIONFILTER2DEXT _glConvolutionFilter2DEXT_ptr = NULL;

static inline void APIENTRY _glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image) {
    const char *_name = "glConvolutionFilter2DEXT";
    if (!_glConvolutionFilter2DEXT_ptr) {
        _glConvolutionFilter2DEXT_ptr = (PFN_GLCONVOLUTIONFILTER2DEXT)_getPrivateProcAddress(_name);
        if (!_glConvolutionFilter2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glConvolutionFilter2DEXT_ptr(target, internalformat, width, height, format, type, image);
}

typedef void (APIENTRY * PFN_GLCONVOLUTIONPARAMETERFEXT)(GLenum target, GLenum pname, GLfloat params);
static PFN_GLCONVOLUTIONPARAMETERFEXT _glConvolutionParameterfEXT_ptr = NULL;

static inline void APIENTRY _glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params) {
    const char *_name = "glConvolutionParameterfEXT";
    if (!_glConvolutionParameterfEXT_ptr) {
        _glConvolutionParameterfEXT_ptr = (PFN_GLCONVOLUTIONPARAMETERFEXT)_getPrivateProcAddress(_name);
        if (!_glConvolutionParameterfEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glConvolutionParameterfEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCONVOLUTIONPARAMETERFVEXT)(GLenum target, GLenum pname, const GLfloat * params);
static PFN_GLCONVOLUTIONPARAMETERFVEXT _glConvolutionParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glConvolutionParameterfvEXT";
    if (!_glConvolutionParameterfvEXT_ptr) {
        _glConvolutionParameterfvEXT_ptr = (PFN_GLCONVOLUTIONPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glConvolutionParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glConvolutionParameterfvEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCONVOLUTIONPARAMETERIEXT)(GLenum target, GLenum pname, GLint params);
static PFN_GLCONVOLUTIONPARAMETERIEXT _glConvolutionParameteriEXT_ptr = NULL;

static inline void APIENTRY _glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params) {
    const char *_name = "glConvolutionParameteriEXT";
    if (!_glConvolutionParameteriEXT_ptr) {
        _glConvolutionParameteriEXT_ptr = (PFN_GLCONVOLUTIONPARAMETERIEXT)_getPrivateProcAddress(_name);
        if (!_glConvolutionParameteriEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glConvolutionParameteriEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCONVOLUTIONPARAMETERIVEXT)(GLenum target, GLenum pname, const GLint * params);
static PFN_GLCONVOLUTIONPARAMETERIVEXT _glConvolutionParameterivEXT_ptr = NULL;

static inline void APIENTRY _glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glConvolutionParameterivEXT";
    if (!_glConvolutionParameterivEXT_ptr) {
        _glConvolutionParameterivEXT_ptr = (PFN_GLCONVOLUTIONPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glConvolutionParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glConvolutionParameterivEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCOPYCONVOLUTIONFILTER1DEXT)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
static PFN_GLCOPYCONVOLUTIONFILTER1DEXT _glCopyConvolutionFilter1DEXT_ptr = NULL;

static inline void APIENTRY _glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyConvolutionFilter1DEXT";
    if (!_glCopyConvolutionFilter1DEXT_ptr) {
        _glCopyConvolutionFilter1DEXT_ptr = (PFN_GLCOPYCONVOLUTIONFILTER1DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyConvolutionFilter1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyConvolutionFilter1DEXT_ptr(target, internalformat, x, y, width);
}

typedef void (APIENTRY * PFN_GLCOPYCONVOLUTIONFILTER2DEXT)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLCOPYCONVOLUTIONFILTER2DEXT _glCopyConvolutionFilter2DEXT_ptr = NULL;

static inline void APIENTRY _glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyConvolutionFilter2DEXT";
    if (!_glCopyConvolutionFilter2DEXT_ptr) {
        _glCopyConvolutionFilter2DEXT_ptr = (PFN_GLCOPYCONVOLUTIONFILTER2DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyConvolutionFilter2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyConvolutionFilter2DEXT_ptr(target, internalformat, x, y, width, height);
}

typedef void (APIENTRY * PFN_GLGETCONVOLUTIONFILTEREXT)(GLenum target, GLenum format, GLenum type, GLvoid * image);
static PFN_GLGETCONVOLUTIONFILTEREXT _glGetConvolutionFilterEXT_ptr = NULL;

static inline void APIENTRY _glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid * image) {
    const char *_name = "glGetConvolutionFilterEXT";
    if (!_glGetConvolutionFilterEXT_ptr) {
        _glGetConvolutionFilterEXT_ptr = (PFN_GLGETCONVOLUTIONFILTEREXT)_getPrivateProcAddress(_name);
        if (!_glGetConvolutionFilterEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetConvolutionFilterEXT_ptr(target, format, type, image);
}

typedef void (APIENTRY * PFN_GLGETCONVOLUTIONPARAMETERFVEXT)(GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETCONVOLUTIONPARAMETERFVEXT _glGetConvolutionParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetConvolutionParameterfvEXT";
    if (!_glGetConvolutionParameterfvEXT_ptr) {
        _glGetConvolutionParameterfvEXT_ptr = (PFN_GLGETCONVOLUTIONPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glGetConvolutionParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetConvolutionParameterfvEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETCONVOLUTIONPARAMETERIVEXT)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETCONVOLUTIONPARAMETERIVEXT _glGetConvolutionParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetConvolutionParameterivEXT";
    if (!_glGetConvolutionParameterivEXT_ptr) {
        _glGetConvolutionParameterivEXT_ptr = (PFN_GLGETCONVOLUTIONPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetConvolutionParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetConvolutionParameterivEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETSEPARABLEFILTEREXT)(GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span);
static PFN_GLGETSEPARABLEFILTEREXT _glGetSeparableFilterEXT_ptr = NULL;

static inline void APIENTRY _glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span) {
    const char *_name = "glGetSeparableFilterEXT";
    if (!_glGetSeparableFilterEXT_ptr) {
        _glGetSeparableFilterEXT_ptr = (PFN_GLGETSEPARABLEFILTEREXT)_getPrivateProcAddress(_name);
        if (!_glGetSeparableFilterEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetSeparableFilterEXT_ptr(target, format, type, row, column, span);
}

typedef void (APIENTRY * PFN_GLSEPARABLEFILTER2DEXT)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column);
static PFN_GLSEPARABLEFILTER2DEXT _glSeparableFilter2DEXT_ptr = NULL;

static inline void APIENTRY _glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column) {
    const char *_name = "glSeparableFilter2DEXT";
    if (!_glSeparableFilter2DEXT_ptr) {
        _glSeparableFilter2DEXT_ptr = (PFN_GLSEPARABLEFILTER2DEXT)_getPrivateProcAddress(_name);
        if (!_glSeparableFilter2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSeparableFilter2DEXT_ptr(target, internalformat, width, height, format, type, row, column);
}

typedef void (APIENTRY * PFN_GLCOLORTABLESGI)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table);
static PFN_GLCOLORTABLESGI _glColorTableSGI_ptr = NULL;

static inline void APIENTRY _glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table) {
    const char *_name = "glColorTableSGI";
    if (!_glColorTableSGI_ptr) {
        _glColorTableSGI_ptr = (PFN_GLCOLORTABLESGI)_getPrivateProcAddress(_name);
        if (!_glColorTableSGI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorTableSGI_ptr(target, internalformat, width, format, type, table);
}

typedef void (APIENTRY * PFN_GLCOLORTABLEPARAMETERFVSGI)(GLenum target, GLenum pname, const GLfloat * params);
static PFN_GLCOLORTABLEPARAMETERFVSGI _glColorTableParameterfvSGI_ptr = NULL;

static inline void APIENTRY _glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glColorTableParameterfvSGI";
    if (!_glColorTableParameterfvSGI_ptr) {
        _glColorTableParameterfvSGI_ptr = (PFN_GLCOLORTABLEPARAMETERFVSGI)_getPrivateProcAddress(_name);
        if (!_glColorTableParameterfvSGI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorTableParameterfvSGI_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCOLORTABLEPARAMETERIVSGI)(GLenum target, GLenum pname, const GLint * params);
static PFN_GLCOLORTABLEPARAMETERIVSGI _glColorTableParameterivSGI_ptr = NULL;

static inline void APIENTRY _glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glColorTableParameterivSGI";
    if (!_glColorTableParameterivSGI_ptr) {
        _glColorTableParameterivSGI_ptr = (PFN_GLCOLORTABLEPARAMETERIVSGI)_getPrivateProcAddress(_name);
        if (!_glColorTableParameterivSGI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorTableParameterivSGI_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCOPYCOLORTABLESGI)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
static PFN_GLCOPYCOLORTABLESGI _glCopyColorTableSGI_ptr = NULL;

static inline void APIENTRY _glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyColorTableSGI";
    if (!_glCopyColorTableSGI_ptr) {
        _glCopyColorTableSGI_ptr = (PFN_GLCOPYCOLORTABLESGI)_getPrivateProcAddress(_name);
        if (!_glCopyColorTableSGI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyColorTableSGI_ptr(target, internalformat, x, y, width);
}

typedef void (APIENTRY * PFN_GLGETCOLORTABLESGI)(GLenum target, GLenum format, GLenum type, GLvoid * table);
static PFN_GLGETCOLORTABLESGI _glGetColorTableSGI_ptr = NULL;

static inline void APIENTRY _glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid * table) {
    const char *_name = "glGetColorTableSGI";
    if (!_glGetColorTableSGI_ptr) {
        _glGetColorTableSGI_ptr = (PFN_GLGETCOLORTABLESGI)_getPrivateProcAddress(_name);
        if (!_glGetColorTableSGI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetColorTableSGI_ptr(target, format, type, table);
}

typedef void (APIENTRY * PFN_GLGETCOLORTABLEPARAMETERFVSGI)(GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETCOLORTABLEPARAMETERFVSGI _glGetColorTableParameterfvSGI_ptr = NULL;

static inline void APIENTRY _glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetColorTableParameterfvSGI";
    if (!_glGetColorTableParameterfvSGI_ptr) {
        _glGetColorTableParameterfvSGI_ptr = (PFN_GLGETCOLORTABLEPARAMETERFVSGI)_getPrivateProcAddress(_name);
        if (!_glGetColorTableParameterfvSGI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetColorTableParameterfvSGI_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETCOLORTABLEPARAMETERIVSGI)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETCOLORTABLEPARAMETERIVSGI _glGetColorTableParameterivSGI_ptr = NULL;

static inline void APIENTRY _glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetColorTableParameterivSGI";
    if (!_glGetColorTableParameterivSGI_ptr) {
        _glGetColorTableParameterivSGI_ptr = (PFN_GLGETCOLORTABLEPARAMETERIVSGI)_getPrivateProcAddress(_name);
        if (!_glGetColorTableParameterivSGI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetColorTableParameterivSGI_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLPIXELTEXGENSGIX)(GLenum mode);
static PFN_GLPIXELTEXGENSGIX _glPixelTexGenSGIX_ptr = NULL;

static inline void APIENTRY _glPixelTexGenSGIX(GLenum mode) {
    const char *_name = "glPixelTexGenSGIX";
    if (!_glPixelTexGenSGIX_ptr) {
        _glPixelTexGenSGIX_ptr = (PFN_GLPIXELTEXGENSGIX)_getPrivateProcAddress(_name);
        if (!_glPixelTexGenSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelTexGenSGIX_ptr(mode);
}

typedef void (APIENTRY * PFN_GLPIXELTEXGENPARAMETERISGIS)(GLenum pname, GLint param);
static PFN_GLPIXELTEXGENPARAMETERISGIS _glPixelTexGenParameteriSGIS_ptr = NULL;

static inline void APIENTRY _glPixelTexGenParameteriSGIS(GLenum pname, GLint param) {
    const char *_name = "glPixelTexGenParameteriSGIS";
    if (!_glPixelTexGenParameteriSGIS_ptr) {
        _glPixelTexGenParameteriSGIS_ptr = (PFN_GLPIXELTEXGENPARAMETERISGIS)_getPrivateProcAddress(_name);
        if (!_glPixelTexGenParameteriSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelTexGenParameteriSGIS_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLPIXELTEXGENPARAMETERIVSGIS)(GLenum pname, const GLint * params);
static PFN_GLPIXELTEXGENPARAMETERIVSGIS _glPixelTexGenParameterivSGIS_ptr = NULL;

static inline void APIENTRY _glPixelTexGenParameterivSGIS(GLenum pname, const GLint * params) {
    const char *_name = "glPixelTexGenParameterivSGIS";
    if (!_glPixelTexGenParameterivSGIS_ptr) {
        _glPixelTexGenParameterivSGIS_ptr = (PFN_GLPIXELTEXGENPARAMETERIVSGIS)_getPrivateProcAddress(_name);
        if (!_glPixelTexGenParameterivSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelTexGenParameterivSGIS_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLPIXELTEXGENPARAMETERFSGIS)(GLenum pname, GLfloat param);
static PFN_GLPIXELTEXGENPARAMETERFSGIS _glPixelTexGenParameterfSGIS_ptr = NULL;

static inline void APIENTRY _glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param) {
    const char *_name = "glPixelTexGenParameterfSGIS";
    if (!_glPixelTexGenParameterfSGIS_ptr) {
        _glPixelTexGenParameterfSGIS_ptr = (PFN_GLPIXELTEXGENPARAMETERFSGIS)_getPrivateProcAddress(_name);
        if (!_glPixelTexGenParameterfSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelTexGenParameterfSGIS_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLPIXELTEXGENPARAMETERFVSGIS)(GLenum pname, const GLfloat * params);
static PFN_GLPIXELTEXGENPARAMETERFVSGIS _glPixelTexGenParameterfvSGIS_ptr = NULL;

static inline void APIENTRY _glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat * params) {
    const char *_name = "glPixelTexGenParameterfvSGIS";
    if (!_glPixelTexGenParameterfvSGIS_ptr) {
        _glPixelTexGenParameterfvSGIS_ptr = (PFN_GLPIXELTEXGENPARAMETERFVSGIS)_getPrivateProcAddress(_name);
        if (!_glPixelTexGenParameterfvSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelTexGenParameterfvSGIS_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLGETPIXELTEXGENPARAMETERIVSGIS)(GLenum pname, GLint * params);
static PFN_GLGETPIXELTEXGENPARAMETERIVSGIS _glGetPixelTexGenParameterivSGIS_ptr = NULL;

static inline void APIENTRY _glGetPixelTexGenParameterivSGIS(GLenum pname, GLint * params) {
    const char *_name = "glGetPixelTexGenParameterivSGIS";
    if (!_glGetPixelTexGenParameterivSGIS_ptr) {
        _glGetPixelTexGenParameterivSGIS_ptr = (PFN_GLGETPIXELTEXGENPARAMETERIVSGIS)_getPrivateProcAddress(_name);
        if (!_glGetPixelTexGenParameterivSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPixelTexGenParameterivSGIS_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLGETPIXELTEXGENPARAMETERFVSGIS)(GLenum pname, GLfloat * params);
static PFN_GLGETPIXELTEXGENPARAMETERFVSGIS _glGetPixelTexGenParameterfvSGIS_ptr = NULL;

static inline void APIENTRY _glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat * params) {
    const char *_name = "glGetPixelTexGenParameterfvSGIS";
    if (!_glGetPixelTexGenParameterfvSGIS_ptr) {
        _glGetPixelTexGenParameterfvSGIS_ptr = (PFN_GLGETPIXELTEXGENPARAMETERFVSGIS)_getPrivateProcAddress(_name);
        if (!_glGetPixelTexGenParameterfvSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPixelTexGenParameterfvSGIS_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLTEXIMAGE4DSGIS)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXIMAGE4DSGIS _glTexImage4DSGIS_ptr = NULL;

static inline void APIENTRY _glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexImage4DSGIS";
    if (!_glTexImage4DSGIS_ptr) {
        _glTexImage4DSGIS_ptr = (PFN_GLTEXIMAGE4DSGIS)_getPrivateProcAddress(_name);
        if (!_glTexImage4DSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexImage4DSGIS_ptr(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLTEXSUBIMAGE4DSGIS)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXSUBIMAGE4DSGIS _glTexSubImage4DSGIS_ptr = NULL;

static inline void APIENTRY _glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage4DSGIS";
    if (!_glTexSubImage4DSGIS_ptr) {
        _glTexSubImage4DSGIS_ptr = (PFN_GLTEXSUBIMAGE4DSGIS)_getPrivateProcAddress(_name);
        if (!_glTexSubImage4DSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexSubImage4DSGIS_ptr(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
}

typedef GLboolean (APIENTRY * PFN_GLARETEXTURESRESIDENTEXT)(GLsizei n, const GLuint * textures, GLboolean * residences);
static PFN_GLARETEXTURESRESIDENTEXT _glAreTexturesResidentEXT_ptr = NULL;

static inline GLboolean APIENTRY _glAreTexturesResidentEXT(GLsizei n, const GLuint * textures, GLboolean * residences) {
    const char *_name = "glAreTexturesResidentEXT";
    if (!_glAreTexturesResidentEXT_ptr) {
        _glAreTexturesResidentEXT_ptr = (PFN_GLARETEXTURESRESIDENTEXT)_getPrivateProcAddress(_name);
        if (!_glAreTexturesResidentEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glAreTexturesResidentEXT_ptr(n, textures, residences);
}

typedef void (APIENTRY * PFN_GLBINDTEXTUREEXT)(GLenum target, GLuint texture);
static PFN_GLBINDTEXTUREEXT _glBindTextureEXT_ptr = NULL;

static inline void APIENTRY _glBindTextureEXT(GLenum target, GLuint texture) {
    const char *_name = "glBindTextureEXT";
    if (!_glBindTextureEXT_ptr) {
        _glBindTextureEXT_ptr = (PFN_GLBINDTEXTUREEXT)_getPrivateProcAddress(_name);
        if (!_glBindTextureEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindTextureEXT_ptr(target, texture);
}

typedef void (APIENTRY * PFN_GLDELETETEXTURESEXT)(GLsizei n, const GLuint * textures);
static PFN_GLDELETETEXTURESEXT _glDeleteTexturesEXT_ptr = NULL;

static inline void APIENTRY _glDeleteTexturesEXT(GLsizei n, const GLuint * textures) {
    const char *_name = "glDeleteTexturesEXT";
    if (!_glDeleteTexturesEXT_ptr) {
        _glDeleteTexturesEXT_ptr = (PFN_GLDELETETEXTURESEXT)_getPrivateProcAddress(_name);
        if (!_glDeleteTexturesEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteTexturesEXT_ptr(n, textures);
}

typedef void (APIENTRY * PFN_GLGENTEXTURESEXT)(GLsizei n, GLuint * textures);
static PFN_GLGENTEXTURESEXT _glGenTexturesEXT_ptr = NULL;

static inline void APIENTRY _glGenTexturesEXT(GLsizei n, GLuint * textures) {
    const char *_name = "glGenTexturesEXT";
    if (!_glGenTexturesEXT_ptr) {
        _glGenTexturesEXT_ptr = (PFN_GLGENTEXTURESEXT)_getPrivateProcAddress(_name);
        if (!_glGenTexturesEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenTexturesEXT_ptr(n, textures);
}

typedef GLboolean (APIENTRY * PFN_GLISTEXTUREEXT)(GLuint texture);
static PFN_GLISTEXTUREEXT _glIsTextureEXT_ptr = NULL;

static inline GLboolean APIENTRY _glIsTextureEXT(GLuint texture) {
    const char *_name = "glIsTextureEXT";
    if (!_glIsTextureEXT_ptr) {
        _glIsTextureEXT_ptr = (PFN_GLISTEXTUREEXT)_getPrivateProcAddress(_name);
        if (!_glIsTextureEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsTextureEXT_ptr(texture);
}

typedef void (APIENTRY * PFN_GLPRIORITIZETEXTURESEXT)(GLsizei n, const GLuint * textures, const GLclampf * priorities);
static PFN_GLPRIORITIZETEXTURESEXT _glPrioritizeTexturesEXT_ptr = NULL;

static inline void APIENTRY _glPrioritizeTexturesEXT(GLsizei n, const GLuint * textures, const GLclampf * priorities) {
    const char *_name = "glPrioritizeTexturesEXT";
    if (!_glPrioritizeTexturesEXT_ptr) {
        _glPrioritizeTexturesEXT_ptr = (PFN_GLPRIORITIZETEXTURESEXT)_getPrivateProcAddress(_name);
        if (!_glPrioritizeTexturesEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPrioritizeTexturesEXT_ptr(n, textures, priorities);
}

typedef void (APIENTRY * PFN_GLDETAILTEXFUNCSGIS)(GLenum target, GLsizei n, const GLfloat * points);
static PFN_GLDETAILTEXFUNCSGIS _glDetailTexFuncSGIS_ptr = NULL;

static inline void APIENTRY _glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat * points) {
    const char *_name = "glDetailTexFuncSGIS";
    if (!_glDetailTexFuncSGIS_ptr) {
        _glDetailTexFuncSGIS_ptr = (PFN_GLDETAILTEXFUNCSGIS)_getPrivateProcAddress(_name);
        if (!_glDetailTexFuncSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDetailTexFuncSGIS_ptr(target, n, points);
}

typedef void (APIENTRY * PFN_GLGETDETAILTEXFUNCSGIS)(GLenum target, GLfloat * points);
static PFN_GLGETDETAILTEXFUNCSGIS _glGetDetailTexFuncSGIS_ptr = NULL;

static inline void APIENTRY _glGetDetailTexFuncSGIS(GLenum target, GLfloat * points) {
    const char *_name = "glGetDetailTexFuncSGIS";
    if (!_glGetDetailTexFuncSGIS_ptr) {
        _glGetDetailTexFuncSGIS_ptr = (PFN_GLGETDETAILTEXFUNCSGIS)_getPrivateProcAddress(_name);
        if (!_glGetDetailTexFuncSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetDetailTexFuncSGIS_ptr(target, points);
}

typedef void (APIENTRY * PFN_GLSHARPENTEXFUNCSGIS)(GLenum target, GLsizei n, const GLfloat * points);
static PFN_GLSHARPENTEXFUNCSGIS _glSharpenTexFuncSGIS_ptr = NULL;

static inline void APIENTRY _glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat * points) {
    const char *_name = "glSharpenTexFuncSGIS";
    if (!_glSharpenTexFuncSGIS_ptr) {
        _glSharpenTexFuncSGIS_ptr = (PFN_GLSHARPENTEXFUNCSGIS)_getPrivateProcAddress(_name);
        if (!_glSharpenTexFuncSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSharpenTexFuncSGIS_ptr(target, n, points);
}

typedef void (APIENTRY * PFN_GLGETSHARPENTEXFUNCSGIS)(GLenum target, GLfloat * points);
static PFN_GLGETSHARPENTEXFUNCSGIS _glGetSharpenTexFuncSGIS_ptr = NULL;

static inline void APIENTRY _glGetSharpenTexFuncSGIS(GLenum target, GLfloat * points) {
    const char *_name = "glGetSharpenTexFuncSGIS";
    if (!_glGetSharpenTexFuncSGIS_ptr) {
        _glGetSharpenTexFuncSGIS_ptr = (PFN_GLGETSHARPENTEXFUNCSGIS)_getPrivateProcAddress(_name);
        if (!_glGetSharpenTexFuncSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetSharpenTexFuncSGIS_ptr(target, points);
}

typedef void (APIENTRY * PFN_GLSAMPLEMASKSGIS)(GLclampf value, GLboolean invert);
static PFN_GLSAMPLEMASKSGIS _glSampleMaskSGIS_ptr = NULL;

static inline void APIENTRY _glSampleMaskSGIS(GLclampf value, GLboolean invert) {
    const char *_name = "glSampleMaskSGIS";
    if (!_glSampleMaskSGIS_ptr) {
        _glSampleMaskSGIS_ptr = (PFN_GLSAMPLEMASKSGIS)_getPrivateProcAddress(_name);
        if (!_glSampleMaskSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSampleMaskSGIS_ptr(value, invert);
}

typedef void (APIENTRY * PFN_GLSAMPLEPATTERNSGIS)(GLenum pattern);
static PFN_GLSAMPLEPATTERNSGIS _glSamplePatternSGIS_ptr = NULL;

static inline void APIENTRY _glSamplePatternSGIS(GLenum pattern) {
    const char *_name = "glSamplePatternSGIS";
    if (!_glSamplePatternSGIS_ptr) {
        _glSamplePatternSGIS_ptr = (PFN_GLSAMPLEPATTERNSGIS)_getPrivateProcAddress(_name);
        if (!_glSamplePatternSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSamplePatternSGIS_ptr(pattern);
}

typedef void (APIENTRY * PFN_GLARRAYELEMENTEXT)(GLint i);
static PFN_GLARRAYELEMENTEXT _glArrayElementEXT_ptr = NULL;

static inline void APIENTRY _glArrayElementEXT(GLint i) {
    const char *_name = "glArrayElementEXT";
    if (!_glArrayElementEXT_ptr) {
        _glArrayElementEXT_ptr = (PFN_GLARRAYELEMENTEXT)_getPrivateProcAddress(_name);
        if (!_glArrayElementEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glArrayElementEXT_ptr(i);
}

typedef void (APIENTRY * PFN_GLCOLORPOINTEREXT)(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer);
static PFN_GLCOLORPOINTEREXT _glColorPointerEXT_ptr = NULL;

static inline void APIENTRY _glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    const char *_name = "glColorPointerEXT";
    if (!_glColorPointerEXT_ptr) {
        _glColorPointerEXT_ptr = (PFN_GLCOLORPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glColorPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorPointerEXT_ptr(size, type, stride, count, pointer);
}

typedef void (APIENTRY * PFN_GLDRAWARRAYSEXT)(GLenum mode, GLint first, GLsizei count);
static PFN_GLDRAWARRAYSEXT _glDrawArraysEXT_ptr = NULL;

static inline void APIENTRY _glDrawArraysEXT(GLenum mode, GLint first, GLsizei count) {
    const char *_name = "glDrawArraysEXT";
    if (!_glDrawArraysEXT_ptr) {
        _glDrawArraysEXT_ptr = (PFN_GLDRAWARRAYSEXT)_getPrivateProcAddress(_name);
        if (!_glDrawArraysEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawArraysEXT_ptr(mode, first, count);
}

typedef void (APIENTRY * PFN_GLEDGEFLAGPOINTEREXT)(GLsizei stride, GLsizei count, const GLboolean * pointer);
static PFN_GLEDGEFLAGPOINTEREXT _glEdgeFlagPointerEXT_ptr = NULL;

static inline void APIENTRY _glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean * pointer) {
    const char *_name = "glEdgeFlagPointerEXT";
    if (!_glEdgeFlagPointerEXT_ptr) {
        _glEdgeFlagPointerEXT_ptr = (PFN_GLEDGEFLAGPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glEdgeFlagPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEdgeFlagPointerEXT_ptr(stride, count, pointer);
}

typedef void (APIENTRY * PFN_GLGETPOINTERVEXT)(GLenum pname, GLvoid * * params);
static PFN_GLGETPOINTERVEXT _glGetPointervEXT_ptr = NULL;

static inline void APIENTRY _glGetPointervEXT(GLenum pname, GLvoid * * params) {
    const char *_name = "glGetPointervEXT";
    if (!_glGetPointervEXT_ptr) {
        _glGetPointervEXT_ptr = (PFN_GLGETPOINTERVEXT)_getPrivateProcAddress(_name);
        if (!_glGetPointervEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPointervEXT_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLINDEXPOINTEREXT)(GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer);
static PFN_GLINDEXPOINTEREXT _glIndexPointerEXT_ptr = NULL;

static inline void APIENTRY _glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    const char *_name = "glIndexPointerEXT";
    if (!_glIndexPointerEXT_ptr) {
        _glIndexPointerEXT_ptr = (PFN_GLINDEXPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glIndexPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexPointerEXT_ptr(type, stride, count, pointer);
}

typedef void (APIENTRY * PFN_GLNORMALPOINTEREXT)(GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer);
static PFN_GLNORMALPOINTEREXT _glNormalPointerEXT_ptr = NULL;

static inline void APIENTRY _glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    const char *_name = "glNormalPointerEXT";
    if (!_glNormalPointerEXT_ptr) {
        _glNormalPointerEXT_ptr = (PFN_GLNORMALPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glNormalPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalPointerEXT_ptr(type, stride, count, pointer);
}

typedef void (APIENTRY * PFN_GLTEXCOORDPOINTEREXT)(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer);
static PFN_GLTEXCOORDPOINTEREXT _glTexCoordPointerEXT_ptr = NULL;

static inline void APIENTRY _glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    const char *_name = "glTexCoordPointerEXT";
    if (!_glTexCoordPointerEXT_ptr) {
        _glTexCoordPointerEXT_ptr = (PFN_GLTEXCOORDPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glTexCoordPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoordPointerEXT_ptr(size, type, stride, count, pointer);
}

typedef void (APIENTRY * PFN_GLVERTEXPOINTEREXT)(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer);
static PFN_GLVERTEXPOINTEREXT _glVertexPointerEXT_ptr = NULL;

static inline void APIENTRY _glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    const char *_name = "glVertexPointerEXT";
    if (!_glVertexPointerEXT_ptr) {
        _glVertexPointerEXT_ptr = (PFN_GLVERTEXPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glVertexPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexPointerEXT_ptr(size, type, stride, count, pointer);
}

typedef void (APIENTRY * PFN_GLBLENDEQUATIONEXT)(GLenum mode);
static PFN_GLBLENDEQUATIONEXT _glBlendEquationEXT_ptr = NULL;

static inline void APIENTRY _glBlendEquationEXT(GLenum mode) {
    const char *_name = "glBlendEquationEXT";
    if (!_glBlendEquationEXT_ptr) {
        _glBlendEquationEXT_ptr = (PFN_GLBLENDEQUATIONEXT)_getPrivateProcAddress(_name);
        if (!_glBlendEquationEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendEquationEXT_ptr(mode);
}

typedef void (APIENTRY * PFN_GLSPRITEPARAMETERFSGIX)(GLenum pname, GLfloat param);
static PFN_GLSPRITEPARAMETERFSGIX _glSpriteParameterfSGIX_ptr = NULL;

static inline void APIENTRY _glSpriteParameterfSGIX(GLenum pname, GLfloat param) {
    const char *_name = "glSpriteParameterfSGIX";
    if (!_glSpriteParameterfSGIX_ptr) {
        _glSpriteParameterfSGIX_ptr = (PFN_GLSPRITEPARAMETERFSGIX)_getPrivateProcAddress(_name);
        if (!_glSpriteParameterfSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSpriteParameterfSGIX_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLSPRITEPARAMETERFVSGIX)(GLenum pname, const GLfloat * params);
static PFN_GLSPRITEPARAMETERFVSGIX _glSpriteParameterfvSGIX_ptr = NULL;

static inline void APIENTRY _glSpriteParameterfvSGIX(GLenum pname, const GLfloat * params) {
    const char *_name = "glSpriteParameterfvSGIX";
    if (!_glSpriteParameterfvSGIX_ptr) {
        _glSpriteParameterfvSGIX_ptr = (PFN_GLSPRITEPARAMETERFVSGIX)_getPrivateProcAddress(_name);
        if (!_glSpriteParameterfvSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSpriteParameterfvSGIX_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLSPRITEPARAMETERISGIX)(GLenum pname, GLint param);
static PFN_GLSPRITEPARAMETERISGIX _glSpriteParameteriSGIX_ptr = NULL;

static inline void APIENTRY _glSpriteParameteriSGIX(GLenum pname, GLint param) {
    const char *_name = "glSpriteParameteriSGIX";
    if (!_glSpriteParameteriSGIX_ptr) {
        _glSpriteParameteriSGIX_ptr = (PFN_GLSPRITEPARAMETERISGIX)_getPrivateProcAddress(_name);
        if (!_glSpriteParameteriSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSpriteParameteriSGIX_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLSPRITEPARAMETERIVSGIX)(GLenum pname, const GLint * params);
static PFN_GLSPRITEPARAMETERIVSGIX _glSpriteParameterivSGIX_ptr = NULL;

static inline void APIENTRY _glSpriteParameterivSGIX(GLenum pname, const GLint * params) {
    const char *_name = "glSpriteParameterivSGIX";
    if (!_glSpriteParameterivSGIX_ptr) {
        _glSpriteParameterivSGIX_ptr = (PFN_GLSPRITEPARAMETERIVSGIX)_getPrivateProcAddress(_name);
        if (!_glSpriteParameterivSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSpriteParameterivSGIX_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLPOINTPARAMETERFEXT)(GLenum pname, GLfloat param);
static PFN_GLPOINTPARAMETERFEXT _glPointParameterfEXT_ptr = NULL;

static inline void APIENTRY _glPointParameterfEXT(GLenum pname, GLfloat param) {
    const char *_name = "glPointParameterfEXT";
    if (!_glPointParameterfEXT_ptr) {
        _glPointParameterfEXT_ptr = (PFN_GLPOINTPARAMETERFEXT)_getPrivateProcAddress(_name);
        if (!_glPointParameterfEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameterfEXT_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLPOINTPARAMETERFVEXT)(GLenum pname, const GLfloat * params);
static PFN_GLPOINTPARAMETERFVEXT _glPointParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glPointParameterfvEXT(GLenum pname, const GLfloat * params) {
    const char *_name = "glPointParameterfvEXT";
    if (!_glPointParameterfvEXT_ptr) {
        _glPointParameterfvEXT_ptr = (PFN_GLPOINTPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glPointParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameterfvEXT_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLPOINTPARAMETERFSGIS)(GLenum pname, GLfloat param);
static PFN_GLPOINTPARAMETERFSGIS _glPointParameterfSGIS_ptr = NULL;

static inline void APIENTRY _glPointParameterfSGIS(GLenum pname, GLfloat param) {
    const char *_name = "glPointParameterfSGIS";
    if (!_glPointParameterfSGIS_ptr) {
        _glPointParameterfSGIS_ptr = (PFN_GLPOINTPARAMETERFSGIS)_getPrivateProcAddress(_name);
        if (!_glPointParameterfSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameterfSGIS_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLPOINTPARAMETERFVSGIS)(GLenum pname, const GLfloat * params);
static PFN_GLPOINTPARAMETERFVSGIS _glPointParameterfvSGIS_ptr = NULL;

static inline void APIENTRY _glPointParameterfvSGIS(GLenum pname, const GLfloat * params) {
    const char *_name = "glPointParameterfvSGIS";
    if (!_glPointParameterfvSGIS_ptr) {
        _glPointParameterfvSGIS_ptr = (PFN_GLPOINTPARAMETERFVSGIS)_getPrivateProcAddress(_name);
        if (!_glPointParameterfvSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameterfvSGIS_ptr(pname, params);
}

typedef GLint (APIENTRY * PFN_GLGETINSTRUMENTSSGIX)(void);
static PFN_GLGETINSTRUMENTSSGIX _glGetInstrumentsSGIX_ptr = NULL;

static inline GLint APIENTRY _glGetInstrumentsSGIX(void) {
    const char *_name = "glGetInstrumentsSGIX";
    if (!_glGetInstrumentsSGIX_ptr) {
        _glGetInstrumentsSGIX_ptr = (PFN_GLGETINSTRUMENTSSGIX)_getPrivateProcAddress(_name);
        if (!_glGetInstrumentsSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetInstrumentsSGIX_ptr();
}

typedef void (APIENTRY * PFN_GLINSTRUMENTSBUFFERSGIX)(GLsizei size, GLint * buffer);
static PFN_GLINSTRUMENTSBUFFERSGIX _glInstrumentsBufferSGIX_ptr = NULL;

static inline void APIENTRY _glInstrumentsBufferSGIX(GLsizei size, GLint * buffer) {
    const char *_name = "glInstrumentsBufferSGIX";
    if (!_glInstrumentsBufferSGIX_ptr) {
        _glInstrumentsBufferSGIX_ptr = (PFN_GLINSTRUMENTSBUFFERSGIX)_getPrivateProcAddress(_name);
        if (!_glInstrumentsBufferSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glInstrumentsBufferSGIX_ptr(size, buffer);
}

typedef GLint (APIENTRY * PFN_GLPOLLINSTRUMENTSSGIX)(GLint * marker_p);
static PFN_GLPOLLINSTRUMENTSSGIX _glPollInstrumentsSGIX_ptr = NULL;

static inline GLint APIENTRY _glPollInstrumentsSGIX(GLint * marker_p) {
    const char *_name = "glPollInstrumentsSGIX";
    if (!_glPollInstrumentsSGIX_ptr) {
        _glPollInstrumentsSGIX_ptr = (PFN_GLPOLLINSTRUMENTSSGIX)_getPrivateProcAddress(_name);
        if (!_glPollInstrumentsSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glPollInstrumentsSGIX_ptr(marker_p);
}

typedef void (APIENTRY * PFN_GLREADINSTRUMENTSSGIX)(GLint marker);
static PFN_GLREADINSTRUMENTSSGIX _glReadInstrumentsSGIX_ptr = NULL;

static inline void APIENTRY _glReadInstrumentsSGIX(GLint marker) {
    const char *_name = "glReadInstrumentsSGIX";
    if (!_glReadInstrumentsSGIX_ptr) {
        _glReadInstrumentsSGIX_ptr = (PFN_GLREADINSTRUMENTSSGIX)_getPrivateProcAddress(_name);
        if (!_glReadInstrumentsSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReadInstrumentsSGIX_ptr(marker);
}

typedef void (APIENTRY * PFN_GLSTARTINSTRUMENTSSGIX)(void);
static PFN_GLSTARTINSTRUMENTSSGIX _glStartInstrumentsSGIX_ptr = NULL;

static inline void APIENTRY _glStartInstrumentsSGIX(void) {
    const char *_name = "glStartInstrumentsSGIX";
    if (!_glStartInstrumentsSGIX_ptr) {
        _glStartInstrumentsSGIX_ptr = (PFN_GLSTARTINSTRUMENTSSGIX)_getPrivateProcAddress(_name);
        if (!_glStartInstrumentsSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glStartInstrumentsSGIX_ptr();
}

typedef void (APIENTRY * PFN_GLSTOPINSTRUMENTSSGIX)(GLint marker);
static PFN_GLSTOPINSTRUMENTSSGIX _glStopInstrumentsSGIX_ptr = NULL;

static inline void APIENTRY _glStopInstrumentsSGIX(GLint marker) {
    const char *_name = "glStopInstrumentsSGIX";
    if (!_glStopInstrumentsSGIX_ptr) {
        _glStopInstrumentsSGIX_ptr = (PFN_GLSTOPINSTRUMENTSSGIX)_getPrivateProcAddress(_name);
        if (!_glStopInstrumentsSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glStopInstrumentsSGIX_ptr(marker);
}

typedef void (APIENTRY * PFN_GLFRAMEZOOMSGIX)(GLint factor);
static PFN_GLFRAMEZOOMSGIX _glFrameZoomSGIX_ptr = NULL;

static inline void APIENTRY _glFrameZoomSGIX(GLint factor) {
    const char *_name = "glFrameZoomSGIX";
    if (!_glFrameZoomSGIX_ptr) {
        _glFrameZoomSGIX_ptr = (PFN_GLFRAMEZOOMSGIX)_getPrivateProcAddress(_name);
        if (!_glFrameZoomSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFrameZoomSGIX_ptr(factor);
}

typedef void (APIENTRY * PFN_GLTAGSAMPLEBUFFERSGIX)(void);
static PFN_GLTAGSAMPLEBUFFERSGIX _glTagSampleBufferSGIX_ptr = NULL;

static inline void APIENTRY _glTagSampleBufferSGIX(void) {
    const char *_name = "glTagSampleBufferSGIX";
    if (!_glTagSampleBufferSGIX_ptr) {
        _glTagSampleBufferSGIX_ptr = (PFN_GLTAGSAMPLEBUFFERSGIX)_getPrivateProcAddress(_name);
        if (!_glTagSampleBufferSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTagSampleBufferSGIX_ptr();
}

typedef void (APIENTRY * PFN_GLDEFORMATIONMAP3DSGIX)(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble * points);
static PFN_GLDEFORMATIONMAP3DSGIX _glDeformationMap3dSGIX_ptr = NULL;

static inline void APIENTRY _glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble * points) {
    const char *_name = "glDeformationMap3dSGIX";
    if (!_glDeformationMap3dSGIX_ptr) {
        _glDeformationMap3dSGIX_ptr = (PFN_GLDEFORMATIONMAP3DSGIX)_getPrivateProcAddress(_name);
        if (!_glDeformationMap3dSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeformationMap3dSGIX_ptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
}

typedef void (APIENTRY * PFN_GLDEFORMATIONMAP3FSGIX)(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat * points);
static PFN_GLDEFORMATIONMAP3FSGIX _glDeformationMap3fSGIX_ptr = NULL;

static inline void APIENTRY _glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat * points) {
    const char *_name = "glDeformationMap3fSGIX";
    if (!_glDeformationMap3fSGIX_ptr) {
        _glDeformationMap3fSGIX_ptr = (PFN_GLDEFORMATIONMAP3FSGIX)_getPrivateProcAddress(_name);
        if (!_glDeformationMap3fSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeformationMap3fSGIX_ptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
}

typedef void (APIENTRY * PFN_GLDEFORMSGIX)(GLbitfield mask);
static PFN_GLDEFORMSGIX _glDeformSGIX_ptr = NULL;

static inline void APIENTRY _glDeformSGIX(GLbitfield mask) {
    const char *_name = "glDeformSGIX";
    if (!_glDeformSGIX_ptr) {
        _glDeformSGIX_ptr = (PFN_GLDEFORMSGIX)_getPrivateProcAddress(_name);
        if (!_glDeformSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeformSGIX_ptr(mask);
}

typedef void (APIENTRY * PFN_GLLOADIDENTITYDEFORMATIONMAPSGIX)(GLbitfield mask);
static PFN_GLLOADIDENTITYDEFORMATIONMAPSGIX _glLoadIdentityDeformationMapSGIX_ptr = NULL;

static inline void APIENTRY _glLoadIdentityDeformationMapSGIX(GLbitfield mask) {
    const char *_name = "glLoadIdentityDeformationMapSGIX";
    if (!_glLoadIdentityDeformationMapSGIX_ptr) {
        _glLoadIdentityDeformationMapSGIX_ptr = (PFN_GLLOADIDENTITYDEFORMATIONMAPSGIX)_getPrivateProcAddress(_name);
        if (!_glLoadIdentityDeformationMapSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLoadIdentityDeformationMapSGIX_ptr(mask);
}

typedef void (APIENTRY * PFN_GLREFERENCEPLANESGIX)(const GLdouble * equation);
static PFN_GLREFERENCEPLANESGIX _glReferencePlaneSGIX_ptr = NULL;

static inline void APIENTRY _glReferencePlaneSGIX(const GLdouble * equation) {
    const char *_name = "glReferencePlaneSGIX";
    if (!_glReferencePlaneSGIX_ptr) {
        _glReferencePlaneSGIX_ptr = (PFN_GLREFERENCEPLANESGIX)_getPrivateProcAddress(_name);
        if (!_glReferencePlaneSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReferencePlaneSGIX_ptr(equation);
}

typedef void (APIENTRY * PFN_GLFLUSHRASTERSGIX)(void);
static PFN_GLFLUSHRASTERSGIX _glFlushRasterSGIX_ptr = NULL;

static inline void APIENTRY _glFlushRasterSGIX(void) {
    const char *_name = "glFlushRasterSGIX";
    if (!_glFlushRasterSGIX_ptr) {
        _glFlushRasterSGIX_ptr = (PFN_GLFLUSHRASTERSGIX)_getPrivateProcAddress(_name);
        if (!_glFlushRasterSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFlushRasterSGIX_ptr();
}

typedef void (APIENTRY * PFN_GLFOGFUNCSGIS)(GLsizei n, const GLfloat * points);
static PFN_GLFOGFUNCSGIS _glFogFuncSGIS_ptr = NULL;

static inline void APIENTRY _glFogFuncSGIS(GLsizei n, const GLfloat * points) {
    const char *_name = "glFogFuncSGIS";
    if (!_glFogFuncSGIS_ptr) {
        _glFogFuncSGIS_ptr = (PFN_GLFOGFUNCSGIS)_getPrivateProcAddress(_name);
        if (!_glFogFuncSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogFuncSGIS_ptr(n, points);
}

typedef void (APIENTRY * PFN_GLGETFOGFUNCSGIS)(GLfloat * points);
static PFN_GLGETFOGFUNCSGIS _glGetFogFuncSGIS_ptr = NULL;

static inline void APIENTRY _glGetFogFuncSGIS(GLfloat * points) {
    const char *_name = "glGetFogFuncSGIS";
    if (!_glGetFogFuncSGIS_ptr) {
        _glGetFogFuncSGIS_ptr = (PFN_GLGETFOGFUNCSGIS)_getPrivateProcAddress(_name);
        if (!_glGetFogFuncSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFogFuncSGIS_ptr(points);
}

typedef void (APIENTRY * PFN_GLIMAGETRANSFORMPARAMETERIHP)(GLenum target, GLenum pname, GLint param);
static PFN_GLIMAGETRANSFORMPARAMETERIHP _glImageTransformParameteriHP_ptr = NULL;

static inline void APIENTRY _glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param) {
    const char *_name = "glImageTransformParameteriHP";
    if (!_glImageTransformParameteriHP_ptr) {
        _glImageTransformParameteriHP_ptr = (PFN_GLIMAGETRANSFORMPARAMETERIHP)_getPrivateProcAddress(_name);
        if (!_glImageTransformParameteriHP_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glImageTransformParameteriHP_ptr(target, pname, param);
}

typedef void (APIENTRY * PFN_GLIMAGETRANSFORMPARAMETERFHP)(GLenum target, GLenum pname, GLfloat param);
static PFN_GLIMAGETRANSFORMPARAMETERFHP _glImageTransformParameterfHP_ptr = NULL;

static inline void APIENTRY _glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glImageTransformParameterfHP";
    if (!_glImageTransformParameterfHP_ptr) {
        _glImageTransformParameterfHP_ptr = (PFN_GLIMAGETRANSFORMPARAMETERFHP)_getPrivateProcAddress(_name);
        if (!_glImageTransformParameterfHP_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glImageTransformParameterfHP_ptr(target, pname, param);
}

typedef void (APIENTRY * PFN_GLIMAGETRANSFORMPARAMETERIVHP)(GLenum target, GLenum pname, const GLint * params);
static PFN_GLIMAGETRANSFORMPARAMETERIVHP _glImageTransformParameterivHP_ptr = NULL;

static inline void APIENTRY _glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glImageTransformParameterivHP";
    if (!_glImageTransformParameterivHP_ptr) {
        _glImageTransformParameterivHP_ptr = (PFN_GLIMAGETRANSFORMPARAMETERIVHP)_getPrivateProcAddress(_name);
        if (!_glImageTransformParameterivHP_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glImageTransformParameterivHP_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLIMAGETRANSFORMPARAMETERFVHP)(GLenum target, GLenum pname, const GLfloat * params);
static PFN_GLIMAGETRANSFORMPARAMETERFVHP _glImageTransformParameterfvHP_ptr = NULL;

static inline void APIENTRY _glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glImageTransformParameterfvHP";
    if (!_glImageTransformParameterfvHP_ptr) {
        _glImageTransformParameterfvHP_ptr = (PFN_GLIMAGETRANSFORMPARAMETERFVHP)_getPrivateProcAddress(_name);
        if (!_glImageTransformParameterfvHP_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glImageTransformParameterfvHP_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETIMAGETRANSFORMPARAMETERIVHP)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETIMAGETRANSFORMPARAMETERIVHP _glGetImageTransformParameterivHP_ptr = NULL;

static inline void APIENTRY _glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetImageTransformParameterivHP";
    if (!_glGetImageTransformParameterivHP_ptr) {
        _glGetImageTransformParameterivHP_ptr = (PFN_GLGETIMAGETRANSFORMPARAMETERIVHP)_getPrivateProcAddress(_name);
        if (!_glGetImageTransformParameterivHP_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetImageTransformParameterivHP_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETIMAGETRANSFORMPARAMETERFVHP)(GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETIMAGETRANSFORMPARAMETERFVHP _glGetImageTransformParameterfvHP_ptr = NULL;

static inline void APIENTRY _glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetImageTransformParameterfvHP";
    if (!_glGetImageTransformParameterfvHP_ptr) {
        _glGetImageTransformParameterfvHP_ptr = (PFN_GLGETIMAGETRANSFORMPARAMETERFVHP)_getPrivateProcAddress(_name);
        if (!_glGetImageTransformParameterfvHP_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetImageTransformParameterfvHP_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCOLORSUBTABLEEXT)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data);
static PFN_GLCOLORSUBTABLEEXT _glColorSubTableEXT_ptr = NULL;

static inline void APIENTRY _glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data) {
    const char *_name = "glColorSubTableEXT";
    if (!_glColorSubTableEXT_ptr) {
        _glColorSubTableEXT_ptr = (PFN_GLCOLORSUBTABLEEXT)_getPrivateProcAddress(_name);
        if (!_glColorSubTableEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorSubTableEXT_ptr(target, start, count, format, type, data);
}

typedef void (APIENTRY * PFN_GLCOPYCOLORSUBTABLEEXT)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
static PFN_GLCOPYCOLORSUBTABLEEXT _glCopyColorSubTableEXT_ptr = NULL;

static inline void APIENTRY _glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyColorSubTableEXT";
    if (!_glCopyColorSubTableEXT_ptr) {
        _glCopyColorSubTableEXT_ptr = (PFN_GLCOPYCOLORSUBTABLEEXT)_getPrivateProcAddress(_name);
        if (!_glCopyColorSubTableEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyColorSubTableEXT_ptr(target, start, x, y, width);
}

typedef void (APIENTRY * PFN_GLHINTPGI)(GLenum target, GLint mode);
static PFN_GLHINTPGI _glHintPGI_ptr = NULL;

static inline void APIENTRY _glHintPGI(GLenum target, GLint mode) {
    const char *_name = "glHintPGI";
    if (!_glHintPGI_ptr) {
        _glHintPGI_ptr = (PFN_GLHINTPGI)_getPrivateProcAddress(_name);
        if (!_glHintPGI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glHintPGI_ptr(target, mode);
}

typedef void (APIENTRY * PFN_GLCOLORTABLEEXT)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table);
static PFN_GLCOLORTABLEEXT _glColorTableEXT_ptr = NULL;

static inline void APIENTRY _glColorTableEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table) {
    const char *_name = "glColorTableEXT";
    if (!_glColorTableEXT_ptr) {
        _glColorTableEXT_ptr = (PFN_GLCOLORTABLEEXT)_getPrivateProcAddress(_name);
        if (!_glColorTableEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorTableEXT_ptr(target, internalformat, width, format, type, table);
}

typedef void (APIENTRY * PFN_GLGETCOLORTABLEEXT)(GLenum target, GLenum format, GLenum type, GLvoid * data);
static PFN_GLGETCOLORTABLEEXT _glGetColorTableEXT_ptr = NULL;

static inline void APIENTRY _glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid * data) {
    const char *_name = "glGetColorTableEXT";
    if (!_glGetColorTableEXT_ptr) {
        _glGetColorTableEXT_ptr = (PFN_GLGETCOLORTABLEEXT)_getPrivateProcAddress(_name);
        if (!_glGetColorTableEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetColorTableEXT_ptr(target, format, type, data);
}

typedef void (APIENTRY * PFN_GLGETCOLORTABLEPARAMETERIVEXT)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETCOLORTABLEPARAMETERIVEXT _glGetColorTableParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetColorTableParameterivEXT";
    if (!_glGetColorTableParameterivEXT_ptr) {
        _glGetColorTableParameterivEXT_ptr = (PFN_GLGETCOLORTABLEPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetColorTableParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetColorTableParameterivEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETCOLORTABLEPARAMETERFVEXT)(GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETCOLORTABLEPARAMETERFVEXT _glGetColorTableParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetColorTableParameterfvEXT";
    if (!_glGetColorTableParameterfvEXT_ptr) {
        _glGetColorTableParameterfvEXT_ptr = (PFN_GLGETCOLORTABLEPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glGetColorTableParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetColorTableParameterfvEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETLISTPARAMETERFVSGIX)(GLuint list, GLenum pname, GLfloat * params);
static PFN_GLGETLISTPARAMETERFVSGIX _glGetListParameterfvSGIX_ptr = NULL;

static inline void APIENTRY _glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat * params) {
    const char *_name = "glGetListParameterfvSGIX";
    if (!_glGetListParameterfvSGIX_ptr) {
        _glGetListParameterfvSGIX_ptr = (PFN_GLGETLISTPARAMETERFVSGIX)_getPrivateProcAddress(_name);
        if (!_glGetListParameterfvSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetListParameterfvSGIX_ptr(list, pname, params);
}

typedef void (APIENTRY * PFN_GLGETLISTPARAMETERIVSGIX)(GLuint list, GLenum pname, GLint * params);
static PFN_GLGETLISTPARAMETERIVSGIX _glGetListParameterivSGIX_ptr = NULL;

static inline void APIENTRY _glGetListParameterivSGIX(GLuint list, GLenum pname, GLint * params) {
    const char *_name = "glGetListParameterivSGIX";
    if (!_glGetListParameterivSGIX_ptr) {
        _glGetListParameterivSGIX_ptr = (PFN_GLGETLISTPARAMETERIVSGIX)_getPrivateProcAddress(_name);
        if (!_glGetListParameterivSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetListParameterivSGIX_ptr(list, pname, params);
}

typedef void (APIENTRY * PFN_GLLISTPARAMETERFSGIX)(GLuint list, GLenum pname, GLfloat param);
static PFN_GLLISTPARAMETERFSGIX _glListParameterfSGIX_ptr = NULL;

static inline void APIENTRY _glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param) {
    const char *_name = "glListParameterfSGIX";
    if (!_glListParameterfSGIX_ptr) {
        _glListParameterfSGIX_ptr = (PFN_GLLISTPARAMETERFSGIX)_getPrivateProcAddress(_name);
        if (!_glListParameterfSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glListParameterfSGIX_ptr(list, pname, param);
}

typedef void (APIENTRY * PFN_GLLISTPARAMETERFVSGIX)(GLuint list, GLenum pname, const GLfloat * params);
static PFN_GLLISTPARAMETERFVSGIX _glListParameterfvSGIX_ptr = NULL;

static inline void APIENTRY _glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat * params) {
    const char *_name = "glListParameterfvSGIX";
    if (!_glListParameterfvSGIX_ptr) {
        _glListParameterfvSGIX_ptr = (PFN_GLLISTPARAMETERFVSGIX)_getPrivateProcAddress(_name);
        if (!_glListParameterfvSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glListParameterfvSGIX_ptr(list, pname, params);
}

typedef void (APIENTRY * PFN_GLLISTPARAMETERISGIX)(GLuint list, GLenum pname, GLint param);
static PFN_GLLISTPARAMETERISGIX _glListParameteriSGIX_ptr = NULL;

static inline void APIENTRY _glListParameteriSGIX(GLuint list, GLenum pname, GLint param) {
    const char *_name = "glListParameteriSGIX";
    if (!_glListParameteriSGIX_ptr) {
        _glListParameteriSGIX_ptr = (PFN_GLLISTPARAMETERISGIX)_getPrivateProcAddress(_name);
        if (!_glListParameteriSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glListParameteriSGIX_ptr(list, pname, param);
}

typedef void (APIENTRY * PFN_GLLISTPARAMETERIVSGIX)(GLuint list, GLenum pname, const GLint * params);
static PFN_GLLISTPARAMETERIVSGIX _glListParameterivSGIX_ptr = NULL;

static inline void APIENTRY _glListParameterivSGIX(GLuint list, GLenum pname, const GLint * params) {
    const char *_name = "glListParameterivSGIX";
    if (!_glListParameterivSGIX_ptr) {
        _glListParameterivSGIX_ptr = (PFN_GLLISTPARAMETERIVSGIX)_getPrivateProcAddress(_name);
        if (!_glListParameterivSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glListParameterivSGIX_ptr(list, pname, params);
}

typedef void (APIENTRY * PFN_GLINDEXMATERIALEXT)(GLenum face, GLenum mode);
static PFN_GLINDEXMATERIALEXT _glIndexMaterialEXT_ptr = NULL;

static inline void APIENTRY _glIndexMaterialEXT(GLenum face, GLenum mode) {
    const char *_name = "glIndexMaterialEXT";
    if (!_glIndexMaterialEXT_ptr) {
        _glIndexMaterialEXT_ptr = (PFN_GLINDEXMATERIALEXT)_getPrivateProcAddress(_name);
        if (!_glIndexMaterialEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexMaterialEXT_ptr(face, mode);
}

typedef void (APIENTRY * PFN_GLINDEXFUNCEXT)(GLenum func, GLclampf ref);
static PFN_GLINDEXFUNCEXT _glIndexFuncEXT_ptr = NULL;

static inline void APIENTRY _glIndexFuncEXT(GLenum func, GLclampf ref) {
    const char *_name = "glIndexFuncEXT";
    if (!_glIndexFuncEXT_ptr) {
        _glIndexFuncEXT_ptr = (PFN_GLINDEXFUNCEXT)_getPrivateProcAddress(_name);
        if (!_glIndexFuncEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexFuncEXT_ptr(func, ref);
}

typedef void (APIENTRY * PFN_GLLOCKARRAYSEXT)(GLint first, GLsizei count);
static PFN_GLLOCKARRAYSEXT _glLockArraysEXT_ptr = NULL;

static inline void APIENTRY _glLockArraysEXT(GLint first, GLsizei count) {
    const char *_name = "glLockArraysEXT";
    if (!_glLockArraysEXT_ptr) {
        _glLockArraysEXT_ptr = (PFN_GLLOCKARRAYSEXT)_getPrivateProcAddress(_name);
        if (!_glLockArraysEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLockArraysEXT_ptr(first, count);
}

typedef void (APIENTRY * PFN_GLUNLOCKARRAYSEXT)(void);
static PFN_GLUNLOCKARRAYSEXT _glUnlockArraysEXT_ptr = NULL;

static inline void APIENTRY _glUnlockArraysEXT(void) {
    const char *_name = "glUnlockArraysEXT";
    if (!_glUnlockArraysEXT_ptr) {
        _glUnlockArraysEXT_ptr = (PFN_GLUNLOCKARRAYSEXT)_getPrivateProcAddress(_name);
        if (!_glUnlockArraysEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUnlockArraysEXT_ptr();
}

typedef void (APIENTRY * PFN_GLCULLPARAMETERDVEXT)(GLenum pname, GLdouble * params);
static PFN_GLCULLPARAMETERDVEXT _glCullParameterdvEXT_ptr = NULL;

static inline void APIENTRY _glCullParameterdvEXT(GLenum pname, GLdouble * params) {
    const char *_name = "glCullParameterdvEXT";
    if (!_glCullParameterdvEXT_ptr) {
        _glCullParameterdvEXT_ptr = (PFN_GLCULLPARAMETERDVEXT)_getPrivateProcAddress(_name);
        if (!_glCullParameterdvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCullParameterdvEXT_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLCULLPARAMETERFVEXT)(GLenum pname, GLfloat * params);
static PFN_GLCULLPARAMETERFVEXT _glCullParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glCullParameterfvEXT(GLenum pname, GLfloat * params) {
    const char *_name = "glCullParameterfvEXT";
    if (!_glCullParameterfvEXT_ptr) {
        _glCullParameterfvEXT_ptr = (PFN_GLCULLPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glCullParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCullParameterfvEXT_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLFRAGMENTCOLORMATERIALSGIX)(GLenum face, GLenum mode);
static PFN_GLFRAGMENTCOLORMATERIALSGIX _glFragmentColorMaterialSGIX_ptr = NULL;

static inline void APIENTRY _glFragmentColorMaterialSGIX(GLenum face, GLenum mode) {
    const char *_name = "glFragmentColorMaterialSGIX";
    if (!_glFragmentColorMaterialSGIX_ptr) {
        _glFragmentColorMaterialSGIX_ptr = (PFN_GLFRAGMENTCOLORMATERIALSGIX)_getPrivateProcAddress(_name);
        if (!_glFragmentColorMaterialSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFragmentColorMaterialSGIX_ptr(face, mode);
}

typedef void (APIENTRY * PFN_GLFRAGMENTLIGHTFSGIX)(GLenum light, GLenum pname, GLfloat param);
static PFN_GLFRAGMENTLIGHTFSGIX _glFragmentLightfSGIX_ptr = NULL;

static inline void APIENTRY _glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param) {
    const char *_name = "glFragmentLightfSGIX";
    if (!_glFragmentLightfSGIX_ptr) {
        _glFragmentLightfSGIX_ptr = (PFN_GLFRAGMENTLIGHTFSGIX)_getPrivateProcAddress(_name);
        if (!_glFragmentLightfSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFragmentLightfSGIX_ptr(light, pname, param);
}

typedef void (APIENTRY * PFN_GLFRAGMENTLIGHTFVSGIX)(GLenum light, GLenum pname, const GLfloat * params);
static PFN_GLFRAGMENTLIGHTFVSGIX _glFragmentLightfvSGIX_ptr = NULL;

static inline void APIENTRY _glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat * params) {
    const char *_name = "glFragmentLightfvSGIX";
    if (!_glFragmentLightfvSGIX_ptr) {
        _glFragmentLightfvSGIX_ptr = (PFN_GLFRAGMENTLIGHTFVSGIX)_getPrivateProcAddress(_name);
        if (!_glFragmentLightfvSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFragmentLightfvSGIX_ptr(light, pname, params);
}

typedef void (APIENTRY * PFN_GLFRAGMENTLIGHTISGIX)(GLenum light, GLenum pname, GLint param);
static PFN_GLFRAGMENTLIGHTISGIX _glFragmentLightiSGIX_ptr = NULL;

static inline void APIENTRY _glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param) {
    const char *_name = "glFragmentLightiSGIX";
    if (!_glFragmentLightiSGIX_ptr) {
        _glFragmentLightiSGIX_ptr = (PFN_GLFRAGMENTLIGHTISGIX)_getPrivateProcAddress(_name);
        if (!_glFragmentLightiSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFragmentLightiSGIX_ptr(light, pname, param);
}

typedef void (APIENTRY * PFN_GLFRAGMENTLIGHTIVSGIX)(GLenum light, GLenum pname, const GLint * params);
static PFN_GLFRAGMENTLIGHTIVSGIX _glFragmentLightivSGIX_ptr = NULL;

static inline void APIENTRY _glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint * params) {
    const char *_name = "glFragmentLightivSGIX";
    if (!_glFragmentLightivSGIX_ptr) {
        _glFragmentLightivSGIX_ptr = (PFN_GLFRAGMENTLIGHTIVSGIX)_getPrivateProcAddress(_name);
        if (!_glFragmentLightivSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFragmentLightivSGIX_ptr(light, pname, params);
}

typedef void (APIENTRY * PFN_GLFRAGMENTLIGHTMODELFSGIX)(GLenum pname, GLfloat param);
static PFN_GLFRAGMENTLIGHTMODELFSGIX _glFragmentLightModelfSGIX_ptr = NULL;

static inline void APIENTRY _glFragmentLightModelfSGIX(GLenum pname, GLfloat param) {
    const char *_name = "glFragmentLightModelfSGIX";
    if (!_glFragmentLightModelfSGIX_ptr) {
        _glFragmentLightModelfSGIX_ptr = (PFN_GLFRAGMENTLIGHTMODELFSGIX)_getPrivateProcAddress(_name);
        if (!_glFragmentLightModelfSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFragmentLightModelfSGIX_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLFRAGMENTLIGHTMODELFVSGIX)(GLenum pname, const GLfloat * params);
static PFN_GLFRAGMENTLIGHTMODELFVSGIX _glFragmentLightModelfvSGIX_ptr = NULL;

static inline void APIENTRY _glFragmentLightModelfvSGIX(GLenum pname, const GLfloat * params) {
    const char *_name = "glFragmentLightModelfvSGIX";
    if (!_glFragmentLightModelfvSGIX_ptr) {
        _glFragmentLightModelfvSGIX_ptr = (PFN_GLFRAGMENTLIGHTMODELFVSGIX)_getPrivateProcAddress(_name);
        if (!_glFragmentLightModelfvSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFragmentLightModelfvSGIX_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLFRAGMENTLIGHTMODELISGIX)(GLenum pname, GLint param);
static PFN_GLFRAGMENTLIGHTMODELISGIX _glFragmentLightModeliSGIX_ptr = NULL;

static inline void APIENTRY _glFragmentLightModeliSGIX(GLenum pname, GLint param) {
    const char *_name = "glFragmentLightModeliSGIX";
    if (!_glFragmentLightModeliSGIX_ptr) {
        _glFragmentLightModeliSGIX_ptr = (PFN_GLFRAGMENTLIGHTMODELISGIX)_getPrivateProcAddress(_name);
        if (!_glFragmentLightModeliSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFragmentLightModeliSGIX_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLFRAGMENTLIGHTMODELIVSGIX)(GLenum pname, const GLint * params);
static PFN_GLFRAGMENTLIGHTMODELIVSGIX _glFragmentLightModelivSGIX_ptr = NULL;

static inline void APIENTRY _glFragmentLightModelivSGIX(GLenum pname, const GLint * params) {
    const char *_name = "glFragmentLightModelivSGIX";
    if (!_glFragmentLightModelivSGIX_ptr) {
        _glFragmentLightModelivSGIX_ptr = (PFN_GLFRAGMENTLIGHTMODELIVSGIX)_getPrivateProcAddress(_name);
        if (!_glFragmentLightModelivSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFragmentLightModelivSGIX_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLFRAGMENTMATERIALFSGIX)(GLenum face, GLenum pname, GLfloat param);
static PFN_GLFRAGMENTMATERIALFSGIX _glFragmentMaterialfSGIX_ptr = NULL;

static inline void APIENTRY _glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param) {
    const char *_name = "glFragmentMaterialfSGIX";
    if (!_glFragmentMaterialfSGIX_ptr) {
        _glFragmentMaterialfSGIX_ptr = (PFN_GLFRAGMENTMATERIALFSGIX)_getPrivateProcAddress(_name);
        if (!_glFragmentMaterialfSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFragmentMaterialfSGIX_ptr(face, pname, param);
}

typedef void (APIENTRY * PFN_GLFRAGMENTMATERIALFVSGIX)(GLenum face, GLenum pname, const GLfloat * params);
static PFN_GLFRAGMENTMATERIALFVSGIX _glFragmentMaterialfvSGIX_ptr = NULL;

static inline void APIENTRY _glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat * params) {
    const char *_name = "glFragmentMaterialfvSGIX";
    if (!_glFragmentMaterialfvSGIX_ptr) {
        _glFragmentMaterialfvSGIX_ptr = (PFN_GLFRAGMENTMATERIALFVSGIX)_getPrivateProcAddress(_name);
        if (!_glFragmentMaterialfvSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFragmentMaterialfvSGIX_ptr(face, pname, params);
}

typedef void (APIENTRY * PFN_GLFRAGMENTMATERIALISGIX)(GLenum face, GLenum pname, GLint param);
static PFN_GLFRAGMENTMATERIALISGIX _glFragmentMaterialiSGIX_ptr = NULL;

static inline void APIENTRY _glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param) {
    const char *_name = "glFragmentMaterialiSGIX";
    if (!_glFragmentMaterialiSGIX_ptr) {
        _glFragmentMaterialiSGIX_ptr = (PFN_GLFRAGMENTMATERIALISGIX)_getPrivateProcAddress(_name);
        if (!_glFragmentMaterialiSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFragmentMaterialiSGIX_ptr(face, pname, param);
}

typedef void (APIENTRY * PFN_GLFRAGMENTMATERIALIVSGIX)(GLenum face, GLenum pname, const GLint * params);
static PFN_GLFRAGMENTMATERIALIVSGIX _glFragmentMaterialivSGIX_ptr = NULL;

static inline void APIENTRY _glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint * params) {
    const char *_name = "glFragmentMaterialivSGIX";
    if (!_glFragmentMaterialivSGIX_ptr) {
        _glFragmentMaterialivSGIX_ptr = (PFN_GLFRAGMENTMATERIALIVSGIX)_getPrivateProcAddress(_name);
        if (!_glFragmentMaterialivSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFragmentMaterialivSGIX_ptr(face, pname, params);
}

typedef void (APIENTRY * PFN_GLGETFRAGMENTLIGHTFVSGIX)(GLenum light, GLenum pname, GLfloat * params);
static PFN_GLGETFRAGMENTLIGHTFVSGIX _glGetFragmentLightfvSGIX_ptr = NULL;

static inline void APIENTRY _glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat * params) {
    const char *_name = "glGetFragmentLightfvSGIX";
    if (!_glGetFragmentLightfvSGIX_ptr) {
        _glGetFragmentLightfvSGIX_ptr = (PFN_GLGETFRAGMENTLIGHTFVSGIX)_getPrivateProcAddress(_name);
        if (!_glGetFragmentLightfvSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFragmentLightfvSGIX_ptr(light, pname, params);
}

typedef void (APIENTRY * PFN_GLGETFRAGMENTLIGHTIVSGIX)(GLenum light, GLenum pname, GLint * params);
static PFN_GLGETFRAGMENTLIGHTIVSGIX _glGetFragmentLightivSGIX_ptr = NULL;

static inline void APIENTRY _glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint * params) {
    const char *_name = "glGetFragmentLightivSGIX";
    if (!_glGetFragmentLightivSGIX_ptr) {
        _glGetFragmentLightivSGIX_ptr = (PFN_GLGETFRAGMENTLIGHTIVSGIX)_getPrivateProcAddress(_name);
        if (!_glGetFragmentLightivSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFragmentLightivSGIX_ptr(light, pname, params);
}

typedef void (APIENTRY * PFN_GLGETFRAGMENTMATERIALFVSGIX)(GLenum face, GLenum pname, GLfloat * params);
static PFN_GLGETFRAGMENTMATERIALFVSGIX _glGetFragmentMaterialfvSGIX_ptr = NULL;

static inline void APIENTRY _glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat * params) {
    const char *_name = "glGetFragmentMaterialfvSGIX";
    if (!_glGetFragmentMaterialfvSGIX_ptr) {
        _glGetFragmentMaterialfvSGIX_ptr = (PFN_GLGETFRAGMENTMATERIALFVSGIX)_getPrivateProcAddress(_name);
        if (!_glGetFragmentMaterialfvSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFragmentMaterialfvSGIX_ptr(face, pname, params);
}

typedef void (APIENTRY * PFN_GLGETFRAGMENTMATERIALIVSGIX)(GLenum face, GLenum pname, GLint * params);
static PFN_GLGETFRAGMENTMATERIALIVSGIX _glGetFragmentMaterialivSGIX_ptr = NULL;

static inline void APIENTRY _glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint * params) {
    const char *_name = "glGetFragmentMaterialivSGIX";
    if (!_glGetFragmentMaterialivSGIX_ptr) {
        _glGetFragmentMaterialivSGIX_ptr = (PFN_GLGETFRAGMENTMATERIALIVSGIX)_getPrivateProcAddress(_name);
        if (!_glGetFragmentMaterialivSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFragmentMaterialivSGIX_ptr(face, pname, params);
}

typedef void (APIENTRY * PFN_GLLIGHTENVISGIX)(GLenum pname, GLint param);
static PFN_GLLIGHTENVISGIX _glLightEnviSGIX_ptr = NULL;

static inline void APIENTRY _glLightEnviSGIX(GLenum pname, GLint param) {
    const char *_name = "glLightEnviSGIX";
    if (!_glLightEnviSGIX_ptr) {
        _glLightEnviSGIX_ptr = (PFN_GLLIGHTENVISGIX)_getPrivateProcAddress(_name);
        if (!_glLightEnviSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLightEnviSGIX_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLDRAWRANGEELEMENTSEXT)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices);
static PFN_GLDRAWRANGEELEMENTSEXT _glDrawRangeElementsEXT_ptr = NULL;

static inline void APIENTRY _glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices) {
    const char *_name = "glDrawRangeElementsEXT";
    if (!_glDrawRangeElementsEXT_ptr) {
        _glDrawRangeElementsEXT_ptr = (PFN_GLDRAWRANGEELEMENTSEXT)_getPrivateProcAddress(_name);
        if (!_glDrawRangeElementsEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawRangeElementsEXT_ptr(mode, start, end, count, type, indices);
}

typedef void (APIENTRY * PFN_GLAPPLYTEXTUREEXT)(GLenum mode);
static PFN_GLAPPLYTEXTUREEXT _glApplyTextureEXT_ptr = NULL;

static inline void APIENTRY _glApplyTextureEXT(GLenum mode) {
    const char *_name = "glApplyTextureEXT";
    if (!_glApplyTextureEXT_ptr) {
        _glApplyTextureEXT_ptr = (PFN_GLAPPLYTEXTUREEXT)_getPrivateProcAddress(_name);
        if (!_glApplyTextureEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glApplyTextureEXT_ptr(mode);
}

typedef void (APIENTRY * PFN_GLTEXTURELIGHTEXT)(GLenum pname);
static PFN_GLTEXTURELIGHTEXT _glTextureLightEXT_ptr = NULL;

static inline void APIENTRY _glTextureLightEXT(GLenum pname) {
    const char *_name = "glTextureLightEXT";
    if (!_glTextureLightEXT_ptr) {
        _glTextureLightEXT_ptr = (PFN_GLTEXTURELIGHTEXT)_getPrivateProcAddress(_name);
        if (!_glTextureLightEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureLightEXT_ptr(pname);
}

typedef void (APIENTRY * PFN_GLTEXTUREMATERIALEXT)(GLenum face, GLenum mode);
static PFN_GLTEXTUREMATERIALEXT _glTextureMaterialEXT_ptr = NULL;

static inline void APIENTRY _glTextureMaterialEXT(GLenum face, GLenum mode) {
    const char *_name = "glTextureMaterialEXT";
    if (!_glTextureMaterialEXT_ptr) {
        _glTextureMaterialEXT_ptr = (PFN_GLTEXTUREMATERIALEXT)_getPrivateProcAddress(_name);
        if (!_glTextureMaterialEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureMaterialEXT_ptr(face, mode);
}

typedef void (APIENTRY * PFN_GLASYNCMARKERSGIX)(GLuint marker);
static PFN_GLASYNCMARKERSGIX _glAsyncMarkerSGIX_ptr = NULL;

static inline void APIENTRY _glAsyncMarkerSGIX(GLuint marker) {
    const char *_name = "glAsyncMarkerSGIX";
    if (!_glAsyncMarkerSGIX_ptr) {
        _glAsyncMarkerSGIX_ptr = (PFN_GLASYNCMARKERSGIX)_getPrivateProcAddress(_name);
        if (!_glAsyncMarkerSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glAsyncMarkerSGIX_ptr(marker);
}

typedef GLint (APIENTRY * PFN_GLFINISHASYNCSGIX)(GLuint * markerp);
static PFN_GLFINISHASYNCSGIX _glFinishAsyncSGIX_ptr = NULL;

static inline GLint APIENTRY _glFinishAsyncSGIX(GLuint * markerp) {
    const char *_name = "glFinishAsyncSGIX";
    if (!_glFinishAsyncSGIX_ptr) {
        _glFinishAsyncSGIX_ptr = (PFN_GLFINISHASYNCSGIX)_getPrivateProcAddress(_name);
        if (!_glFinishAsyncSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glFinishAsyncSGIX_ptr(markerp);
}

typedef GLint (APIENTRY * PFN_GLPOLLASYNCSGIX)(GLuint * markerp);
static PFN_GLPOLLASYNCSGIX _glPollAsyncSGIX_ptr = NULL;

static inline GLint APIENTRY _glPollAsyncSGIX(GLuint * markerp) {
    const char *_name = "glPollAsyncSGIX";
    if (!_glPollAsyncSGIX_ptr) {
        _glPollAsyncSGIX_ptr = (PFN_GLPOLLASYNCSGIX)_getPrivateProcAddress(_name);
        if (!_glPollAsyncSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glPollAsyncSGIX_ptr(markerp);
}

typedef GLuint (APIENTRY * PFN_GLGENASYNCMARKERSSGIX)(GLsizei range);
static PFN_GLGENASYNCMARKERSSGIX _glGenAsyncMarkersSGIX_ptr = NULL;

static inline GLuint APIENTRY _glGenAsyncMarkersSGIX(GLsizei range) {
    const char *_name = "glGenAsyncMarkersSGIX";
    if (!_glGenAsyncMarkersSGIX_ptr) {
        _glGenAsyncMarkersSGIX_ptr = (PFN_GLGENASYNCMARKERSSGIX)_getPrivateProcAddress(_name);
        if (!_glGenAsyncMarkersSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGenAsyncMarkersSGIX_ptr(range);
}

typedef void (APIENTRY * PFN_GLDELETEASYNCMARKERSSGIX)(GLuint marker, GLsizei range);
static PFN_GLDELETEASYNCMARKERSSGIX _glDeleteAsyncMarkersSGIX_ptr = NULL;

static inline void APIENTRY _glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range) {
    const char *_name = "glDeleteAsyncMarkersSGIX";
    if (!_glDeleteAsyncMarkersSGIX_ptr) {
        _glDeleteAsyncMarkersSGIX_ptr = (PFN_GLDELETEASYNCMARKERSSGIX)_getPrivateProcAddress(_name);
        if (!_glDeleteAsyncMarkersSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteAsyncMarkersSGIX_ptr(marker, range);
}

typedef GLboolean (APIENTRY * PFN_GLISASYNCMARKERSGIX)(GLuint marker);
static PFN_GLISASYNCMARKERSGIX _glIsAsyncMarkerSGIX_ptr = NULL;

static inline GLboolean APIENTRY _glIsAsyncMarkerSGIX(GLuint marker) {
    const char *_name = "glIsAsyncMarkerSGIX";
    if (!_glIsAsyncMarkerSGIX_ptr) {
        _glIsAsyncMarkerSGIX_ptr = (PFN_GLISASYNCMARKERSGIX)_getPrivateProcAddress(_name);
        if (!_glIsAsyncMarkerSGIX_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsAsyncMarkerSGIX_ptr(marker);
}

typedef void (APIENTRY * PFN_GLVERTEXPOINTERVINTEL)(GLint size, GLenum type, const GLvoid * * pointer);
static PFN_GLVERTEXPOINTERVINTEL _glVertexPointervINTEL_ptr = NULL;

static inline void APIENTRY _glVertexPointervINTEL(GLint size, GLenum type, const GLvoid * * pointer) {
    const char *_name = "glVertexPointervINTEL";
    if (!_glVertexPointervINTEL_ptr) {
        _glVertexPointervINTEL_ptr = (PFN_GLVERTEXPOINTERVINTEL)_getPrivateProcAddress(_name);
        if (!_glVertexPointervINTEL_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexPointervINTEL_ptr(size, type, pointer);
}

typedef void (APIENTRY * PFN_GLNORMALPOINTERVINTEL)(GLenum type, const GLvoid * * pointer);
static PFN_GLNORMALPOINTERVINTEL _glNormalPointervINTEL_ptr = NULL;

static inline void APIENTRY _glNormalPointervINTEL(GLenum type, const GLvoid * * pointer) {
    const char *_name = "glNormalPointervINTEL";
    if (!_glNormalPointervINTEL_ptr) {
        _glNormalPointervINTEL_ptr = (PFN_GLNORMALPOINTERVINTEL)_getPrivateProcAddress(_name);
        if (!_glNormalPointervINTEL_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalPointervINTEL_ptr(type, pointer);
}

typedef void (APIENTRY * PFN_GLCOLORPOINTERVINTEL)(GLint size, GLenum type, const GLvoid * * pointer);
static PFN_GLCOLORPOINTERVINTEL _glColorPointervINTEL_ptr = NULL;

static inline void APIENTRY _glColorPointervINTEL(GLint size, GLenum type, const GLvoid * * pointer) {
    const char *_name = "glColorPointervINTEL";
    if (!_glColorPointervINTEL_ptr) {
        _glColorPointervINTEL_ptr = (PFN_GLCOLORPOINTERVINTEL)_getPrivateProcAddress(_name);
        if (!_glColorPointervINTEL_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorPointervINTEL_ptr(size, type, pointer);
}

typedef void (APIENTRY * PFN_GLTEXCOORDPOINTERVINTEL)(GLint size, GLenum type, const GLvoid * * pointer);
static PFN_GLTEXCOORDPOINTERVINTEL _glTexCoordPointervINTEL_ptr = NULL;

static inline void APIENTRY _glTexCoordPointervINTEL(GLint size, GLenum type, const GLvoid * * pointer) {
    const char *_name = "glTexCoordPointervINTEL";
    if (!_glTexCoordPointervINTEL_ptr) {
        _glTexCoordPointervINTEL_ptr = (PFN_GLTEXCOORDPOINTERVINTEL)_getPrivateProcAddress(_name);
        if (!_glTexCoordPointervINTEL_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoordPointervINTEL_ptr(size, type, pointer);
}

typedef void (APIENTRY * PFN_GLPIXELTRANSFORMPARAMETERIEXT)(GLenum target, GLenum pname, GLint param);
static PFN_GLPIXELTRANSFORMPARAMETERIEXT _glPixelTransformParameteriEXT_ptr = NULL;

static inline void APIENTRY _glPixelTransformParameteriEXT(GLenum target, GLenum pname, GLint param) {
    const char *_name = "glPixelTransformParameteriEXT";
    if (!_glPixelTransformParameteriEXT_ptr) {
        _glPixelTransformParameteriEXT_ptr = (PFN_GLPIXELTRANSFORMPARAMETERIEXT)_getPrivateProcAddress(_name);
        if (!_glPixelTransformParameteriEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelTransformParameteriEXT_ptr(target, pname, param);
}

typedef void (APIENTRY * PFN_GLPIXELTRANSFORMPARAMETERFEXT)(GLenum target, GLenum pname, GLfloat param);
static PFN_GLPIXELTRANSFORMPARAMETERFEXT _glPixelTransformParameterfEXT_ptr = NULL;

static inline void APIENTRY _glPixelTransformParameterfEXT(GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glPixelTransformParameterfEXT";
    if (!_glPixelTransformParameterfEXT_ptr) {
        _glPixelTransformParameterfEXT_ptr = (PFN_GLPIXELTRANSFORMPARAMETERFEXT)_getPrivateProcAddress(_name);
        if (!_glPixelTransformParameterfEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelTransformParameterfEXT_ptr(target, pname, param);
}

typedef void (APIENTRY * PFN_GLPIXELTRANSFORMPARAMETERIVEXT)(GLenum target, GLenum pname, const GLint * params);
static PFN_GLPIXELTRANSFORMPARAMETERIVEXT _glPixelTransformParameterivEXT_ptr = NULL;

static inline void APIENTRY _glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glPixelTransformParameterivEXT";
    if (!_glPixelTransformParameterivEXT_ptr) {
        _glPixelTransformParameterivEXT_ptr = (PFN_GLPIXELTRANSFORMPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glPixelTransformParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelTransformParameterivEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLPIXELTRANSFORMPARAMETERFVEXT)(GLenum target, GLenum pname, const GLfloat * params);
static PFN_GLPIXELTRANSFORMPARAMETERFVEXT _glPixelTransformParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glPixelTransformParameterfvEXT";
    if (!_glPixelTransformParameterfvEXT_ptr) {
        _glPixelTransformParameterfvEXT_ptr = (PFN_GLPIXELTRANSFORMPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glPixelTransformParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelTransformParameterfvEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3BEXT)(GLbyte red, GLbyte green, GLbyte blue);
static PFN_GLSECONDARYCOLOR3BEXT _glSecondaryColor3bEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue) {
    const char *_name = "glSecondaryColor3bEXT";
    if (!_glSecondaryColor3bEXT_ptr) {
        _glSecondaryColor3bEXT_ptr = (PFN_GLSECONDARYCOLOR3BEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3bEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3bEXT_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3BVEXT)(const GLbyte * v);
static PFN_GLSECONDARYCOLOR3BVEXT _glSecondaryColor3bvEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3bvEXT(const GLbyte * v) {
    const char *_name = "glSecondaryColor3bvEXT";
    if (!_glSecondaryColor3bvEXT_ptr) {
        _glSecondaryColor3bvEXT_ptr = (PFN_GLSECONDARYCOLOR3BVEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3bvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3bvEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3DEXT)(GLdouble red, GLdouble green, GLdouble blue);
static PFN_GLSECONDARYCOLOR3DEXT _glSecondaryColor3dEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue) {
    const char *_name = "glSecondaryColor3dEXT";
    if (!_glSecondaryColor3dEXT_ptr) {
        _glSecondaryColor3dEXT_ptr = (PFN_GLSECONDARYCOLOR3DEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3dEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3dEXT_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3DVEXT)(const GLdouble * v);
static PFN_GLSECONDARYCOLOR3DVEXT _glSecondaryColor3dvEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3dvEXT(const GLdouble * v) {
    const char *_name = "glSecondaryColor3dvEXT";
    if (!_glSecondaryColor3dvEXT_ptr) {
        _glSecondaryColor3dvEXT_ptr = (PFN_GLSECONDARYCOLOR3DVEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3dvEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3FEXT)(GLfloat red, GLfloat green, GLfloat blue);
static PFN_GLSECONDARYCOLOR3FEXT _glSecondaryColor3fEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue) {
    const char *_name = "glSecondaryColor3fEXT";
    if (!_glSecondaryColor3fEXT_ptr) {
        _glSecondaryColor3fEXT_ptr = (PFN_GLSECONDARYCOLOR3FEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3fEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3fEXT_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3FVEXT)(const GLfloat * v);
static PFN_GLSECONDARYCOLOR3FVEXT _glSecondaryColor3fvEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3fvEXT(const GLfloat * v) {
    const char *_name = "glSecondaryColor3fvEXT";
    if (!_glSecondaryColor3fvEXT_ptr) {
        _glSecondaryColor3fvEXT_ptr = (PFN_GLSECONDARYCOLOR3FVEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3fvEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3IEXT)(GLint red, GLint green, GLint blue);
static PFN_GLSECONDARYCOLOR3IEXT _glSecondaryColor3iEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3iEXT(GLint red, GLint green, GLint blue) {
    const char *_name = "glSecondaryColor3iEXT";
    if (!_glSecondaryColor3iEXT_ptr) {
        _glSecondaryColor3iEXT_ptr = (PFN_GLSECONDARYCOLOR3IEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3iEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3iEXT_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3IVEXT)(const GLint * v);
static PFN_GLSECONDARYCOLOR3IVEXT _glSecondaryColor3ivEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3ivEXT(const GLint * v) {
    const char *_name = "glSecondaryColor3ivEXT";
    if (!_glSecondaryColor3ivEXT_ptr) {
        _glSecondaryColor3ivEXT_ptr = (PFN_GLSECONDARYCOLOR3IVEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3ivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3ivEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3SEXT)(GLshort red, GLshort green, GLshort blue);
static PFN_GLSECONDARYCOLOR3SEXT _glSecondaryColor3sEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue) {
    const char *_name = "glSecondaryColor3sEXT";
    if (!_glSecondaryColor3sEXT_ptr) {
        _glSecondaryColor3sEXT_ptr = (PFN_GLSECONDARYCOLOR3SEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3sEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3sEXT_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3SVEXT)(const GLshort * v);
static PFN_GLSECONDARYCOLOR3SVEXT _glSecondaryColor3svEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3svEXT(const GLshort * v) {
    const char *_name = "glSecondaryColor3svEXT";
    if (!_glSecondaryColor3svEXT_ptr) {
        _glSecondaryColor3svEXT_ptr = (PFN_GLSECONDARYCOLOR3SVEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3svEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3svEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3UBEXT)(GLubyte red, GLubyte green, GLubyte blue);
static PFN_GLSECONDARYCOLOR3UBEXT _glSecondaryColor3ubEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue) {
    const char *_name = "glSecondaryColor3ubEXT";
    if (!_glSecondaryColor3ubEXT_ptr) {
        _glSecondaryColor3ubEXT_ptr = (PFN_GLSECONDARYCOLOR3UBEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3ubEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3ubEXT_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3UBVEXT)(const GLubyte * v);
static PFN_GLSECONDARYCOLOR3UBVEXT _glSecondaryColor3ubvEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3ubvEXT(const GLubyte * v) {
    const char *_name = "glSecondaryColor3ubvEXT";
    if (!_glSecondaryColor3ubvEXT_ptr) {
        _glSecondaryColor3ubvEXT_ptr = (PFN_GLSECONDARYCOLOR3UBVEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3ubvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3ubvEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3UIEXT)(GLuint red, GLuint green, GLuint blue);
static PFN_GLSECONDARYCOLOR3UIEXT _glSecondaryColor3uiEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue) {
    const char *_name = "glSecondaryColor3uiEXT";
    if (!_glSecondaryColor3uiEXT_ptr) {
        _glSecondaryColor3uiEXT_ptr = (PFN_GLSECONDARYCOLOR3UIEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3uiEXT_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3UIVEXT)(const GLuint * v);
static PFN_GLSECONDARYCOLOR3UIVEXT _glSecondaryColor3uivEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3uivEXT(const GLuint * v) {
    const char *_name = "glSecondaryColor3uivEXT";
    if (!_glSecondaryColor3uivEXT_ptr) {
        _glSecondaryColor3uivEXT_ptr = (PFN_GLSECONDARYCOLOR3UIVEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3uivEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3USEXT)(GLushort red, GLushort green, GLushort blue);
static PFN_GLSECONDARYCOLOR3USEXT _glSecondaryColor3usEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue) {
    const char *_name = "glSecondaryColor3usEXT";
    if (!_glSecondaryColor3usEXT_ptr) {
        _glSecondaryColor3usEXT_ptr = (PFN_GLSECONDARYCOLOR3USEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3usEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3usEXT_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3USVEXT)(const GLushort * v);
static PFN_GLSECONDARYCOLOR3USVEXT _glSecondaryColor3usvEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3usvEXT(const GLushort * v) {
    const char *_name = "glSecondaryColor3usvEXT";
    if (!_glSecondaryColor3usvEXT_ptr) {
        _glSecondaryColor3usvEXT_ptr = (PFN_GLSECONDARYCOLOR3USVEXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3usvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3usvEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLORPOINTEREXT)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLSECONDARYCOLORPOINTEREXT _glSecondaryColorPointerEXT_ptr = NULL;

static inline void APIENTRY _glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glSecondaryColorPointerEXT";
    if (!_glSecondaryColorPointerEXT_ptr) {
        _glSecondaryColorPointerEXT_ptr = (PFN_GLSECONDARYCOLORPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glSecondaryColorPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColorPointerEXT_ptr(size, type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLTEXTURENORMALEXT)(GLenum mode);
static PFN_GLTEXTURENORMALEXT _glTextureNormalEXT_ptr = NULL;

static inline void APIENTRY _glTextureNormalEXT(GLenum mode) {
    const char *_name = "glTextureNormalEXT";
    if (!_glTextureNormalEXT_ptr) {
        _glTextureNormalEXT_ptr = (PFN_GLTEXTURENORMALEXT)_getPrivateProcAddress(_name);
        if (!_glTextureNormalEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureNormalEXT_ptr(mode);
}

typedef void (APIENTRY * PFN_GLMULTIDRAWARRAYSEXT)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount);
static PFN_GLMULTIDRAWARRAYSEXT _glMultiDrawArraysEXT_ptr = NULL;

static inline void APIENTRY _glMultiDrawArraysEXT(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount) {
    const char *_name = "glMultiDrawArraysEXT";
    if (!_glMultiDrawArraysEXT_ptr) {
        _glMultiDrawArraysEXT_ptr = (PFN_GLMULTIDRAWARRAYSEXT)_getPrivateProcAddress(_name);
        if (!_glMultiDrawArraysEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiDrawArraysEXT_ptr(mode, first, count, primcount);
}

typedef void (APIENTRY * PFN_GLMULTIDRAWELEMENTSEXT)(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * * indices, GLsizei primcount);
static PFN_GLMULTIDRAWELEMENTSEXT _glMultiDrawElementsEXT_ptr = NULL;

static inline void APIENTRY _glMultiDrawElementsEXT(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * * indices, GLsizei primcount) {
    const char *_name = "glMultiDrawElementsEXT";
    if (!_glMultiDrawElementsEXT_ptr) {
        _glMultiDrawElementsEXT_ptr = (PFN_GLMULTIDRAWELEMENTSEXT)_getPrivateProcAddress(_name);
        if (!_glMultiDrawElementsEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiDrawElementsEXT_ptr(mode, count, type, indices, primcount);
}

typedef void (APIENTRY * PFN_GLFOGCOORDFEXT)(GLfloat coord);
static PFN_GLFOGCOORDFEXT _glFogCoordfEXT_ptr = NULL;

static inline void APIENTRY _glFogCoordfEXT(GLfloat coord) {
    const char *_name = "glFogCoordfEXT";
    if (!_glFogCoordfEXT_ptr) {
        _glFogCoordfEXT_ptr = (PFN_GLFOGCOORDFEXT)_getPrivateProcAddress(_name);
        if (!_glFogCoordfEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoordfEXT_ptr(coord);
}

typedef void (APIENTRY * PFN_GLFOGCOORDFVEXT)(const GLfloat * coord);
static PFN_GLFOGCOORDFVEXT _glFogCoordfvEXT_ptr = NULL;

static inline void APIENTRY _glFogCoordfvEXT(const GLfloat * coord) {
    const char *_name = "glFogCoordfvEXT";
    if (!_glFogCoordfvEXT_ptr) {
        _glFogCoordfvEXT_ptr = (PFN_GLFOGCOORDFVEXT)_getPrivateProcAddress(_name);
        if (!_glFogCoordfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoordfvEXT_ptr(coord);
}

typedef void (APIENTRY * PFN_GLFOGCOORDDEXT)(GLdouble coord);
static PFN_GLFOGCOORDDEXT _glFogCoorddEXT_ptr = NULL;

static inline void APIENTRY _glFogCoorddEXT(GLdouble coord) {
    const char *_name = "glFogCoorddEXT";
    if (!_glFogCoorddEXT_ptr) {
        _glFogCoorddEXT_ptr = (PFN_GLFOGCOORDDEXT)_getPrivateProcAddress(_name);
        if (!_glFogCoorddEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoorddEXT_ptr(coord);
}

typedef void (APIENTRY * PFN_GLFOGCOORDDVEXT)(const GLdouble * coord);
static PFN_GLFOGCOORDDVEXT _glFogCoorddvEXT_ptr = NULL;

static inline void APIENTRY _glFogCoorddvEXT(const GLdouble * coord) {
    const char *_name = "glFogCoorddvEXT";
    if (!_glFogCoorddvEXT_ptr) {
        _glFogCoorddvEXT_ptr = (PFN_GLFOGCOORDDVEXT)_getPrivateProcAddress(_name);
        if (!_glFogCoorddvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoorddvEXT_ptr(coord);
}

typedef void (APIENTRY * PFN_GLFOGCOORDPOINTEREXT)(GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLFOGCOORDPOINTEREXT _glFogCoordPointerEXT_ptr = NULL;

static inline void APIENTRY _glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glFogCoordPointerEXT";
    if (!_glFogCoordPointerEXT_ptr) {
        _glFogCoordPointerEXT_ptr = (PFN_GLFOGCOORDPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glFogCoordPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoordPointerEXT_ptr(type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLTANGENT3BEXT)(GLbyte tx, GLbyte ty, GLbyte tz);
static PFN_GLTANGENT3BEXT _glTangent3bEXT_ptr = NULL;

static inline void APIENTRY _glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz) {
    const char *_name = "glTangent3bEXT";
    if (!_glTangent3bEXT_ptr) {
        _glTangent3bEXT_ptr = (PFN_GLTANGENT3BEXT)_getPrivateProcAddress(_name);
        if (!_glTangent3bEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTangent3bEXT_ptr(tx, ty, tz);
}

typedef void (APIENTRY * PFN_GLTANGENT3BVEXT)(const GLbyte * v);
static PFN_GLTANGENT3BVEXT _glTangent3bvEXT_ptr = NULL;

static inline void APIENTRY _glTangent3bvEXT(const GLbyte * v) {
    const char *_name = "glTangent3bvEXT";
    if (!_glTangent3bvEXT_ptr) {
        _glTangent3bvEXT_ptr = (PFN_GLTANGENT3BVEXT)_getPrivateProcAddress(_name);
        if (!_glTangent3bvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTangent3bvEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLTANGENT3DEXT)(GLdouble tx, GLdouble ty, GLdouble tz);
static PFN_GLTANGENT3DEXT _glTangent3dEXT_ptr = NULL;

static inline void APIENTRY _glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz) {
    const char *_name = "glTangent3dEXT";
    if (!_glTangent3dEXT_ptr) {
        _glTangent3dEXT_ptr = (PFN_GLTANGENT3DEXT)_getPrivateProcAddress(_name);
        if (!_glTangent3dEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTangent3dEXT_ptr(tx, ty, tz);
}

typedef void (APIENTRY * PFN_GLTANGENT3DVEXT)(const GLdouble * v);
static PFN_GLTANGENT3DVEXT _glTangent3dvEXT_ptr = NULL;

static inline void APIENTRY _glTangent3dvEXT(const GLdouble * v) {
    const char *_name = "glTangent3dvEXT";
    if (!_glTangent3dvEXT_ptr) {
        _glTangent3dvEXT_ptr = (PFN_GLTANGENT3DVEXT)_getPrivateProcAddress(_name);
        if (!_glTangent3dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTangent3dvEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLTANGENT3FEXT)(GLfloat tx, GLfloat ty, GLfloat tz);
static PFN_GLTANGENT3FEXT _glTangent3fEXT_ptr = NULL;

static inline void APIENTRY _glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz) {
    const char *_name = "glTangent3fEXT";
    if (!_glTangent3fEXT_ptr) {
        _glTangent3fEXT_ptr = (PFN_GLTANGENT3FEXT)_getPrivateProcAddress(_name);
        if (!_glTangent3fEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTangent3fEXT_ptr(tx, ty, tz);
}

typedef void (APIENTRY * PFN_GLTANGENT3FVEXT)(const GLfloat * v);
static PFN_GLTANGENT3FVEXT _glTangent3fvEXT_ptr = NULL;

static inline void APIENTRY _glTangent3fvEXT(const GLfloat * v) {
    const char *_name = "glTangent3fvEXT";
    if (!_glTangent3fvEXT_ptr) {
        _glTangent3fvEXT_ptr = (PFN_GLTANGENT3FVEXT)_getPrivateProcAddress(_name);
        if (!_glTangent3fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTangent3fvEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLTANGENT3IEXT)(GLint tx, GLint ty, GLint tz);
static PFN_GLTANGENT3IEXT _glTangent3iEXT_ptr = NULL;

static inline void APIENTRY _glTangent3iEXT(GLint tx, GLint ty, GLint tz) {
    const char *_name = "glTangent3iEXT";
    if (!_glTangent3iEXT_ptr) {
        _glTangent3iEXT_ptr = (PFN_GLTANGENT3IEXT)_getPrivateProcAddress(_name);
        if (!_glTangent3iEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTangent3iEXT_ptr(tx, ty, tz);
}

typedef void (APIENTRY * PFN_GLTANGENT3IVEXT)(const GLint * v);
static PFN_GLTANGENT3IVEXT _glTangent3ivEXT_ptr = NULL;

static inline void APIENTRY _glTangent3ivEXT(const GLint * v) {
    const char *_name = "glTangent3ivEXT";
    if (!_glTangent3ivEXT_ptr) {
        _glTangent3ivEXT_ptr = (PFN_GLTANGENT3IVEXT)_getPrivateProcAddress(_name);
        if (!_glTangent3ivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTangent3ivEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLTANGENT3SEXT)(GLshort tx, GLshort ty, GLshort tz);
static PFN_GLTANGENT3SEXT _glTangent3sEXT_ptr = NULL;

static inline void APIENTRY _glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz) {
    const char *_name = "glTangent3sEXT";
    if (!_glTangent3sEXT_ptr) {
        _glTangent3sEXT_ptr = (PFN_GLTANGENT3SEXT)_getPrivateProcAddress(_name);
        if (!_glTangent3sEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTangent3sEXT_ptr(tx, ty, tz);
}

typedef void (APIENTRY * PFN_GLTANGENT3SVEXT)(const GLshort * v);
static PFN_GLTANGENT3SVEXT _glTangent3svEXT_ptr = NULL;

static inline void APIENTRY _glTangent3svEXT(const GLshort * v) {
    const char *_name = "glTangent3svEXT";
    if (!_glTangent3svEXT_ptr) {
        _glTangent3svEXT_ptr = (PFN_GLTANGENT3SVEXT)_getPrivateProcAddress(_name);
        if (!_glTangent3svEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTangent3svEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLBINORMAL3BEXT)(GLbyte bx, GLbyte by, GLbyte bz);
static PFN_GLBINORMAL3BEXT _glBinormal3bEXT_ptr = NULL;

static inline void APIENTRY _glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz) {
    const char *_name = "glBinormal3bEXT";
    if (!_glBinormal3bEXT_ptr) {
        _glBinormal3bEXT_ptr = (PFN_GLBINORMAL3BEXT)_getPrivateProcAddress(_name);
        if (!_glBinormal3bEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBinormal3bEXT_ptr(bx, by, bz);
}

typedef void (APIENTRY * PFN_GLBINORMAL3BVEXT)(const GLbyte * v);
static PFN_GLBINORMAL3BVEXT _glBinormal3bvEXT_ptr = NULL;

static inline void APIENTRY _glBinormal3bvEXT(const GLbyte * v) {
    const char *_name = "glBinormal3bvEXT";
    if (!_glBinormal3bvEXT_ptr) {
        _glBinormal3bvEXT_ptr = (PFN_GLBINORMAL3BVEXT)_getPrivateProcAddress(_name);
        if (!_glBinormal3bvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBinormal3bvEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLBINORMAL3DEXT)(GLdouble bx, GLdouble by, GLdouble bz);
static PFN_GLBINORMAL3DEXT _glBinormal3dEXT_ptr = NULL;

static inline void APIENTRY _glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz) {
    const char *_name = "glBinormal3dEXT";
    if (!_glBinormal3dEXT_ptr) {
        _glBinormal3dEXT_ptr = (PFN_GLBINORMAL3DEXT)_getPrivateProcAddress(_name);
        if (!_glBinormal3dEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBinormal3dEXT_ptr(bx, by, bz);
}

typedef void (APIENTRY * PFN_GLBINORMAL3DVEXT)(const GLdouble * v);
static PFN_GLBINORMAL3DVEXT _glBinormal3dvEXT_ptr = NULL;

static inline void APIENTRY _glBinormal3dvEXT(const GLdouble * v) {
    const char *_name = "glBinormal3dvEXT";
    if (!_glBinormal3dvEXT_ptr) {
        _glBinormal3dvEXT_ptr = (PFN_GLBINORMAL3DVEXT)_getPrivateProcAddress(_name);
        if (!_glBinormal3dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBinormal3dvEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLBINORMAL3FEXT)(GLfloat bx, GLfloat by, GLfloat bz);
static PFN_GLBINORMAL3FEXT _glBinormal3fEXT_ptr = NULL;

static inline void APIENTRY _glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz) {
    const char *_name = "glBinormal3fEXT";
    if (!_glBinormal3fEXT_ptr) {
        _glBinormal3fEXT_ptr = (PFN_GLBINORMAL3FEXT)_getPrivateProcAddress(_name);
        if (!_glBinormal3fEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBinormal3fEXT_ptr(bx, by, bz);
}

typedef void (APIENTRY * PFN_GLBINORMAL3FVEXT)(const GLfloat * v);
static PFN_GLBINORMAL3FVEXT _glBinormal3fvEXT_ptr = NULL;

static inline void APIENTRY _glBinormal3fvEXT(const GLfloat * v) {
    const char *_name = "glBinormal3fvEXT";
    if (!_glBinormal3fvEXT_ptr) {
        _glBinormal3fvEXT_ptr = (PFN_GLBINORMAL3FVEXT)_getPrivateProcAddress(_name);
        if (!_glBinormal3fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBinormal3fvEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLBINORMAL3IEXT)(GLint bx, GLint by, GLint bz);
static PFN_GLBINORMAL3IEXT _glBinormal3iEXT_ptr = NULL;

static inline void APIENTRY _glBinormal3iEXT(GLint bx, GLint by, GLint bz) {
    const char *_name = "glBinormal3iEXT";
    if (!_glBinormal3iEXT_ptr) {
        _glBinormal3iEXT_ptr = (PFN_GLBINORMAL3IEXT)_getPrivateProcAddress(_name);
        if (!_glBinormal3iEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBinormal3iEXT_ptr(bx, by, bz);
}

typedef void (APIENTRY * PFN_GLBINORMAL3IVEXT)(const GLint * v);
static PFN_GLBINORMAL3IVEXT _glBinormal3ivEXT_ptr = NULL;

static inline void APIENTRY _glBinormal3ivEXT(const GLint * v) {
    const char *_name = "glBinormal3ivEXT";
    if (!_glBinormal3ivEXT_ptr) {
        _glBinormal3ivEXT_ptr = (PFN_GLBINORMAL3IVEXT)_getPrivateProcAddress(_name);
        if (!_glBinormal3ivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBinormal3ivEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLBINORMAL3SEXT)(GLshort bx, GLshort by, GLshort bz);
static PFN_GLBINORMAL3SEXT _glBinormal3sEXT_ptr = NULL;

static inline void APIENTRY _glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz) {
    const char *_name = "glBinormal3sEXT";
    if (!_glBinormal3sEXT_ptr) {
        _glBinormal3sEXT_ptr = (PFN_GLBINORMAL3SEXT)_getPrivateProcAddress(_name);
        if (!_glBinormal3sEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBinormal3sEXT_ptr(bx, by, bz);
}

typedef void (APIENTRY * PFN_GLBINORMAL3SVEXT)(const GLshort * v);
static PFN_GLBINORMAL3SVEXT _glBinormal3svEXT_ptr = NULL;

static inline void APIENTRY _glBinormal3svEXT(const GLshort * v) {
    const char *_name = "glBinormal3svEXT";
    if (!_glBinormal3svEXT_ptr) {
        _glBinormal3svEXT_ptr = (PFN_GLBINORMAL3SVEXT)_getPrivateProcAddress(_name);
        if (!_glBinormal3svEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBinormal3svEXT_ptr(v);
}

typedef void (APIENTRY * PFN_GLTANGENTPOINTEREXT)(GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLTANGENTPOINTEREXT _glTangentPointerEXT_ptr = NULL;

static inline void APIENTRY _glTangentPointerEXT(GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glTangentPointerEXT";
    if (!_glTangentPointerEXT_ptr) {
        _glTangentPointerEXT_ptr = (PFN_GLTANGENTPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glTangentPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTangentPointerEXT_ptr(type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLBINORMALPOINTEREXT)(GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLBINORMALPOINTEREXT _glBinormalPointerEXT_ptr = NULL;

static inline void APIENTRY _glBinormalPointerEXT(GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glBinormalPointerEXT";
    if (!_glBinormalPointerEXT_ptr) {
        _glBinormalPointerEXT_ptr = (PFN_GLBINORMALPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glBinormalPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBinormalPointerEXT_ptr(type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLFINISHTEXTURESUNX)(void);
static PFN_GLFINISHTEXTURESUNX _glFinishTextureSUNX_ptr = NULL;

static inline void APIENTRY _glFinishTextureSUNX(void) {
    const char *_name = "glFinishTextureSUNX";
    if (!_glFinishTextureSUNX_ptr) {
        _glFinishTextureSUNX_ptr = (PFN_GLFINISHTEXTURESUNX)_getPrivateProcAddress(_name);
        if (!_glFinishTextureSUNX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFinishTextureSUNX_ptr();
}

typedef void (APIENTRY * PFN_GLGLOBALALPHAFACTORBSUN)(GLbyte factor);
static PFN_GLGLOBALALPHAFACTORBSUN _glGlobalAlphaFactorbSUN_ptr = NULL;

static inline void APIENTRY _glGlobalAlphaFactorbSUN(GLbyte factor) {
    const char *_name = "glGlobalAlphaFactorbSUN";
    if (!_glGlobalAlphaFactorbSUN_ptr) {
        _glGlobalAlphaFactorbSUN_ptr = (PFN_GLGLOBALALPHAFACTORBSUN)_getPrivateProcAddress(_name);
        if (!_glGlobalAlphaFactorbSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGlobalAlphaFactorbSUN_ptr(factor);
}

typedef void (APIENTRY * PFN_GLGLOBALALPHAFACTORSSUN)(GLshort factor);
static PFN_GLGLOBALALPHAFACTORSSUN _glGlobalAlphaFactorsSUN_ptr = NULL;

static inline void APIENTRY _glGlobalAlphaFactorsSUN(GLshort factor) {
    const char *_name = "glGlobalAlphaFactorsSUN";
    if (!_glGlobalAlphaFactorsSUN_ptr) {
        _glGlobalAlphaFactorsSUN_ptr = (PFN_GLGLOBALALPHAFACTORSSUN)_getPrivateProcAddress(_name);
        if (!_glGlobalAlphaFactorsSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGlobalAlphaFactorsSUN_ptr(factor);
}

typedef void (APIENTRY * PFN_GLGLOBALALPHAFACTORISUN)(GLint factor);
static PFN_GLGLOBALALPHAFACTORISUN _glGlobalAlphaFactoriSUN_ptr = NULL;

static inline void APIENTRY _glGlobalAlphaFactoriSUN(GLint factor) {
    const char *_name = "glGlobalAlphaFactoriSUN";
    if (!_glGlobalAlphaFactoriSUN_ptr) {
        _glGlobalAlphaFactoriSUN_ptr = (PFN_GLGLOBALALPHAFACTORISUN)_getPrivateProcAddress(_name);
        if (!_glGlobalAlphaFactoriSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGlobalAlphaFactoriSUN_ptr(factor);
}

typedef void (APIENTRY * PFN_GLGLOBALALPHAFACTORFSUN)(GLfloat factor);
static PFN_GLGLOBALALPHAFACTORFSUN _glGlobalAlphaFactorfSUN_ptr = NULL;

static inline void APIENTRY _glGlobalAlphaFactorfSUN(GLfloat factor) {
    const char *_name = "glGlobalAlphaFactorfSUN";
    if (!_glGlobalAlphaFactorfSUN_ptr) {
        _glGlobalAlphaFactorfSUN_ptr = (PFN_GLGLOBALALPHAFACTORFSUN)_getPrivateProcAddress(_name);
        if (!_glGlobalAlphaFactorfSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGlobalAlphaFactorfSUN_ptr(factor);
}

typedef void (APIENTRY * PFN_GLGLOBALALPHAFACTORDSUN)(GLdouble factor);
static PFN_GLGLOBALALPHAFACTORDSUN _glGlobalAlphaFactordSUN_ptr = NULL;

static inline void APIENTRY _glGlobalAlphaFactordSUN(GLdouble factor) {
    const char *_name = "glGlobalAlphaFactordSUN";
    if (!_glGlobalAlphaFactordSUN_ptr) {
        _glGlobalAlphaFactordSUN_ptr = (PFN_GLGLOBALALPHAFACTORDSUN)_getPrivateProcAddress(_name);
        if (!_glGlobalAlphaFactordSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGlobalAlphaFactordSUN_ptr(factor);
}

typedef void (APIENTRY * PFN_GLGLOBALALPHAFACTORUBSUN)(GLubyte factor);
static PFN_GLGLOBALALPHAFACTORUBSUN _glGlobalAlphaFactorubSUN_ptr = NULL;

static inline void APIENTRY _glGlobalAlphaFactorubSUN(GLubyte factor) {
    const char *_name = "glGlobalAlphaFactorubSUN";
    if (!_glGlobalAlphaFactorubSUN_ptr) {
        _glGlobalAlphaFactorubSUN_ptr = (PFN_GLGLOBALALPHAFACTORUBSUN)_getPrivateProcAddress(_name);
        if (!_glGlobalAlphaFactorubSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGlobalAlphaFactorubSUN_ptr(factor);
}

typedef void (APIENTRY * PFN_GLGLOBALALPHAFACTORUSSUN)(GLushort factor);
static PFN_GLGLOBALALPHAFACTORUSSUN _glGlobalAlphaFactorusSUN_ptr = NULL;

static inline void APIENTRY _glGlobalAlphaFactorusSUN(GLushort factor) {
    const char *_name = "glGlobalAlphaFactorusSUN";
    if (!_glGlobalAlphaFactorusSUN_ptr) {
        _glGlobalAlphaFactorusSUN_ptr = (PFN_GLGLOBALALPHAFACTORUSSUN)_getPrivateProcAddress(_name);
        if (!_glGlobalAlphaFactorusSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGlobalAlphaFactorusSUN_ptr(factor);
}

typedef void (APIENTRY * PFN_GLGLOBALALPHAFACTORUISUN)(GLuint factor);
static PFN_GLGLOBALALPHAFACTORUISUN _glGlobalAlphaFactoruiSUN_ptr = NULL;

static inline void APIENTRY _glGlobalAlphaFactoruiSUN(GLuint factor) {
    const char *_name = "glGlobalAlphaFactoruiSUN";
    if (!_glGlobalAlphaFactoruiSUN_ptr) {
        _glGlobalAlphaFactoruiSUN_ptr = (PFN_GLGLOBALALPHAFACTORUISUN)_getPrivateProcAddress(_name);
        if (!_glGlobalAlphaFactoruiSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGlobalAlphaFactoruiSUN_ptr(factor);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUISUN)(GLuint code);
static PFN_GLREPLACEMENTCODEUISUN _glReplacementCodeuiSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiSUN(GLuint code) {
    const char *_name = "glReplacementCodeuiSUN";
    if (!_glReplacementCodeuiSUN_ptr) {
        _glReplacementCodeuiSUN_ptr = (PFN_GLREPLACEMENTCODEUISUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiSUN_ptr(code);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUSSUN)(GLushort code);
static PFN_GLREPLACEMENTCODEUSSUN _glReplacementCodeusSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeusSUN(GLushort code) {
    const char *_name = "glReplacementCodeusSUN";
    if (!_glReplacementCodeusSUN_ptr) {
        _glReplacementCodeusSUN_ptr = (PFN_GLREPLACEMENTCODEUSSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeusSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeusSUN_ptr(code);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUBSUN)(GLubyte code);
static PFN_GLREPLACEMENTCODEUBSUN _glReplacementCodeubSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeubSUN(GLubyte code) {
    const char *_name = "glReplacementCodeubSUN";
    if (!_glReplacementCodeubSUN_ptr) {
        _glReplacementCodeubSUN_ptr = (PFN_GLREPLACEMENTCODEUBSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeubSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeubSUN_ptr(code);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUIVSUN)(const GLuint * code);
static PFN_GLREPLACEMENTCODEUIVSUN _glReplacementCodeuivSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuivSUN(const GLuint * code) {
    const char *_name = "glReplacementCodeuivSUN";
    if (!_glReplacementCodeuivSUN_ptr) {
        _glReplacementCodeuivSUN_ptr = (PFN_GLREPLACEMENTCODEUIVSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuivSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuivSUN_ptr(code);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUSVSUN)(const GLushort * code);
static PFN_GLREPLACEMENTCODEUSVSUN _glReplacementCodeusvSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeusvSUN(const GLushort * code) {
    const char *_name = "glReplacementCodeusvSUN";
    if (!_glReplacementCodeusvSUN_ptr) {
        _glReplacementCodeusvSUN_ptr = (PFN_GLREPLACEMENTCODEUSVSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeusvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeusvSUN_ptr(code);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUBVSUN)(const GLubyte * code);
static PFN_GLREPLACEMENTCODEUBVSUN _glReplacementCodeubvSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeubvSUN(const GLubyte * code) {
    const char *_name = "glReplacementCodeubvSUN";
    if (!_glReplacementCodeubvSUN_ptr) {
        _glReplacementCodeubvSUN_ptr = (PFN_GLREPLACEMENTCODEUBVSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeubvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeubvSUN_ptr(code);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEPOINTERSUN)(GLenum type, GLsizei stride, const GLvoid * * pointer);
static PFN_GLREPLACEMENTCODEPOINTERSUN _glReplacementCodePointerSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodePointerSUN(GLenum type, GLsizei stride, const GLvoid * * pointer) {
    const char *_name = "glReplacementCodePointerSUN";
    if (!_glReplacementCodePointerSUN_ptr) {
        _glReplacementCodePointerSUN_ptr = (PFN_GLREPLACEMENTCODEPOINTERSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodePointerSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodePointerSUN_ptr(type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLCOLOR4UBVERTEX2FSUN)(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
static PFN_GLCOLOR4UBVERTEX2FSUN _glColor4ubVertex2fSUN_ptr = NULL;

static inline void APIENTRY _glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y) {
    const char *_name = "glColor4ubVertex2fSUN";
    if (!_glColor4ubVertex2fSUN_ptr) {
        _glColor4ubVertex2fSUN_ptr = (PFN_GLCOLOR4UBVERTEX2FSUN)_getPrivateProcAddress(_name);
        if (!_glColor4ubVertex2fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4ubVertex2fSUN_ptr(r, g, b, a, x, y);
}

typedef void (APIENTRY * PFN_GLCOLOR4UBVERTEX2FVSUN)(const GLubyte * c, const GLfloat * v);
static PFN_GLCOLOR4UBVERTEX2FVSUN _glColor4ubVertex2fvSUN_ptr = NULL;

static inline void APIENTRY _glColor4ubVertex2fvSUN(const GLubyte * c, const GLfloat * v) {
    const char *_name = "glColor4ubVertex2fvSUN";
    if (!_glColor4ubVertex2fvSUN_ptr) {
        _glColor4ubVertex2fvSUN_ptr = (PFN_GLCOLOR4UBVERTEX2FVSUN)_getPrivateProcAddress(_name);
        if (!_glColor4ubVertex2fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4ubVertex2fvSUN_ptr(c, v);
}

typedef void (APIENTRY * PFN_GLCOLOR4UBVERTEX3FSUN)(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLCOLOR4UBVERTEX3FSUN _glColor4ubVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glColor4ubVertex3fSUN";
    if (!_glColor4ubVertex3fSUN_ptr) {
        _glColor4ubVertex3fSUN_ptr = (PFN_GLCOLOR4UBVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glColor4ubVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4ubVertex3fSUN_ptr(r, g, b, a, x, y, z);
}

typedef void (APIENTRY * PFN_GLCOLOR4UBVERTEX3FVSUN)(const GLubyte * c, const GLfloat * v);
static PFN_GLCOLOR4UBVERTEX3FVSUN _glColor4ubVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glColor4ubVertex3fvSUN(const GLubyte * c, const GLfloat * v) {
    const char *_name = "glColor4ubVertex3fvSUN";
    if (!_glColor4ubVertex3fvSUN_ptr) {
        _glColor4ubVertex3fvSUN_ptr = (PFN_GLCOLOR4UBVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glColor4ubVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4ubVertex3fvSUN_ptr(c, v);
}

typedef void (APIENTRY * PFN_GLCOLOR3FVERTEX3FSUN)(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLCOLOR3FVERTEX3FSUN _glColor3fVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glColor3fVertex3fSUN";
    if (!_glColor3fVertex3fSUN_ptr) {
        _glColor3fVertex3fSUN_ptr = (PFN_GLCOLOR3FVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glColor3fVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3fVertex3fSUN_ptr(r, g, b, x, y, z);
}

typedef void (APIENTRY * PFN_GLCOLOR3FVERTEX3FVSUN)(const GLfloat * c, const GLfloat * v);
static PFN_GLCOLOR3FVERTEX3FVSUN _glColor3fVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glColor3fVertex3fvSUN(const GLfloat * c, const GLfloat * v) {
    const char *_name = "glColor3fVertex3fvSUN";
    if (!_glColor3fVertex3fvSUN_ptr) {
        _glColor3fVertex3fvSUN_ptr = (PFN_GLCOLOR3FVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glColor3fVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3fVertex3fvSUN_ptr(c, v);
}

typedef void (APIENTRY * PFN_GLNORMAL3FVERTEX3FSUN)(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLNORMAL3FVERTEX3FSUN _glNormal3fVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glNormal3fVertex3fSUN";
    if (!_glNormal3fVertex3fSUN_ptr) {
        _glNormal3fVertex3fSUN_ptr = (PFN_GLNORMAL3FVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glNormal3fVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3fVertex3fSUN_ptr(nx, ny, nz, x, y, z);
}

typedef void (APIENTRY * PFN_GLNORMAL3FVERTEX3FVSUN)(const GLfloat * n, const GLfloat * v);
static PFN_GLNORMAL3FVERTEX3FVSUN _glNormal3fVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glNormal3fVertex3fvSUN(const GLfloat * n, const GLfloat * v) {
    const char *_name = "glNormal3fVertex3fvSUN";
    if (!_glNormal3fVertex3fvSUN_ptr) {
        _glNormal3fVertex3fvSUN_ptr = (PFN_GLNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glNormal3fVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3fVertex3fvSUN_ptr(n, v);
}

typedef void (APIENTRY * PFN_GLCOLOR4FNORMAL3FVERTEX3FSUN)(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLCOLOR4FNORMAL3FVERTEX3FSUN _glColor4fNormal3fVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glColor4fNormal3fVertex3fSUN";
    if (!_glColor4fNormal3fVertex3fSUN_ptr) {
        _glColor4fNormal3fVertex3fSUN_ptr = (PFN_GLCOLOR4FNORMAL3FVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glColor4fNormal3fVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4fNormal3fVertex3fSUN_ptr(r, g, b, a, nx, ny, nz, x, y, z);
}

typedef void (APIENTRY * PFN_GLCOLOR4FNORMAL3FVERTEX3FVSUN)(const GLfloat * c, const GLfloat * n, const GLfloat * v);
static PFN_GLCOLOR4FNORMAL3FVERTEX3FVSUN _glColor4fNormal3fVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glColor4fNormal3fVertex3fvSUN(const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glColor4fNormal3fVertex3fvSUN";
    if (!_glColor4fNormal3fVertex3fvSUN_ptr) {
        _glColor4fNormal3fVertex3fvSUN_ptr = (PFN_GLCOLOR4FNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glColor4fNormal3fVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4fNormal3fVertex3fvSUN_ptr(c, n, v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2FVERTEX3FSUN)(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLTEXCOORD2FVERTEX3FSUN _glTexCoord2fVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glTexCoord2fVertex3fSUN";
    if (!_glTexCoord2fVertex3fSUN_ptr) {
        _glTexCoord2fVertex3fSUN_ptr = (PFN_GLTEXCOORD2FVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord2fVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2fVertex3fSUN_ptr(s, t, x, y, z);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2FVERTEX3FVSUN)(const GLfloat * tc, const GLfloat * v);
static PFN_GLTEXCOORD2FVERTEX3FVSUN _glTexCoord2fVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord2fVertex3fvSUN(const GLfloat * tc, const GLfloat * v) {
    const char *_name = "glTexCoord2fVertex3fvSUN";
    if (!_glTexCoord2fVertex3fvSUN_ptr) {
        _glTexCoord2fVertex3fvSUN_ptr = (PFN_GLTEXCOORD2FVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord2fVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2fVertex3fvSUN_ptr(tc, v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4FVERTEX4FSUN)(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLTEXCOORD4FVERTEX4FSUN _glTexCoord4fVertex4fSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glTexCoord4fVertex4fSUN";
    if (!_glTexCoord4fVertex4fSUN_ptr) {
        _glTexCoord4fVertex4fSUN_ptr = (PFN_GLTEXCOORD4FVERTEX4FSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord4fVertex4fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4fVertex4fSUN_ptr(s, t, p, q, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4FVERTEX4FVSUN)(const GLfloat * tc, const GLfloat * v);
static PFN_GLTEXCOORD4FVERTEX4FVSUN _glTexCoord4fVertex4fvSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord4fVertex4fvSUN(const GLfloat * tc, const GLfloat * v) {
    const char *_name = "glTexCoord4fVertex4fvSUN";
    if (!_glTexCoord4fVertex4fvSUN_ptr) {
        _glTexCoord4fVertex4fvSUN_ptr = (PFN_GLTEXCOORD4FVERTEX4FVSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord4fVertex4fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4fVertex4fvSUN_ptr(tc, v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2FCOLOR4UBVERTEX3FSUN)(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLTEXCOORD2FCOLOR4UBVERTEX3FSUN _glTexCoord2fColor4ubVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glTexCoord2fColor4ubVertex3fSUN";
    if (!_glTexCoord2fColor4ubVertex3fSUN_ptr) {
        _glTexCoord2fColor4ubVertex3fSUN_ptr = (PFN_GLTEXCOORD2FCOLOR4UBVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord2fColor4ubVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2fColor4ubVertex3fSUN_ptr(s, t, r, g, b, a, x, y, z);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2FCOLOR4UBVERTEX3FVSUN)(const GLfloat * tc, const GLubyte * c, const GLfloat * v);
static PFN_GLTEXCOORD2FCOLOR4UBVERTEX3FVSUN _glTexCoord2fColor4ubVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord2fColor4ubVertex3fvSUN(const GLfloat * tc, const GLubyte * c, const GLfloat * v) {
    const char *_name = "glTexCoord2fColor4ubVertex3fvSUN";
    if (!_glTexCoord2fColor4ubVertex3fvSUN_ptr) {
        _glTexCoord2fColor4ubVertex3fvSUN_ptr = (PFN_GLTEXCOORD2FCOLOR4UBVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord2fColor4ubVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2fColor4ubVertex3fvSUN_ptr(tc, c, v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2FCOLOR3FVERTEX3FSUN)(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLTEXCOORD2FCOLOR3FVERTEX3FSUN _glTexCoord2fColor3fVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glTexCoord2fColor3fVertex3fSUN";
    if (!_glTexCoord2fColor3fVertex3fSUN_ptr) {
        _glTexCoord2fColor3fVertex3fSUN_ptr = (PFN_GLTEXCOORD2FCOLOR3FVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord2fColor3fVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2fColor3fVertex3fSUN_ptr(s, t, r, g, b, x, y, z);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2FCOLOR3FVERTEX3FVSUN)(const GLfloat * tc, const GLfloat * c, const GLfloat * v);
static PFN_GLTEXCOORD2FCOLOR3FVERTEX3FVSUN _glTexCoord2fColor3fVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord2fColor3fVertex3fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * v) {
    const char *_name = "glTexCoord2fColor3fVertex3fvSUN";
    if (!_glTexCoord2fColor3fVertex3fvSUN_ptr) {
        _glTexCoord2fColor3fVertex3fvSUN_ptr = (PFN_GLTEXCOORD2FCOLOR3FVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord2fColor3fVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2fColor3fVertex3fvSUN_ptr(tc, c, v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2FNORMAL3FVERTEX3FSUN)(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLTEXCOORD2FNORMAL3FVERTEX3FSUN _glTexCoord2fNormal3fVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glTexCoord2fNormal3fVertex3fSUN";
    if (!_glTexCoord2fNormal3fVertex3fSUN_ptr) {
        _glTexCoord2fNormal3fVertex3fSUN_ptr = (PFN_GLTEXCOORD2FNORMAL3FVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord2fNormal3fVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2fNormal3fVertex3fSUN_ptr(s, t, nx, ny, nz, x, y, z);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2FNORMAL3FVERTEX3FVSUN)(const GLfloat * tc, const GLfloat * n, const GLfloat * v);
static PFN_GLTEXCOORD2FNORMAL3FVERTEX3FVSUN _glTexCoord2fNormal3fVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord2fNormal3fVertex3fvSUN(const GLfloat * tc, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glTexCoord2fNormal3fVertex3fvSUN";
    if (!_glTexCoord2fNormal3fVertex3fvSUN_ptr) {
        _glTexCoord2fNormal3fVertex3fvSUN_ptr = (PFN_GLTEXCOORD2FNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord2fNormal3fVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2fNormal3fVertex3fvSUN_ptr(tc, n, v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN)(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN _glTexCoord2fColor4fNormal3fVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glTexCoord2fColor4fNormal3fVertex3fSUN";
    if (!_glTexCoord2fColor4fNormal3fVertex3fSUN_ptr) {
        _glTexCoord2fColor4fNormal3fVertex3fSUN_ptr = (PFN_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord2fColor4fNormal3fVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2fColor4fNormal3fVertex3fSUN_ptr(s, t, r, g, b, a, nx, ny, nz, x, y, z);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN)(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v);
static PFN_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN _glTexCoord2fColor4fNormal3fVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glTexCoord2fColor4fNormal3fVertex3fvSUN";
    if (!_glTexCoord2fColor4fNormal3fVertex3fvSUN_ptr) {
        _glTexCoord2fColor4fNormal3fVertex3fvSUN_ptr = (PFN_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord2fColor4fNormal3fVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2fColor4fNormal3fVertex3fvSUN_ptr(tc, c, n, v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUN)(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUN _glTexCoord4fColor4fNormal3fVertex4fSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glTexCoord4fColor4fNormal3fVertex4fSUN";
    if (!_glTexCoord4fColor4fNormal3fVertex4fSUN_ptr) {
        _glTexCoord4fColor4fNormal3fVertex4fSUN_ptr = (PFN_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord4fColor4fNormal3fVertex4fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4fColor4fNormal3fVertex4fSUN_ptr(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUN)(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v);
static PFN_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUN _glTexCoord4fColor4fNormal3fVertex4fvSUN_ptr = NULL;

static inline void APIENTRY _glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glTexCoord4fColor4fNormal3fVertex4fvSUN";
    if (!_glTexCoord4fColor4fNormal3fVertex4fvSUN_ptr) {
        _glTexCoord4fColor4fNormal3fVertex4fvSUN_ptr = (PFN_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUN)_getPrivateProcAddress(_name);
        if (!_glTexCoord4fColor4fNormal3fVertex4fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4fColor4fNormal3fVertex4fvSUN_ptr(tc, c, n, v);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUIVERTEX3FSUN)(GLuint rc, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLREPLACEMENTCODEUIVERTEX3FSUN _glReplacementCodeuiVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiVertex3fSUN";
    if (!_glReplacementCodeuiVertex3fSUN_ptr) {
        _glReplacementCodeuiVertex3fSUN_ptr = (PFN_GLREPLACEMENTCODEUIVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiVertex3fSUN_ptr(rc, x, y, z);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUIVERTEX3FVSUN)(const GLuint * rc, const GLfloat * v);
static PFN_GLREPLACEMENTCODEUIVERTEX3FVSUN _glReplacementCodeuiVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiVertex3fvSUN(const GLuint * rc, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiVertex3fvSUN";
    if (!_glReplacementCodeuiVertex3fvSUN_ptr) {
        _glReplacementCodeuiVertex3fvSUN_ptr = (PFN_GLREPLACEMENTCODEUIVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiVertex3fvSUN_ptr(rc, v);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUN)(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUN _glReplacementCodeuiColor4ubVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiColor4ubVertex3fSUN";
    if (!_glReplacementCodeuiColor4ubVertex3fSUN_ptr) {
        _glReplacementCodeuiColor4ubVertex3fSUN_ptr = (PFN_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiColor4ubVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiColor4ubVertex3fSUN_ptr(rc, r, g, b, a, x, y, z);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUN)(const GLuint * rc, const GLubyte * c, const GLfloat * v);
static PFN_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUN _glReplacementCodeuiColor4ubVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint * rc, const GLubyte * c, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiColor4ubVertex3fvSUN";
    if (!_glReplacementCodeuiColor4ubVertex3fvSUN_ptr) {
        _glReplacementCodeuiColor4ubVertex3fvSUN_ptr = (PFN_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiColor4ubVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiColor4ubVertex3fvSUN_ptr(rc, c, v);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUICOLOR3FVERTEX3FSUN)(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLREPLACEMENTCODEUICOLOR3FVERTEX3FSUN _glReplacementCodeuiColor3fVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiColor3fVertex3fSUN";
    if (!_glReplacementCodeuiColor3fVertex3fSUN_ptr) {
        _glReplacementCodeuiColor3fVertex3fSUN_ptr = (PFN_GLREPLACEMENTCODEUICOLOR3FVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiColor3fVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiColor3fVertex3fSUN_ptr(rc, r, g, b, x, y, z);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUN)(const GLuint * rc, const GLfloat * c, const GLfloat * v);
static PFN_GLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUN _glReplacementCodeuiColor3fVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiColor3fVertex3fvSUN(const GLuint * rc, const GLfloat * c, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiColor3fVertex3fvSUN";
    if (!_glReplacementCodeuiColor3fVertex3fvSUN_ptr) {
        _glReplacementCodeuiColor3fVertex3fvSUN_ptr = (PFN_GLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiColor3fVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiColor3fVertex3fvSUN_ptr(rc, c, v);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUINORMAL3FVERTEX3FSUN)(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLREPLACEMENTCODEUINORMAL3FVERTEX3FSUN _glReplacementCodeuiNormal3fVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiNormal3fVertex3fSUN";
    if (!_glReplacementCodeuiNormal3fVertex3fSUN_ptr) {
        _glReplacementCodeuiNormal3fVertex3fSUN_ptr = (PFN_GLREPLACEMENTCODEUINORMAL3FVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiNormal3fVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiNormal3fVertex3fSUN_ptr(rc, nx, ny, nz, x, y, z);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUN)(const GLuint * rc, const GLfloat * n, const GLfloat * v);
static PFN_GLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUN _glReplacementCodeuiNormal3fVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiNormal3fVertex3fvSUN";
    if (!_glReplacementCodeuiNormal3fVertex3fvSUN_ptr) {
        _glReplacementCodeuiNormal3fVertex3fvSUN_ptr = (PFN_GLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiNormal3fVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiNormal3fVertex3fvSUN_ptr(rc, n, v);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUN)(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUN _glReplacementCodeuiColor4fNormal3fVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiColor4fNormal3fVertex3fSUN";
    if (!_glReplacementCodeuiColor4fNormal3fVertex3fSUN_ptr) {
        _glReplacementCodeuiColor4fNormal3fVertex3fSUN_ptr = (PFN_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiColor4fNormal3fVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiColor4fNormal3fVertex3fSUN_ptr(rc, r, g, b, a, nx, ny, nz, x, y, z);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUN)(const GLuint * rc, const GLfloat * c, const GLfloat * n, const GLfloat * v);
static PFN_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUN _glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiColor4fNormal3fVertex3fvSUN";
    if (!_glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ptr) {
        _glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ptr = (PFN_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ptr(rc, c, n, v);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUN)(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUN _glReplacementCodeuiTexCoord2fVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiTexCoord2fVertex3fSUN";
    if (!_glReplacementCodeuiTexCoord2fVertex3fSUN_ptr) {
        _glReplacementCodeuiTexCoord2fVertex3fSUN_ptr = (PFN_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiTexCoord2fVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiTexCoord2fVertex3fSUN_ptr(rc, s, t, x, y, z);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUN)(const GLuint * rc, const GLfloat * tc, const GLfloat * v);
static PFN_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUN _glReplacementCodeuiTexCoord2fVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiTexCoord2fVertex3fvSUN";
    if (!_glReplacementCodeuiTexCoord2fVertex3fvSUN_ptr) {
        _glReplacementCodeuiTexCoord2fVertex3fvSUN_ptr = (PFN_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiTexCoord2fVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiTexCoord2fVertex3fvSUN_ptr(rc, tc, v);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUN)(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUN _glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN";
    if (!_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ptr) {
        _glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ptr = (PFN_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ptr(rc, s, t, nx, ny, nz, x, y, z);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUN)(const GLuint * rc, const GLfloat * tc, const GLfloat * n, const GLfloat * v);
static PFN_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUN _glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN";
    if (!_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ptr) {
        _glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ptr = (PFN_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ptr(rc, tc, n, v);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN)(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN";
    if (!_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ptr) {
        _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ptr = (PFN_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ptr(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
}

typedef void (APIENTRY * PFN_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN)(const GLuint * rc, const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v);
static PFN_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ptr = NULL;

static inline void APIENTRY _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN";
    if (!_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ptr) {
        _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ptr = (PFN_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress(_name);
        if (!_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ptr(rc, tc, c, n, v);
}

typedef void (APIENTRY * PFN_GLBLENDFUNCSEPARATEEXT)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
static PFN_GLBLENDFUNCSEPARATEEXT _glBlendFuncSeparateEXT_ptr = NULL;

static inline void APIENTRY _glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
    const char *_name = "glBlendFuncSeparateEXT";
    if (!_glBlendFuncSeparateEXT_ptr) {
        _glBlendFuncSeparateEXT_ptr = (PFN_GLBLENDFUNCSEPARATEEXT)_getPrivateProcAddress(_name);
        if (!_glBlendFuncSeparateEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendFuncSeparateEXT_ptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

typedef void (APIENTRY * PFN_GLBLENDFUNCSEPARATEINGR)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
static PFN_GLBLENDFUNCSEPARATEINGR _glBlendFuncSeparateINGR_ptr = NULL;

static inline void APIENTRY _glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
    const char *_name = "glBlendFuncSeparateINGR";
    if (!_glBlendFuncSeparateINGR_ptr) {
        _glBlendFuncSeparateINGR_ptr = (PFN_GLBLENDFUNCSEPARATEINGR)_getPrivateProcAddress(_name);
        if (!_glBlendFuncSeparateINGR_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendFuncSeparateINGR_ptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

typedef void (APIENTRY * PFN_GLVERTEXWEIGHTFEXT)(GLfloat weight);
static PFN_GLVERTEXWEIGHTFEXT _glVertexWeightfEXT_ptr = NULL;

static inline void APIENTRY _glVertexWeightfEXT(GLfloat weight) {
    const char *_name = "glVertexWeightfEXT";
    if (!_glVertexWeightfEXT_ptr) {
        _glVertexWeightfEXT_ptr = (PFN_GLVERTEXWEIGHTFEXT)_getPrivateProcAddress(_name);
        if (!_glVertexWeightfEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexWeightfEXT_ptr(weight);
}

typedef void (APIENTRY * PFN_GLVERTEXWEIGHTFVEXT)(const GLfloat * weight);
static PFN_GLVERTEXWEIGHTFVEXT _glVertexWeightfvEXT_ptr = NULL;

static inline void APIENTRY _glVertexWeightfvEXT(const GLfloat * weight) {
    const char *_name = "glVertexWeightfvEXT";
    if (!_glVertexWeightfvEXT_ptr) {
        _glVertexWeightfvEXT_ptr = (PFN_GLVERTEXWEIGHTFVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexWeightfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexWeightfvEXT_ptr(weight);
}

typedef void (APIENTRY * PFN_GLVERTEXWEIGHTPOINTEREXT)(GLsizei size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLVERTEXWEIGHTPOINTEREXT _glVertexWeightPointerEXT_ptr = NULL;

static inline void APIENTRY _glVertexWeightPointerEXT(GLsizei size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexWeightPointerEXT";
    if (!_glVertexWeightPointerEXT_ptr) {
        _glVertexWeightPointerEXT_ptr = (PFN_GLVERTEXWEIGHTPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glVertexWeightPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexWeightPointerEXT_ptr(size, type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLFLUSHVERTEXARRAYRANGENV)(void);
static PFN_GLFLUSHVERTEXARRAYRANGENV _glFlushVertexArrayRangeNV_ptr = NULL;

static inline void APIENTRY _glFlushVertexArrayRangeNV(void) {
    const char *_name = "glFlushVertexArrayRangeNV";
    if (!_glFlushVertexArrayRangeNV_ptr) {
        _glFlushVertexArrayRangeNV_ptr = (PFN_GLFLUSHVERTEXARRAYRANGENV)_getPrivateProcAddress(_name);
        if (!_glFlushVertexArrayRangeNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFlushVertexArrayRangeNV_ptr();
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYRANGENV)(GLsizei length, const GLvoid * pointer);
static PFN_GLVERTEXARRAYRANGENV _glVertexArrayRangeNV_ptr = NULL;

static inline void APIENTRY _glVertexArrayRangeNV(GLsizei length, const GLvoid * pointer) {
    const char *_name = "glVertexArrayRangeNV";
    if (!_glVertexArrayRangeNV_ptr) {
        _glVertexArrayRangeNV_ptr = (PFN_GLVERTEXARRAYRANGENV)_getPrivateProcAddress(_name);
        if (!_glVertexArrayRangeNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayRangeNV_ptr(length, pointer);
}

typedef void (APIENTRY * PFN_GLCOMBINERPARAMETERFVNV)(GLenum pname, const GLfloat * params);
static PFN_GLCOMBINERPARAMETERFVNV _glCombinerParameterfvNV_ptr = NULL;

static inline void APIENTRY _glCombinerParameterfvNV(GLenum pname, const GLfloat * params) {
    const char *_name = "glCombinerParameterfvNV";
    if (!_glCombinerParameterfvNV_ptr) {
        _glCombinerParameterfvNV_ptr = (PFN_GLCOMBINERPARAMETERFVNV)_getPrivateProcAddress(_name);
        if (!_glCombinerParameterfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCombinerParameterfvNV_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLCOMBINERPARAMETERFNV)(GLenum pname, GLfloat param);
static PFN_GLCOMBINERPARAMETERFNV _glCombinerParameterfNV_ptr = NULL;

static inline void APIENTRY _glCombinerParameterfNV(GLenum pname, GLfloat param) {
    const char *_name = "glCombinerParameterfNV";
    if (!_glCombinerParameterfNV_ptr) {
        _glCombinerParameterfNV_ptr = (PFN_GLCOMBINERPARAMETERFNV)_getPrivateProcAddress(_name);
        if (!_glCombinerParameterfNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCombinerParameterfNV_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLCOMBINERPARAMETERIVNV)(GLenum pname, const GLint * params);
static PFN_GLCOMBINERPARAMETERIVNV _glCombinerParameterivNV_ptr = NULL;

static inline void APIENTRY _glCombinerParameterivNV(GLenum pname, const GLint * params) {
    const char *_name = "glCombinerParameterivNV";
    if (!_glCombinerParameterivNV_ptr) {
        _glCombinerParameterivNV_ptr = (PFN_GLCOMBINERPARAMETERIVNV)_getPrivateProcAddress(_name);
        if (!_glCombinerParameterivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCombinerParameterivNV_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLCOMBINERPARAMETERINV)(GLenum pname, GLint param);
static PFN_GLCOMBINERPARAMETERINV _glCombinerParameteriNV_ptr = NULL;

static inline void APIENTRY _glCombinerParameteriNV(GLenum pname, GLint param) {
    const char *_name = "glCombinerParameteriNV";
    if (!_glCombinerParameteriNV_ptr) {
        _glCombinerParameteriNV_ptr = (PFN_GLCOMBINERPARAMETERINV)_getPrivateProcAddress(_name);
        if (!_glCombinerParameteriNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCombinerParameteriNV_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLCOMBINERINPUTNV)(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
static PFN_GLCOMBINERINPUTNV _glCombinerInputNV_ptr = NULL;

static inline void APIENTRY _glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage) {
    const char *_name = "glCombinerInputNV";
    if (!_glCombinerInputNV_ptr) {
        _glCombinerInputNV_ptr = (PFN_GLCOMBINERINPUTNV)_getPrivateProcAddress(_name);
        if (!_glCombinerInputNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCombinerInputNV_ptr(stage, portion, variable, input, mapping, componentUsage);
}

typedef void (APIENTRY * PFN_GLCOMBINEROUTPUTNV)(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
static PFN_GLCOMBINEROUTPUTNV _glCombinerOutputNV_ptr = NULL;

static inline void APIENTRY _glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum) {
    const char *_name = "glCombinerOutputNV";
    if (!_glCombinerOutputNV_ptr) {
        _glCombinerOutputNV_ptr = (PFN_GLCOMBINEROUTPUTNV)_getPrivateProcAddress(_name);
        if (!_glCombinerOutputNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCombinerOutputNV_ptr(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
}

typedef void (APIENTRY * PFN_GLFINALCOMBINERINPUTNV)(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
static PFN_GLFINALCOMBINERINPUTNV _glFinalCombinerInputNV_ptr = NULL;

static inline void APIENTRY _glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage) {
    const char *_name = "glFinalCombinerInputNV";
    if (!_glFinalCombinerInputNV_ptr) {
        _glFinalCombinerInputNV_ptr = (PFN_GLFINALCOMBINERINPUTNV)_getPrivateProcAddress(_name);
        if (!_glFinalCombinerInputNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFinalCombinerInputNV_ptr(variable, input, mapping, componentUsage);
}

typedef void (APIENTRY * PFN_GLGETCOMBINERINPUTPARAMETERFVNV)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params);
static PFN_GLGETCOMBINERINPUTPARAMETERFVNV _glGetCombinerInputParameterfvNV_ptr = NULL;

static inline void APIENTRY _glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params) {
    const char *_name = "glGetCombinerInputParameterfvNV";
    if (!_glGetCombinerInputParameterfvNV_ptr) {
        _glGetCombinerInputParameterfvNV_ptr = (PFN_GLGETCOMBINERINPUTPARAMETERFVNV)_getPrivateProcAddress(_name);
        if (!_glGetCombinerInputParameterfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetCombinerInputParameterfvNV_ptr(stage, portion, variable, pname, params);
}

typedef void (APIENTRY * PFN_GLGETCOMBINERINPUTPARAMETERIVNV)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params);
static PFN_GLGETCOMBINERINPUTPARAMETERIVNV _glGetCombinerInputParameterivNV_ptr = NULL;

static inline void APIENTRY _glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params) {
    const char *_name = "glGetCombinerInputParameterivNV";
    if (!_glGetCombinerInputParameterivNV_ptr) {
        _glGetCombinerInputParameterivNV_ptr = (PFN_GLGETCOMBINERINPUTPARAMETERIVNV)_getPrivateProcAddress(_name);
        if (!_glGetCombinerInputParameterivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetCombinerInputParameterivNV_ptr(stage, portion, variable, pname, params);
}

typedef void (APIENTRY * PFN_GLGETCOMBINEROUTPUTPARAMETERFVNV)(GLenum stage, GLenum portion, GLenum pname, GLfloat * params);
static PFN_GLGETCOMBINEROUTPUTPARAMETERFVNV _glGetCombinerOutputParameterfvNV_ptr = NULL;

static inline void APIENTRY _glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat * params) {
    const char *_name = "glGetCombinerOutputParameterfvNV";
    if (!_glGetCombinerOutputParameterfvNV_ptr) {
        _glGetCombinerOutputParameterfvNV_ptr = (PFN_GLGETCOMBINEROUTPUTPARAMETERFVNV)_getPrivateProcAddress(_name);
        if (!_glGetCombinerOutputParameterfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetCombinerOutputParameterfvNV_ptr(stage, portion, pname, params);
}

typedef void (APIENTRY * PFN_GLGETCOMBINEROUTPUTPARAMETERIVNV)(GLenum stage, GLenum portion, GLenum pname, GLint * params);
static PFN_GLGETCOMBINEROUTPUTPARAMETERIVNV _glGetCombinerOutputParameterivNV_ptr = NULL;

static inline void APIENTRY _glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint * params) {
    const char *_name = "glGetCombinerOutputParameterivNV";
    if (!_glGetCombinerOutputParameterivNV_ptr) {
        _glGetCombinerOutputParameterivNV_ptr = (PFN_GLGETCOMBINEROUTPUTPARAMETERIVNV)_getPrivateProcAddress(_name);
        if (!_glGetCombinerOutputParameterivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetCombinerOutputParameterivNV_ptr(stage, portion, pname, params);
}

typedef void (APIENTRY * PFN_GLGETFINALCOMBINERINPUTPARAMETERFVNV)(GLenum variable, GLenum pname, GLfloat * params);
static PFN_GLGETFINALCOMBINERINPUTPARAMETERFVNV _glGetFinalCombinerInputParameterfvNV_ptr = NULL;

static inline void APIENTRY _glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat * params) {
    const char *_name = "glGetFinalCombinerInputParameterfvNV";
    if (!_glGetFinalCombinerInputParameterfvNV_ptr) {
        _glGetFinalCombinerInputParameterfvNV_ptr = (PFN_GLGETFINALCOMBINERINPUTPARAMETERFVNV)_getPrivateProcAddress(_name);
        if (!_glGetFinalCombinerInputParameterfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFinalCombinerInputParameterfvNV_ptr(variable, pname, params);
}

typedef void (APIENTRY * PFN_GLGETFINALCOMBINERINPUTPARAMETERIVNV)(GLenum variable, GLenum pname, GLint * params);
static PFN_GLGETFINALCOMBINERINPUTPARAMETERIVNV _glGetFinalCombinerInputParameterivNV_ptr = NULL;

static inline void APIENTRY _glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint * params) {
    const char *_name = "glGetFinalCombinerInputParameterivNV";
    if (!_glGetFinalCombinerInputParameterivNV_ptr) {
        _glGetFinalCombinerInputParameterivNV_ptr = (PFN_GLGETFINALCOMBINERINPUTPARAMETERIVNV)_getPrivateProcAddress(_name);
        if (!_glGetFinalCombinerInputParameterivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFinalCombinerInputParameterivNV_ptr(variable, pname, params);
}

typedef void (APIENTRY * PFN_GLRESIZEBUFFERSMESA)(void);
static PFN_GLRESIZEBUFFERSMESA _glResizeBuffersMESA_ptr = NULL;

static inline void APIENTRY _glResizeBuffersMESA(void) {
    const char *_name = "glResizeBuffersMESA";
    if (!_glResizeBuffersMESA_ptr) {
        _glResizeBuffersMESA_ptr = (PFN_GLRESIZEBUFFERSMESA)_getPrivateProcAddress(_name);
        if (!_glResizeBuffersMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glResizeBuffersMESA_ptr();
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2DMESA)(GLdouble x, GLdouble y);
static PFN_GLWINDOWPOS2DMESA _glWindowPos2dMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos2dMESA(GLdouble x, GLdouble y) {
    const char *_name = "glWindowPos2dMESA";
    if (!_glWindowPos2dMESA_ptr) {
        _glWindowPos2dMESA_ptr = (PFN_GLWINDOWPOS2DMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos2dMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2dMESA_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2DVMESA)(const GLdouble * v);
static PFN_GLWINDOWPOS2DVMESA _glWindowPos2dvMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos2dvMESA(const GLdouble * v) {
    const char *_name = "glWindowPos2dvMESA";
    if (!_glWindowPos2dvMESA_ptr) {
        _glWindowPos2dvMESA_ptr = (PFN_GLWINDOWPOS2DVMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos2dvMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2dvMESA_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2FMESA)(GLfloat x, GLfloat y);
static PFN_GLWINDOWPOS2FMESA _glWindowPos2fMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos2fMESA(GLfloat x, GLfloat y) {
    const char *_name = "glWindowPos2fMESA";
    if (!_glWindowPos2fMESA_ptr) {
        _glWindowPos2fMESA_ptr = (PFN_GLWINDOWPOS2FMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos2fMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2fMESA_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2FVMESA)(const GLfloat * v);
static PFN_GLWINDOWPOS2FVMESA _glWindowPos2fvMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos2fvMESA(const GLfloat * v) {
    const char *_name = "glWindowPos2fvMESA";
    if (!_glWindowPos2fvMESA_ptr) {
        _glWindowPos2fvMESA_ptr = (PFN_GLWINDOWPOS2FVMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos2fvMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2fvMESA_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2IMESA)(GLint x, GLint y);
static PFN_GLWINDOWPOS2IMESA _glWindowPos2iMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos2iMESA(GLint x, GLint y) {
    const char *_name = "glWindowPos2iMESA";
    if (!_glWindowPos2iMESA_ptr) {
        _glWindowPos2iMESA_ptr = (PFN_GLWINDOWPOS2IMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos2iMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2iMESA_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2IVMESA)(const GLint * v);
static PFN_GLWINDOWPOS2IVMESA _glWindowPos2ivMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos2ivMESA(const GLint * v) {
    const char *_name = "glWindowPos2ivMESA";
    if (!_glWindowPos2ivMESA_ptr) {
        _glWindowPos2ivMESA_ptr = (PFN_GLWINDOWPOS2IVMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos2ivMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2ivMESA_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2SMESA)(GLshort x, GLshort y);
static PFN_GLWINDOWPOS2SMESA _glWindowPos2sMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos2sMESA(GLshort x, GLshort y) {
    const char *_name = "glWindowPos2sMESA";
    if (!_glWindowPos2sMESA_ptr) {
        _glWindowPos2sMESA_ptr = (PFN_GLWINDOWPOS2SMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos2sMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2sMESA_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS2SVMESA)(const GLshort * v);
static PFN_GLWINDOWPOS2SVMESA _glWindowPos2svMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos2svMESA(const GLshort * v) {
    const char *_name = "glWindowPos2svMESA";
    if (!_glWindowPos2svMESA_ptr) {
        _glWindowPos2svMESA_ptr = (PFN_GLWINDOWPOS2SVMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos2svMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos2svMESA_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3DMESA)(GLdouble x, GLdouble y, GLdouble z);
static PFN_GLWINDOWPOS3DMESA _glWindowPos3dMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glWindowPos3dMESA";
    if (!_glWindowPos3dMESA_ptr) {
        _glWindowPos3dMESA_ptr = (PFN_GLWINDOWPOS3DMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos3dMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3dMESA_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3DVMESA)(const GLdouble * v);
static PFN_GLWINDOWPOS3DVMESA _glWindowPos3dvMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos3dvMESA(const GLdouble * v) {
    const char *_name = "glWindowPos3dvMESA";
    if (!_glWindowPos3dvMESA_ptr) {
        _glWindowPos3dvMESA_ptr = (PFN_GLWINDOWPOS3DVMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos3dvMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3dvMESA_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3FMESA)(GLfloat x, GLfloat y, GLfloat z);
static PFN_GLWINDOWPOS3FMESA _glWindowPos3fMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glWindowPos3fMESA";
    if (!_glWindowPos3fMESA_ptr) {
        _glWindowPos3fMESA_ptr = (PFN_GLWINDOWPOS3FMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos3fMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3fMESA_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3FVMESA)(const GLfloat * v);
static PFN_GLWINDOWPOS3FVMESA _glWindowPos3fvMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos3fvMESA(const GLfloat * v) {
    const char *_name = "glWindowPos3fvMESA";
    if (!_glWindowPos3fvMESA_ptr) {
        _glWindowPos3fvMESA_ptr = (PFN_GLWINDOWPOS3FVMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos3fvMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3fvMESA_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3IMESA)(GLint x, GLint y, GLint z);
static PFN_GLWINDOWPOS3IMESA _glWindowPos3iMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos3iMESA(GLint x, GLint y, GLint z) {
    const char *_name = "glWindowPos3iMESA";
    if (!_glWindowPos3iMESA_ptr) {
        _glWindowPos3iMESA_ptr = (PFN_GLWINDOWPOS3IMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos3iMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3iMESA_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3IVMESA)(const GLint * v);
static PFN_GLWINDOWPOS3IVMESA _glWindowPos3ivMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos3ivMESA(const GLint * v) {
    const char *_name = "glWindowPos3ivMESA";
    if (!_glWindowPos3ivMESA_ptr) {
        _glWindowPos3ivMESA_ptr = (PFN_GLWINDOWPOS3IVMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos3ivMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3ivMESA_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3SMESA)(GLshort x, GLshort y, GLshort z);
static PFN_GLWINDOWPOS3SMESA _glWindowPos3sMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos3sMESA(GLshort x, GLshort y, GLshort z) {
    const char *_name = "glWindowPos3sMESA";
    if (!_glWindowPos3sMESA_ptr) {
        _glWindowPos3sMESA_ptr = (PFN_GLWINDOWPOS3SMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos3sMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3sMESA_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS3SVMESA)(const GLshort * v);
static PFN_GLWINDOWPOS3SVMESA _glWindowPos3svMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos3svMESA(const GLshort * v) {
    const char *_name = "glWindowPos3svMESA";
    if (!_glWindowPos3svMESA_ptr) {
        _glWindowPos3svMESA_ptr = (PFN_GLWINDOWPOS3SVMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos3svMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos3svMESA_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS4DMESA)(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLWINDOWPOS4DMESA _glWindowPos4dMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glWindowPos4dMESA";
    if (!_glWindowPos4dMESA_ptr) {
        _glWindowPos4dMESA_ptr = (PFN_GLWINDOWPOS4DMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos4dMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos4dMESA_ptr(x, y, z, w);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS4DVMESA)(const GLdouble * v);
static PFN_GLWINDOWPOS4DVMESA _glWindowPos4dvMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos4dvMESA(const GLdouble * v) {
    const char *_name = "glWindowPos4dvMESA";
    if (!_glWindowPos4dvMESA_ptr) {
        _glWindowPos4dvMESA_ptr = (PFN_GLWINDOWPOS4DVMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos4dvMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos4dvMESA_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS4FMESA)(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLWINDOWPOS4FMESA _glWindowPos4fMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glWindowPos4fMESA";
    if (!_glWindowPos4fMESA_ptr) {
        _glWindowPos4fMESA_ptr = (PFN_GLWINDOWPOS4FMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos4fMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos4fMESA_ptr(x, y, z, w);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS4FVMESA)(const GLfloat * v);
static PFN_GLWINDOWPOS4FVMESA _glWindowPos4fvMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos4fvMESA(const GLfloat * v) {
    const char *_name = "glWindowPos4fvMESA";
    if (!_glWindowPos4fvMESA_ptr) {
        _glWindowPos4fvMESA_ptr = (PFN_GLWINDOWPOS4FVMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos4fvMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos4fvMESA_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS4IMESA)(GLint x, GLint y, GLint z, GLint w);
static PFN_GLWINDOWPOS4IMESA _glWindowPos4iMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glWindowPos4iMESA";
    if (!_glWindowPos4iMESA_ptr) {
        _glWindowPos4iMESA_ptr = (PFN_GLWINDOWPOS4IMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos4iMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos4iMESA_ptr(x, y, z, w);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS4IVMESA)(const GLint * v);
static PFN_GLWINDOWPOS4IVMESA _glWindowPos4ivMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos4ivMESA(const GLint * v) {
    const char *_name = "glWindowPos4ivMESA";
    if (!_glWindowPos4ivMESA_ptr) {
        _glWindowPos4ivMESA_ptr = (PFN_GLWINDOWPOS4IVMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos4ivMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos4ivMESA_ptr(v);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS4SMESA)(GLshort x, GLshort y, GLshort z, GLshort w);
static PFN_GLWINDOWPOS4SMESA _glWindowPos4sMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glWindowPos4sMESA";
    if (!_glWindowPos4sMESA_ptr) {
        _glWindowPos4sMESA_ptr = (PFN_GLWINDOWPOS4SMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos4sMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos4sMESA_ptr(x, y, z, w);
}

typedef void (APIENTRY * PFN_GLWINDOWPOS4SVMESA)(const GLshort * v);
static PFN_GLWINDOWPOS4SVMESA _glWindowPos4svMESA_ptr = NULL;

static inline void APIENTRY _glWindowPos4svMESA(const GLshort * v) {
    const char *_name = "glWindowPos4svMESA";
    if (!_glWindowPos4svMESA_ptr) {
        _glWindowPos4svMESA_ptr = (PFN_GLWINDOWPOS4SVMESA)_getPrivateProcAddress(_name);
        if (!_glWindowPos4svMESA_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWindowPos4svMESA_ptr(v);
}

typedef void (APIENTRY * PFN_GLMULTIMODEDRAWARRAYSIBM)(const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride);
static PFN_GLMULTIMODEDRAWARRAYSIBM _glMultiModeDrawArraysIBM_ptr = NULL;

static inline void APIENTRY _glMultiModeDrawArraysIBM(const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride) {
    const char *_name = "glMultiModeDrawArraysIBM";
    if (!_glMultiModeDrawArraysIBM_ptr) {
        _glMultiModeDrawArraysIBM_ptr = (PFN_GLMULTIMODEDRAWARRAYSIBM)_getPrivateProcAddress(_name);
        if (!_glMultiModeDrawArraysIBM_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiModeDrawArraysIBM_ptr(mode, first, count, primcount, modestride);
}

typedef void (APIENTRY * PFN_GLMULTIMODEDRAWELEMENTSIBM)(const GLenum * mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei primcount, GLint modestride);
static PFN_GLMULTIMODEDRAWELEMENTSIBM _glMultiModeDrawElementsIBM_ptr = NULL;

static inline void APIENTRY _glMultiModeDrawElementsIBM(const GLenum * mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei primcount, GLint modestride) {
    const char *_name = "glMultiModeDrawElementsIBM";
    if (!_glMultiModeDrawElementsIBM_ptr) {
        _glMultiModeDrawElementsIBM_ptr = (PFN_GLMULTIMODEDRAWELEMENTSIBM)_getPrivateProcAddress(_name);
        if (!_glMultiModeDrawElementsIBM_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiModeDrawElementsIBM_ptr(mode, count, type, indices, primcount, modestride);
}

typedef void (APIENTRY * PFN_GLCOLORPOINTERLISTIBM)(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride);
static PFN_GLCOLORPOINTERLISTIBM _glColorPointerListIBM_ptr = NULL;

static inline void APIENTRY _glColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glColorPointerListIBM";
    if (!_glColorPointerListIBM_ptr) {
        _glColorPointerListIBM_ptr = (PFN_GLCOLORPOINTERLISTIBM)_getPrivateProcAddress(_name);
        if (!_glColorPointerListIBM_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorPointerListIBM_ptr(size, type, stride, pointer, ptrstride);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLORPOINTERLISTIBM)(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride);
static PFN_GLSECONDARYCOLORPOINTERLISTIBM _glSecondaryColorPointerListIBM_ptr = NULL;

static inline void APIENTRY _glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glSecondaryColorPointerListIBM";
    if (!_glSecondaryColorPointerListIBM_ptr) {
        _glSecondaryColorPointerListIBM_ptr = (PFN_GLSECONDARYCOLORPOINTERLISTIBM)_getPrivateProcAddress(_name);
        if (!_glSecondaryColorPointerListIBM_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColorPointerListIBM_ptr(size, type, stride, pointer, ptrstride);
}

typedef void (APIENTRY * PFN_GLEDGEFLAGPOINTERLISTIBM)(GLint stride, const GLboolean * * pointer, GLint ptrstride);
static PFN_GLEDGEFLAGPOINTERLISTIBM _glEdgeFlagPointerListIBM_ptr = NULL;

static inline void APIENTRY _glEdgeFlagPointerListIBM(GLint stride, const GLboolean * * pointer, GLint ptrstride) {
    const char *_name = "glEdgeFlagPointerListIBM";
    if (!_glEdgeFlagPointerListIBM_ptr) {
        _glEdgeFlagPointerListIBM_ptr = (PFN_GLEDGEFLAGPOINTERLISTIBM)_getPrivateProcAddress(_name);
        if (!_glEdgeFlagPointerListIBM_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEdgeFlagPointerListIBM_ptr(stride, pointer, ptrstride);
}

typedef void (APIENTRY * PFN_GLFOGCOORDPOINTERLISTIBM)(GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride);
static PFN_GLFOGCOORDPOINTERLISTIBM _glFogCoordPointerListIBM_ptr = NULL;

static inline void APIENTRY _glFogCoordPointerListIBM(GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glFogCoordPointerListIBM";
    if (!_glFogCoordPointerListIBM_ptr) {
        _glFogCoordPointerListIBM_ptr = (PFN_GLFOGCOORDPOINTERLISTIBM)_getPrivateProcAddress(_name);
        if (!_glFogCoordPointerListIBM_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoordPointerListIBM_ptr(type, stride, pointer, ptrstride);
}

typedef void (APIENTRY * PFN_GLINDEXPOINTERLISTIBM)(GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride);
static PFN_GLINDEXPOINTERLISTIBM _glIndexPointerListIBM_ptr = NULL;

static inline void APIENTRY _glIndexPointerListIBM(GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glIndexPointerListIBM";
    if (!_glIndexPointerListIBM_ptr) {
        _glIndexPointerListIBM_ptr = (PFN_GLINDEXPOINTERLISTIBM)_getPrivateProcAddress(_name);
        if (!_glIndexPointerListIBM_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexPointerListIBM_ptr(type, stride, pointer, ptrstride);
}

typedef void (APIENTRY * PFN_GLNORMALPOINTERLISTIBM)(GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride);
static PFN_GLNORMALPOINTERLISTIBM _glNormalPointerListIBM_ptr = NULL;

static inline void APIENTRY _glNormalPointerListIBM(GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glNormalPointerListIBM";
    if (!_glNormalPointerListIBM_ptr) {
        _glNormalPointerListIBM_ptr = (PFN_GLNORMALPOINTERLISTIBM)_getPrivateProcAddress(_name);
        if (!_glNormalPointerListIBM_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalPointerListIBM_ptr(type, stride, pointer, ptrstride);
}

typedef void (APIENTRY * PFN_GLTEXCOORDPOINTERLISTIBM)(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride);
static PFN_GLTEXCOORDPOINTERLISTIBM _glTexCoordPointerListIBM_ptr = NULL;

static inline void APIENTRY _glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glTexCoordPointerListIBM";
    if (!_glTexCoordPointerListIBM_ptr) {
        _glTexCoordPointerListIBM_ptr = (PFN_GLTEXCOORDPOINTERLISTIBM)_getPrivateProcAddress(_name);
        if (!_glTexCoordPointerListIBM_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoordPointerListIBM_ptr(size, type, stride, pointer, ptrstride);
}

typedef void (APIENTRY * PFN_GLVERTEXPOINTERLISTIBM)(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride);
static PFN_GLVERTEXPOINTERLISTIBM _glVertexPointerListIBM_ptr = NULL;

static inline void APIENTRY _glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glVertexPointerListIBM";
    if (!_glVertexPointerListIBM_ptr) {
        _glVertexPointerListIBM_ptr = (PFN_GLVERTEXPOINTERLISTIBM)_getPrivateProcAddress(_name);
        if (!_glVertexPointerListIBM_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexPointerListIBM_ptr(size, type, stride, pointer, ptrstride);
}

typedef void (APIENTRY * PFN_GLTBUFFERMASK3DFX)(GLuint mask);
static PFN_GLTBUFFERMASK3DFX _glTbufferMask3DFX_ptr = NULL;

static inline void APIENTRY _glTbufferMask3DFX(GLuint mask) {
    const char *_name = "glTbufferMask3DFX";
    if (!_glTbufferMask3DFX_ptr) {
        _glTbufferMask3DFX_ptr = (PFN_GLTBUFFERMASK3DFX)_getPrivateProcAddress(_name);
        if (!_glTbufferMask3DFX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTbufferMask3DFX_ptr(mask);
}

typedef void (APIENTRY * PFN_GLSAMPLEMASKEXT)(GLclampf value, GLboolean invert);
static PFN_GLSAMPLEMASKEXT _glSampleMaskEXT_ptr = NULL;

static inline void APIENTRY _glSampleMaskEXT(GLclampf value, GLboolean invert) {
    const char *_name = "glSampleMaskEXT";
    if (!_glSampleMaskEXT_ptr) {
        _glSampleMaskEXT_ptr = (PFN_GLSAMPLEMASKEXT)_getPrivateProcAddress(_name);
        if (!_glSampleMaskEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSampleMaskEXT_ptr(value, invert);
}

typedef void (APIENTRY * PFN_GLSAMPLEPATTERNEXT)(GLenum pattern);
static PFN_GLSAMPLEPATTERNEXT _glSamplePatternEXT_ptr = NULL;

static inline void APIENTRY _glSamplePatternEXT(GLenum pattern) {
    const char *_name = "glSamplePatternEXT";
    if (!_glSamplePatternEXT_ptr) {
        _glSamplePatternEXT_ptr = (PFN_GLSAMPLEPATTERNEXT)_getPrivateProcAddress(_name);
        if (!_glSamplePatternEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSamplePatternEXT_ptr(pattern);
}

typedef void (APIENTRY * PFN_GLTEXTURECOLORMASKSGIS)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
static PFN_GLTEXTURECOLORMASKSGIS _glTextureColorMaskSGIS_ptr = NULL;

static inline void APIENTRY _glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
    const char *_name = "glTextureColorMaskSGIS";
    if (!_glTextureColorMaskSGIS_ptr) {
        _glTextureColorMaskSGIS_ptr = (PFN_GLTEXTURECOLORMASKSGIS)_getPrivateProcAddress(_name);
        if (!_glTextureColorMaskSGIS_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureColorMaskSGIS_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLIGLOOINTERFACESGIX)(GLenum pname, const GLvoid * params);
static PFN_GLIGLOOINTERFACESGIX _glIglooInterfaceSGIX_ptr = NULL;

static inline void APIENTRY _glIglooInterfaceSGIX(GLenum pname, const GLvoid * params) {
    const char *_name = "glIglooInterfaceSGIX";
    if (!_glIglooInterfaceSGIX_ptr) {
        _glIglooInterfaceSGIX_ptr = (PFN_GLIGLOOINTERFACESGIX)_getPrivateProcAddress(_name);
        if (!_glIglooInterfaceSGIX_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIglooInterfaceSGIX_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLDELETEFENCESNV)(GLsizei n, const GLuint * fences);
static PFN_GLDELETEFENCESNV _glDeleteFencesNV_ptr = NULL;

static inline void APIENTRY _glDeleteFencesNV(GLsizei n, const GLuint * fences) {
    const char *_name = "glDeleteFencesNV";
    if (!_glDeleteFencesNV_ptr) {
        _glDeleteFencesNV_ptr = (PFN_GLDELETEFENCESNV)_getPrivateProcAddress(_name);
        if (!_glDeleteFencesNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteFencesNV_ptr(n, fences);
}

typedef void (APIENTRY * PFN_GLGENFENCESNV)(GLsizei n, GLuint * fences);
static PFN_GLGENFENCESNV _glGenFencesNV_ptr = NULL;

static inline void APIENTRY _glGenFencesNV(GLsizei n, GLuint * fences) {
    const char *_name = "glGenFencesNV";
    if (!_glGenFencesNV_ptr) {
        _glGenFencesNV_ptr = (PFN_GLGENFENCESNV)_getPrivateProcAddress(_name);
        if (!_glGenFencesNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenFencesNV_ptr(n, fences);
}

typedef GLboolean (APIENTRY * PFN_GLISFENCENV)(GLuint fence);
static PFN_GLISFENCENV _glIsFenceNV_ptr = NULL;

static inline GLboolean APIENTRY _glIsFenceNV(GLuint fence) {
    const char *_name = "glIsFenceNV";
    if (!_glIsFenceNV_ptr) {
        _glIsFenceNV_ptr = (PFN_GLISFENCENV)_getPrivateProcAddress(_name);
        if (!_glIsFenceNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsFenceNV_ptr(fence);
}

typedef GLboolean (APIENTRY * PFN_GLTESTFENCENV)(GLuint fence);
static PFN_GLTESTFENCENV _glTestFenceNV_ptr = NULL;

static inline GLboolean APIENTRY _glTestFenceNV(GLuint fence) {
    const char *_name = "glTestFenceNV";
    if (!_glTestFenceNV_ptr) {
        _glTestFenceNV_ptr = (PFN_GLTESTFENCENV)_getPrivateProcAddress(_name);
        if (!_glTestFenceNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glTestFenceNV_ptr(fence);
}

typedef void (APIENTRY * PFN_GLGETFENCEIVNV)(GLuint fence, GLenum pname, GLint * params);
static PFN_GLGETFENCEIVNV _glGetFenceivNV_ptr = NULL;

static inline void APIENTRY _glGetFenceivNV(GLuint fence, GLenum pname, GLint * params) {
    const char *_name = "glGetFenceivNV";
    if (!_glGetFenceivNV_ptr) {
        _glGetFenceivNV_ptr = (PFN_GLGETFENCEIVNV)_getPrivateProcAddress(_name);
        if (!_glGetFenceivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFenceivNV_ptr(fence, pname, params);
}

typedef void (APIENTRY * PFN_GLFINISHFENCENV)(GLuint fence);
static PFN_GLFINISHFENCENV _glFinishFenceNV_ptr = NULL;

static inline void APIENTRY _glFinishFenceNV(GLuint fence) {
    const char *_name = "glFinishFenceNV";
    if (!_glFinishFenceNV_ptr) {
        _glFinishFenceNV_ptr = (PFN_GLFINISHFENCENV)_getPrivateProcAddress(_name);
        if (!_glFinishFenceNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFinishFenceNV_ptr(fence);
}

typedef void (APIENTRY * PFN_GLSETFENCENV)(GLuint fence, GLenum condition);
static PFN_GLSETFENCENV _glSetFenceNV_ptr = NULL;

static inline void APIENTRY _glSetFenceNV(GLuint fence, GLenum condition) {
    const char *_name = "glSetFenceNV";
    if (!_glSetFenceNV_ptr) {
        _glSetFenceNV_ptr = (PFN_GLSETFENCENV)_getPrivateProcAddress(_name);
        if (!_glSetFenceNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSetFenceNV_ptr(fence, condition);
}

typedef void (APIENTRY * PFN_GLMAPCONTROLPOINTSNV)(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid * points);
static PFN_GLMAPCONTROLPOINTSNV _glMapControlPointsNV_ptr = NULL;

static inline void APIENTRY _glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid * points) {
    const char *_name = "glMapControlPointsNV";
    if (!_glMapControlPointsNV_ptr) {
        _glMapControlPointsNV_ptr = (PFN_GLMAPCONTROLPOINTSNV)_getPrivateProcAddress(_name);
        if (!_glMapControlPointsNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMapControlPointsNV_ptr(target, index, type, ustride, vstride, uorder, vorder, packed, points);
}

typedef void (APIENTRY * PFN_GLMAPPARAMETERIVNV)(GLenum target, GLenum pname, const GLint * params);
static PFN_GLMAPPARAMETERIVNV _glMapParameterivNV_ptr = NULL;

static inline void APIENTRY _glMapParameterivNV(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glMapParameterivNV";
    if (!_glMapParameterivNV_ptr) {
        _glMapParameterivNV_ptr = (PFN_GLMAPPARAMETERIVNV)_getPrivateProcAddress(_name);
        if (!_glMapParameterivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMapParameterivNV_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLMAPPARAMETERFVNV)(GLenum target, GLenum pname, const GLfloat * params);
static PFN_GLMAPPARAMETERFVNV _glMapParameterfvNV_ptr = NULL;

static inline void APIENTRY _glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glMapParameterfvNV";
    if (!_glMapParameterfvNV_ptr) {
        _glMapParameterfvNV_ptr = (PFN_GLMAPPARAMETERFVNV)_getPrivateProcAddress(_name);
        if (!_glMapParameterfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMapParameterfvNV_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMAPCONTROLPOINTSNV)(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid * points);
static PFN_GLGETMAPCONTROLPOINTSNV _glGetMapControlPointsNV_ptr = NULL;

static inline void APIENTRY _glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid * points) {
    const char *_name = "glGetMapControlPointsNV";
    if (!_glGetMapControlPointsNV_ptr) {
        _glGetMapControlPointsNV_ptr = (PFN_GLGETMAPCONTROLPOINTSNV)_getPrivateProcAddress(_name);
        if (!_glGetMapControlPointsNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMapControlPointsNV_ptr(target, index, type, ustride, vstride, packed, points);
}

typedef void (APIENTRY * PFN_GLGETMAPPARAMETERIVNV)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETMAPPARAMETERIVNV _glGetMapParameterivNV_ptr = NULL;

static inline void APIENTRY _glGetMapParameterivNV(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetMapParameterivNV";
    if (!_glGetMapParameterivNV_ptr) {
        _glGetMapParameterivNV_ptr = (PFN_GLGETMAPPARAMETERIVNV)_getPrivateProcAddress(_name);
        if (!_glGetMapParameterivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMapParameterivNV_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMAPPARAMETERFVNV)(GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETMAPPARAMETERFVNV _glGetMapParameterfvNV_ptr = NULL;

static inline void APIENTRY _glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMapParameterfvNV";
    if (!_glGetMapParameterfvNV_ptr) {
        _glGetMapParameterfvNV_ptr = (PFN_GLGETMAPPARAMETERFVNV)_getPrivateProcAddress(_name);
        if (!_glGetMapParameterfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMapParameterfvNV_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMAPATTRIBPARAMETERIVNV)(GLenum target, GLuint index, GLenum pname, GLint * params);
static PFN_GLGETMAPATTRIBPARAMETERIVNV _glGetMapAttribParameterivNV_ptr = NULL;

static inline void APIENTRY _glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetMapAttribParameterivNV";
    if (!_glGetMapAttribParameterivNV_ptr) {
        _glGetMapAttribParameterivNV_ptr = (PFN_GLGETMAPATTRIBPARAMETERIVNV)_getPrivateProcAddress(_name);
        if (!_glGetMapAttribParameterivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMapAttribParameterivNV_ptr(target, index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMAPATTRIBPARAMETERFVNV)(GLenum target, GLuint index, GLenum pname, GLfloat * params);
static PFN_GLGETMAPATTRIBPARAMETERFVNV _glGetMapAttribParameterfvNV_ptr = NULL;

static inline void APIENTRY _glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMapAttribParameterfvNV";
    if (!_glGetMapAttribParameterfvNV_ptr) {
        _glGetMapAttribParameterfvNV_ptr = (PFN_GLGETMAPATTRIBPARAMETERFVNV)_getPrivateProcAddress(_name);
        if (!_glGetMapAttribParameterfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMapAttribParameterfvNV_ptr(target, index, pname, params);
}

typedef void (APIENTRY * PFN_GLEVALMAPSNV)(GLenum target, GLenum mode);
static PFN_GLEVALMAPSNV _glEvalMapsNV_ptr = NULL;

static inline void APIENTRY _glEvalMapsNV(GLenum target, GLenum mode) {
    const char *_name = "glEvalMapsNV";
    if (!_glEvalMapsNV_ptr) {
        _glEvalMapsNV_ptr = (PFN_GLEVALMAPSNV)_getPrivateProcAddress(_name);
        if (!_glEvalMapsNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEvalMapsNV_ptr(target, mode);
}

typedef void (APIENTRY * PFN_GLCOMBINERSTAGEPARAMETERFVNV)(GLenum stage, GLenum pname, const GLfloat * params);
static PFN_GLCOMBINERSTAGEPARAMETERFVNV _glCombinerStageParameterfvNV_ptr = NULL;

static inline void APIENTRY _glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat * params) {
    const char *_name = "glCombinerStageParameterfvNV";
    if (!_glCombinerStageParameterfvNV_ptr) {
        _glCombinerStageParameterfvNV_ptr = (PFN_GLCOMBINERSTAGEPARAMETERFVNV)_getPrivateProcAddress(_name);
        if (!_glCombinerStageParameterfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCombinerStageParameterfvNV_ptr(stage, pname, params);
}

typedef void (APIENTRY * PFN_GLGETCOMBINERSTAGEPARAMETERFVNV)(GLenum stage, GLenum pname, GLfloat * params);
static PFN_GLGETCOMBINERSTAGEPARAMETERFVNV _glGetCombinerStageParameterfvNV_ptr = NULL;

static inline void APIENTRY _glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat * params) {
    const char *_name = "glGetCombinerStageParameterfvNV";
    if (!_glGetCombinerStageParameterfvNV_ptr) {
        _glGetCombinerStageParameterfvNV_ptr = (PFN_GLGETCOMBINERSTAGEPARAMETERFVNV)_getPrivateProcAddress(_name);
        if (!_glGetCombinerStageParameterfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetCombinerStageParameterfvNV_ptr(stage, pname, params);
}

typedef GLboolean (APIENTRY * PFN_GLAREPROGRAMSRESIDENTNV)(GLsizei n, const GLuint * ids, GLboolean * residences);
static PFN_GLAREPROGRAMSRESIDENTNV _glAreProgramsResidentNV_ptr = NULL;

static inline GLboolean APIENTRY _glAreProgramsResidentNV(GLsizei n, const GLuint * ids, GLboolean * residences) {
    const char *_name = "glAreProgramsResidentNV";
    if (!_glAreProgramsResidentNV_ptr) {
        _glAreProgramsResidentNV_ptr = (PFN_GLAREPROGRAMSRESIDENTNV)_getPrivateProcAddress(_name);
        if (!_glAreProgramsResidentNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glAreProgramsResidentNV_ptr(n, ids, residences);
}

typedef void (APIENTRY * PFN_GLBINDPROGRAMNV)(GLenum target, GLuint program);
static PFN_GLBINDPROGRAMNV _glBindProgramNV_ptr = NULL;

static inline void APIENTRY _glBindProgramNV(GLenum target, GLuint program) {
    const char *_name = "glBindProgramNV";
    if (!_glBindProgramNV_ptr) {
        _glBindProgramNV_ptr = (PFN_GLBINDPROGRAMNV)_getPrivateProcAddress(_name);
        if (!_glBindProgramNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindProgramNV_ptr(target, program);
}

typedef void (APIENTRY * PFN_GLDELETEPROGRAMSNV)(GLsizei n, const GLuint * programs);
static PFN_GLDELETEPROGRAMSNV _glDeleteProgramsNV_ptr = NULL;

static inline void APIENTRY _glDeleteProgramsNV(GLsizei n, const GLuint * programs) {
    const char *_name = "glDeleteProgramsNV";
    if (!_glDeleteProgramsNV_ptr) {
        _glDeleteProgramsNV_ptr = (PFN_GLDELETEPROGRAMSNV)_getPrivateProcAddress(_name);
        if (!_glDeleteProgramsNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteProgramsNV_ptr(n, programs);
}

typedef void (APIENTRY * PFN_GLEXECUTEPROGRAMNV)(GLenum target, GLuint id, const GLfloat * params);
static PFN_GLEXECUTEPROGRAMNV _glExecuteProgramNV_ptr = NULL;

static inline void APIENTRY _glExecuteProgramNV(GLenum target, GLuint id, const GLfloat * params) {
    const char *_name = "glExecuteProgramNV";
    if (!_glExecuteProgramNV_ptr) {
        _glExecuteProgramNV_ptr = (PFN_GLEXECUTEPROGRAMNV)_getPrivateProcAddress(_name);
        if (!_glExecuteProgramNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glExecuteProgramNV_ptr(target, id, params);
}

typedef void (APIENTRY * PFN_GLGENPROGRAMSNV)(GLsizei n, GLuint * programs);
static PFN_GLGENPROGRAMSNV _glGenProgramsNV_ptr = NULL;

static inline void APIENTRY _glGenProgramsNV(GLsizei n, GLuint * programs) {
    const char *_name = "glGenProgramsNV";
    if (!_glGenProgramsNV_ptr) {
        _glGenProgramsNV_ptr = (PFN_GLGENPROGRAMSNV)_getPrivateProcAddress(_name);
        if (!_glGenProgramsNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenProgramsNV_ptr(n, programs);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMPARAMETERDVNV)(GLenum target, GLuint index, GLenum pname, GLdouble * params);
static PFN_GLGETPROGRAMPARAMETERDVNV _glGetProgramParameterdvNV_ptr = NULL;

static inline void APIENTRY _glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble * params) {
    const char *_name = "glGetProgramParameterdvNV";
    if (!_glGetProgramParameterdvNV_ptr) {
        _glGetProgramParameterdvNV_ptr = (PFN_GLGETPROGRAMPARAMETERDVNV)_getPrivateProcAddress(_name);
        if (!_glGetProgramParameterdvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramParameterdvNV_ptr(target, index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMPARAMETERFVNV)(GLenum target, GLuint index, GLenum pname, GLfloat * params);
static PFN_GLGETPROGRAMPARAMETERFVNV _glGetProgramParameterfvNV_ptr = NULL;

static inline void APIENTRY _glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat * params) {
    const char *_name = "glGetProgramParameterfvNV";
    if (!_glGetProgramParameterfvNV_ptr) {
        _glGetProgramParameterfvNV_ptr = (PFN_GLGETPROGRAMPARAMETERFVNV)_getPrivateProcAddress(_name);
        if (!_glGetProgramParameterfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramParameterfvNV_ptr(target, index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMIVNV)(GLuint id, GLenum pname, GLint * params);
static PFN_GLGETPROGRAMIVNV _glGetProgramivNV_ptr = NULL;

static inline void APIENTRY _glGetProgramivNV(GLuint id, GLenum pname, GLint * params) {
    const char *_name = "glGetProgramivNV";
    if (!_glGetProgramivNV_ptr) {
        _glGetProgramivNV_ptr = (PFN_GLGETPROGRAMIVNV)_getPrivateProcAddress(_name);
        if (!_glGetProgramivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramivNV_ptr(id, pname, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMSTRINGNV)(GLuint id, GLenum pname, GLubyte * program);
static PFN_GLGETPROGRAMSTRINGNV _glGetProgramStringNV_ptr = NULL;

static inline void APIENTRY _glGetProgramStringNV(GLuint id, GLenum pname, GLubyte * program) {
    const char *_name = "glGetProgramStringNV";
    if (!_glGetProgramStringNV_ptr) {
        _glGetProgramStringNV_ptr = (PFN_GLGETPROGRAMSTRINGNV)_getPrivateProcAddress(_name);
        if (!_glGetProgramStringNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramStringNV_ptr(id, pname, program);
}

typedef void (APIENTRY * PFN_GLGETTRACKMATRIXIVNV)(GLenum target, GLuint address, GLenum pname, GLint * params);
static PFN_GLGETTRACKMATRIXIVNV _glGetTrackMatrixivNV_ptr = NULL;

static inline void APIENTRY _glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint * params) {
    const char *_name = "glGetTrackMatrixivNV";
    if (!_glGetTrackMatrixivNV_ptr) {
        _glGetTrackMatrixivNV_ptr = (PFN_GLGETTRACKMATRIXIVNV)_getPrivateProcAddress(_name);
        if (!_glGetTrackMatrixivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTrackMatrixivNV_ptr(target, address, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBDVNV)(GLuint index, GLenum pname, GLdouble * params);
static PFN_GLGETVERTEXATTRIBDVNV _glGetVertexAttribdvNV_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble * params) {
    const char *_name = "glGetVertexAttribdvNV";
    if (!_glGetVertexAttribdvNV_ptr) {
        _glGetVertexAttribdvNV_ptr = (PFN_GLGETVERTEXATTRIBDVNV)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribdvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribdvNV_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBFVNV)(GLuint index, GLenum pname, GLfloat * params);
static PFN_GLGETVERTEXATTRIBFVNV _glGetVertexAttribfvNV_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat * params) {
    const char *_name = "glGetVertexAttribfvNV";
    if (!_glGetVertexAttribfvNV_ptr) {
        _glGetVertexAttribfvNV_ptr = (PFN_GLGETVERTEXATTRIBFVNV)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribfvNV_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBIVNV)(GLuint index, GLenum pname, GLint * params);
static PFN_GLGETVERTEXATTRIBIVNV _glGetVertexAttribivNV_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribivNV(GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetVertexAttribivNV";
    if (!_glGetVertexAttribivNV_ptr) {
        _glGetVertexAttribivNV_ptr = (PFN_GLGETVERTEXATTRIBIVNV)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribivNV_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBPOINTERVNV)(GLuint index, GLenum pname, GLvoid * * pointer);
static PFN_GLGETVERTEXATTRIBPOINTERVNV _glGetVertexAttribPointervNV_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid * * pointer) {
    const char *_name = "glGetVertexAttribPointervNV";
    if (!_glGetVertexAttribPointervNV_ptr) {
        _glGetVertexAttribPointervNV_ptr = (PFN_GLGETVERTEXATTRIBPOINTERVNV)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribPointervNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribPointervNV_ptr(index, pname, pointer);
}

typedef GLboolean (APIENTRY * PFN_GLISPROGRAMNV)(GLuint program);
static PFN_GLISPROGRAMNV _glIsProgramNV_ptr = NULL;

static inline GLboolean APIENTRY _glIsProgramNV(GLuint program) {
    const char *_name = "glIsProgramNV";
    if (!_glIsProgramNV_ptr) {
        _glIsProgramNV_ptr = (PFN_GLISPROGRAMNV)_getPrivateProcAddress(_name);
        if (!_glIsProgramNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsProgramNV_ptr(program);
}

typedef void (APIENTRY * PFN_GLLOADPROGRAMNV)(GLenum target, GLuint id, GLsizei len, const GLubyte * program);
static PFN_GLLOADPROGRAMNV _glLoadProgramNV_ptr = NULL;

static inline void APIENTRY _glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte * program) {
    const char *_name = "glLoadProgramNV";
    if (!_glLoadProgramNV_ptr) {
        _glLoadProgramNV_ptr = (PFN_GLLOADPROGRAMNV)_getPrivateProcAddress(_name);
        if (!_glLoadProgramNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLoadProgramNV_ptr(target, id, len, program);
}

typedef void (APIENTRY * PFN_GLPROGRAMPARAMETER4DNV)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLPROGRAMPARAMETER4DNV _glProgramParameter4dNV_ptr = NULL;

static inline void APIENTRY _glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glProgramParameter4dNV";
    if (!_glProgramParameter4dNV_ptr) {
        _glProgramParameter4dNV_ptr = (PFN_GLPROGRAMPARAMETER4DNV)_getPrivateProcAddress(_name);
        if (!_glProgramParameter4dNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramParameter4dNV_ptr(target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMPARAMETER4DVNV)(GLenum target, GLuint index, const GLdouble * v);
static PFN_GLPROGRAMPARAMETER4DVNV _glProgramParameter4dvNV_ptr = NULL;

static inline void APIENTRY _glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble * v) {
    const char *_name = "glProgramParameter4dvNV";
    if (!_glProgramParameter4dvNV_ptr) {
        _glProgramParameter4dvNV_ptr = (PFN_GLPROGRAMPARAMETER4DVNV)_getPrivateProcAddress(_name);
        if (!_glProgramParameter4dvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramParameter4dvNV_ptr(target, index, v);
}

typedef void (APIENTRY * PFN_GLPROGRAMPARAMETER4FNV)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLPROGRAMPARAMETER4FNV _glProgramParameter4fNV_ptr = NULL;

static inline void APIENTRY _glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glProgramParameter4fNV";
    if (!_glProgramParameter4fNV_ptr) {
        _glProgramParameter4fNV_ptr = (PFN_GLPROGRAMPARAMETER4FNV)_getPrivateProcAddress(_name);
        if (!_glProgramParameter4fNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramParameter4fNV_ptr(target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMPARAMETER4FVNV)(GLenum target, GLuint index, const GLfloat * v);
static PFN_GLPROGRAMPARAMETER4FVNV _glProgramParameter4fvNV_ptr = NULL;

static inline void APIENTRY _glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat * v) {
    const char *_name = "glProgramParameter4fvNV";
    if (!_glProgramParameter4fvNV_ptr) {
        _glProgramParameter4fvNV_ptr = (PFN_GLPROGRAMPARAMETER4FVNV)_getPrivateProcAddress(_name);
        if (!_glProgramParameter4fvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramParameter4fvNV_ptr(target, index, v);
}

typedef void (APIENTRY * PFN_GLPROGRAMPARAMETERS4DVNV)(GLenum target, GLuint index, GLsizei count, const GLdouble * v);
static PFN_GLPROGRAMPARAMETERS4DVNV _glProgramParameters4dvNV_ptr = NULL;

static inline void APIENTRY _glProgramParameters4dvNV(GLenum target, GLuint index, GLsizei count, const GLdouble * v) {
    const char *_name = "glProgramParameters4dvNV";
    if (!_glProgramParameters4dvNV_ptr) {
        _glProgramParameters4dvNV_ptr = (PFN_GLPROGRAMPARAMETERS4DVNV)_getPrivateProcAddress(_name);
        if (!_glProgramParameters4dvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramParameters4dvNV_ptr(target, index, count, v);
}

typedef void (APIENTRY * PFN_GLPROGRAMPARAMETERS4FVNV)(GLenum target, GLuint index, GLsizei count, const GLfloat * v);
static PFN_GLPROGRAMPARAMETERS4FVNV _glProgramParameters4fvNV_ptr = NULL;

static inline void APIENTRY _glProgramParameters4fvNV(GLenum target, GLuint index, GLsizei count, const GLfloat * v) {
    const char *_name = "glProgramParameters4fvNV";
    if (!_glProgramParameters4fvNV_ptr) {
        _glProgramParameters4fvNV_ptr = (PFN_GLPROGRAMPARAMETERS4FVNV)_getPrivateProcAddress(_name);
        if (!_glProgramParameters4fvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramParameters4fvNV_ptr(target, index, count, v);
}

typedef void (APIENTRY * PFN_GLREQUESTRESIDENTPROGRAMSNV)(GLsizei n, const GLuint * programs);
static PFN_GLREQUESTRESIDENTPROGRAMSNV _glRequestResidentProgramsNV_ptr = NULL;

static inline void APIENTRY _glRequestResidentProgramsNV(GLsizei n, const GLuint * programs) {
    const char *_name = "glRequestResidentProgramsNV";
    if (!_glRequestResidentProgramsNV_ptr) {
        _glRequestResidentProgramsNV_ptr = (PFN_GLREQUESTRESIDENTPROGRAMSNV)_getPrivateProcAddress(_name);
        if (!_glRequestResidentProgramsNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRequestResidentProgramsNV_ptr(n, programs);
}

typedef void (APIENTRY * PFN_GLTRACKMATRIXNV)(GLenum target, GLuint address, GLenum matrix, GLenum transform);
static PFN_GLTRACKMATRIXNV _glTrackMatrixNV_ptr = NULL;

static inline void APIENTRY _glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform) {
    const char *_name = "glTrackMatrixNV";
    if (!_glTrackMatrixNV_ptr) {
        _glTrackMatrixNV_ptr = (PFN_GLTRACKMATRIXNV)_getPrivateProcAddress(_name);
        if (!_glTrackMatrixNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTrackMatrixNV_ptr(target, address, matrix, transform);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBPOINTERNV)(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLVERTEXATTRIBPOINTERNV _glVertexAttribPointerNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribPointerNV(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribPointerNV";
    if (!_glVertexAttribPointerNV_ptr) {
        _glVertexAttribPointerNV_ptr = (PFN_GLVERTEXATTRIBPOINTERNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribPointerNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribPointerNV_ptr(index, size, type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1DNV)(GLuint index, GLdouble x);
static PFN_GLVERTEXATTRIB1DNV _glVertexAttrib1dNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1dNV(GLuint index, GLdouble x) {
    const char *_name = "glVertexAttrib1dNV";
    if (!_glVertexAttrib1dNV_ptr) {
        _glVertexAttrib1dNV_ptr = (PFN_GLVERTEXATTRIB1DNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1dNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1dNV_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1DVNV)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIB1DVNV _glVertexAttrib1dvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1dvNV(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib1dvNV";
    if (!_glVertexAttrib1dvNV_ptr) {
        _glVertexAttrib1dvNV_ptr = (PFN_GLVERTEXATTRIB1DVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1dvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1dvNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1FNV)(GLuint index, GLfloat x);
static PFN_GLVERTEXATTRIB1FNV _glVertexAttrib1fNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1fNV(GLuint index, GLfloat x) {
    const char *_name = "glVertexAttrib1fNV";
    if (!_glVertexAttrib1fNV_ptr) {
        _glVertexAttrib1fNV_ptr = (PFN_GLVERTEXATTRIB1FNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1fNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1fNV_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1FVNV)(GLuint index, const GLfloat * v);
static PFN_GLVERTEXATTRIB1FVNV _glVertexAttrib1fvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1fvNV(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib1fvNV";
    if (!_glVertexAttrib1fvNV_ptr) {
        _glVertexAttrib1fvNV_ptr = (PFN_GLVERTEXATTRIB1FVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1fvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1fvNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1SNV)(GLuint index, GLshort x);
static PFN_GLVERTEXATTRIB1SNV _glVertexAttrib1sNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1sNV(GLuint index, GLshort x) {
    const char *_name = "glVertexAttrib1sNV";
    if (!_glVertexAttrib1sNV_ptr) {
        _glVertexAttrib1sNV_ptr = (PFN_GLVERTEXATTRIB1SNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1sNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1sNV_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1SVNV)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB1SVNV _glVertexAttrib1svNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1svNV(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib1svNV";
    if (!_glVertexAttrib1svNV_ptr) {
        _glVertexAttrib1svNV_ptr = (PFN_GLVERTEXATTRIB1SVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1svNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1svNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2DNV)(GLuint index, GLdouble x, GLdouble y);
static PFN_GLVERTEXATTRIB2DNV _glVertexAttrib2dNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y) {
    const char *_name = "glVertexAttrib2dNV";
    if (!_glVertexAttrib2dNV_ptr) {
        _glVertexAttrib2dNV_ptr = (PFN_GLVERTEXATTRIB2DNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2dNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2dNV_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2DVNV)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIB2DVNV _glVertexAttrib2dvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2dvNV(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib2dvNV";
    if (!_glVertexAttrib2dvNV_ptr) {
        _glVertexAttrib2dvNV_ptr = (PFN_GLVERTEXATTRIB2DVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2dvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2dvNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2FNV)(GLuint index, GLfloat x, GLfloat y);
static PFN_GLVERTEXATTRIB2FNV _glVertexAttrib2fNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y) {
    const char *_name = "glVertexAttrib2fNV";
    if (!_glVertexAttrib2fNV_ptr) {
        _glVertexAttrib2fNV_ptr = (PFN_GLVERTEXATTRIB2FNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2fNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2fNV_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2FVNV)(GLuint index, const GLfloat * v);
static PFN_GLVERTEXATTRIB2FVNV _glVertexAttrib2fvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2fvNV(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib2fvNV";
    if (!_glVertexAttrib2fvNV_ptr) {
        _glVertexAttrib2fvNV_ptr = (PFN_GLVERTEXATTRIB2FVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2fvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2fvNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2SNV)(GLuint index, GLshort x, GLshort y);
static PFN_GLVERTEXATTRIB2SNV _glVertexAttrib2sNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y) {
    const char *_name = "glVertexAttrib2sNV";
    if (!_glVertexAttrib2sNV_ptr) {
        _glVertexAttrib2sNV_ptr = (PFN_GLVERTEXATTRIB2SNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2sNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2sNV_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2SVNV)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB2SVNV _glVertexAttrib2svNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2svNV(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib2svNV";
    if (!_glVertexAttrib2svNV_ptr) {
        _glVertexAttrib2svNV_ptr = (PFN_GLVERTEXATTRIB2SVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2svNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2svNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3DNV)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
static PFN_GLVERTEXATTRIB3DNV _glVertexAttrib3dNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertexAttrib3dNV";
    if (!_glVertexAttrib3dNV_ptr) {
        _glVertexAttrib3dNV_ptr = (PFN_GLVERTEXATTRIB3DNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3dNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3dNV_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3DVNV)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIB3DVNV _glVertexAttrib3dvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3dvNV(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib3dvNV";
    if (!_glVertexAttrib3dvNV_ptr) {
        _glVertexAttrib3dvNV_ptr = (PFN_GLVERTEXATTRIB3DVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3dvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3dvNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3FNV)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLVERTEXATTRIB3FNV _glVertexAttrib3fNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glVertexAttrib3fNV";
    if (!_glVertexAttrib3fNV_ptr) {
        _glVertexAttrib3fNV_ptr = (PFN_GLVERTEXATTRIB3FNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3fNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3fNV_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3FVNV)(GLuint index, const GLfloat * v);
static PFN_GLVERTEXATTRIB3FVNV _glVertexAttrib3fvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3fvNV(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib3fvNV";
    if (!_glVertexAttrib3fvNV_ptr) {
        _glVertexAttrib3fvNV_ptr = (PFN_GLVERTEXATTRIB3FVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3fvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3fvNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3SNV)(GLuint index, GLshort x, GLshort y, GLshort z);
static PFN_GLVERTEXATTRIB3SNV _glVertexAttrib3sNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z) {
    const char *_name = "glVertexAttrib3sNV";
    if (!_glVertexAttrib3sNV_ptr) {
        _glVertexAttrib3sNV_ptr = (PFN_GLVERTEXATTRIB3SNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3sNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3sNV_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3SVNV)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB3SVNV _glVertexAttrib3svNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3svNV(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib3svNV";
    if (!_glVertexAttrib3svNV_ptr) {
        _glVertexAttrib3svNV_ptr = (PFN_GLVERTEXATTRIB3SVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3svNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3svNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4DNV)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLVERTEXATTRIB4DNV _glVertexAttrib4dNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertexAttrib4dNV";
    if (!_glVertexAttrib4dNV_ptr) {
        _glVertexAttrib4dNV_ptr = (PFN_GLVERTEXATTRIB4DNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4dNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4dNV_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4DVNV)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIB4DVNV _glVertexAttrib4dvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4dvNV(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib4dvNV";
    if (!_glVertexAttrib4dvNV_ptr) {
        _glVertexAttrib4dvNV_ptr = (PFN_GLVERTEXATTRIB4DVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4dvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4dvNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4FNV)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLVERTEXATTRIB4FNV _glVertexAttrib4fNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glVertexAttrib4fNV";
    if (!_glVertexAttrib4fNV_ptr) {
        _glVertexAttrib4fNV_ptr = (PFN_GLVERTEXATTRIB4FNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4fNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4fNV_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4FVNV)(GLuint index, const GLfloat * v);
static PFN_GLVERTEXATTRIB4FVNV _glVertexAttrib4fvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4fvNV(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib4fvNV";
    if (!_glVertexAttrib4fvNV_ptr) {
        _glVertexAttrib4fvNV_ptr = (PFN_GLVERTEXATTRIB4FVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4fvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4fvNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4SNV)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
static PFN_GLVERTEXATTRIB4SNV _glVertexAttrib4sNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glVertexAttrib4sNV";
    if (!_glVertexAttrib4sNV_ptr) {
        _glVertexAttrib4sNV_ptr = (PFN_GLVERTEXATTRIB4SNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4sNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4sNV_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4SVNV)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIB4SVNV _glVertexAttrib4svNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4svNV(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib4svNV";
    if (!_glVertexAttrib4svNV_ptr) {
        _glVertexAttrib4svNV_ptr = (PFN_GLVERTEXATTRIB4SVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4svNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4svNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4UBNV)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
static PFN_GLVERTEXATTRIB4UBNV _glVertexAttrib4ubNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) {
    const char *_name = "glVertexAttrib4ubNV";
    if (!_glVertexAttrib4ubNV_ptr) {
        _glVertexAttrib4ubNV_ptr = (PFN_GLVERTEXATTRIB4UBNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4ubNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4ubNV_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4UBVNV)(GLuint index, const GLubyte * v);
static PFN_GLVERTEXATTRIB4UBVNV _glVertexAttrib4ubvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4ubvNV(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttrib4ubvNV";
    if (!_glVertexAttrib4ubvNV_ptr) {
        _glVertexAttrib4ubvNV_ptr = (PFN_GLVERTEXATTRIB4UBVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4ubvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4ubvNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS1DVNV)(GLuint index, GLsizei count, const GLdouble * v);
static PFN_GLVERTEXATTRIBS1DVNV _glVertexAttribs1dvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs1dvNV(GLuint index, GLsizei count, const GLdouble * v) {
    const char *_name = "glVertexAttribs1dvNV";
    if (!_glVertexAttribs1dvNV_ptr) {
        _glVertexAttribs1dvNV_ptr = (PFN_GLVERTEXATTRIBS1DVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs1dvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs1dvNV_ptr(index, count, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS1FVNV)(GLuint index, GLsizei count, const GLfloat * v);
static PFN_GLVERTEXATTRIBS1FVNV _glVertexAttribs1fvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs1fvNV(GLuint index, GLsizei count, const GLfloat * v) {
    const char *_name = "glVertexAttribs1fvNV";
    if (!_glVertexAttribs1fvNV_ptr) {
        _glVertexAttribs1fvNV_ptr = (PFN_GLVERTEXATTRIBS1FVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs1fvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs1fvNV_ptr(index, count, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS1SVNV)(GLuint index, GLsizei count, const GLshort * v);
static PFN_GLVERTEXATTRIBS1SVNV _glVertexAttribs1svNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs1svNV(GLuint index, GLsizei count, const GLshort * v) {
    const char *_name = "glVertexAttribs1svNV";
    if (!_glVertexAttribs1svNV_ptr) {
        _glVertexAttribs1svNV_ptr = (PFN_GLVERTEXATTRIBS1SVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs1svNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs1svNV_ptr(index, count, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS2DVNV)(GLuint index, GLsizei count, const GLdouble * v);
static PFN_GLVERTEXATTRIBS2DVNV _glVertexAttribs2dvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs2dvNV(GLuint index, GLsizei count, const GLdouble * v) {
    const char *_name = "glVertexAttribs2dvNV";
    if (!_glVertexAttribs2dvNV_ptr) {
        _glVertexAttribs2dvNV_ptr = (PFN_GLVERTEXATTRIBS2DVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs2dvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs2dvNV_ptr(index, count, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS2FVNV)(GLuint index, GLsizei count, const GLfloat * v);
static PFN_GLVERTEXATTRIBS2FVNV _glVertexAttribs2fvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs2fvNV(GLuint index, GLsizei count, const GLfloat * v) {
    const char *_name = "glVertexAttribs2fvNV";
    if (!_glVertexAttribs2fvNV_ptr) {
        _glVertexAttribs2fvNV_ptr = (PFN_GLVERTEXATTRIBS2FVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs2fvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs2fvNV_ptr(index, count, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS2SVNV)(GLuint index, GLsizei count, const GLshort * v);
static PFN_GLVERTEXATTRIBS2SVNV _glVertexAttribs2svNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs2svNV(GLuint index, GLsizei count, const GLshort * v) {
    const char *_name = "glVertexAttribs2svNV";
    if (!_glVertexAttribs2svNV_ptr) {
        _glVertexAttribs2svNV_ptr = (PFN_GLVERTEXATTRIBS2SVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs2svNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs2svNV_ptr(index, count, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS3DVNV)(GLuint index, GLsizei count, const GLdouble * v);
static PFN_GLVERTEXATTRIBS3DVNV _glVertexAttribs3dvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs3dvNV(GLuint index, GLsizei count, const GLdouble * v) {
    const char *_name = "glVertexAttribs3dvNV";
    if (!_glVertexAttribs3dvNV_ptr) {
        _glVertexAttribs3dvNV_ptr = (PFN_GLVERTEXATTRIBS3DVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs3dvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs3dvNV_ptr(index, count, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS3FVNV)(GLuint index, GLsizei count, const GLfloat * v);
static PFN_GLVERTEXATTRIBS3FVNV _glVertexAttribs3fvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs3fvNV(GLuint index, GLsizei count, const GLfloat * v) {
    const char *_name = "glVertexAttribs3fvNV";
    if (!_glVertexAttribs3fvNV_ptr) {
        _glVertexAttribs3fvNV_ptr = (PFN_GLVERTEXATTRIBS3FVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs3fvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs3fvNV_ptr(index, count, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS3SVNV)(GLuint index, GLsizei count, const GLshort * v);
static PFN_GLVERTEXATTRIBS3SVNV _glVertexAttribs3svNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs3svNV(GLuint index, GLsizei count, const GLshort * v) {
    const char *_name = "glVertexAttribs3svNV";
    if (!_glVertexAttribs3svNV_ptr) {
        _glVertexAttribs3svNV_ptr = (PFN_GLVERTEXATTRIBS3SVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs3svNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs3svNV_ptr(index, count, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS4DVNV)(GLuint index, GLsizei count, const GLdouble * v);
static PFN_GLVERTEXATTRIBS4DVNV _glVertexAttribs4dvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs4dvNV(GLuint index, GLsizei count, const GLdouble * v) {
    const char *_name = "glVertexAttribs4dvNV";
    if (!_glVertexAttribs4dvNV_ptr) {
        _glVertexAttribs4dvNV_ptr = (PFN_GLVERTEXATTRIBS4DVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs4dvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs4dvNV_ptr(index, count, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS4FVNV)(GLuint index, GLsizei count, const GLfloat * v);
static PFN_GLVERTEXATTRIBS4FVNV _glVertexAttribs4fvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs4fvNV(GLuint index, GLsizei count, const GLfloat * v) {
    const char *_name = "glVertexAttribs4fvNV";
    if (!_glVertexAttribs4fvNV_ptr) {
        _glVertexAttribs4fvNV_ptr = (PFN_GLVERTEXATTRIBS4FVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs4fvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs4fvNV_ptr(index, count, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS4SVNV)(GLuint index, GLsizei count, const GLshort * v);
static PFN_GLVERTEXATTRIBS4SVNV _glVertexAttribs4svNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs4svNV(GLuint index, GLsizei count, const GLshort * v) {
    const char *_name = "glVertexAttribs4svNV";
    if (!_glVertexAttribs4svNV_ptr) {
        _glVertexAttribs4svNV_ptr = (PFN_GLVERTEXATTRIBS4SVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs4svNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs4svNV_ptr(index, count, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS4UBVNV)(GLuint index, GLsizei count, const GLubyte * v);
static PFN_GLVERTEXATTRIBS4UBVNV _glVertexAttribs4ubvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs4ubvNV(GLuint index, GLsizei count, const GLubyte * v) {
    const char *_name = "glVertexAttribs4ubvNV";
    if (!_glVertexAttribs4ubvNV_ptr) {
        _glVertexAttribs4ubvNV_ptr = (PFN_GLVERTEXATTRIBS4UBVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs4ubvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs4ubvNV_ptr(index, count, v);
}

typedef void (APIENTRY * PFN_GLTEXBUMPPARAMETERIVATI)(GLenum pname, const GLint * param);
static PFN_GLTEXBUMPPARAMETERIVATI _glTexBumpParameterivATI_ptr = NULL;

static inline void APIENTRY _glTexBumpParameterivATI(GLenum pname, const GLint * param) {
    const char *_name = "glTexBumpParameterivATI";
    if (!_glTexBumpParameterivATI_ptr) {
        _glTexBumpParameterivATI_ptr = (PFN_GLTEXBUMPPARAMETERIVATI)_getPrivateProcAddress(_name);
        if (!_glTexBumpParameterivATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexBumpParameterivATI_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLTEXBUMPPARAMETERFVATI)(GLenum pname, const GLfloat * param);
static PFN_GLTEXBUMPPARAMETERFVATI _glTexBumpParameterfvATI_ptr = NULL;

static inline void APIENTRY _glTexBumpParameterfvATI(GLenum pname, const GLfloat * param) {
    const char *_name = "glTexBumpParameterfvATI";
    if (!_glTexBumpParameterfvATI_ptr) {
        _glTexBumpParameterfvATI_ptr = (PFN_GLTEXBUMPPARAMETERFVATI)_getPrivateProcAddress(_name);
        if (!_glTexBumpParameterfvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexBumpParameterfvATI_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLGETTEXBUMPPARAMETERIVATI)(GLenum pname, GLint * param);
static PFN_GLGETTEXBUMPPARAMETERIVATI _glGetTexBumpParameterivATI_ptr = NULL;

static inline void APIENTRY _glGetTexBumpParameterivATI(GLenum pname, GLint * param) {
    const char *_name = "glGetTexBumpParameterivATI";
    if (!_glGetTexBumpParameterivATI_ptr) {
        _glGetTexBumpParameterivATI_ptr = (PFN_GLGETTEXBUMPPARAMETERIVATI)_getPrivateProcAddress(_name);
        if (!_glGetTexBumpParameterivATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexBumpParameterivATI_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLGETTEXBUMPPARAMETERFVATI)(GLenum pname, GLfloat * param);
static PFN_GLGETTEXBUMPPARAMETERFVATI _glGetTexBumpParameterfvATI_ptr = NULL;

static inline void APIENTRY _glGetTexBumpParameterfvATI(GLenum pname, GLfloat * param) {
    const char *_name = "glGetTexBumpParameterfvATI";
    if (!_glGetTexBumpParameterfvATI_ptr) {
        _glGetTexBumpParameterfvATI_ptr = (PFN_GLGETTEXBUMPPARAMETERFVATI)_getPrivateProcAddress(_name);
        if (!_glGetTexBumpParameterfvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexBumpParameterfvATI_ptr(pname, param);
}

typedef GLuint (APIENTRY * PFN_GLGENFRAGMENTSHADERSATI)(GLuint range);
static PFN_GLGENFRAGMENTSHADERSATI _glGenFragmentShadersATI_ptr = NULL;

static inline GLuint APIENTRY _glGenFragmentShadersATI(GLuint range) {
    const char *_name = "glGenFragmentShadersATI";
    if (!_glGenFragmentShadersATI_ptr) {
        _glGenFragmentShadersATI_ptr = (PFN_GLGENFRAGMENTSHADERSATI)_getPrivateProcAddress(_name);
        if (!_glGenFragmentShadersATI_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGenFragmentShadersATI_ptr(range);
}

typedef void (APIENTRY * PFN_GLBINDFRAGMENTSHADERATI)(GLuint id);
static PFN_GLBINDFRAGMENTSHADERATI _glBindFragmentShaderATI_ptr = NULL;

static inline void APIENTRY _glBindFragmentShaderATI(GLuint id) {
    const char *_name = "glBindFragmentShaderATI";
    if (!_glBindFragmentShaderATI_ptr) {
        _glBindFragmentShaderATI_ptr = (PFN_GLBINDFRAGMENTSHADERATI)_getPrivateProcAddress(_name);
        if (!_glBindFragmentShaderATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindFragmentShaderATI_ptr(id);
}

typedef void (APIENTRY * PFN_GLDELETEFRAGMENTSHADERATI)(GLuint id);
static PFN_GLDELETEFRAGMENTSHADERATI _glDeleteFragmentShaderATI_ptr = NULL;

static inline void APIENTRY _glDeleteFragmentShaderATI(GLuint id) {
    const char *_name = "glDeleteFragmentShaderATI";
    if (!_glDeleteFragmentShaderATI_ptr) {
        _glDeleteFragmentShaderATI_ptr = (PFN_GLDELETEFRAGMENTSHADERATI)_getPrivateProcAddress(_name);
        if (!_glDeleteFragmentShaderATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteFragmentShaderATI_ptr(id);
}

typedef void (APIENTRY * PFN_GLBEGINFRAGMENTSHADERATI)(void);
static PFN_GLBEGINFRAGMENTSHADERATI _glBeginFragmentShaderATI_ptr = NULL;

static inline void APIENTRY _glBeginFragmentShaderATI(void) {
    const char *_name = "glBeginFragmentShaderATI";
    if (!_glBeginFragmentShaderATI_ptr) {
        _glBeginFragmentShaderATI_ptr = (PFN_GLBEGINFRAGMENTSHADERATI)_getPrivateProcAddress(_name);
        if (!_glBeginFragmentShaderATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginFragmentShaderATI_ptr();
}

typedef void (APIENTRY * PFN_GLENDFRAGMENTSHADERATI)(void);
static PFN_GLENDFRAGMENTSHADERATI _glEndFragmentShaderATI_ptr = NULL;

static inline void APIENTRY _glEndFragmentShaderATI(void) {
    const char *_name = "glEndFragmentShaderATI";
    if (!_glEndFragmentShaderATI_ptr) {
        _glEndFragmentShaderATI_ptr = (PFN_GLENDFRAGMENTSHADERATI)_getPrivateProcAddress(_name);
        if (!_glEndFragmentShaderATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndFragmentShaderATI_ptr();
}

typedef void (APIENTRY * PFN_GLPASSTEXCOORDATI)(GLuint dst, GLuint coord, GLenum swizzle);
static PFN_GLPASSTEXCOORDATI _glPassTexCoordATI_ptr = NULL;

static inline void APIENTRY _glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle) {
    const char *_name = "glPassTexCoordATI";
    if (!_glPassTexCoordATI_ptr) {
        _glPassTexCoordATI_ptr = (PFN_GLPASSTEXCOORDATI)_getPrivateProcAddress(_name);
        if (!_glPassTexCoordATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPassTexCoordATI_ptr(dst, coord, swizzle);
}

typedef void (APIENTRY * PFN_GLSAMPLEMAPATI)(GLuint dst, GLuint interp, GLenum swizzle);
static PFN_GLSAMPLEMAPATI _glSampleMapATI_ptr = NULL;

static inline void APIENTRY _glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle) {
    const char *_name = "glSampleMapATI";
    if (!_glSampleMapATI_ptr) {
        _glSampleMapATI_ptr = (PFN_GLSAMPLEMAPATI)_getPrivateProcAddress(_name);
        if (!_glSampleMapATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSampleMapATI_ptr(dst, interp, swizzle);
}

typedef void (APIENTRY * PFN_GLCOLORFRAGMENTOP1ATI)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
static PFN_GLCOLORFRAGMENTOP1ATI _glColorFragmentOp1ATI_ptr = NULL;

static inline void APIENTRY _glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) {
    const char *_name = "glColorFragmentOp1ATI";
    if (!_glColorFragmentOp1ATI_ptr) {
        _glColorFragmentOp1ATI_ptr = (PFN_GLCOLORFRAGMENTOP1ATI)_getPrivateProcAddress(_name);
        if (!_glColorFragmentOp1ATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorFragmentOp1ATI_ptr(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
}

typedef void (APIENTRY * PFN_GLCOLORFRAGMENTOP2ATI)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
static PFN_GLCOLORFRAGMENTOP2ATI _glColorFragmentOp2ATI_ptr = NULL;

static inline void APIENTRY _glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) {
    const char *_name = "glColorFragmentOp2ATI";
    if (!_glColorFragmentOp2ATI_ptr) {
        _glColorFragmentOp2ATI_ptr = (PFN_GLCOLORFRAGMENTOP2ATI)_getPrivateProcAddress(_name);
        if (!_glColorFragmentOp2ATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorFragmentOp2ATI_ptr(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
}

typedef void (APIENTRY * PFN_GLCOLORFRAGMENTOP3ATI)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
static PFN_GLCOLORFRAGMENTOP3ATI _glColorFragmentOp3ATI_ptr = NULL;

static inline void APIENTRY _glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) {
    const char *_name = "glColorFragmentOp3ATI";
    if (!_glColorFragmentOp3ATI_ptr) {
        _glColorFragmentOp3ATI_ptr = (PFN_GLCOLORFRAGMENTOP3ATI)_getPrivateProcAddress(_name);
        if (!_glColorFragmentOp3ATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorFragmentOp3ATI_ptr(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
}

typedef void (APIENTRY * PFN_GLALPHAFRAGMENTOP1ATI)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
static PFN_GLALPHAFRAGMENTOP1ATI _glAlphaFragmentOp1ATI_ptr = NULL;

static inline void APIENTRY _glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) {
    const char *_name = "glAlphaFragmentOp1ATI";
    if (!_glAlphaFragmentOp1ATI_ptr) {
        _glAlphaFragmentOp1ATI_ptr = (PFN_GLALPHAFRAGMENTOP1ATI)_getPrivateProcAddress(_name);
        if (!_glAlphaFragmentOp1ATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glAlphaFragmentOp1ATI_ptr(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
}

typedef void (APIENTRY * PFN_GLALPHAFRAGMENTOP2ATI)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
static PFN_GLALPHAFRAGMENTOP2ATI _glAlphaFragmentOp2ATI_ptr = NULL;

static inline void APIENTRY _glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) {
    const char *_name = "glAlphaFragmentOp2ATI";
    if (!_glAlphaFragmentOp2ATI_ptr) {
        _glAlphaFragmentOp2ATI_ptr = (PFN_GLALPHAFRAGMENTOP2ATI)_getPrivateProcAddress(_name);
        if (!_glAlphaFragmentOp2ATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glAlphaFragmentOp2ATI_ptr(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
}

typedef void (APIENTRY * PFN_GLALPHAFRAGMENTOP3ATI)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
static PFN_GLALPHAFRAGMENTOP3ATI _glAlphaFragmentOp3ATI_ptr = NULL;

static inline void APIENTRY _glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) {
    const char *_name = "glAlphaFragmentOp3ATI";
    if (!_glAlphaFragmentOp3ATI_ptr) {
        _glAlphaFragmentOp3ATI_ptr = (PFN_GLALPHAFRAGMENTOP3ATI)_getPrivateProcAddress(_name);
        if (!_glAlphaFragmentOp3ATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glAlphaFragmentOp3ATI_ptr(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
}

typedef void (APIENTRY * PFN_GLSETFRAGMENTSHADERCONSTANTATI)(GLuint dst, const GLfloat * value);
static PFN_GLSETFRAGMENTSHADERCONSTANTATI _glSetFragmentShaderConstantATI_ptr = NULL;

static inline void APIENTRY _glSetFragmentShaderConstantATI(GLuint dst, const GLfloat * value) {
    const char *_name = "glSetFragmentShaderConstantATI";
    if (!_glSetFragmentShaderConstantATI_ptr) {
        _glSetFragmentShaderConstantATI_ptr = (PFN_GLSETFRAGMENTSHADERCONSTANTATI)_getPrivateProcAddress(_name);
        if (!_glSetFragmentShaderConstantATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSetFragmentShaderConstantATI_ptr(dst, value);
}

typedef void (APIENTRY * PFN_GLPNTRIANGLESIATI)(GLenum pname, GLint param);
static PFN_GLPNTRIANGLESIATI _glPNTrianglesiATI_ptr = NULL;

static inline void APIENTRY _glPNTrianglesiATI(GLenum pname, GLint param) {
    const char *_name = "glPNTrianglesiATI";
    if (!_glPNTrianglesiATI_ptr) {
        _glPNTrianglesiATI_ptr = (PFN_GLPNTRIANGLESIATI)_getPrivateProcAddress(_name);
        if (!_glPNTrianglesiATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPNTrianglesiATI_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLPNTRIANGLESFATI)(GLenum pname, GLfloat param);
static PFN_GLPNTRIANGLESFATI _glPNTrianglesfATI_ptr = NULL;

static inline void APIENTRY _glPNTrianglesfATI(GLenum pname, GLfloat param) {
    const char *_name = "glPNTrianglesfATI";
    if (!_glPNTrianglesfATI_ptr) {
        _glPNTrianglesfATI_ptr = (PFN_GLPNTRIANGLESFATI)_getPrivateProcAddress(_name);
        if (!_glPNTrianglesfATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPNTrianglesfATI_ptr(pname, param);
}

typedef GLuint (APIENTRY * PFN_GLNEWOBJECTBUFFERATI)(GLsizei size, const GLvoid * pointer, GLenum usage);
static PFN_GLNEWOBJECTBUFFERATI _glNewObjectBufferATI_ptr = NULL;

static inline GLuint APIENTRY _glNewObjectBufferATI(GLsizei size, const GLvoid * pointer, GLenum usage) {
    const char *_name = "glNewObjectBufferATI";
    if (!_glNewObjectBufferATI_ptr) {
        _glNewObjectBufferATI_ptr = (PFN_GLNEWOBJECTBUFFERATI)_getPrivateProcAddress(_name);
        if (!_glNewObjectBufferATI_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glNewObjectBufferATI_ptr(size, pointer, usage);
}

typedef GLboolean (APIENTRY * PFN_GLISOBJECTBUFFERATI)(GLuint buffer);
static PFN_GLISOBJECTBUFFERATI _glIsObjectBufferATI_ptr = NULL;

static inline GLboolean APIENTRY _glIsObjectBufferATI(GLuint buffer) {
    const char *_name = "glIsObjectBufferATI";
    if (!_glIsObjectBufferATI_ptr) {
        _glIsObjectBufferATI_ptr = (PFN_GLISOBJECTBUFFERATI)_getPrivateProcAddress(_name);
        if (!_glIsObjectBufferATI_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsObjectBufferATI_ptr(buffer);
}

typedef void (APIENTRY * PFN_GLUPDATEOBJECTBUFFERATI)(GLuint buffer, GLuint offset, GLsizei size, const GLvoid * pointer, GLenum preserve);
static PFN_GLUPDATEOBJECTBUFFERATI _glUpdateObjectBufferATI_ptr = NULL;

static inline void APIENTRY _glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const GLvoid * pointer, GLenum preserve) {
    const char *_name = "glUpdateObjectBufferATI";
    if (!_glUpdateObjectBufferATI_ptr) {
        _glUpdateObjectBufferATI_ptr = (PFN_GLUPDATEOBJECTBUFFERATI)_getPrivateProcAddress(_name);
        if (!_glUpdateObjectBufferATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUpdateObjectBufferATI_ptr(buffer, offset, size, pointer, preserve);
}

typedef void (APIENTRY * PFN_GLGETOBJECTBUFFERFVATI)(GLuint buffer, GLenum pname, GLfloat * params);
static PFN_GLGETOBJECTBUFFERFVATI _glGetObjectBufferfvATI_ptr = NULL;

static inline void APIENTRY _glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat * params) {
    const char *_name = "glGetObjectBufferfvATI";
    if (!_glGetObjectBufferfvATI_ptr) {
        _glGetObjectBufferfvATI_ptr = (PFN_GLGETOBJECTBUFFERFVATI)_getPrivateProcAddress(_name);
        if (!_glGetObjectBufferfvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetObjectBufferfvATI_ptr(buffer, pname, params);
}

typedef void (APIENTRY * PFN_GLGETOBJECTBUFFERIVATI)(GLuint buffer, GLenum pname, GLint * params);
static PFN_GLGETOBJECTBUFFERIVATI _glGetObjectBufferivATI_ptr = NULL;

static inline void APIENTRY _glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint * params) {
    const char *_name = "glGetObjectBufferivATI";
    if (!_glGetObjectBufferivATI_ptr) {
        _glGetObjectBufferivATI_ptr = (PFN_GLGETOBJECTBUFFERIVATI)_getPrivateProcAddress(_name);
        if (!_glGetObjectBufferivATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetObjectBufferivATI_ptr(buffer, pname, params);
}

typedef void (APIENTRY * PFN_GLFREEOBJECTBUFFERATI)(GLuint buffer);
static PFN_GLFREEOBJECTBUFFERATI _glFreeObjectBufferATI_ptr = NULL;

static inline void APIENTRY _glFreeObjectBufferATI(GLuint buffer) {
    const char *_name = "glFreeObjectBufferATI";
    if (!_glFreeObjectBufferATI_ptr) {
        _glFreeObjectBufferATI_ptr = (PFN_GLFREEOBJECTBUFFERATI)_getPrivateProcAddress(_name);
        if (!_glFreeObjectBufferATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFreeObjectBufferATI_ptr(buffer);
}

typedef void (APIENTRY * PFN_GLARRAYOBJECTATI)(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
static PFN_GLARRAYOBJECTATI _glArrayObjectATI_ptr = NULL;

static inline void APIENTRY _glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset) {
    const char *_name = "glArrayObjectATI";
    if (!_glArrayObjectATI_ptr) {
        _glArrayObjectATI_ptr = (PFN_GLARRAYOBJECTATI)_getPrivateProcAddress(_name);
        if (!_glArrayObjectATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glArrayObjectATI_ptr(array, size, type, stride, buffer, offset);
}

typedef void (APIENTRY * PFN_GLGETARRAYOBJECTFVATI)(GLenum array, GLenum pname, GLfloat * params);
static PFN_GLGETARRAYOBJECTFVATI _glGetArrayObjectfvATI_ptr = NULL;

static inline void APIENTRY _glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat * params) {
    const char *_name = "glGetArrayObjectfvATI";
    if (!_glGetArrayObjectfvATI_ptr) {
        _glGetArrayObjectfvATI_ptr = (PFN_GLGETARRAYOBJECTFVATI)_getPrivateProcAddress(_name);
        if (!_glGetArrayObjectfvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetArrayObjectfvATI_ptr(array, pname, params);
}

typedef void (APIENTRY * PFN_GLGETARRAYOBJECTIVATI)(GLenum array, GLenum pname, GLint * params);
static PFN_GLGETARRAYOBJECTIVATI _glGetArrayObjectivATI_ptr = NULL;

static inline void APIENTRY _glGetArrayObjectivATI(GLenum array, GLenum pname, GLint * params) {
    const char *_name = "glGetArrayObjectivATI";
    if (!_glGetArrayObjectivATI_ptr) {
        _glGetArrayObjectivATI_ptr = (PFN_GLGETARRAYOBJECTIVATI)_getPrivateProcAddress(_name);
        if (!_glGetArrayObjectivATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetArrayObjectivATI_ptr(array, pname, params);
}

typedef void (APIENTRY * PFN_GLVARIANTARRAYOBJECTATI)(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
static PFN_GLVARIANTARRAYOBJECTATI _glVariantArrayObjectATI_ptr = NULL;

static inline void APIENTRY _glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset) {
    const char *_name = "glVariantArrayObjectATI";
    if (!_glVariantArrayObjectATI_ptr) {
        _glVariantArrayObjectATI_ptr = (PFN_GLVARIANTARRAYOBJECTATI)_getPrivateProcAddress(_name);
        if (!_glVariantArrayObjectATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVariantArrayObjectATI_ptr(id, type, stride, buffer, offset);
}

typedef void (APIENTRY * PFN_GLGETVARIANTARRAYOBJECTFVATI)(GLuint id, GLenum pname, GLfloat * params);
static PFN_GLGETVARIANTARRAYOBJECTFVATI _glGetVariantArrayObjectfvATI_ptr = NULL;

static inline void APIENTRY _glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat * params) {
    const char *_name = "glGetVariantArrayObjectfvATI";
    if (!_glGetVariantArrayObjectfvATI_ptr) {
        _glGetVariantArrayObjectfvATI_ptr = (PFN_GLGETVARIANTARRAYOBJECTFVATI)_getPrivateProcAddress(_name);
        if (!_glGetVariantArrayObjectfvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVariantArrayObjectfvATI_ptr(id, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVARIANTARRAYOBJECTIVATI)(GLuint id, GLenum pname, GLint * params);
static PFN_GLGETVARIANTARRAYOBJECTIVATI _glGetVariantArrayObjectivATI_ptr = NULL;

static inline void APIENTRY _glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint * params) {
    const char *_name = "glGetVariantArrayObjectivATI";
    if (!_glGetVariantArrayObjectivATI_ptr) {
        _glGetVariantArrayObjectivATI_ptr = (PFN_GLGETVARIANTARRAYOBJECTIVATI)_getPrivateProcAddress(_name);
        if (!_glGetVariantArrayObjectivATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVariantArrayObjectivATI_ptr(id, pname, params);
}

typedef void (APIENTRY * PFN_GLBEGINVERTEXSHADEREXT)(void);
static PFN_GLBEGINVERTEXSHADEREXT _glBeginVertexShaderEXT_ptr = NULL;

static inline void APIENTRY _glBeginVertexShaderEXT(void) {
    const char *_name = "glBeginVertexShaderEXT";
    if (!_glBeginVertexShaderEXT_ptr) {
        _glBeginVertexShaderEXT_ptr = (PFN_GLBEGINVERTEXSHADEREXT)_getPrivateProcAddress(_name);
        if (!_glBeginVertexShaderEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginVertexShaderEXT_ptr();
}

typedef void (APIENTRY * PFN_GLENDVERTEXSHADEREXT)(void);
static PFN_GLENDVERTEXSHADEREXT _glEndVertexShaderEXT_ptr = NULL;

static inline void APIENTRY _glEndVertexShaderEXT(void) {
    const char *_name = "glEndVertexShaderEXT";
    if (!_glEndVertexShaderEXT_ptr) {
        _glEndVertexShaderEXT_ptr = (PFN_GLENDVERTEXSHADEREXT)_getPrivateProcAddress(_name);
        if (!_glEndVertexShaderEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndVertexShaderEXT_ptr();
}

typedef void (APIENTRY * PFN_GLBINDVERTEXSHADEREXT)(GLuint id);
static PFN_GLBINDVERTEXSHADEREXT _glBindVertexShaderEXT_ptr = NULL;

static inline void APIENTRY _glBindVertexShaderEXT(GLuint id) {
    const char *_name = "glBindVertexShaderEXT";
    if (!_glBindVertexShaderEXT_ptr) {
        _glBindVertexShaderEXT_ptr = (PFN_GLBINDVERTEXSHADEREXT)_getPrivateProcAddress(_name);
        if (!_glBindVertexShaderEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindVertexShaderEXT_ptr(id);
}

typedef GLuint (APIENTRY * PFN_GLGENVERTEXSHADERSEXT)(GLuint range);
static PFN_GLGENVERTEXSHADERSEXT _glGenVertexShadersEXT_ptr = NULL;

static inline GLuint APIENTRY _glGenVertexShadersEXT(GLuint range) {
    const char *_name = "glGenVertexShadersEXT";
    if (!_glGenVertexShadersEXT_ptr) {
        _glGenVertexShadersEXT_ptr = (PFN_GLGENVERTEXSHADERSEXT)_getPrivateProcAddress(_name);
        if (!_glGenVertexShadersEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGenVertexShadersEXT_ptr(range);
}

typedef void (APIENTRY * PFN_GLDELETEVERTEXSHADEREXT)(GLuint id);
static PFN_GLDELETEVERTEXSHADEREXT _glDeleteVertexShaderEXT_ptr = NULL;

static inline void APIENTRY _glDeleteVertexShaderEXT(GLuint id) {
    const char *_name = "glDeleteVertexShaderEXT";
    if (!_glDeleteVertexShaderEXT_ptr) {
        _glDeleteVertexShaderEXT_ptr = (PFN_GLDELETEVERTEXSHADEREXT)_getPrivateProcAddress(_name);
        if (!_glDeleteVertexShaderEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteVertexShaderEXT_ptr(id);
}

typedef void (APIENTRY * PFN_GLSHADEROP1EXT)(GLenum op, GLuint res, GLuint arg1);
static PFN_GLSHADEROP1EXT _glShaderOp1EXT_ptr = NULL;

static inline void APIENTRY _glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1) {
    const char *_name = "glShaderOp1EXT";
    if (!_glShaderOp1EXT_ptr) {
        _glShaderOp1EXT_ptr = (PFN_GLSHADEROP1EXT)_getPrivateProcAddress(_name);
        if (!_glShaderOp1EXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glShaderOp1EXT_ptr(op, res, arg1);
}

typedef void (APIENTRY * PFN_GLSHADEROP2EXT)(GLenum op, GLuint res, GLuint arg1, GLuint arg2);
static PFN_GLSHADEROP2EXT _glShaderOp2EXT_ptr = NULL;

static inline void APIENTRY _glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2) {
    const char *_name = "glShaderOp2EXT";
    if (!_glShaderOp2EXT_ptr) {
        _glShaderOp2EXT_ptr = (PFN_GLSHADEROP2EXT)_getPrivateProcAddress(_name);
        if (!_glShaderOp2EXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glShaderOp2EXT_ptr(op, res, arg1, arg2);
}

typedef void (APIENTRY * PFN_GLSHADEROP3EXT)(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
static PFN_GLSHADEROP3EXT _glShaderOp3EXT_ptr = NULL;

static inline void APIENTRY _glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3) {
    const char *_name = "glShaderOp3EXT";
    if (!_glShaderOp3EXT_ptr) {
        _glShaderOp3EXT_ptr = (PFN_GLSHADEROP3EXT)_getPrivateProcAddress(_name);
        if (!_glShaderOp3EXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glShaderOp3EXT_ptr(op, res, arg1, arg2, arg3);
}

typedef void (APIENTRY * PFN_GLSWIZZLEEXT)(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
static PFN_GLSWIZZLEEXT _glSwizzleEXT_ptr = NULL;

static inline void APIENTRY _glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) {
    const char *_name = "glSwizzleEXT";
    if (!_glSwizzleEXT_ptr) {
        _glSwizzleEXT_ptr = (PFN_GLSWIZZLEEXT)_getPrivateProcAddress(_name);
        if (!_glSwizzleEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSwizzleEXT_ptr(res, in, outX, outY, outZ, outW);
}

typedef void (APIENTRY * PFN_GLWRITEMASKEXT)(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
static PFN_GLWRITEMASKEXT _glWriteMaskEXT_ptr = NULL;

static inline void APIENTRY _glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) {
    const char *_name = "glWriteMaskEXT";
    if (!_glWriteMaskEXT_ptr) {
        _glWriteMaskEXT_ptr = (PFN_GLWRITEMASKEXT)_getPrivateProcAddress(_name);
        if (!_glWriteMaskEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWriteMaskEXT_ptr(res, in, outX, outY, outZ, outW);
}

typedef void (APIENTRY * PFN_GLINSERTCOMPONENTEXT)(GLuint res, GLuint src, GLuint num);
static PFN_GLINSERTCOMPONENTEXT _glInsertComponentEXT_ptr = NULL;

static inline void APIENTRY _glInsertComponentEXT(GLuint res, GLuint src, GLuint num) {
    const char *_name = "glInsertComponentEXT";
    if (!_glInsertComponentEXT_ptr) {
        _glInsertComponentEXT_ptr = (PFN_GLINSERTCOMPONENTEXT)_getPrivateProcAddress(_name);
        if (!_glInsertComponentEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glInsertComponentEXT_ptr(res, src, num);
}

typedef void (APIENTRY * PFN_GLEXTRACTCOMPONENTEXT)(GLuint res, GLuint src, GLuint num);
static PFN_GLEXTRACTCOMPONENTEXT _glExtractComponentEXT_ptr = NULL;

static inline void APIENTRY _glExtractComponentEXT(GLuint res, GLuint src, GLuint num) {
    const char *_name = "glExtractComponentEXT";
    if (!_glExtractComponentEXT_ptr) {
        _glExtractComponentEXT_ptr = (PFN_GLEXTRACTCOMPONENTEXT)_getPrivateProcAddress(_name);
        if (!_glExtractComponentEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glExtractComponentEXT_ptr(res, src, num);
}

typedef GLuint (APIENTRY * PFN_GLGENSYMBOLSEXT)(GLenum datatype, GLenum storagetype, GLenum range, GLuint components);
static PFN_GLGENSYMBOLSEXT _glGenSymbolsEXT_ptr = NULL;

static inline GLuint APIENTRY _glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components) {
    const char *_name = "glGenSymbolsEXT";
    if (!_glGenSymbolsEXT_ptr) {
        _glGenSymbolsEXT_ptr = (PFN_GLGENSYMBOLSEXT)_getPrivateProcAddress(_name);
        if (!_glGenSymbolsEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGenSymbolsEXT_ptr(datatype, storagetype, range, components);
}

typedef void (APIENTRY * PFN_GLSETINVARIANTEXT)(GLuint id, GLenum type, const GLvoid * addr);
static PFN_GLSETINVARIANTEXT _glSetInvariantEXT_ptr = NULL;

static inline void APIENTRY _glSetInvariantEXT(GLuint id, GLenum type, const GLvoid * addr) {
    const char *_name = "glSetInvariantEXT";
    if (!_glSetInvariantEXT_ptr) {
        _glSetInvariantEXT_ptr = (PFN_GLSETINVARIANTEXT)_getPrivateProcAddress(_name);
        if (!_glSetInvariantEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSetInvariantEXT_ptr(id, type, addr);
}

typedef void (APIENTRY * PFN_GLSETLOCALCONSTANTEXT)(GLuint id, GLenum type, const GLvoid * addr);
static PFN_GLSETLOCALCONSTANTEXT _glSetLocalConstantEXT_ptr = NULL;

static inline void APIENTRY _glSetLocalConstantEXT(GLuint id, GLenum type, const GLvoid * addr) {
    const char *_name = "glSetLocalConstantEXT";
    if (!_glSetLocalConstantEXT_ptr) {
        _glSetLocalConstantEXT_ptr = (PFN_GLSETLOCALCONSTANTEXT)_getPrivateProcAddress(_name);
        if (!_glSetLocalConstantEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSetLocalConstantEXT_ptr(id, type, addr);
}

typedef void (APIENTRY * PFN_GLVARIANTBVEXT)(GLuint id, const GLbyte * addr);
static PFN_GLVARIANTBVEXT _glVariantbvEXT_ptr = NULL;

static inline void APIENTRY _glVariantbvEXT(GLuint id, const GLbyte * addr) {
    const char *_name = "glVariantbvEXT";
    if (!_glVariantbvEXT_ptr) {
        _glVariantbvEXT_ptr = (PFN_GLVARIANTBVEXT)_getPrivateProcAddress(_name);
        if (!_glVariantbvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVariantbvEXT_ptr(id, addr);
}

typedef void (APIENTRY * PFN_GLVARIANTSVEXT)(GLuint id, const GLshort * addr);
static PFN_GLVARIANTSVEXT _glVariantsvEXT_ptr = NULL;

static inline void APIENTRY _glVariantsvEXT(GLuint id, const GLshort * addr) {
    const char *_name = "glVariantsvEXT";
    if (!_glVariantsvEXT_ptr) {
        _glVariantsvEXT_ptr = (PFN_GLVARIANTSVEXT)_getPrivateProcAddress(_name);
        if (!_glVariantsvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVariantsvEXT_ptr(id, addr);
}

typedef void (APIENTRY * PFN_GLVARIANTIVEXT)(GLuint id, const GLint * addr);
static PFN_GLVARIANTIVEXT _glVariantivEXT_ptr = NULL;

static inline void APIENTRY _glVariantivEXT(GLuint id, const GLint * addr) {
    const char *_name = "glVariantivEXT";
    if (!_glVariantivEXT_ptr) {
        _glVariantivEXT_ptr = (PFN_GLVARIANTIVEXT)_getPrivateProcAddress(_name);
        if (!_glVariantivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVariantivEXT_ptr(id, addr);
}

typedef void (APIENTRY * PFN_GLVARIANTFVEXT)(GLuint id, const GLfloat * addr);
static PFN_GLVARIANTFVEXT _glVariantfvEXT_ptr = NULL;

static inline void APIENTRY _glVariantfvEXT(GLuint id, const GLfloat * addr) {
    const char *_name = "glVariantfvEXT";
    if (!_glVariantfvEXT_ptr) {
        _glVariantfvEXT_ptr = (PFN_GLVARIANTFVEXT)_getPrivateProcAddress(_name);
        if (!_glVariantfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVariantfvEXT_ptr(id, addr);
}

typedef void (APIENTRY * PFN_GLVARIANTDVEXT)(GLuint id, const GLdouble * addr);
static PFN_GLVARIANTDVEXT _glVariantdvEXT_ptr = NULL;

static inline void APIENTRY _glVariantdvEXT(GLuint id, const GLdouble * addr) {
    const char *_name = "glVariantdvEXT";
    if (!_glVariantdvEXT_ptr) {
        _glVariantdvEXT_ptr = (PFN_GLVARIANTDVEXT)_getPrivateProcAddress(_name);
        if (!_glVariantdvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVariantdvEXT_ptr(id, addr);
}

typedef void (APIENTRY * PFN_GLVARIANTUBVEXT)(GLuint id, const GLubyte * addr);
static PFN_GLVARIANTUBVEXT _glVariantubvEXT_ptr = NULL;

static inline void APIENTRY _glVariantubvEXT(GLuint id, const GLubyte * addr) {
    const char *_name = "glVariantubvEXT";
    if (!_glVariantubvEXT_ptr) {
        _glVariantubvEXT_ptr = (PFN_GLVARIANTUBVEXT)_getPrivateProcAddress(_name);
        if (!_glVariantubvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVariantubvEXT_ptr(id, addr);
}

typedef void (APIENTRY * PFN_GLVARIANTUSVEXT)(GLuint id, const GLushort * addr);
static PFN_GLVARIANTUSVEXT _glVariantusvEXT_ptr = NULL;

static inline void APIENTRY _glVariantusvEXT(GLuint id, const GLushort * addr) {
    const char *_name = "glVariantusvEXT";
    if (!_glVariantusvEXT_ptr) {
        _glVariantusvEXT_ptr = (PFN_GLVARIANTUSVEXT)_getPrivateProcAddress(_name);
        if (!_glVariantusvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVariantusvEXT_ptr(id, addr);
}

typedef void (APIENTRY * PFN_GLVARIANTUIVEXT)(GLuint id, const GLuint * addr);
static PFN_GLVARIANTUIVEXT _glVariantuivEXT_ptr = NULL;

static inline void APIENTRY _glVariantuivEXT(GLuint id, const GLuint * addr) {
    const char *_name = "glVariantuivEXT";
    if (!_glVariantuivEXT_ptr) {
        _glVariantuivEXT_ptr = (PFN_GLVARIANTUIVEXT)_getPrivateProcAddress(_name);
        if (!_glVariantuivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVariantuivEXT_ptr(id, addr);
}

typedef void (APIENTRY * PFN_GLVARIANTPOINTEREXT)(GLuint id, GLenum type, GLuint stride, const GLvoid * addr);
static PFN_GLVARIANTPOINTEREXT _glVariantPointerEXT_ptr = NULL;

static inline void APIENTRY _glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const GLvoid * addr) {
    const char *_name = "glVariantPointerEXT";
    if (!_glVariantPointerEXT_ptr) {
        _glVariantPointerEXT_ptr = (PFN_GLVARIANTPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glVariantPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVariantPointerEXT_ptr(id, type, stride, addr);
}

typedef void (APIENTRY * PFN_GLENABLEVARIANTCLIENTSTATEEXT)(GLuint id);
static PFN_GLENABLEVARIANTCLIENTSTATEEXT _glEnableVariantClientStateEXT_ptr = NULL;

static inline void APIENTRY _glEnableVariantClientStateEXT(GLuint id) {
    const char *_name = "glEnableVariantClientStateEXT";
    if (!_glEnableVariantClientStateEXT_ptr) {
        _glEnableVariantClientStateEXT_ptr = (PFN_GLENABLEVARIANTCLIENTSTATEEXT)_getPrivateProcAddress(_name);
        if (!_glEnableVariantClientStateEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEnableVariantClientStateEXT_ptr(id);
}

typedef void (APIENTRY * PFN_GLDISABLEVARIANTCLIENTSTATEEXT)(GLuint id);
static PFN_GLDISABLEVARIANTCLIENTSTATEEXT _glDisableVariantClientStateEXT_ptr = NULL;

static inline void APIENTRY _glDisableVariantClientStateEXT(GLuint id) {
    const char *_name = "glDisableVariantClientStateEXT";
    if (!_glDisableVariantClientStateEXT_ptr) {
        _glDisableVariantClientStateEXT_ptr = (PFN_GLDISABLEVARIANTCLIENTSTATEEXT)_getPrivateProcAddress(_name);
        if (!_glDisableVariantClientStateEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDisableVariantClientStateEXT_ptr(id);
}

typedef GLuint (APIENTRY * PFN_GLBINDLIGHTPARAMETEREXT)(GLenum light, GLenum value);
static PFN_GLBINDLIGHTPARAMETEREXT _glBindLightParameterEXT_ptr = NULL;

static inline GLuint APIENTRY _glBindLightParameterEXT(GLenum light, GLenum value) {
    const char *_name = "glBindLightParameterEXT";
    if (!_glBindLightParameterEXT_ptr) {
        _glBindLightParameterEXT_ptr = (PFN_GLBINDLIGHTPARAMETEREXT)_getPrivateProcAddress(_name);
        if (!_glBindLightParameterEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glBindLightParameterEXT_ptr(light, value);
}

typedef GLuint (APIENTRY * PFN_GLBINDMATERIALPARAMETEREXT)(GLenum face, GLenum value);
static PFN_GLBINDMATERIALPARAMETEREXT _glBindMaterialParameterEXT_ptr = NULL;

static inline GLuint APIENTRY _glBindMaterialParameterEXT(GLenum face, GLenum value) {
    const char *_name = "glBindMaterialParameterEXT";
    if (!_glBindMaterialParameterEXT_ptr) {
        _glBindMaterialParameterEXT_ptr = (PFN_GLBINDMATERIALPARAMETEREXT)_getPrivateProcAddress(_name);
        if (!_glBindMaterialParameterEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glBindMaterialParameterEXT_ptr(face, value);
}

typedef GLuint (APIENTRY * PFN_GLBINDTEXGENPARAMETEREXT)(GLenum unit, GLenum coord, GLenum value);
static PFN_GLBINDTEXGENPARAMETEREXT _glBindTexGenParameterEXT_ptr = NULL;

static inline GLuint APIENTRY _glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value) {
    const char *_name = "glBindTexGenParameterEXT";
    if (!_glBindTexGenParameterEXT_ptr) {
        _glBindTexGenParameterEXT_ptr = (PFN_GLBINDTEXGENPARAMETEREXT)_getPrivateProcAddress(_name);
        if (!_glBindTexGenParameterEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glBindTexGenParameterEXT_ptr(unit, coord, value);
}

typedef GLuint (APIENTRY * PFN_GLBINDTEXTUREUNITPARAMETEREXT)(GLenum unit, GLenum value);
static PFN_GLBINDTEXTUREUNITPARAMETEREXT _glBindTextureUnitParameterEXT_ptr = NULL;

static inline GLuint APIENTRY _glBindTextureUnitParameterEXT(GLenum unit, GLenum value) {
    const char *_name = "glBindTextureUnitParameterEXT";
    if (!_glBindTextureUnitParameterEXT_ptr) {
        _glBindTextureUnitParameterEXT_ptr = (PFN_GLBINDTEXTUREUNITPARAMETEREXT)_getPrivateProcAddress(_name);
        if (!_glBindTextureUnitParameterEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glBindTextureUnitParameterEXT_ptr(unit, value);
}

typedef GLuint (APIENTRY * PFN_GLBINDPARAMETEREXT)(GLenum value);
static PFN_GLBINDPARAMETEREXT _glBindParameterEXT_ptr = NULL;

static inline GLuint APIENTRY _glBindParameterEXT(GLenum value) {
    const char *_name = "glBindParameterEXT";
    if (!_glBindParameterEXT_ptr) {
        _glBindParameterEXT_ptr = (PFN_GLBINDPARAMETEREXT)_getPrivateProcAddress(_name);
        if (!_glBindParameterEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glBindParameterEXT_ptr(value);
}

typedef GLboolean (APIENTRY * PFN_GLISVARIANTENABLEDEXT)(GLuint id, GLenum cap);
static PFN_GLISVARIANTENABLEDEXT _glIsVariantEnabledEXT_ptr = NULL;

static inline GLboolean APIENTRY _glIsVariantEnabledEXT(GLuint id, GLenum cap) {
    const char *_name = "glIsVariantEnabledEXT";
    if (!_glIsVariantEnabledEXT_ptr) {
        _glIsVariantEnabledEXT_ptr = (PFN_GLISVARIANTENABLEDEXT)_getPrivateProcAddress(_name);
        if (!_glIsVariantEnabledEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsVariantEnabledEXT_ptr(id, cap);
}

typedef void (APIENTRY * PFN_GLGETVARIANTBOOLEANVEXT)(GLuint id, GLenum value, GLboolean * data);
static PFN_GLGETVARIANTBOOLEANVEXT _glGetVariantBooleanvEXT_ptr = NULL;

static inline void APIENTRY _glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean * data) {
    const char *_name = "glGetVariantBooleanvEXT";
    if (!_glGetVariantBooleanvEXT_ptr) {
        _glGetVariantBooleanvEXT_ptr = (PFN_GLGETVARIANTBOOLEANVEXT)_getPrivateProcAddress(_name);
        if (!_glGetVariantBooleanvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVariantBooleanvEXT_ptr(id, value, data);
}

typedef void (APIENTRY * PFN_GLGETVARIANTINTEGERVEXT)(GLuint id, GLenum value, GLint * data);
static PFN_GLGETVARIANTINTEGERVEXT _glGetVariantIntegervEXT_ptr = NULL;

static inline void APIENTRY _glGetVariantIntegervEXT(GLuint id, GLenum value, GLint * data) {
    const char *_name = "glGetVariantIntegervEXT";
    if (!_glGetVariantIntegervEXT_ptr) {
        _glGetVariantIntegervEXT_ptr = (PFN_GLGETVARIANTINTEGERVEXT)_getPrivateProcAddress(_name);
        if (!_glGetVariantIntegervEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVariantIntegervEXT_ptr(id, value, data);
}

typedef void (APIENTRY * PFN_GLGETVARIANTFLOATVEXT)(GLuint id, GLenum value, GLfloat * data);
static PFN_GLGETVARIANTFLOATVEXT _glGetVariantFloatvEXT_ptr = NULL;

static inline void APIENTRY _glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat * data) {
    const char *_name = "glGetVariantFloatvEXT";
    if (!_glGetVariantFloatvEXT_ptr) {
        _glGetVariantFloatvEXT_ptr = (PFN_GLGETVARIANTFLOATVEXT)_getPrivateProcAddress(_name);
        if (!_glGetVariantFloatvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVariantFloatvEXT_ptr(id, value, data);
}

typedef void (APIENTRY * PFN_GLGETVARIANTPOINTERVEXT)(GLuint id, GLenum value, GLvoid * * data);
static PFN_GLGETVARIANTPOINTERVEXT _glGetVariantPointervEXT_ptr = NULL;

static inline void APIENTRY _glGetVariantPointervEXT(GLuint id, GLenum value, GLvoid * * data) {
    const char *_name = "glGetVariantPointervEXT";
    if (!_glGetVariantPointervEXT_ptr) {
        _glGetVariantPointervEXT_ptr = (PFN_GLGETVARIANTPOINTERVEXT)_getPrivateProcAddress(_name);
        if (!_glGetVariantPointervEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVariantPointervEXT_ptr(id, value, data);
}

typedef void (APIENTRY * PFN_GLGETINVARIANTBOOLEANVEXT)(GLuint id, GLenum value, GLboolean * data);
static PFN_GLGETINVARIANTBOOLEANVEXT _glGetInvariantBooleanvEXT_ptr = NULL;

static inline void APIENTRY _glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean * data) {
    const char *_name = "glGetInvariantBooleanvEXT";
    if (!_glGetInvariantBooleanvEXT_ptr) {
        _glGetInvariantBooleanvEXT_ptr = (PFN_GLGETINVARIANTBOOLEANVEXT)_getPrivateProcAddress(_name);
        if (!_glGetInvariantBooleanvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetInvariantBooleanvEXT_ptr(id, value, data);
}

typedef void (APIENTRY * PFN_GLGETINVARIANTINTEGERVEXT)(GLuint id, GLenum value, GLint * data);
static PFN_GLGETINVARIANTINTEGERVEXT _glGetInvariantIntegervEXT_ptr = NULL;

static inline void APIENTRY _glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint * data) {
    const char *_name = "glGetInvariantIntegervEXT";
    if (!_glGetInvariantIntegervEXT_ptr) {
        _glGetInvariantIntegervEXT_ptr = (PFN_GLGETINVARIANTINTEGERVEXT)_getPrivateProcAddress(_name);
        if (!_glGetInvariantIntegervEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetInvariantIntegervEXT_ptr(id, value, data);
}

typedef void (APIENTRY * PFN_GLGETINVARIANTFLOATVEXT)(GLuint id, GLenum value, GLfloat * data);
static PFN_GLGETINVARIANTFLOATVEXT _glGetInvariantFloatvEXT_ptr = NULL;

static inline void APIENTRY _glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat * data) {
    const char *_name = "glGetInvariantFloatvEXT";
    if (!_glGetInvariantFloatvEXT_ptr) {
        _glGetInvariantFloatvEXT_ptr = (PFN_GLGETINVARIANTFLOATVEXT)_getPrivateProcAddress(_name);
        if (!_glGetInvariantFloatvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetInvariantFloatvEXT_ptr(id, value, data);
}

typedef void (APIENTRY * PFN_GLGETLOCALCONSTANTBOOLEANVEXT)(GLuint id, GLenum value, GLboolean * data);
static PFN_GLGETLOCALCONSTANTBOOLEANVEXT _glGetLocalConstantBooleanvEXT_ptr = NULL;

static inline void APIENTRY _glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean * data) {
    const char *_name = "glGetLocalConstantBooleanvEXT";
    if (!_glGetLocalConstantBooleanvEXT_ptr) {
        _glGetLocalConstantBooleanvEXT_ptr = (PFN_GLGETLOCALCONSTANTBOOLEANVEXT)_getPrivateProcAddress(_name);
        if (!_glGetLocalConstantBooleanvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetLocalConstantBooleanvEXT_ptr(id, value, data);
}

typedef void (APIENTRY * PFN_GLGETLOCALCONSTANTINTEGERVEXT)(GLuint id, GLenum value, GLint * data);
static PFN_GLGETLOCALCONSTANTINTEGERVEXT _glGetLocalConstantIntegervEXT_ptr = NULL;

static inline void APIENTRY _glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint * data) {
    const char *_name = "glGetLocalConstantIntegervEXT";
    if (!_glGetLocalConstantIntegervEXT_ptr) {
        _glGetLocalConstantIntegervEXT_ptr = (PFN_GLGETLOCALCONSTANTINTEGERVEXT)_getPrivateProcAddress(_name);
        if (!_glGetLocalConstantIntegervEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetLocalConstantIntegervEXT_ptr(id, value, data);
}

typedef void (APIENTRY * PFN_GLGETLOCALCONSTANTFLOATVEXT)(GLuint id, GLenum value, GLfloat * data);
static PFN_GLGETLOCALCONSTANTFLOATVEXT _glGetLocalConstantFloatvEXT_ptr = NULL;

static inline void APIENTRY _glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat * data) {
    const char *_name = "glGetLocalConstantFloatvEXT";
    if (!_glGetLocalConstantFloatvEXT_ptr) {
        _glGetLocalConstantFloatvEXT_ptr = (PFN_GLGETLOCALCONSTANTFLOATVEXT)_getPrivateProcAddress(_name);
        if (!_glGetLocalConstantFloatvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetLocalConstantFloatvEXT_ptr(id, value, data);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM1SATI)(GLenum stream, GLshort x);
static PFN_GLVERTEXSTREAM1SATI _glVertexStream1sATI_ptr = NULL;

static inline void APIENTRY _glVertexStream1sATI(GLenum stream, GLshort x) {
    const char *_name = "glVertexStream1sATI";
    if (!_glVertexStream1sATI_ptr) {
        _glVertexStream1sATI_ptr = (PFN_GLVERTEXSTREAM1SATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream1sATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream1sATI_ptr(stream, x);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM1SVATI)(GLenum stream, const GLshort * coords);
static PFN_GLVERTEXSTREAM1SVATI _glVertexStream1svATI_ptr = NULL;

static inline void APIENTRY _glVertexStream1svATI(GLenum stream, const GLshort * coords) {
    const char *_name = "glVertexStream1svATI";
    if (!_glVertexStream1svATI_ptr) {
        _glVertexStream1svATI_ptr = (PFN_GLVERTEXSTREAM1SVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream1svATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream1svATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM1IATI)(GLenum stream, GLint x);
static PFN_GLVERTEXSTREAM1IATI _glVertexStream1iATI_ptr = NULL;

static inline void APIENTRY _glVertexStream1iATI(GLenum stream, GLint x) {
    const char *_name = "glVertexStream1iATI";
    if (!_glVertexStream1iATI_ptr) {
        _glVertexStream1iATI_ptr = (PFN_GLVERTEXSTREAM1IATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream1iATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream1iATI_ptr(stream, x);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM1IVATI)(GLenum stream, const GLint * coords);
static PFN_GLVERTEXSTREAM1IVATI _glVertexStream1ivATI_ptr = NULL;

static inline void APIENTRY _glVertexStream1ivATI(GLenum stream, const GLint * coords) {
    const char *_name = "glVertexStream1ivATI";
    if (!_glVertexStream1ivATI_ptr) {
        _glVertexStream1ivATI_ptr = (PFN_GLVERTEXSTREAM1IVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream1ivATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream1ivATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM1FATI)(GLenum stream, GLfloat x);
static PFN_GLVERTEXSTREAM1FATI _glVertexStream1fATI_ptr = NULL;

static inline void APIENTRY _glVertexStream1fATI(GLenum stream, GLfloat x) {
    const char *_name = "glVertexStream1fATI";
    if (!_glVertexStream1fATI_ptr) {
        _glVertexStream1fATI_ptr = (PFN_GLVERTEXSTREAM1FATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream1fATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream1fATI_ptr(stream, x);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM1FVATI)(GLenum stream, const GLfloat * coords);
static PFN_GLVERTEXSTREAM1FVATI _glVertexStream1fvATI_ptr = NULL;

static inline void APIENTRY _glVertexStream1fvATI(GLenum stream, const GLfloat * coords) {
    const char *_name = "glVertexStream1fvATI";
    if (!_glVertexStream1fvATI_ptr) {
        _glVertexStream1fvATI_ptr = (PFN_GLVERTEXSTREAM1FVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream1fvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream1fvATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM1DATI)(GLenum stream, GLdouble x);
static PFN_GLVERTEXSTREAM1DATI _glVertexStream1dATI_ptr = NULL;

static inline void APIENTRY _glVertexStream1dATI(GLenum stream, GLdouble x) {
    const char *_name = "glVertexStream1dATI";
    if (!_glVertexStream1dATI_ptr) {
        _glVertexStream1dATI_ptr = (PFN_GLVERTEXSTREAM1DATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream1dATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream1dATI_ptr(stream, x);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM1DVATI)(GLenum stream, const GLdouble * coords);
static PFN_GLVERTEXSTREAM1DVATI _glVertexStream1dvATI_ptr = NULL;

static inline void APIENTRY _glVertexStream1dvATI(GLenum stream, const GLdouble * coords) {
    const char *_name = "glVertexStream1dvATI";
    if (!_glVertexStream1dvATI_ptr) {
        _glVertexStream1dvATI_ptr = (PFN_GLVERTEXSTREAM1DVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream1dvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream1dvATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM2SATI)(GLenum stream, GLshort x, GLshort y);
static PFN_GLVERTEXSTREAM2SATI _glVertexStream2sATI_ptr = NULL;

static inline void APIENTRY _glVertexStream2sATI(GLenum stream, GLshort x, GLshort y) {
    const char *_name = "glVertexStream2sATI";
    if (!_glVertexStream2sATI_ptr) {
        _glVertexStream2sATI_ptr = (PFN_GLVERTEXSTREAM2SATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream2sATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream2sATI_ptr(stream, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM2SVATI)(GLenum stream, const GLshort * coords);
static PFN_GLVERTEXSTREAM2SVATI _glVertexStream2svATI_ptr = NULL;

static inline void APIENTRY _glVertexStream2svATI(GLenum stream, const GLshort * coords) {
    const char *_name = "glVertexStream2svATI";
    if (!_glVertexStream2svATI_ptr) {
        _glVertexStream2svATI_ptr = (PFN_GLVERTEXSTREAM2SVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream2svATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream2svATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM2IATI)(GLenum stream, GLint x, GLint y);
static PFN_GLVERTEXSTREAM2IATI _glVertexStream2iATI_ptr = NULL;

static inline void APIENTRY _glVertexStream2iATI(GLenum stream, GLint x, GLint y) {
    const char *_name = "glVertexStream2iATI";
    if (!_glVertexStream2iATI_ptr) {
        _glVertexStream2iATI_ptr = (PFN_GLVERTEXSTREAM2IATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream2iATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream2iATI_ptr(stream, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM2IVATI)(GLenum stream, const GLint * coords);
static PFN_GLVERTEXSTREAM2IVATI _glVertexStream2ivATI_ptr = NULL;

static inline void APIENTRY _glVertexStream2ivATI(GLenum stream, const GLint * coords) {
    const char *_name = "glVertexStream2ivATI";
    if (!_glVertexStream2ivATI_ptr) {
        _glVertexStream2ivATI_ptr = (PFN_GLVERTEXSTREAM2IVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream2ivATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream2ivATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM2FATI)(GLenum stream, GLfloat x, GLfloat y);
static PFN_GLVERTEXSTREAM2FATI _glVertexStream2fATI_ptr = NULL;

static inline void APIENTRY _glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y) {
    const char *_name = "glVertexStream2fATI";
    if (!_glVertexStream2fATI_ptr) {
        _glVertexStream2fATI_ptr = (PFN_GLVERTEXSTREAM2FATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream2fATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream2fATI_ptr(stream, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM2FVATI)(GLenum stream, const GLfloat * coords);
static PFN_GLVERTEXSTREAM2FVATI _glVertexStream2fvATI_ptr = NULL;

static inline void APIENTRY _glVertexStream2fvATI(GLenum stream, const GLfloat * coords) {
    const char *_name = "glVertexStream2fvATI";
    if (!_glVertexStream2fvATI_ptr) {
        _glVertexStream2fvATI_ptr = (PFN_GLVERTEXSTREAM2FVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream2fvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream2fvATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM2DATI)(GLenum stream, GLdouble x, GLdouble y);
static PFN_GLVERTEXSTREAM2DATI _glVertexStream2dATI_ptr = NULL;

static inline void APIENTRY _glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y) {
    const char *_name = "glVertexStream2dATI";
    if (!_glVertexStream2dATI_ptr) {
        _glVertexStream2dATI_ptr = (PFN_GLVERTEXSTREAM2DATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream2dATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream2dATI_ptr(stream, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM2DVATI)(GLenum stream, const GLdouble * coords);
static PFN_GLVERTEXSTREAM2DVATI _glVertexStream2dvATI_ptr = NULL;

static inline void APIENTRY _glVertexStream2dvATI(GLenum stream, const GLdouble * coords) {
    const char *_name = "glVertexStream2dvATI";
    if (!_glVertexStream2dvATI_ptr) {
        _glVertexStream2dvATI_ptr = (PFN_GLVERTEXSTREAM2DVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream2dvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream2dvATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM3SATI)(GLenum stream, GLshort x, GLshort y, GLshort z);
static PFN_GLVERTEXSTREAM3SATI _glVertexStream3sATI_ptr = NULL;

static inline void APIENTRY _glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z) {
    const char *_name = "glVertexStream3sATI";
    if (!_glVertexStream3sATI_ptr) {
        _glVertexStream3sATI_ptr = (PFN_GLVERTEXSTREAM3SATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream3sATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream3sATI_ptr(stream, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM3SVATI)(GLenum stream, const GLshort * coords);
static PFN_GLVERTEXSTREAM3SVATI _glVertexStream3svATI_ptr = NULL;

static inline void APIENTRY _glVertexStream3svATI(GLenum stream, const GLshort * coords) {
    const char *_name = "glVertexStream3svATI";
    if (!_glVertexStream3svATI_ptr) {
        _glVertexStream3svATI_ptr = (PFN_GLVERTEXSTREAM3SVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream3svATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream3svATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM3IATI)(GLenum stream, GLint x, GLint y, GLint z);
static PFN_GLVERTEXSTREAM3IATI _glVertexStream3iATI_ptr = NULL;

static inline void APIENTRY _glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z) {
    const char *_name = "glVertexStream3iATI";
    if (!_glVertexStream3iATI_ptr) {
        _glVertexStream3iATI_ptr = (PFN_GLVERTEXSTREAM3IATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream3iATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream3iATI_ptr(stream, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM3IVATI)(GLenum stream, const GLint * coords);
static PFN_GLVERTEXSTREAM3IVATI _glVertexStream3ivATI_ptr = NULL;

static inline void APIENTRY _glVertexStream3ivATI(GLenum stream, const GLint * coords) {
    const char *_name = "glVertexStream3ivATI";
    if (!_glVertexStream3ivATI_ptr) {
        _glVertexStream3ivATI_ptr = (PFN_GLVERTEXSTREAM3IVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream3ivATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream3ivATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM3FATI)(GLenum stream, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLVERTEXSTREAM3FATI _glVertexStream3fATI_ptr = NULL;

static inline void APIENTRY _glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glVertexStream3fATI";
    if (!_glVertexStream3fATI_ptr) {
        _glVertexStream3fATI_ptr = (PFN_GLVERTEXSTREAM3FATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream3fATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream3fATI_ptr(stream, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM3FVATI)(GLenum stream, const GLfloat * coords);
static PFN_GLVERTEXSTREAM3FVATI _glVertexStream3fvATI_ptr = NULL;

static inline void APIENTRY _glVertexStream3fvATI(GLenum stream, const GLfloat * coords) {
    const char *_name = "glVertexStream3fvATI";
    if (!_glVertexStream3fvATI_ptr) {
        _glVertexStream3fvATI_ptr = (PFN_GLVERTEXSTREAM3FVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream3fvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream3fvATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM3DATI)(GLenum stream, GLdouble x, GLdouble y, GLdouble z);
static PFN_GLVERTEXSTREAM3DATI _glVertexStream3dATI_ptr = NULL;

static inline void APIENTRY _glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertexStream3dATI";
    if (!_glVertexStream3dATI_ptr) {
        _glVertexStream3dATI_ptr = (PFN_GLVERTEXSTREAM3DATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream3dATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream3dATI_ptr(stream, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM3DVATI)(GLenum stream, const GLdouble * coords);
static PFN_GLVERTEXSTREAM3DVATI _glVertexStream3dvATI_ptr = NULL;

static inline void APIENTRY _glVertexStream3dvATI(GLenum stream, const GLdouble * coords) {
    const char *_name = "glVertexStream3dvATI";
    if (!_glVertexStream3dvATI_ptr) {
        _glVertexStream3dvATI_ptr = (PFN_GLVERTEXSTREAM3DVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream3dvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream3dvATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM4SATI)(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
static PFN_GLVERTEXSTREAM4SATI _glVertexStream4sATI_ptr = NULL;

static inline void APIENTRY _glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glVertexStream4sATI";
    if (!_glVertexStream4sATI_ptr) {
        _glVertexStream4sATI_ptr = (PFN_GLVERTEXSTREAM4SATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream4sATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream4sATI_ptr(stream, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM4SVATI)(GLenum stream, const GLshort * coords);
static PFN_GLVERTEXSTREAM4SVATI _glVertexStream4svATI_ptr = NULL;

static inline void APIENTRY _glVertexStream4svATI(GLenum stream, const GLshort * coords) {
    const char *_name = "glVertexStream4svATI";
    if (!_glVertexStream4svATI_ptr) {
        _glVertexStream4svATI_ptr = (PFN_GLVERTEXSTREAM4SVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream4svATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream4svATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM4IATI)(GLenum stream, GLint x, GLint y, GLint z, GLint w);
static PFN_GLVERTEXSTREAM4IATI _glVertexStream4iATI_ptr = NULL;

static inline void APIENTRY _glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glVertexStream4iATI";
    if (!_glVertexStream4iATI_ptr) {
        _glVertexStream4iATI_ptr = (PFN_GLVERTEXSTREAM4IATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream4iATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream4iATI_ptr(stream, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM4IVATI)(GLenum stream, const GLint * coords);
static PFN_GLVERTEXSTREAM4IVATI _glVertexStream4ivATI_ptr = NULL;

static inline void APIENTRY _glVertexStream4ivATI(GLenum stream, const GLint * coords) {
    const char *_name = "glVertexStream4ivATI";
    if (!_glVertexStream4ivATI_ptr) {
        _glVertexStream4ivATI_ptr = (PFN_GLVERTEXSTREAM4IVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream4ivATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream4ivATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM4FATI)(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLVERTEXSTREAM4FATI _glVertexStream4fATI_ptr = NULL;

static inline void APIENTRY _glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glVertexStream4fATI";
    if (!_glVertexStream4fATI_ptr) {
        _glVertexStream4fATI_ptr = (PFN_GLVERTEXSTREAM4FATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream4fATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream4fATI_ptr(stream, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM4FVATI)(GLenum stream, const GLfloat * coords);
static PFN_GLVERTEXSTREAM4FVATI _glVertexStream4fvATI_ptr = NULL;

static inline void APIENTRY _glVertexStream4fvATI(GLenum stream, const GLfloat * coords) {
    const char *_name = "glVertexStream4fvATI";
    if (!_glVertexStream4fvATI_ptr) {
        _glVertexStream4fvATI_ptr = (PFN_GLVERTEXSTREAM4FVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream4fvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream4fvATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM4DATI)(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLVERTEXSTREAM4DATI _glVertexStream4dATI_ptr = NULL;

static inline void APIENTRY _glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertexStream4dATI";
    if (!_glVertexStream4dATI_ptr) {
        _glVertexStream4dATI_ptr = (PFN_GLVERTEXSTREAM4DATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream4dATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream4dATI_ptr(stream, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXSTREAM4DVATI)(GLenum stream, const GLdouble * coords);
static PFN_GLVERTEXSTREAM4DVATI _glVertexStream4dvATI_ptr = NULL;

static inline void APIENTRY _glVertexStream4dvATI(GLenum stream, const GLdouble * coords) {
    const char *_name = "glVertexStream4dvATI";
    if (!_glVertexStream4dvATI_ptr) {
        _glVertexStream4dvATI_ptr = (PFN_GLVERTEXSTREAM4DVATI)_getPrivateProcAddress(_name);
        if (!_glVertexStream4dvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexStream4dvATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLNORMALSTREAM3BATI)(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz);
static PFN_GLNORMALSTREAM3BATI _glNormalStream3bATI_ptr = NULL;

static inline void APIENTRY _glNormalStream3bATI(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz) {
    const char *_name = "glNormalStream3bATI";
    if (!_glNormalStream3bATI_ptr) {
        _glNormalStream3bATI_ptr = (PFN_GLNORMALSTREAM3BATI)_getPrivateProcAddress(_name);
        if (!_glNormalStream3bATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalStream3bATI_ptr(stream, nx, ny, nz);
}

typedef void (APIENTRY * PFN_GLNORMALSTREAM3BVATI)(GLenum stream, const GLbyte * coords);
static PFN_GLNORMALSTREAM3BVATI _glNormalStream3bvATI_ptr = NULL;

static inline void APIENTRY _glNormalStream3bvATI(GLenum stream, const GLbyte * coords) {
    const char *_name = "glNormalStream3bvATI";
    if (!_glNormalStream3bvATI_ptr) {
        _glNormalStream3bvATI_ptr = (PFN_GLNORMALSTREAM3BVATI)_getPrivateProcAddress(_name);
        if (!_glNormalStream3bvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalStream3bvATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLNORMALSTREAM3SATI)(GLenum stream, GLshort nx, GLshort ny, GLshort nz);
static PFN_GLNORMALSTREAM3SATI _glNormalStream3sATI_ptr = NULL;

static inline void APIENTRY _glNormalStream3sATI(GLenum stream, GLshort nx, GLshort ny, GLshort nz) {
    const char *_name = "glNormalStream3sATI";
    if (!_glNormalStream3sATI_ptr) {
        _glNormalStream3sATI_ptr = (PFN_GLNORMALSTREAM3SATI)_getPrivateProcAddress(_name);
        if (!_glNormalStream3sATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalStream3sATI_ptr(stream, nx, ny, nz);
}

typedef void (APIENTRY * PFN_GLNORMALSTREAM3SVATI)(GLenum stream, const GLshort * coords);
static PFN_GLNORMALSTREAM3SVATI _glNormalStream3svATI_ptr = NULL;

static inline void APIENTRY _glNormalStream3svATI(GLenum stream, const GLshort * coords) {
    const char *_name = "glNormalStream3svATI";
    if (!_glNormalStream3svATI_ptr) {
        _glNormalStream3svATI_ptr = (PFN_GLNORMALSTREAM3SVATI)_getPrivateProcAddress(_name);
        if (!_glNormalStream3svATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalStream3svATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLNORMALSTREAM3IATI)(GLenum stream, GLint nx, GLint ny, GLint nz);
static PFN_GLNORMALSTREAM3IATI _glNormalStream3iATI_ptr = NULL;

static inline void APIENTRY _glNormalStream3iATI(GLenum stream, GLint nx, GLint ny, GLint nz) {
    const char *_name = "glNormalStream3iATI";
    if (!_glNormalStream3iATI_ptr) {
        _glNormalStream3iATI_ptr = (PFN_GLNORMALSTREAM3IATI)_getPrivateProcAddress(_name);
        if (!_glNormalStream3iATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalStream3iATI_ptr(stream, nx, ny, nz);
}

typedef void (APIENTRY * PFN_GLNORMALSTREAM3IVATI)(GLenum stream, const GLint * coords);
static PFN_GLNORMALSTREAM3IVATI _glNormalStream3ivATI_ptr = NULL;

static inline void APIENTRY _glNormalStream3ivATI(GLenum stream, const GLint * coords) {
    const char *_name = "glNormalStream3ivATI";
    if (!_glNormalStream3ivATI_ptr) {
        _glNormalStream3ivATI_ptr = (PFN_GLNORMALSTREAM3IVATI)_getPrivateProcAddress(_name);
        if (!_glNormalStream3ivATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalStream3ivATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLNORMALSTREAM3FATI)(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz);
static PFN_GLNORMALSTREAM3FATI _glNormalStream3fATI_ptr = NULL;

static inline void APIENTRY _glNormalStream3fATI(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz) {
    const char *_name = "glNormalStream3fATI";
    if (!_glNormalStream3fATI_ptr) {
        _glNormalStream3fATI_ptr = (PFN_GLNORMALSTREAM3FATI)_getPrivateProcAddress(_name);
        if (!_glNormalStream3fATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalStream3fATI_ptr(stream, nx, ny, nz);
}

typedef void (APIENTRY * PFN_GLNORMALSTREAM3FVATI)(GLenum stream, const GLfloat * coords);
static PFN_GLNORMALSTREAM3FVATI _glNormalStream3fvATI_ptr = NULL;

static inline void APIENTRY _glNormalStream3fvATI(GLenum stream, const GLfloat * coords) {
    const char *_name = "glNormalStream3fvATI";
    if (!_glNormalStream3fvATI_ptr) {
        _glNormalStream3fvATI_ptr = (PFN_GLNORMALSTREAM3FVATI)_getPrivateProcAddress(_name);
        if (!_glNormalStream3fvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalStream3fvATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLNORMALSTREAM3DATI)(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz);
static PFN_GLNORMALSTREAM3DATI _glNormalStream3dATI_ptr = NULL;

static inline void APIENTRY _glNormalStream3dATI(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz) {
    const char *_name = "glNormalStream3dATI";
    if (!_glNormalStream3dATI_ptr) {
        _glNormalStream3dATI_ptr = (PFN_GLNORMALSTREAM3DATI)_getPrivateProcAddress(_name);
        if (!_glNormalStream3dATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalStream3dATI_ptr(stream, nx, ny, nz);
}

typedef void (APIENTRY * PFN_GLNORMALSTREAM3DVATI)(GLenum stream, const GLdouble * coords);
static PFN_GLNORMALSTREAM3DVATI _glNormalStream3dvATI_ptr = NULL;

static inline void APIENTRY _glNormalStream3dvATI(GLenum stream, const GLdouble * coords) {
    const char *_name = "glNormalStream3dvATI";
    if (!_glNormalStream3dvATI_ptr) {
        _glNormalStream3dvATI_ptr = (PFN_GLNORMALSTREAM3DVATI)_getPrivateProcAddress(_name);
        if (!_glNormalStream3dvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalStream3dvATI_ptr(stream, coords);
}

typedef void (APIENTRY * PFN_GLCLIENTACTIVEVERTEXSTREAMATI)(GLenum stream);
static PFN_GLCLIENTACTIVEVERTEXSTREAMATI _glClientActiveVertexStreamATI_ptr = NULL;

static inline void APIENTRY _glClientActiveVertexStreamATI(GLenum stream) {
    const char *_name = "glClientActiveVertexStreamATI";
    if (!_glClientActiveVertexStreamATI_ptr) {
        _glClientActiveVertexStreamATI_ptr = (PFN_GLCLIENTACTIVEVERTEXSTREAMATI)_getPrivateProcAddress(_name);
        if (!_glClientActiveVertexStreamATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClientActiveVertexStreamATI_ptr(stream);
}

typedef void (APIENTRY * PFN_GLVERTEXBLENDENVIATI)(GLenum pname, GLint param);
static PFN_GLVERTEXBLENDENVIATI _glVertexBlendEnviATI_ptr = NULL;

static inline void APIENTRY _glVertexBlendEnviATI(GLenum pname, GLint param) {
    const char *_name = "glVertexBlendEnviATI";
    if (!_glVertexBlendEnviATI_ptr) {
        _glVertexBlendEnviATI_ptr = (PFN_GLVERTEXBLENDENVIATI)_getPrivateProcAddress(_name);
        if (!_glVertexBlendEnviATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexBlendEnviATI_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLVERTEXBLENDENVFATI)(GLenum pname, GLfloat param);
static PFN_GLVERTEXBLENDENVFATI _glVertexBlendEnvfATI_ptr = NULL;

static inline void APIENTRY _glVertexBlendEnvfATI(GLenum pname, GLfloat param) {
    const char *_name = "glVertexBlendEnvfATI";
    if (!_glVertexBlendEnvfATI_ptr) {
        _glVertexBlendEnvfATI_ptr = (PFN_GLVERTEXBLENDENVFATI)_getPrivateProcAddress(_name);
        if (!_glVertexBlendEnvfATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexBlendEnvfATI_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLELEMENTPOINTERATI)(GLenum type, const GLvoid * pointer);
static PFN_GLELEMENTPOINTERATI _glElementPointerATI_ptr = NULL;

static inline void APIENTRY _glElementPointerATI(GLenum type, const GLvoid * pointer) {
    const char *_name = "glElementPointerATI";
    if (!_glElementPointerATI_ptr) {
        _glElementPointerATI_ptr = (PFN_GLELEMENTPOINTERATI)_getPrivateProcAddress(_name);
        if (!_glElementPointerATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glElementPointerATI_ptr(type, pointer);
}

typedef void (APIENTRY * PFN_GLDRAWELEMENTARRAYATI)(GLenum mode, GLsizei count);
static PFN_GLDRAWELEMENTARRAYATI _glDrawElementArrayATI_ptr = NULL;

static inline void APIENTRY _glDrawElementArrayATI(GLenum mode, GLsizei count) {
    const char *_name = "glDrawElementArrayATI";
    if (!_glDrawElementArrayATI_ptr) {
        _glDrawElementArrayATI_ptr = (PFN_GLDRAWELEMENTARRAYATI)_getPrivateProcAddress(_name);
        if (!_glDrawElementArrayATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawElementArrayATI_ptr(mode, count);
}

typedef void (APIENTRY * PFN_GLDRAWRANGEELEMENTARRAYATI)(GLenum mode, GLuint start, GLuint end, GLsizei count);
static PFN_GLDRAWRANGEELEMENTARRAYATI _glDrawRangeElementArrayATI_ptr = NULL;

static inline void APIENTRY _glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count) {
    const char *_name = "glDrawRangeElementArrayATI";
    if (!_glDrawRangeElementArrayATI_ptr) {
        _glDrawRangeElementArrayATI_ptr = (PFN_GLDRAWRANGEELEMENTARRAYATI)_getPrivateProcAddress(_name);
        if (!_glDrawRangeElementArrayATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawRangeElementArrayATI_ptr(mode, start, end, count);
}

typedef void (APIENTRY * PFN_GLDRAWMESHARRAYSSUN)(GLenum mode, GLint first, GLsizei count, GLsizei width);
static PFN_GLDRAWMESHARRAYSSUN _glDrawMeshArraysSUN_ptr = NULL;

static inline void APIENTRY _glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width) {
    const char *_name = "glDrawMeshArraysSUN";
    if (!_glDrawMeshArraysSUN_ptr) {
        _glDrawMeshArraysSUN_ptr = (PFN_GLDRAWMESHARRAYSSUN)_getPrivateProcAddress(_name);
        if (!_glDrawMeshArraysSUN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawMeshArraysSUN_ptr(mode, first, count, width);
}

typedef void (APIENTRY * PFN_GLGENOCCLUSIONQUERIESNV)(GLsizei n, GLuint * ids);
static PFN_GLGENOCCLUSIONQUERIESNV _glGenOcclusionQueriesNV_ptr = NULL;

static inline void APIENTRY _glGenOcclusionQueriesNV(GLsizei n, GLuint * ids) {
    const char *_name = "glGenOcclusionQueriesNV";
    if (!_glGenOcclusionQueriesNV_ptr) {
        _glGenOcclusionQueriesNV_ptr = (PFN_GLGENOCCLUSIONQUERIESNV)_getPrivateProcAddress(_name);
        if (!_glGenOcclusionQueriesNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenOcclusionQueriesNV_ptr(n, ids);
}

typedef void (APIENTRY * PFN_GLDELETEOCCLUSIONQUERIESNV)(GLsizei n, const GLuint * ids);
static PFN_GLDELETEOCCLUSIONQUERIESNV _glDeleteOcclusionQueriesNV_ptr = NULL;

static inline void APIENTRY _glDeleteOcclusionQueriesNV(GLsizei n, const GLuint * ids) {
    const char *_name = "glDeleteOcclusionQueriesNV";
    if (!_glDeleteOcclusionQueriesNV_ptr) {
        _glDeleteOcclusionQueriesNV_ptr = (PFN_GLDELETEOCCLUSIONQUERIESNV)_getPrivateProcAddress(_name);
        if (!_glDeleteOcclusionQueriesNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteOcclusionQueriesNV_ptr(n, ids);
}

typedef GLboolean (APIENTRY * PFN_GLISOCCLUSIONQUERYNV)(GLuint id);
static PFN_GLISOCCLUSIONQUERYNV _glIsOcclusionQueryNV_ptr = NULL;

static inline GLboolean APIENTRY _glIsOcclusionQueryNV(GLuint id) {
    const char *_name = "glIsOcclusionQueryNV";
    if (!_glIsOcclusionQueryNV_ptr) {
        _glIsOcclusionQueryNV_ptr = (PFN_GLISOCCLUSIONQUERYNV)_getPrivateProcAddress(_name);
        if (!_glIsOcclusionQueryNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsOcclusionQueryNV_ptr(id);
}

typedef void (APIENTRY * PFN_GLBEGINOCCLUSIONQUERYNV)(GLuint id);
static PFN_GLBEGINOCCLUSIONQUERYNV _glBeginOcclusionQueryNV_ptr = NULL;

static inline void APIENTRY _glBeginOcclusionQueryNV(GLuint id) {
    const char *_name = "glBeginOcclusionQueryNV";
    if (!_glBeginOcclusionQueryNV_ptr) {
        _glBeginOcclusionQueryNV_ptr = (PFN_GLBEGINOCCLUSIONQUERYNV)_getPrivateProcAddress(_name);
        if (!_glBeginOcclusionQueryNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginOcclusionQueryNV_ptr(id);
}

typedef void (APIENTRY * PFN_GLENDOCCLUSIONQUERYNV)(void);
static PFN_GLENDOCCLUSIONQUERYNV _glEndOcclusionQueryNV_ptr = NULL;

static inline void APIENTRY _glEndOcclusionQueryNV(void) {
    const char *_name = "glEndOcclusionQueryNV";
    if (!_glEndOcclusionQueryNV_ptr) {
        _glEndOcclusionQueryNV_ptr = (PFN_GLENDOCCLUSIONQUERYNV)_getPrivateProcAddress(_name);
        if (!_glEndOcclusionQueryNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndOcclusionQueryNV_ptr();
}

typedef void (APIENTRY * PFN_GLGETOCCLUSIONQUERYIVNV)(GLuint id, GLenum pname, GLint * params);
static PFN_GLGETOCCLUSIONQUERYIVNV _glGetOcclusionQueryivNV_ptr = NULL;

static inline void APIENTRY _glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint * params) {
    const char *_name = "glGetOcclusionQueryivNV";
    if (!_glGetOcclusionQueryivNV_ptr) {
        _glGetOcclusionQueryivNV_ptr = (PFN_GLGETOCCLUSIONQUERYIVNV)_getPrivateProcAddress(_name);
        if (!_glGetOcclusionQueryivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetOcclusionQueryivNV_ptr(id, pname, params);
}

typedef void (APIENTRY * PFN_GLGETOCCLUSIONQUERYUIVNV)(GLuint id, GLenum pname, GLuint * params);
static PFN_GLGETOCCLUSIONQUERYUIVNV _glGetOcclusionQueryuivNV_ptr = NULL;

static inline void APIENTRY _glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint * params) {
    const char *_name = "glGetOcclusionQueryuivNV";
    if (!_glGetOcclusionQueryuivNV_ptr) {
        _glGetOcclusionQueryuivNV_ptr = (PFN_GLGETOCCLUSIONQUERYUIVNV)_getPrivateProcAddress(_name);
        if (!_glGetOcclusionQueryuivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetOcclusionQueryuivNV_ptr(id, pname, params);
}

typedef void (APIENTRY * PFN_GLPOINTPARAMETERINV)(GLenum pname, GLint param);
static PFN_GLPOINTPARAMETERINV _glPointParameteriNV_ptr = NULL;

static inline void APIENTRY _glPointParameteriNV(GLenum pname, GLint param) {
    const char *_name = "glPointParameteriNV";
    if (!_glPointParameteriNV_ptr) {
        _glPointParameteriNV_ptr = (PFN_GLPOINTPARAMETERINV)_getPrivateProcAddress(_name);
        if (!_glPointParameteriNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameteriNV_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLPOINTPARAMETERIVNV)(GLenum pname, const GLint * params);
static PFN_GLPOINTPARAMETERIVNV _glPointParameterivNV_ptr = NULL;

static inline void APIENTRY _glPointParameterivNV(GLenum pname, const GLint * params) {
    const char *_name = "glPointParameterivNV";
    if (!_glPointParameterivNV_ptr) {
        _glPointParameterivNV_ptr = (PFN_GLPOINTPARAMETERIVNV)_getPrivateProcAddress(_name);
        if (!_glPointParameterivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameterivNV_ptr(pname, params);
}

typedef void (APIENTRY * PFN_GLACTIVESTENCILFACEEXT)(GLenum face);
static PFN_GLACTIVESTENCILFACEEXT _glActiveStencilFaceEXT_ptr = NULL;

static inline void APIENTRY _glActiveStencilFaceEXT(GLenum face) {
    const char *_name = "glActiveStencilFaceEXT";
    if (!_glActiveStencilFaceEXT_ptr) {
        _glActiveStencilFaceEXT_ptr = (PFN_GLACTIVESTENCILFACEEXT)_getPrivateProcAddress(_name);
        if (!_glActiveStencilFaceEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glActiveStencilFaceEXT_ptr(face);
}

typedef void (APIENTRY * PFN_GLELEMENTPOINTERAPPLE)(GLenum type, const GLvoid * pointer);
static PFN_GLELEMENTPOINTERAPPLE _glElementPointerAPPLE_ptr = NULL;

static inline void APIENTRY _glElementPointerAPPLE(GLenum type, const GLvoid * pointer) {
    const char *_name = "glElementPointerAPPLE";
    if (!_glElementPointerAPPLE_ptr) {
        _glElementPointerAPPLE_ptr = (PFN_GLELEMENTPOINTERAPPLE)_getPrivateProcAddress(_name);
        if (!_glElementPointerAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glElementPointerAPPLE_ptr(type, pointer);
}

typedef void (APIENTRY * PFN_GLDRAWELEMENTARRAYAPPLE)(GLenum mode, GLint first, GLsizei count);
static PFN_GLDRAWELEMENTARRAYAPPLE _glDrawElementArrayAPPLE_ptr = NULL;

static inline void APIENTRY _glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count) {
    const char *_name = "glDrawElementArrayAPPLE";
    if (!_glDrawElementArrayAPPLE_ptr) {
        _glDrawElementArrayAPPLE_ptr = (PFN_GLDRAWELEMENTARRAYAPPLE)_getPrivateProcAddress(_name);
        if (!_glDrawElementArrayAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawElementArrayAPPLE_ptr(mode, first, count);
}

typedef void (APIENTRY * PFN_GLDRAWRANGEELEMENTARRAYAPPLE)(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
static PFN_GLDRAWRANGEELEMENTARRAYAPPLE _glDrawRangeElementArrayAPPLE_ptr = NULL;

static inline void APIENTRY _glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count) {
    const char *_name = "glDrawRangeElementArrayAPPLE";
    if (!_glDrawRangeElementArrayAPPLE_ptr) {
        _glDrawRangeElementArrayAPPLE_ptr = (PFN_GLDRAWRANGEELEMENTARRAYAPPLE)_getPrivateProcAddress(_name);
        if (!_glDrawRangeElementArrayAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawRangeElementArrayAPPLE_ptr(mode, start, end, first, count);
}

typedef void (APIENTRY * PFN_GLMULTIDRAWELEMENTARRAYAPPLE)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount);
static PFN_GLMULTIDRAWELEMENTARRAYAPPLE _glMultiDrawElementArrayAPPLE_ptr = NULL;

static inline void APIENTRY _glMultiDrawElementArrayAPPLE(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount) {
    const char *_name = "glMultiDrawElementArrayAPPLE";
    if (!_glMultiDrawElementArrayAPPLE_ptr) {
        _glMultiDrawElementArrayAPPLE_ptr = (PFN_GLMULTIDRAWELEMENTARRAYAPPLE)_getPrivateProcAddress(_name);
        if (!_glMultiDrawElementArrayAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiDrawElementArrayAPPLE_ptr(mode, first, count, primcount);
}

typedef void (APIENTRY * PFN_GLMULTIDRAWRANGEELEMENTARRAYAPPLE)(GLenum mode, GLuint start, GLuint end, const GLint * first, const GLsizei * count, GLsizei primcount);
static PFN_GLMULTIDRAWRANGEELEMENTARRAYAPPLE _glMultiDrawRangeElementArrayAPPLE_ptr = NULL;

static inline void APIENTRY _glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint * first, const GLsizei * count, GLsizei primcount) {
    const char *_name = "glMultiDrawRangeElementArrayAPPLE";
    if (!_glMultiDrawRangeElementArrayAPPLE_ptr) {
        _glMultiDrawRangeElementArrayAPPLE_ptr = (PFN_GLMULTIDRAWRANGEELEMENTARRAYAPPLE)_getPrivateProcAddress(_name);
        if (!_glMultiDrawRangeElementArrayAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiDrawRangeElementArrayAPPLE_ptr(mode, start, end, first, count, primcount);
}

typedef void (APIENTRY * PFN_GLGENFENCESAPPLE)(GLsizei n, GLuint * fences);
static PFN_GLGENFENCESAPPLE _glGenFencesAPPLE_ptr = NULL;

static inline void APIENTRY _glGenFencesAPPLE(GLsizei n, GLuint * fences) {
    const char *_name = "glGenFencesAPPLE";
    if (!_glGenFencesAPPLE_ptr) {
        _glGenFencesAPPLE_ptr = (PFN_GLGENFENCESAPPLE)_getPrivateProcAddress(_name);
        if (!_glGenFencesAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenFencesAPPLE_ptr(n, fences);
}

typedef void (APIENTRY * PFN_GLDELETEFENCESAPPLE)(GLsizei n, const GLuint * fences);
static PFN_GLDELETEFENCESAPPLE _glDeleteFencesAPPLE_ptr = NULL;

static inline void APIENTRY _glDeleteFencesAPPLE(GLsizei n, const GLuint * fences) {
    const char *_name = "glDeleteFencesAPPLE";
    if (!_glDeleteFencesAPPLE_ptr) {
        _glDeleteFencesAPPLE_ptr = (PFN_GLDELETEFENCESAPPLE)_getPrivateProcAddress(_name);
        if (!_glDeleteFencesAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteFencesAPPLE_ptr(n, fences);
}

typedef void (APIENTRY * PFN_GLSETFENCEAPPLE)(GLuint fence);
static PFN_GLSETFENCEAPPLE _glSetFenceAPPLE_ptr = NULL;

static inline void APIENTRY _glSetFenceAPPLE(GLuint fence) {
    const char *_name = "glSetFenceAPPLE";
    if (!_glSetFenceAPPLE_ptr) {
        _glSetFenceAPPLE_ptr = (PFN_GLSETFENCEAPPLE)_getPrivateProcAddress(_name);
        if (!_glSetFenceAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSetFenceAPPLE_ptr(fence);
}

typedef GLboolean (APIENTRY * PFN_GLISFENCEAPPLE)(GLuint fence);
static PFN_GLISFENCEAPPLE _glIsFenceAPPLE_ptr = NULL;

static inline GLboolean APIENTRY _glIsFenceAPPLE(GLuint fence) {
    const char *_name = "glIsFenceAPPLE";
    if (!_glIsFenceAPPLE_ptr) {
        _glIsFenceAPPLE_ptr = (PFN_GLISFENCEAPPLE)_getPrivateProcAddress(_name);
        if (!_glIsFenceAPPLE_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsFenceAPPLE_ptr(fence);
}

typedef GLboolean (APIENTRY * PFN_GLTESTFENCEAPPLE)(GLuint fence);
static PFN_GLTESTFENCEAPPLE _glTestFenceAPPLE_ptr = NULL;

static inline GLboolean APIENTRY _glTestFenceAPPLE(GLuint fence) {
    const char *_name = "glTestFenceAPPLE";
    if (!_glTestFenceAPPLE_ptr) {
        _glTestFenceAPPLE_ptr = (PFN_GLTESTFENCEAPPLE)_getPrivateProcAddress(_name);
        if (!_glTestFenceAPPLE_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glTestFenceAPPLE_ptr(fence);
}

typedef void (APIENTRY * PFN_GLFINISHFENCEAPPLE)(GLuint fence);
static PFN_GLFINISHFENCEAPPLE _glFinishFenceAPPLE_ptr = NULL;

static inline void APIENTRY _glFinishFenceAPPLE(GLuint fence) {
    const char *_name = "glFinishFenceAPPLE";
    if (!_glFinishFenceAPPLE_ptr) {
        _glFinishFenceAPPLE_ptr = (PFN_GLFINISHFENCEAPPLE)_getPrivateProcAddress(_name);
        if (!_glFinishFenceAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFinishFenceAPPLE_ptr(fence);
}

typedef GLboolean (APIENTRY * PFN_GLTESTOBJECTAPPLE)(GLenum object, GLuint name);
static PFN_GLTESTOBJECTAPPLE _glTestObjectAPPLE_ptr = NULL;

static inline GLboolean APIENTRY _glTestObjectAPPLE(GLenum object, GLuint name) {
    const char *_name = "glTestObjectAPPLE";
    if (!_glTestObjectAPPLE_ptr) {
        _glTestObjectAPPLE_ptr = (PFN_GLTESTOBJECTAPPLE)_getPrivateProcAddress(_name);
        if (!_glTestObjectAPPLE_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glTestObjectAPPLE_ptr(object, name);
}

typedef void (APIENTRY * PFN_GLFINISHOBJECTAPPLE)(GLenum object, GLint name);
static PFN_GLFINISHOBJECTAPPLE _glFinishObjectAPPLE_ptr = NULL;

static inline void APIENTRY _glFinishObjectAPPLE(GLenum object, GLint name) {
    const char *_name = "glFinishObjectAPPLE";
    if (!_glFinishObjectAPPLE_ptr) {
        _glFinishObjectAPPLE_ptr = (PFN_GLFINISHOBJECTAPPLE)_getPrivateProcAddress(_name);
        if (!_glFinishObjectAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFinishObjectAPPLE_ptr(object, name);
}

typedef void (APIENTRY * PFN_GLBINDVERTEXARRAYAPPLE)(GLuint array);
static PFN_GLBINDVERTEXARRAYAPPLE _glBindVertexArrayAPPLE_ptr = NULL;

static inline void APIENTRY _glBindVertexArrayAPPLE(GLuint array) {
    const char *_name = "glBindVertexArrayAPPLE";
    if (!_glBindVertexArrayAPPLE_ptr) {
        _glBindVertexArrayAPPLE_ptr = (PFN_GLBINDVERTEXARRAYAPPLE)_getPrivateProcAddress(_name);
        if (!_glBindVertexArrayAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindVertexArrayAPPLE_ptr(array);
}

typedef void (APIENTRY * PFN_GLDELETEVERTEXARRAYSAPPLE)(GLsizei n, const GLuint * arrays);
static PFN_GLDELETEVERTEXARRAYSAPPLE _glDeleteVertexArraysAPPLE_ptr = NULL;

static inline void APIENTRY _glDeleteVertexArraysAPPLE(GLsizei n, const GLuint * arrays) {
    const char *_name = "glDeleteVertexArraysAPPLE";
    if (!_glDeleteVertexArraysAPPLE_ptr) {
        _glDeleteVertexArraysAPPLE_ptr = (PFN_GLDELETEVERTEXARRAYSAPPLE)_getPrivateProcAddress(_name);
        if (!_glDeleteVertexArraysAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteVertexArraysAPPLE_ptr(n, arrays);
}

typedef void (APIENTRY * PFN_GLGENVERTEXARRAYSAPPLE)(GLsizei n, GLuint * arrays);
static PFN_GLGENVERTEXARRAYSAPPLE _glGenVertexArraysAPPLE_ptr = NULL;

static inline void APIENTRY _glGenVertexArraysAPPLE(GLsizei n, GLuint * arrays) {
    const char *_name = "glGenVertexArraysAPPLE";
    if (!_glGenVertexArraysAPPLE_ptr) {
        _glGenVertexArraysAPPLE_ptr = (PFN_GLGENVERTEXARRAYSAPPLE)_getPrivateProcAddress(_name);
        if (!_glGenVertexArraysAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenVertexArraysAPPLE_ptr(n, arrays);
}

typedef GLboolean (APIENTRY * PFN_GLISVERTEXARRAYAPPLE)(GLuint array);
static PFN_GLISVERTEXARRAYAPPLE _glIsVertexArrayAPPLE_ptr = NULL;

static inline GLboolean APIENTRY _glIsVertexArrayAPPLE(GLuint array) {
    const char *_name = "glIsVertexArrayAPPLE";
    if (!_glIsVertexArrayAPPLE_ptr) {
        _glIsVertexArrayAPPLE_ptr = (PFN_GLISVERTEXARRAYAPPLE)_getPrivateProcAddress(_name);
        if (!_glIsVertexArrayAPPLE_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsVertexArrayAPPLE_ptr(array);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYRANGEAPPLE)(GLsizei length, GLvoid * pointer);
static PFN_GLVERTEXARRAYRANGEAPPLE _glVertexArrayRangeAPPLE_ptr = NULL;

static inline void APIENTRY _glVertexArrayRangeAPPLE(GLsizei length, GLvoid * pointer) {
    const char *_name = "glVertexArrayRangeAPPLE";
    if (!_glVertexArrayRangeAPPLE_ptr) {
        _glVertexArrayRangeAPPLE_ptr = (PFN_GLVERTEXARRAYRANGEAPPLE)_getPrivateProcAddress(_name);
        if (!_glVertexArrayRangeAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayRangeAPPLE_ptr(length, pointer);
}

typedef void (APIENTRY * PFN_GLFLUSHVERTEXARRAYRANGEAPPLE)(GLsizei length, GLvoid * pointer);
static PFN_GLFLUSHVERTEXARRAYRANGEAPPLE _glFlushVertexArrayRangeAPPLE_ptr = NULL;

static inline void APIENTRY _glFlushVertexArrayRangeAPPLE(GLsizei length, GLvoid * pointer) {
    const char *_name = "glFlushVertexArrayRangeAPPLE";
    if (!_glFlushVertexArrayRangeAPPLE_ptr) {
        _glFlushVertexArrayRangeAPPLE_ptr = (PFN_GLFLUSHVERTEXARRAYRANGEAPPLE)_getPrivateProcAddress(_name);
        if (!_glFlushVertexArrayRangeAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFlushVertexArrayRangeAPPLE_ptr(length, pointer);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYPARAMETERIAPPLE)(GLenum pname, GLint param);
static PFN_GLVERTEXARRAYPARAMETERIAPPLE _glVertexArrayParameteriAPPLE_ptr = NULL;

static inline void APIENTRY _glVertexArrayParameteriAPPLE(GLenum pname, GLint param) {
    const char *_name = "glVertexArrayParameteriAPPLE";
    if (!_glVertexArrayParameteriAPPLE_ptr) {
        _glVertexArrayParameteriAPPLE_ptr = (PFN_GLVERTEXARRAYPARAMETERIAPPLE)_getPrivateProcAddress(_name);
        if (!_glVertexArrayParameteriAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayParameteriAPPLE_ptr(pname, param);
}

typedef void (APIENTRY * PFN_GLFLUSHRENDERAPPLE)(void);
static PFN_GLFLUSHRENDERAPPLE _glFlushRenderAPPLE_ptr = NULL;

static inline void APIENTRY _glFlushRenderAPPLE(void) {
    const char *_name = "glFlushRenderAPPLE";
    if (!_glFlushRenderAPPLE_ptr) {
        _glFlushRenderAPPLE_ptr = (PFN_GLFLUSHRENDERAPPLE)_getPrivateProcAddress(_name);
        if (!_glFlushRenderAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFlushRenderAPPLE_ptr();
}

typedef void (APIENTRY * PFN_GLFINISHRENDERAPPLE)(void);
static PFN_GLFINISHRENDERAPPLE _glFinishRenderAPPLE_ptr = NULL;

static inline void APIENTRY _glFinishRenderAPPLE(void) {
    const char *_name = "glFinishRenderAPPLE";
    if (!_glFinishRenderAPPLE_ptr) {
        _glFinishRenderAPPLE_ptr = (PFN_GLFINISHRENDERAPPLE)_getPrivateProcAddress(_name);
        if (!_glFinishRenderAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFinishRenderAPPLE_ptr();
}

typedef void (APIENTRY * PFN_GLSWAPAPPLE)(void);
static PFN_GLSWAPAPPLE _glSwapAPPLE_ptr = NULL;

static inline void APIENTRY _glSwapAPPLE(void) {
    const char *_name = "glSwapAPPLE";
    if (!_glSwapAPPLE_ptr) {
        _glSwapAPPLE_ptr = (PFN_GLSWAPAPPLE)_getPrivateProcAddress(_name);
        if (!_glSwapAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSwapAPPLE_ptr();
}

typedef void (APIENTRY * PFN_GLDRAWBUFFERSATI)(GLsizei n, const GLenum * bufs);
static PFN_GLDRAWBUFFERSATI _glDrawBuffersATI_ptr = NULL;

static inline void APIENTRY _glDrawBuffersATI(GLsizei n, const GLenum * bufs) {
    const char *_name = "glDrawBuffersATI";
    if (!_glDrawBuffersATI_ptr) {
        _glDrawBuffersATI_ptr = (PFN_GLDRAWBUFFERSATI)_getPrivateProcAddress(_name);
        if (!_glDrawBuffersATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawBuffersATI_ptr(n, bufs);
}

typedef void (APIENTRY * PFN_GLPROGRAMNAMEDPARAMETER4FNV)(GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLPROGRAMNAMEDPARAMETER4FNV _glProgramNamedParameter4fNV_ptr = NULL;

static inline void APIENTRY _glProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glProgramNamedParameter4fNV";
    if (!_glProgramNamedParameter4fNV_ptr) {
        _glProgramNamedParameter4fNV_ptr = (PFN_GLPROGRAMNAMEDPARAMETER4FNV)_getPrivateProcAddress(_name);
        if (!_glProgramNamedParameter4fNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramNamedParameter4fNV_ptr(id, len, name, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMNAMEDPARAMETER4DNV)(GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLPROGRAMNAMEDPARAMETER4DNV _glProgramNamedParameter4dNV_ptr = NULL;

static inline void APIENTRY _glProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glProgramNamedParameter4dNV";
    if (!_glProgramNamedParameter4dNV_ptr) {
        _glProgramNamedParameter4dNV_ptr = (PFN_GLPROGRAMNAMEDPARAMETER4DNV)_getPrivateProcAddress(_name);
        if (!_glProgramNamedParameter4dNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramNamedParameter4dNV_ptr(id, len, name, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMNAMEDPARAMETER4FVNV)(GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v);
static PFN_GLPROGRAMNAMEDPARAMETER4FVNV _glProgramNamedParameter4fvNV_ptr = NULL;

static inline void APIENTRY _glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v) {
    const char *_name = "glProgramNamedParameter4fvNV";
    if (!_glProgramNamedParameter4fvNV_ptr) {
        _glProgramNamedParameter4fvNV_ptr = (PFN_GLPROGRAMNAMEDPARAMETER4FVNV)_getPrivateProcAddress(_name);
        if (!_glProgramNamedParameter4fvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramNamedParameter4fvNV_ptr(id, len, name, v);
}

typedef void (APIENTRY * PFN_GLPROGRAMNAMEDPARAMETER4DVNV)(GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v);
static PFN_GLPROGRAMNAMEDPARAMETER4DVNV _glProgramNamedParameter4dvNV_ptr = NULL;

static inline void APIENTRY _glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v) {
    const char *_name = "glProgramNamedParameter4dvNV";
    if (!_glProgramNamedParameter4dvNV_ptr) {
        _glProgramNamedParameter4dvNV_ptr = (PFN_GLPROGRAMNAMEDPARAMETER4DVNV)_getPrivateProcAddress(_name);
        if (!_glProgramNamedParameter4dvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramNamedParameter4dvNV_ptr(id, len, name, v);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMNAMEDPARAMETERDVNV)(GLuint id, GLsizei len, const GLubyte * name, GLdouble * params);
static PFN_GLGETPROGRAMNAMEDPARAMETERDVNV _glGetProgramNamedParameterdvNV_ptr = NULL;

static inline void APIENTRY _glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte * name, GLdouble * params) {
    const char *_name = "glGetProgramNamedParameterdvNV";
    if (!_glGetProgramNamedParameterdvNV_ptr) {
        _glGetProgramNamedParameterdvNV_ptr = (PFN_GLGETPROGRAMNAMEDPARAMETERDVNV)_getPrivateProcAddress(_name);
        if (!_glGetProgramNamedParameterdvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramNamedParameterdvNV_ptr(id, len, name, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMNAMEDPARAMETERFVNV)(GLuint id, GLsizei len, const GLubyte * name, GLfloat * params);
static PFN_GLGETPROGRAMNAMEDPARAMETERFVNV _glGetProgramNamedParameterfvNV_ptr = NULL;

static inline void APIENTRY _glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte * name, GLfloat * params) {
    const char *_name = "glGetProgramNamedParameterfvNV";
    if (!_glGetProgramNamedParameterfvNV_ptr) {
        _glGetProgramNamedParameterfvNV_ptr = (PFN_GLGETPROGRAMNAMEDPARAMETERFVNV)_getPrivateProcAddress(_name);
        if (!_glGetProgramNamedParameterfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramNamedParameterfvNV_ptr(id, len, name, params);
}

typedef void (APIENTRY * PFN_GLVERTEX2HNV)(GLhalfNV x, GLhalfNV y);
static PFN_GLVERTEX2HNV _glVertex2hNV_ptr = NULL;

static inline void APIENTRY _glVertex2hNV(GLhalfNV x, GLhalfNV y) {
    const char *_name = "glVertex2hNV";
    if (!_glVertex2hNV_ptr) {
        _glVertex2hNV_ptr = (PFN_GLVERTEX2HNV)_getPrivateProcAddress(_name);
        if (!_glVertex2hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex2hNV_ptr(x, y);
}

typedef void (APIENTRY * PFN_GLVERTEX2HVNV)(const GLhalfNV * v);
static PFN_GLVERTEX2HVNV _glVertex2hvNV_ptr = NULL;

static inline void APIENTRY _glVertex2hvNV(const GLhalfNV * v) {
    const char *_name = "glVertex2hvNV";
    if (!_glVertex2hvNV_ptr) {
        _glVertex2hvNV_ptr = (PFN_GLVERTEX2HVNV)_getPrivateProcAddress(_name);
        if (!_glVertex2hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex2hvNV_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX3HNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z);
static PFN_GLVERTEX3HNV _glVertex3hNV_ptr = NULL;

static inline void APIENTRY _glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z) {
    const char *_name = "glVertex3hNV";
    if (!_glVertex3hNV_ptr) {
        _glVertex3hNV_ptr = (PFN_GLVERTEX3HNV)_getPrivateProcAddress(_name);
        if (!_glVertex3hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex3hNV_ptr(x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEX3HVNV)(const GLhalfNV * v);
static PFN_GLVERTEX3HVNV _glVertex3hvNV_ptr = NULL;

static inline void APIENTRY _glVertex3hvNV(const GLhalfNV * v) {
    const char *_name = "glVertex3hvNV";
    if (!_glVertex3hvNV_ptr) {
        _glVertex3hvNV_ptr = (PFN_GLVERTEX3HVNV)_getPrivateProcAddress(_name);
        if (!_glVertex3hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex3hvNV_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEX4HNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
static PFN_GLVERTEX4HNV _glVertex4hNV_ptr = NULL;

static inline void APIENTRY _glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) {
    const char *_name = "glVertex4hNV";
    if (!_glVertex4hNV_ptr) {
        _glVertex4hNV_ptr = (PFN_GLVERTEX4HNV)_getPrivateProcAddress(_name);
        if (!_glVertex4hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex4hNV_ptr(x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEX4HVNV)(const GLhalfNV * v);
static PFN_GLVERTEX4HVNV _glVertex4hvNV_ptr = NULL;

static inline void APIENTRY _glVertex4hvNV(const GLhalfNV * v) {
    const char *_name = "glVertex4hvNV";
    if (!_glVertex4hvNV_ptr) {
        _glVertex4hvNV_ptr = (PFN_GLVERTEX4HVNV)_getPrivateProcAddress(_name);
        if (!_glVertex4hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertex4hvNV_ptr(v);
}

typedef void (APIENTRY * PFN_GLNORMAL3HNV)(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);
static PFN_GLNORMAL3HNV _glNormal3hNV_ptr = NULL;

static inline void APIENTRY _glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz) {
    const char *_name = "glNormal3hNV";
    if (!_glNormal3hNV_ptr) {
        _glNormal3hNV_ptr = (PFN_GLNORMAL3HNV)_getPrivateProcAddress(_name);
        if (!_glNormal3hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3hNV_ptr(nx, ny, nz);
}

typedef void (APIENTRY * PFN_GLNORMAL3HVNV)(const GLhalfNV * v);
static PFN_GLNORMAL3HVNV _glNormal3hvNV_ptr = NULL;

static inline void APIENTRY _glNormal3hvNV(const GLhalfNV * v) {
    const char *_name = "glNormal3hvNV";
    if (!_glNormal3hvNV_ptr) {
        _glNormal3hvNV_ptr = (PFN_GLNORMAL3HVNV)_getPrivateProcAddress(_name);
        if (!_glNormal3hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3hvNV_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR3HNV)(GLhalfNV red, GLhalfNV green, GLhalfNV blue);
static PFN_GLCOLOR3HNV _glColor3hNV_ptr = NULL;

static inline void APIENTRY _glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue) {
    const char *_name = "glColor3hNV";
    if (!_glColor3hNV_ptr) {
        _glColor3hNV_ptr = (PFN_GLCOLOR3HNV)_getPrivateProcAddress(_name);
        if (!_glColor3hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3hNV_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLCOLOR3HVNV)(const GLhalfNV * v);
static PFN_GLCOLOR3HVNV _glColor3hvNV_ptr = NULL;

static inline void APIENTRY _glColor3hvNV(const GLhalfNV * v) {
    const char *_name = "glColor3hvNV";
    if (!_glColor3hvNV_ptr) {
        _glColor3hvNV_ptr = (PFN_GLCOLOR3HVNV)_getPrivateProcAddress(_name);
        if (!_glColor3hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor3hvNV_ptr(v);
}

typedef void (APIENTRY * PFN_GLCOLOR4HNV)(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha);
static PFN_GLCOLOR4HNV _glColor4hNV_ptr = NULL;

static inline void APIENTRY _glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha) {
    const char *_name = "glColor4hNV";
    if (!_glColor4hNV_ptr) {
        _glColor4hNV_ptr = (PFN_GLCOLOR4HNV)_getPrivateProcAddress(_name);
        if (!_glColor4hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4hNV_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLCOLOR4HVNV)(const GLhalfNV * v);
static PFN_GLCOLOR4HVNV _glColor4hvNV_ptr = NULL;

static inline void APIENTRY _glColor4hvNV(const GLhalfNV * v) {
    const char *_name = "glColor4hvNV";
    if (!_glColor4hvNV_ptr) {
        _glColor4hvNV_ptr = (PFN_GLCOLOR4HVNV)_getPrivateProcAddress(_name);
        if (!_glColor4hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4hvNV_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD1HNV)(GLhalfNV s);
static PFN_GLTEXCOORD1HNV _glTexCoord1hNV_ptr = NULL;

static inline void APIENTRY _glTexCoord1hNV(GLhalfNV s) {
    const char *_name = "glTexCoord1hNV";
    if (!_glTexCoord1hNV_ptr) {
        _glTexCoord1hNV_ptr = (PFN_GLTEXCOORD1HNV)_getPrivateProcAddress(_name);
        if (!_glTexCoord1hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord1hNV_ptr(s);
}

typedef void (APIENTRY * PFN_GLTEXCOORD1HVNV)(const GLhalfNV * v);
static PFN_GLTEXCOORD1HVNV _glTexCoord1hvNV_ptr = NULL;

static inline void APIENTRY _glTexCoord1hvNV(const GLhalfNV * v) {
    const char *_name = "glTexCoord1hvNV";
    if (!_glTexCoord1hvNV_ptr) {
        _glTexCoord1hvNV_ptr = (PFN_GLTEXCOORD1HVNV)_getPrivateProcAddress(_name);
        if (!_glTexCoord1hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord1hvNV_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2HNV)(GLhalfNV s, GLhalfNV t);
static PFN_GLTEXCOORD2HNV _glTexCoord2hNV_ptr = NULL;

static inline void APIENTRY _glTexCoord2hNV(GLhalfNV s, GLhalfNV t) {
    const char *_name = "glTexCoord2hNV";
    if (!_glTexCoord2hNV_ptr) {
        _glTexCoord2hNV_ptr = (PFN_GLTEXCOORD2HNV)_getPrivateProcAddress(_name);
        if (!_glTexCoord2hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2hNV_ptr(s, t);
}

typedef void (APIENTRY * PFN_GLTEXCOORD2HVNV)(const GLhalfNV * v);
static PFN_GLTEXCOORD2HVNV _glTexCoord2hvNV_ptr = NULL;

static inline void APIENTRY _glTexCoord2hvNV(const GLhalfNV * v) {
    const char *_name = "glTexCoord2hvNV";
    if (!_glTexCoord2hvNV_ptr) {
        _glTexCoord2hvNV_ptr = (PFN_GLTEXCOORD2HVNV)_getPrivateProcAddress(_name);
        if (!_glTexCoord2hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord2hvNV_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD3HNV)(GLhalfNV s, GLhalfNV t, GLhalfNV r);
static PFN_GLTEXCOORD3HNV _glTexCoord3hNV_ptr = NULL;

static inline void APIENTRY _glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r) {
    const char *_name = "glTexCoord3hNV";
    if (!_glTexCoord3hNV_ptr) {
        _glTexCoord3hNV_ptr = (PFN_GLTEXCOORD3HNV)_getPrivateProcAddress(_name);
        if (!_glTexCoord3hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord3hNV_ptr(s, t, r);
}

typedef void (APIENTRY * PFN_GLTEXCOORD3HVNV)(const GLhalfNV * v);
static PFN_GLTEXCOORD3HVNV _glTexCoord3hvNV_ptr = NULL;

static inline void APIENTRY _glTexCoord3hvNV(const GLhalfNV * v) {
    const char *_name = "glTexCoord3hvNV";
    if (!_glTexCoord3hvNV_ptr) {
        _glTexCoord3hvNV_ptr = (PFN_GLTEXCOORD3HVNV)_getPrivateProcAddress(_name);
        if (!_glTexCoord3hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord3hvNV_ptr(v);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4HNV)(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
static PFN_GLTEXCOORD4HNV _glTexCoord4hNV_ptr = NULL;

static inline void APIENTRY _glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) {
    const char *_name = "glTexCoord4hNV";
    if (!_glTexCoord4hNV_ptr) {
        _glTexCoord4hNV_ptr = (PFN_GLTEXCOORD4HNV)_getPrivateProcAddress(_name);
        if (!_glTexCoord4hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4hNV_ptr(s, t, r, q);
}

typedef void (APIENTRY * PFN_GLTEXCOORD4HVNV)(const GLhalfNV * v);
static PFN_GLTEXCOORD4HVNV _glTexCoord4hvNV_ptr = NULL;

static inline void APIENTRY _glTexCoord4hvNV(const GLhalfNV * v) {
    const char *_name = "glTexCoord4hvNV";
    if (!_glTexCoord4hvNV_ptr) {
        _glTexCoord4hvNV_ptr = (PFN_GLTEXCOORD4HVNV)_getPrivateProcAddress(_name);
        if (!_glTexCoord4hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoord4hvNV_ptr(v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1HNV)(GLenum target, GLhalfNV s);
static PFN_GLMULTITEXCOORD1HNV _glMultiTexCoord1hNV_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1hNV(GLenum target, GLhalfNV s) {
    const char *_name = "glMultiTexCoord1hNV";
    if (!_glMultiTexCoord1hNV_ptr) {
        _glMultiTexCoord1hNV_ptr = (PFN_GLMULTITEXCOORD1HNV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1hNV_ptr(target, s);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD1HVNV)(GLenum target, const GLhalfNV * v);
static PFN_GLMULTITEXCOORD1HVNV _glMultiTexCoord1hvNV_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord1hvNV(GLenum target, const GLhalfNV * v) {
    const char *_name = "glMultiTexCoord1hvNV";
    if (!_glMultiTexCoord1hvNV_ptr) {
        _glMultiTexCoord1hvNV_ptr = (PFN_GLMULTITEXCOORD1HVNV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord1hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord1hvNV_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2HNV)(GLenum target, GLhalfNV s, GLhalfNV t);
static PFN_GLMULTITEXCOORD2HNV _glMultiTexCoord2hNV_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t) {
    const char *_name = "glMultiTexCoord2hNV";
    if (!_glMultiTexCoord2hNV_ptr) {
        _glMultiTexCoord2hNV_ptr = (PFN_GLMULTITEXCOORD2HNV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2hNV_ptr(target, s, t);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD2HVNV)(GLenum target, const GLhalfNV * v);
static PFN_GLMULTITEXCOORD2HVNV _glMultiTexCoord2hvNV_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord2hvNV(GLenum target, const GLhalfNV * v) {
    const char *_name = "glMultiTexCoord2hvNV";
    if (!_glMultiTexCoord2hvNV_ptr) {
        _glMultiTexCoord2hvNV_ptr = (PFN_GLMULTITEXCOORD2HVNV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord2hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord2hvNV_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3HNV)(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r);
static PFN_GLMULTITEXCOORD3HNV _glMultiTexCoord3hNV_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r) {
    const char *_name = "glMultiTexCoord3hNV";
    if (!_glMultiTexCoord3hNV_ptr) {
        _glMultiTexCoord3hNV_ptr = (PFN_GLMULTITEXCOORD3HNV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3hNV_ptr(target, s, t, r);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD3HVNV)(GLenum target, const GLhalfNV * v);
static PFN_GLMULTITEXCOORD3HVNV _glMultiTexCoord3hvNV_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord3hvNV(GLenum target, const GLhalfNV * v) {
    const char *_name = "glMultiTexCoord3hvNV";
    if (!_glMultiTexCoord3hvNV_ptr) {
        _glMultiTexCoord3hvNV_ptr = (PFN_GLMULTITEXCOORD3HVNV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord3hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord3hvNV_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4HNV)(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
static PFN_GLMULTITEXCOORD4HNV _glMultiTexCoord4hNV_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) {
    const char *_name = "glMultiTexCoord4hNV";
    if (!_glMultiTexCoord4hNV_ptr) {
        _glMultiTexCoord4hNV_ptr = (PFN_GLMULTITEXCOORD4HNV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4hNV_ptr(target, s, t, r, q);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORD4HVNV)(GLenum target, const GLhalfNV * v);
static PFN_GLMULTITEXCOORD4HVNV _glMultiTexCoord4hvNV_ptr = NULL;

static inline void APIENTRY _glMultiTexCoord4hvNV(GLenum target, const GLhalfNV * v) {
    const char *_name = "glMultiTexCoord4hvNV";
    if (!_glMultiTexCoord4hvNV_ptr) {
        _glMultiTexCoord4hvNV_ptr = (PFN_GLMULTITEXCOORD4HVNV)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4hvNV_ptr(target, v);
}

typedef void (APIENTRY * PFN_GLFOGCOORDHNV)(GLhalfNV fog);
static PFN_GLFOGCOORDHNV _glFogCoordhNV_ptr = NULL;

static inline void APIENTRY _glFogCoordhNV(GLhalfNV fog) {
    const char *_name = "glFogCoordhNV";
    if (!_glFogCoordhNV_ptr) {
        _glFogCoordhNV_ptr = (PFN_GLFOGCOORDHNV)_getPrivateProcAddress(_name);
        if (!_glFogCoordhNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoordhNV_ptr(fog);
}

typedef void (APIENTRY * PFN_GLFOGCOORDHVNV)(const GLhalfNV * fog);
static PFN_GLFOGCOORDHVNV _glFogCoordhvNV_ptr = NULL;

static inline void APIENTRY _glFogCoordhvNV(const GLhalfNV * fog) {
    const char *_name = "glFogCoordhvNV";
    if (!_glFogCoordhvNV_ptr) {
        _glFogCoordhvNV_ptr = (PFN_GLFOGCOORDHVNV)_getPrivateProcAddress(_name);
        if (!_glFogCoordhvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoordhvNV_ptr(fog);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3HNV)(GLhalfNV red, GLhalfNV green, GLhalfNV blue);
static PFN_GLSECONDARYCOLOR3HNV _glSecondaryColor3hNV_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue) {
    const char *_name = "glSecondaryColor3hNV";
    if (!_glSecondaryColor3hNV_ptr) {
        _glSecondaryColor3hNV_ptr = (PFN_GLSECONDARYCOLOR3HNV)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3hNV_ptr(red, green, blue);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLOR3HVNV)(const GLhalfNV * v);
static PFN_GLSECONDARYCOLOR3HVNV _glSecondaryColor3hvNV_ptr = NULL;

static inline void APIENTRY _glSecondaryColor3hvNV(const GLhalfNV * v) {
    const char *_name = "glSecondaryColor3hvNV";
    if (!_glSecondaryColor3hvNV_ptr) {
        _glSecondaryColor3hvNV_ptr = (PFN_GLSECONDARYCOLOR3HVNV)_getPrivateProcAddress(_name);
        if (!_glSecondaryColor3hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColor3hvNV_ptr(v);
}

typedef void (APIENTRY * PFN_GLVERTEXWEIGHTHNV)(GLhalfNV weight);
static PFN_GLVERTEXWEIGHTHNV _glVertexWeighthNV_ptr = NULL;

static inline void APIENTRY _glVertexWeighthNV(GLhalfNV weight) {
    const char *_name = "glVertexWeighthNV";
    if (!_glVertexWeighthNV_ptr) {
        _glVertexWeighthNV_ptr = (PFN_GLVERTEXWEIGHTHNV)_getPrivateProcAddress(_name);
        if (!_glVertexWeighthNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexWeighthNV_ptr(weight);
}

typedef void (APIENTRY * PFN_GLVERTEXWEIGHTHVNV)(const GLhalfNV * weight);
static PFN_GLVERTEXWEIGHTHVNV _glVertexWeighthvNV_ptr = NULL;

static inline void APIENTRY _glVertexWeighthvNV(const GLhalfNV * weight) {
    const char *_name = "glVertexWeighthvNV";
    if (!_glVertexWeighthvNV_ptr) {
        _glVertexWeighthvNV_ptr = (PFN_GLVERTEXWEIGHTHVNV)_getPrivateProcAddress(_name);
        if (!_glVertexWeighthvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexWeighthvNV_ptr(weight);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1HNV)(GLuint index, GLhalfNV x);
static PFN_GLVERTEXATTRIB1HNV _glVertexAttrib1hNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1hNV(GLuint index, GLhalfNV x) {
    const char *_name = "glVertexAttrib1hNV";
    if (!_glVertexAttrib1hNV_ptr) {
        _glVertexAttrib1hNV_ptr = (PFN_GLVERTEXATTRIB1HNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1hNV_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB1HVNV)(GLuint index, const GLhalfNV * v);
static PFN_GLVERTEXATTRIB1HVNV _glVertexAttrib1hvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib1hvNV(GLuint index, const GLhalfNV * v) {
    const char *_name = "glVertexAttrib1hvNV";
    if (!_glVertexAttrib1hvNV_ptr) {
        _glVertexAttrib1hvNV_ptr = (PFN_GLVERTEXATTRIB1HVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib1hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib1hvNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2HNV)(GLuint index, GLhalfNV x, GLhalfNV y);
static PFN_GLVERTEXATTRIB2HNV _glVertexAttrib2hNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y) {
    const char *_name = "glVertexAttrib2hNV";
    if (!_glVertexAttrib2hNV_ptr) {
        _glVertexAttrib2hNV_ptr = (PFN_GLVERTEXATTRIB2HNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2hNV_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB2HVNV)(GLuint index, const GLhalfNV * v);
static PFN_GLVERTEXATTRIB2HVNV _glVertexAttrib2hvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib2hvNV(GLuint index, const GLhalfNV * v) {
    const char *_name = "glVertexAttrib2hvNV";
    if (!_glVertexAttrib2hvNV_ptr) {
        _glVertexAttrib2hvNV_ptr = (PFN_GLVERTEXATTRIB2HVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib2hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib2hvNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3HNV)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z);
static PFN_GLVERTEXATTRIB3HNV _glVertexAttrib3hNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z) {
    const char *_name = "glVertexAttrib3hNV";
    if (!_glVertexAttrib3hNV_ptr) {
        _glVertexAttrib3hNV_ptr = (PFN_GLVERTEXATTRIB3HNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3hNV_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB3HVNV)(GLuint index, const GLhalfNV * v);
static PFN_GLVERTEXATTRIB3HVNV _glVertexAttrib3hvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib3hvNV(GLuint index, const GLhalfNV * v) {
    const char *_name = "glVertexAttrib3hvNV";
    if (!_glVertexAttrib3hvNV_ptr) {
        _glVertexAttrib3hvNV_ptr = (PFN_GLVERTEXATTRIB3HVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib3hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib3hvNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4HNV)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
static PFN_GLVERTEXATTRIB4HNV _glVertexAttrib4hNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) {
    const char *_name = "glVertexAttrib4hNV";
    if (!_glVertexAttrib4hNV_ptr) {
        _glVertexAttrib4hNV_ptr = (PFN_GLVERTEXATTRIB4HNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4hNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4hNV_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIB4HVNV)(GLuint index, const GLhalfNV * v);
static PFN_GLVERTEXATTRIB4HVNV _glVertexAttrib4hvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttrib4hvNV(GLuint index, const GLhalfNV * v) {
    const char *_name = "glVertexAttrib4hvNV";
    if (!_glVertexAttrib4hvNV_ptr) {
        _glVertexAttrib4hvNV_ptr = (PFN_GLVERTEXATTRIB4HVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttrib4hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttrib4hvNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS1HVNV)(GLuint index, GLsizei n, const GLhalfNV * v);
static PFN_GLVERTEXATTRIBS1HVNV _glVertexAttribs1hvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs1hvNV(GLuint index, GLsizei n, const GLhalfNV * v) {
    const char *_name = "glVertexAttribs1hvNV";
    if (!_glVertexAttribs1hvNV_ptr) {
        _glVertexAttribs1hvNV_ptr = (PFN_GLVERTEXATTRIBS1HVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs1hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs1hvNV_ptr(index, n, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS2HVNV)(GLuint index, GLsizei n, const GLhalfNV * v);
static PFN_GLVERTEXATTRIBS2HVNV _glVertexAttribs2hvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs2hvNV(GLuint index, GLsizei n, const GLhalfNV * v) {
    const char *_name = "glVertexAttribs2hvNV";
    if (!_glVertexAttribs2hvNV_ptr) {
        _glVertexAttribs2hvNV_ptr = (PFN_GLVERTEXATTRIBS2HVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs2hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs2hvNV_ptr(index, n, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS3HVNV)(GLuint index, GLsizei n, const GLhalfNV * v);
static PFN_GLVERTEXATTRIBS3HVNV _glVertexAttribs3hvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs3hvNV(GLuint index, GLsizei n, const GLhalfNV * v) {
    const char *_name = "glVertexAttribs3hvNV";
    if (!_glVertexAttribs3hvNV_ptr) {
        _glVertexAttribs3hvNV_ptr = (PFN_GLVERTEXATTRIBS3HVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs3hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs3hvNV_ptr(index, n, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBS4HVNV)(GLuint index, GLsizei n, const GLhalfNV * v);
static PFN_GLVERTEXATTRIBS4HVNV _glVertexAttribs4hvNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribs4hvNV(GLuint index, GLsizei n, const GLhalfNV * v) {
    const char *_name = "glVertexAttribs4hvNV";
    if (!_glVertexAttribs4hvNV_ptr) {
        _glVertexAttribs4hvNV_ptr = (PFN_GLVERTEXATTRIBS4HVNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribs4hvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribs4hvNV_ptr(index, n, v);
}

typedef void (APIENTRY * PFN_GLPIXELDATARANGENV)(GLenum target, GLsizei length, const GLvoid * pointer);
static PFN_GLPIXELDATARANGENV _glPixelDataRangeNV_ptr = NULL;

static inline void APIENTRY _glPixelDataRangeNV(GLenum target, GLsizei length, const GLvoid * pointer) {
    const char *_name = "glPixelDataRangeNV";
    if (!_glPixelDataRangeNV_ptr) {
        _glPixelDataRangeNV_ptr = (PFN_GLPIXELDATARANGENV)_getPrivateProcAddress(_name);
        if (!_glPixelDataRangeNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPixelDataRangeNV_ptr(target, length, pointer);
}

typedef void (APIENTRY * PFN_GLFLUSHPIXELDATARANGENV)(GLenum target);
static PFN_GLFLUSHPIXELDATARANGENV _glFlushPixelDataRangeNV_ptr = NULL;

static inline void APIENTRY _glFlushPixelDataRangeNV(GLenum target) {
    const char *_name = "glFlushPixelDataRangeNV";
    if (!_glFlushPixelDataRangeNV_ptr) {
        _glFlushPixelDataRangeNV_ptr = (PFN_GLFLUSHPIXELDATARANGENV)_getPrivateProcAddress(_name);
        if (!_glFlushPixelDataRangeNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFlushPixelDataRangeNV_ptr(target);
}

typedef void (APIENTRY * PFN_GLPRIMITIVERESTARTNV)(void);
static PFN_GLPRIMITIVERESTARTNV _glPrimitiveRestartNV_ptr = NULL;

static inline void APIENTRY _glPrimitiveRestartNV(void) {
    const char *_name = "glPrimitiveRestartNV";
    if (!_glPrimitiveRestartNV_ptr) {
        _glPrimitiveRestartNV_ptr = (PFN_GLPRIMITIVERESTARTNV)_getPrivateProcAddress(_name);
        if (!_glPrimitiveRestartNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPrimitiveRestartNV_ptr();
}

typedef void (APIENTRY * PFN_GLPRIMITIVERESTARTINDEXNV)(GLuint index);
static PFN_GLPRIMITIVERESTARTINDEXNV _glPrimitiveRestartIndexNV_ptr = NULL;

static inline void APIENTRY _glPrimitiveRestartIndexNV(GLuint index) {
    const char *_name = "glPrimitiveRestartIndexNV";
    if (!_glPrimitiveRestartIndexNV_ptr) {
        _glPrimitiveRestartIndexNV_ptr = (PFN_GLPRIMITIVERESTARTINDEXNV)_getPrivateProcAddress(_name);
        if (!_glPrimitiveRestartIndexNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPrimitiveRestartIndexNV_ptr(index);
}

typedef GLvoid * (APIENTRY * PFN_GLMAPOBJECTBUFFERATI)(GLuint buffer);
static PFN_GLMAPOBJECTBUFFERATI _glMapObjectBufferATI_ptr = NULL;

static inline GLvoid * APIENTRY _glMapObjectBufferATI(GLuint buffer) {
    const char *_name = "glMapObjectBufferATI";
    if (!_glMapObjectBufferATI_ptr) {
        _glMapObjectBufferATI_ptr = (PFN_GLMAPOBJECTBUFFERATI)_getPrivateProcAddress(_name);
        if (!_glMapObjectBufferATI_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glMapObjectBufferATI_ptr(buffer);
}

typedef void (APIENTRY * PFN_GLUNMAPOBJECTBUFFERATI)(GLuint buffer);
static PFN_GLUNMAPOBJECTBUFFERATI _glUnmapObjectBufferATI_ptr = NULL;

static inline void APIENTRY _glUnmapObjectBufferATI(GLuint buffer) {
    const char *_name = "glUnmapObjectBufferATI";
    if (!_glUnmapObjectBufferATI_ptr) {
        _glUnmapObjectBufferATI_ptr = (PFN_GLUNMAPOBJECTBUFFERATI)_getPrivateProcAddress(_name);
        if (!_glUnmapObjectBufferATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUnmapObjectBufferATI_ptr(buffer);
}

typedef void (APIENTRY * PFN_GLSTENCILOPSEPARATEATI)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
static PFN_GLSTENCILOPSEPARATEATI _glStencilOpSeparateATI_ptr = NULL;

static inline void APIENTRY _glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) {
    const char *_name = "glStencilOpSeparateATI";
    if (!_glStencilOpSeparateATI_ptr) {
        _glStencilOpSeparateATI_ptr = (PFN_GLSTENCILOPSEPARATEATI)_getPrivateProcAddress(_name);
        if (!_glStencilOpSeparateATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glStencilOpSeparateATI_ptr(face, sfail, dpfail, dppass);
}

typedef void (APIENTRY * PFN_GLSTENCILFUNCSEPARATEATI)(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
static PFN_GLSTENCILFUNCSEPARATEATI _glStencilFuncSeparateATI_ptr = NULL;

static inline void APIENTRY _glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask) {
    const char *_name = "glStencilFuncSeparateATI";
    if (!_glStencilFuncSeparateATI_ptr) {
        _glStencilFuncSeparateATI_ptr = (PFN_GLSTENCILFUNCSEPARATEATI)_getPrivateProcAddress(_name);
        if (!_glStencilFuncSeparateATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glStencilFuncSeparateATI_ptr(frontfunc, backfunc, ref, mask);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBARRAYOBJECTATI)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
static PFN_GLVERTEXATTRIBARRAYOBJECTATI _glVertexAttribArrayObjectATI_ptr = NULL;

static inline void APIENTRY _glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset) {
    const char *_name = "glVertexAttribArrayObjectATI";
    if (!_glVertexAttribArrayObjectATI_ptr) {
        _glVertexAttribArrayObjectATI_ptr = (PFN_GLVERTEXATTRIBARRAYOBJECTATI)_getPrivateProcAddress(_name);
        if (!_glVertexAttribArrayObjectATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribArrayObjectATI_ptr(index, size, type, normalized, stride, buffer, offset);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBARRAYOBJECTFVATI)(GLuint index, GLenum pname, GLfloat * params);
static PFN_GLGETVERTEXATTRIBARRAYOBJECTFVATI _glGetVertexAttribArrayObjectfvATI_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat * params) {
    const char *_name = "glGetVertexAttribArrayObjectfvATI";
    if (!_glGetVertexAttribArrayObjectfvATI_ptr) {
        _glGetVertexAttribArrayObjectfvATI_ptr = (PFN_GLGETVERTEXATTRIBARRAYOBJECTFVATI)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribArrayObjectfvATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribArrayObjectfvATI_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBARRAYOBJECTIVATI)(GLuint index, GLenum pname, GLint * params);
static PFN_GLGETVERTEXATTRIBARRAYOBJECTIVATI _glGetVertexAttribArrayObjectivATI_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetVertexAttribArrayObjectivATI";
    if (!_glGetVertexAttribArrayObjectivATI_ptr) {
        _glGetVertexAttribArrayObjectivATI_ptr = (PFN_GLGETVERTEXATTRIBARRAYOBJECTIVATI)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribArrayObjectivATI_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribArrayObjectivATI_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLDEPTHBOUNDSEXT)(GLclampd zmin, GLclampd zmax);
static PFN_GLDEPTHBOUNDSEXT _glDepthBoundsEXT_ptr = NULL;

static inline void APIENTRY _glDepthBoundsEXT(GLclampd zmin, GLclampd zmax) {
    const char *_name = "glDepthBoundsEXT";
    if (!_glDepthBoundsEXT_ptr) {
        _glDepthBoundsEXT_ptr = (PFN_GLDEPTHBOUNDSEXT)_getPrivateProcAddress(_name);
        if (!_glDepthBoundsEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDepthBoundsEXT_ptr(zmin, zmax);
}

typedef void (APIENTRY * PFN_GLBLENDEQUATIONSEPARATEEXT)(GLenum modeRGB, GLenum modeAlpha);
static PFN_GLBLENDEQUATIONSEPARATEEXT _glBlendEquationSeparateEXT_ptr = NULL;

static inline void APIENTRY _glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha) {
    const char *_name = "glBlendEquationSeparateEXT";
    if (!_glBlendEquationSeparateEXT_ptr) {
        _glBlendEquationSeparateEXT_ptr = (PFN_GLBLENDEQUATIONSEPARATEEXT)_getPrivateProcAddress(_name);
        if (!_glBlendEquationSeparateEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendEquationSeparateEXT_ptr(modeRGB, modeAlpha);
}

typedef GLboolean (APIENTRY * PFN_GLISRENDERBUFFEREXT)(GLuint renderbuffer);
static PFN_GLISRENDERBUFFEREXT _glIsRenderbufferEXT_ptr = NULL;

static inline GLboolean APIENTRY _glIsRenderbufferEXT(GLuint renderbuffer) {
    const char *_name = "glIsRenderbufferEXT";
    if (!_glIsRenderbufferEXT_ptr) {
        _glIsRenderbufferEXT_ptr = (PFN_GLISRENDERBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glIsRenderbufferEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsRenderbufferEXT_ptr(renderbuffer);
}

typedef void (APIENTRY * PFN_GLBINDRENDERBUFFEREXT)(GLenum target, GLuint renderbuffer);
static PFN_GLBINDRENDERBUFFEREXT _glBindRenderbufferEXT_ptr = NULL;

static inline void APIENTRY _glBindRenderbufferEXT(GLenum target, GLuint renderbuffer) {
    const char *_name = "glBindRenderbufferEXT";
    if (!_glBindRenderbufferEXT_ptr) {
        _glBindRenderbufferEXT_ptr = (PFN_GLBINDRENDERBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glBindRenderbufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindRenderbufferEXT_ptr(target, renderbuffer);
}

typedef void (APIENTRY * PFN_GLDELETERENDERBUFFERSEXT)(GLsizei n, const GLuint * renderbuffers);
static PFN_GLDELETERENDERBUFFERSEXT _glDeleteRenderbuffersEXT_ptr = NULL;

static inline void APIENTRY _glDeleteRenderbuffersEXT(GLsizei n, const GLuint * renderbuffers) {
    const char *_name = "glDeleteRenderbuffersEXT";
    if (!_glDeleteRenderbuffersEXT_ptr) {
        _glDeleteRenderbuffersEXT_ptr = (PFN_GLDELETERENDERBUFFERSEXT)_getPrivateProcAddress(_name);
        if (!_glDeleteRenderbuffersEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteRenderbuffersEXT_ptr(n, renderbuffers);
}

typedef void (APIENTRY * PFN_GLGENRENDERBUFFERSEXT)(GLsizei n, GLuint * renderbuffers);
static PFN_GLGENRENDERBUFFERSEXT _glGenRenderbuffersEXT_ptr = NULL;

static inline void APIENTRY _glGenRenderbuffersEXT(GLsizei n, GLuint * renderbuffers) {
    const char *_name = "glGenRenderbuffersEXT";
    if (!_glGenRenderbuffersEXT_ptr) {
        _glGenRenderbuffersEXT_ptr = (PFN_GLGENRENDERBUFFERSEXT)_getPrivateProcAddress(_name);
        if (!_glGenRenderbuffersEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenRenderbuffersEXT_ptr(n, renderbuffers);
}

typedef void (APIENTRY * PFN_GLRENDERBUFFERSTORAGEEXT)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLRENDERBUFFERSTORAGEEXT _glRenderbufferStorageEXT_ptr = NULL;

static inline void APIENTRY _glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageEXT";
    if (!_glRenderbufferStorageEXT_ptr) {
        _glRenderbufferStorageEXT_ptr = (PFN_GLRENDERBUFFERSTORAGEEXT)_getPrivateProcAddress(_name);
        if (!_glRenderbufferStorageEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRenderbufferStorageEXT_ptr(target, internalformat, width, height);
}

typedef void (APIENTRY * PFN_GLGETRENDERBUFFERPARAMETERIVEXT)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETRENDERBUFFERPARAMETERIVEXT _glGetRenderbufferParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetRenderbufferParameterivEXT";
    if (!_glGetRenderbufferParameterivEXT_ptr) {
        _glGetRenderbufferParameterivEXT_ptr = (PFN_GLGETRENDERBUFFERPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetRenderbufferParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetRenderbufferParameterivEXT_ptr(target, pname, params);
}

typedef GLboolean (APIENTRY * PFN_GLISFRAMEBUFFEREXT)(GLuint framebuffer);
static PFN_GLISFRAMEBUFFEREXT _glIsFramebufferEXT_ptr = NULL;

static inline GLboolean APIENTRY _glIsFramebufferEXT(GLuint framebuffer) {
    const char *_name = "glIsFramebufferEXT";
    if (!_glIsFramebufferEXT_ptr) {
        _glIsFramebufferEXT_ptr = (PFN_GLISFRAMEBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glIsFramebufferEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsFramebufferEXT_ptr(framebuffer);
}

typedef void (APIENTRY * PFN_GLBINDFRAMEBUFFEREXT)(GLenum target, GLuint framebuffer);
static PFN_GLBINDFRAMEBUFFEREXT _glBindFramebufferEXT_ptr = NULL;

static inline void APIENTRY _glBindFramebufferEXT(GLenum target, GLuint framebuffer) {
    const char *_name = "glBindFramebufferEXT";
    if (!_glBindFramebufferEXT_ptr) {
        _glBindFramebufferEXT_ptr = (PFN_GLBINDFRAMEBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glBindFramebufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindFramebufferEXT_ptr(target, framebuffer);
}

typedef void (APIENTRY * PFN_GLDELETEFRAMEBUFFERSEXT)(GLsizei n, const GLuint * framebuffers);
static PFN_GLDELETEFRAMEBUFFERSEXT _glDeleteFramebuffersEXT_ptr = NULL;

static inline void APIENTRY _glDeleteFramebuffersEXT(GLsizei n, const GLuint * framebuffers) {
    const char *_name = "glDeleteFramebuffersEXT";
    if (!_glDeleteFramebuffersEXT_ptr) {
        _glDeleteFramebuffersEXT_ptr = (PFN_GLDELETEFRAMEBUFFERSEXT)_getPrivateProcAddress(_name);
        if (!_glDeleteFramebuffersEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteFramebuffersEXT_ptr(n, framebuffers);
}

typedef void (APIENTRY * PFN_GLGENFRAMEBUFFERSEXT)(GLsizei n, GLuint * framebuffers);
static PFN_GLGENFRAMEBUFFERSEXT _glGenFramebuffersEXT_ptr = NULL;

static inline void APIENTRY _glGenFramebuffersEXT(GLsizei n, GLuint * framebuffers) {
    const char *_name = "glGenFramebuffersEXT";
    if (!_glGenFramebuffersEXT_ptr) {
        _glGenFramebuffersEXT_ptr = (PFN_GLGENFRAMEBUFFERSEXT)_getPrivateProcAddress(_name);
        if (!_glGenFramebuffersEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenFramebuffersEXT_ptr(n, framebuffers);
}

typedef GLenum (APIENTRY * PFN_GLCHECKFRAMEBUFFERSTATUSEXT)(GLenum target);
static PFN_GLCHECKFRAMEBUFFERSTATUSEXT _glCheckFramebufferStatusEXT_ptr = NULL;

static inline GLenum APIENTRY _glCheckFramebufferStatusEXT(GLenum target) {
    const char *_name = "glCheckFramebufferStatusEXT";
    if (!_glCheckFramebufferStatusEXT_ptr) {
        _glCheckFramebufferStatusEXT_ptr = (PFN_GLCHECKFRAMEBUFFERSTATUSEXT)_getPrivateProcAddress(_name);
        if (!_glCheckFramebufferStatusEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glCheckFramebufferStatusEXT_ptr(target);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTURE1DEXT)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
static PFN_GLFRAMEBUFFERTEXTURE1DEXT _glFramebufferTexture1DEXT_ptr = NULL;

static inline void APIENTRY _glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTexture1DEXT";
    if (!_glFramebufferTexture1DEXT_ptr) {
        _glFramebufferTexture1DEXT_ptr = (PFN_GLFRAMEBUFFERTEXTURE1DEXT)_getPrivateProcAddress(_name);
        if (!_glFramebufferTexture1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTexture1DEXT_ptr(target, attachment, textarget, texture, level);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTURE2DEXT)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
static PFN_GLFRAMEBUFFERTEXTURE2DEXT _glFramebufferTexture2DEXT_ptr = NULL;

static inline void APIENTRY _glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTexture2DEXT";
    if (!_glFramebufferTexture2DEXT_ptr) {
        _glFramebufferTexture2DEXT_ptr = (PFN_GLFRAMEBUFFERTEXTURE2DEXT)_getPrivateProcAddress(_name);
        if (!_glFramebufferTexture2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTexture2DEXT_ptr(target, attachment, textarget, texture, level);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTURE3DEXT)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
static PFN_GLFRAMEBUFFERTEXTURE3DEXT _glFramebufferTexture3DEXT_ptr = NULL;

static inline void APIENTRY _glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
    const char *_name = "glFramebufferTexture3DEXT";
    if (!_glFramebufferTexture3DEXT_ptr) {
        _glFramebufferTexture3DEXT_ptr = (PFN_GLFRAMEBUFFERTEXTURE3DEXT)_getPrivateProcAddress(_name);
        if (!_glFramebufferTexture3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTexture3DEXT_ptr(target, attachment, textarget, texture, level, zoffset);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERRENDERBUFFEREXT)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
static PFN_GLFRAMEBUFFERRENDERBUFFEREXT _glFramebufferRenderbufferEXT_ptr = NULL;

static inline void APIENTRY _glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    const char *_name = "glFramebufferRenderbufferEXT";
    if (!_glFramebufferRenderbufferEXT_ptr) {
        _glFramebufferRenderbufferEXT_ptr = (PFN_GLFRAMEBUFFERRENDERBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glFramebufferRenderbufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferRenderbufferEXT_ptr(target, attachment, renderbuffertarget, renderbuffer);
}

typedef void (APIENTRY * PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXT)(GLenum target, GLenum attachment, GLenum pname, GLint * params);
static PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXT _glGetFramebufferAttachmentParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint * params) {
    const char *_name = "glGetFramebufferAttachmentParameterivEXT";
    if (!_glGetFramebufferAttachmentParameterivEXT_ptr) {
        _glGetFramebufferAttachmentParameterivEXT_ptr = (PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetFramebufferAttachmentParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFramebufferAttachmentParameterivEXT_ptr(target, attachment, pname, params);
}

typedef void (APIENTRY * PFN_GLGENERATEMIPMAPEXT)(GLenum target);
static PFN_GLGENERATEMIPMAPEXT _glGenerateMipmapEXT_ptr = NULL;

static inline void APIENTRY _glGenerateMipmapEXT(GLenum target) {
    const char *_name = "glGenerateMipmapEXT";
    if (!_glGenerateMipmapEXT_ptr) {
        _glGenerateMipmapEXT_ptr = (PFN_GLGENERATEMIPMAPEXT)_getPrivateProcAddress(_name);
        if (!_glGenerateMipmapEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenerateMipmapEXT_ptr(target);
}

typedef void (APIENTRY * PFN_GLSTRINGMARKERGREMEDY)(GLsizei len, const GLvoid * string);
static PFN_GLSTRINGMARKERGREMEDY _glStringMarkerGREMEDY_ptr = NULL;

static inline void APIENTRY _glStringMarkerGREMEDY(GLsizei len, const GLvoid * string) {
    const char *_name = "glStringMarkerGREMEDY";
    if (!_glStringMarkerGREMEDY_ptr) {
        _glStringMarkerGREMEDY_ptr = (PFN_GLSTRINGMARKERGREMEDY)_getPrivateProcAddress(_name);
        if (!_glStringMarkerGREMEDY_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glStringMarkerGREMEDY_ptr(len, string);
}

typedef void (APIENTRY * PFN_GLSTENCILCLEARTAGEXT)(GLsizei stencilTagBits, GLuint stencilClearTag);
static PFN_GLSTENCILCLEARTAGEXT _glStencilClearTagEXT_ptr = NULL;

static inline void APIENTRY _glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag) {
    const char *_name = "glStencilClearTagEXT";
    if (!_glStencilClearTagEXT_ptr) {
        _glStencilClearTagEXT_ptr = (PFN_GLSTENCILCLEARTAGEXT)_getPrivateProcAddress(_name);
        if (!_glStencilClearTagEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glStencilClearTagEXT_ptr(stencilTagBits, stencilClearTag);
}

typedef void (APIENTRY * PFN_GLBLITFRAMEBUFFEREXT)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
static PFN_GLBLITFRAMEBUFFEREXT _glBlitFramebufferEXT_ptr = NULL;

static inline void APIENTRY _glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    const char *_name = "glBlitFramebufferEXT";
    if (!_glBlitFramebufferEXT_ptr) {
        _glBlitFramebufferEXT_ptr = (PFN_GLBLITFRAMEBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glBlitFramebufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlitFramebufferEXT_ptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

typedef void (APIENTRY * PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEEXT)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEEXT _glRenderbufferStorageMultisampleEXT_ptr = NULL;

static inline void APIENTRY _glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageMultisampleEXT";
    if (!_glRenderbufferStorageMultisampleEXT_ptr) {
        _glRenderbufferStorageMultisampleEXT_ptr = (PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEEXT)_getPrivateProcAddress(_name);
        if (!_glRenderbufferStorageMultisampleEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRenderbufferStorageMultisampleEXT_ptr(target, samples, internalformat, width, height);
}

typedef void (APIENTRY * PFN_GLGETQUERYOBJECTI64VEXT)(GLuint id, GLenum pname, GLint64EXT * params);
static PFN_GLGETQUERYOBJECTI64VEXT _glGetQueryObjecti64vEXT_ptr = NULL;

static inline void APIENTRY _glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT * params) {
    const char *_name = "glGetQueryObjecti64vEXT";
    if (!_glGetQueryObjecti64vEXT_ptr) {
        _glGetQueryObjecti64vEXT_ptr = (PFN_GLGETQUERYOBJECTI64VEXT)_getPrivateProcAddress(_name);
        if (!_glGetQueryObjecti64vEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetQueryObjecti64vEXT_ptr(id, pname, params);
}

typedef void (APIENTRY * PFN_GLGETQUERYOBJECTUI64VEXT)(GLuint id, GLenum pname, GLuint64EXT * params);
static PFN_GLGETQUERYOBJECTUI64VEXT _glGetQueryObjectui64vEXT_ptr = NULL;

static inline void APIENTRY _glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT * params) {
    const char *_name = "glGetQueryObjectui64vEXT";
    if (!_glGetQueryObjectui64vEXT_ptr) {
        _glGetQueryObjectui64vEXT_ptr = (PFN_GLGETQUERYOBJECTUI64VEXT)_getPrivateProcAddress(_name);
        if (!_glGetQueryObjectui64vEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetQueryObjectui64vEXT_ptr(id, pname, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMENVPARAMETERS4FVEXT)(GLenum target, GLuint index, GLsizei count, const GLfloat * params);
static PFN_GLPROGRAMENVPARAMETERS4FVEXT _glProgramEnvParameters4fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat * params) {
    const char *_name = "glProgramEnvParameters4fvEXT";
    if (!_glProgramEnvParameters4fvEXT_ptr) {
        _glProgramEnvParameters4fvEXT_ptr = (PFN_GLPROGRAMENVPARAMETERS4FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramEnvParameters4fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramEnvParameters4fvEXT_ptr(target, index, count, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMLOCALPARAMETERS4FVEXT)(GLenum target, GLuint index, GLsizei count, const GLfloat * params);
static PFN_GLPROGRAMLOCALPARAMETERS4FVEXT _glProgramLocalParameters4fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat * params) {
    const char *_name = "glProgramLocalParameters4fvEXT";
    if (!_glProgramLocalParameters4fvEXT_ptr) {
        _glProgramLocalParameters4fvEXT_ptr = (PFN_GLPROGRAMLOCALPARAMETERS4FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramLocalParameters4fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramLocalParameters4fvEXT_ptr(target, index, count, params);
}

typedef void (APIENTRY * PFN_GLBUFFERPARAMETERIAPPLE)(GLenum target, GLenum pname, GLint param);
static PFN_GLBUFFERPARAMETERIAPPLE _glBufferParameteriAPPLE_ptr = NULL;

static inline void APIENTRY _glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param) {
    const char *_name = "glBufferParameteriAPPLE";
    if (!_glBufferParameteriAPPLE_ptr) {
        _glBufferParameteriAPPLE_ptr = (PFN_GLBUFFERPARAMETERIAPPLE)_getPrivateProcAddress(_name);
        if (!_glBufferParameteriAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBufferParameteriAPPLE_ptr(target, pname, param);
}

typedef void (APIENTRY * PFN_GLFLUSHMAPPEDBUFFERRANGEAPPLE)(GLenum target, GLintptr offset, GLsizeiptr size);
static PFN_GLFLUSHMAPPEDBUFFERRANGEAPPLE _glFlushMappedBufferRangeAPPLE_ptr = NULL;

static inline void APIENTRY _glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glFlushMappedBufferRangeAPPLE";
    if (!_glFlushMappedBufferRangeAPPLE_ptr) {
        _glFlushMappedBufferRangeAPPLE_ptr = (PFN_GLFLUSHMAPPEDBUFFERRANGEAPPLE)_getPrivateProcAddress(_name);
        if (!_glFlushMappedBufferRangeAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFlushMappedBufferRangeAPPLE_ptr(target, offset, size);
}

typedef void (APIENTRY * PFN_GLPROGRAMLOCALPARAMETERI4INV)(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
static PFN_GLPROGRAMLOCALPARAMETERI4INV _glProgramLocalParameterI4iNV_ptr = NULL;

static inline void APIENTRY _glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glProgramLocalParameterI4iNV";
    if (!_glProgramLocalParameterI4iNV_ptr) {
        _glProgramLocalParameterI4iNV_ptr = (PFN_GLPROGRAMLOCALPARAMETERI4INV)_getPrivateProcAddress(_name);
        if (!_glProgramLocalParameterI4iNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramLocalParameterI4iNV_ptr(target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMLOCALPARAMETERI4IVNV)(GLenum target, GLuint index, const GLint * params);
static PFN_GLPROGRAMLOCALPARAMETERI4IVNV _glProgramLocalParameterI4ivNV_ptr = NULL;

static inline void APIENTRY _glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint * params) {
    const char *_name = "glProgramLocalParameterI4ivNV";
    if (!_glProgramLocalParameterI4ivNV_ptr) {
        _glProgramLocalParameterI4ivNV_ptr = (PFN_GLPROGRAMLOCALPARAMETERI4IVNV)_getPrivateProcAddress(_name);
        if (!_glProgramLocalParameterI4ivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramLocalParameterI4ivNV_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMLOCALPARAMETERSI4IVNV)(GLenum target, GLuint index, GLsizei count, const GLint * params);
static PFN_GLPROGRAMLOCALPARAMETERSI4IVNV _glProgramLocalParametersI4ivNV_ptr = NULL;

static inline void APIENTRY _glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint * params) {
    const char *_name = "glProgramLocalParametersI4ivNV";
    if (!_glProgramLocalParametersI4ivNV_ptr) {
        _glProgramLocalParametersI4ivNV_ptr = (PFN_GLPROGRAMLOCALPARAMETERSI4IVNV)_getPrivateProcAddress(_name);
        if (!_glProgramLocalParametersI4ivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramLocalParametersI4ivNV_ptr(target, index, count, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMLOCALPARAMETERI4UINV)(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
static PFN_GLPROGRAMLOCALPARAMETERI4UINV _glProgramLocalParameterI4uiNV_ptr = NULL;

static inline void APIENTRY _glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    const char *_name = "glProgramLocalParameterI4uiNV";
    if (!_glProgramLocalParameterI4uiNV_ptr) {
        _glProgramLocalParameterI4uiNV_ptr = (PFN_GLPROGRAMLOCALPARAMETERI4UINV)_getPrivateProcAddress(_name);
        if (!_glProgramLocalParameterI4uiNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramLocalParameterI4uiNV_ptr(target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMLOCALPARAMETERI4UIVNV)(GLenum target, GLuint index, const GLuint * params);
static PFN_GLPROGRAMLOCALPARAMETERI4UIVNV _glProgramLocalParameterI4uivNV_ptr = NULL;

static inline void APIENTRY _glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint * params) {
    const char *_name = "glProgramLocalParameterI4uivNV";
    if (!_glProgramLocalParameterI4uivNV_ptr) {
        _glProgramLocalParameterI4uivNV_ptr = (PFN_GLPROGRAMLOCALPARAMETERI4UIVNV)_getPrivateProcAddress(_name);
        if (!_glProgramLocalParameterI4uivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramLocalParameterI4uivNV_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMLOCALPARAMETERSI4UIVNV)(GLenum target, GLuint index, GLsizei count, const GLuint * params);
static PFN_GLPROGRAMLOCALPARAMETERSI4UIVNV _glProgramLocalParametersI4uivNV_ptr = NULL;

static inline void APIENTRY _glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint * params) {
    const char *_name = "glProgramLocalParametersI4uivNV";
    if (!_glProgramLocalParametersI4uivNV_ptr) {
        _glProgramLocalParametersI4uivNV_ptr = (PFN_GLPROGRAMLOCALPARAMETERSI4UIVNV)_getPrivateProcAddress(_name);
        if (!_glProgramLocalParametersI4uivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramLocalParametersI4uivNV_ptr(target, index, count, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMENVPARAMETERI4INV)(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
static PFN_GLPROGRAMENVPARAMETERI4INV _glProgramEnvParameterI4iNV_ptr = NULL;

static inline void APIENTRY _glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glProgramEnvParameterI4iNV";
    if (!_glProgramEnvParameterI4iNV_ptr) {
        _glProgramEnvParameterI4iNV_ptr = (PFN_GLPROGRAMENVPARAMETERI4INV)_getPrivateProcAddress(_name);
        if (!_glProgramEnvParameterI4iNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramEnvParameterI4iNV_ptr(target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMENVPARAMETERI4IVNV)(GLenum target, GLuint index, const GLint * params);
static PFN_GLPROGRAMENVPARAMETERI4IVNV _glProgramEnvParameterI4ivNV_ptr = NULL;

static inline void APIENTRY _glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint * params) {
    const char *_name = "glProgramEnvParameterI4ivNV";
    if (!_glProgramEnvParameterI4ivNV_ptr) {
        _glProgramEnvParameterI4ivNV_ptr = (PFN_GLPROGRAMENVPARAMETERI4IVNV)_getPrivateProcAddress(_name);
        if (!_glProgramEnvParameterI4ivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramEnvParameterI4ivNV_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMENVPARAMETERSI4IVNV)(GLenum target, GLuint index, GLsizei count, const GLint * params);
static PFN_GLPROGRAMENVPARAMETERSI4IVNV _glProgramEnvParametersI4ivNV_ptr = NULL;

static inline void APIENTRY _glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint * params) {
    const char *_name = "glProgramEnvParametersI4ivNV";
    if (!_glProgramEnvParametersI4ivNV_ptr) {
        _glProgramEnvParametersI4ivNV_ptr = (PFN_GLPROGRAMENVPARAMETERSI4IVNV)_getPrivateProcAddress(_name);
        if (!_glProgramEnvParametersI4ivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramEnvParametersI4ivNV_ptr(target, index, count, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMENVPARAMETERI4UINV)(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
static PFN_GLPROGRAMENVPARAMETERI4UINV _glProgramEnvParameterI4uiNV_ptr = NULL;

static inline void APIENTRY _glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    const char *_name = "glProgramEnvParameterI4uiNV";
    if (!_glProgramEnvParameterI4uiNV_ptr) {
        _glProgramEnvParameterI4uiNV_ptr = (PFN_GLPROGRAMENVPARAMETERI4UINV)_getPrivateProcAddress(_name);
        if (!_glProgramEnvParameterI4uiNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramEnvParameterI4uiNV_ptr(target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMENVPARAMETERI4UIVNV)(GLenum target, GLuint index, const GLuint * params);
static PFN_GLPROGRAMENVPARAMETERI4UIVNV _glProgramEnvParameterI4uivNV_ptr = NULL;

static inline void APIENTRY _glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint * params) {
    const char *_name = "glProgramEnvParameterI4uivNV";
    if (!_glProgramEnvParameterI4uivNV_ptr) {
        _glProgramEnvParameterI4uivNV_ptr = (PFN_GLPROGRAMENVPARAMETERI4UIVNV)_getPrivateProcAddress(_name);
        if (!_glProgramEnvParameterI4uivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramEnvParameterI4uivNV_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMENVPARAMETERSI4UIVNV)(GLenum target, GLuint index, GLsizei count, const GLuint * params);
static PFN_GLPROGRAMENVPARAMETERSI4UIVNV _glProgramEnvParametersI4uivNV_ptr = NULL;

static inline void APIENTRY _glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint * params) {
    const char *_name = "glProgramEnvParametersI4uivNV";
    if (!_glProgramEnvParametersI4uivNV_ptr) {
        _glProgramEnvParametersI4uivNV_ptr = (PFN_GLPROGRAMENVPARAMETERSI4UIVNV)_getPrivateProcAddress(_name);
        if (!_glProgramEnvParametersI4uivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramEnvParametersI4uivNV_ptr(target, index, count, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMLOCALPARAMETERIIVNV)(GLenum target, GLuint index, GLint * params);
static PFN_GLGETPROGRAMLOCALPARAMETERIIVNV _glGetProgramLocalParameterIivNV_ptr = NULL;

static inline void APIENTRY _glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint * params) {
    const char *_name = "glGetProgramLocalParameterIivNV";
    if (!_glGetProgramLocalParameterIivNV_ptr) {
        _glGetProgramLocalParameterIivNV_ptr = (PFN_GLGETPROGRAMLOCALPARAMETERIIVNV)_getPrivateProcAddress(_name);
        if (!_glGetProgramLocalParameterIivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramLocalParameterIivNV_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMLOCALPARAMETERIUIVNV)(GLenum target, GLuint index, GLuint * params);
static PFN_GLGETPROGRAMLOCALPARAMETERIUIVNV _glGetProgramLocalParameterIuivNV_ptr = NULL;

static inline void APIENTRY _glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint * params) {
    const char *_name = "glGetProgramLocalParameterIuivNV";
    if (!_glGetProgramLocalParameterIuivNV_ptr) {
        _glGetProgramLocalParameterIuivNV_ptr = (PFN_GLGETPROGRAMLOCALPARAMETERIUIVNV)_getPrivateProcAddress(_name);
        if (!_glGetProgramLocalParameterIuivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramLocalParameterIuivNV_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMENVPARAMETERIIVNV)(GLenum target, GLuint index, GLint * params);
static PFN_GLGETPROGRAMENVPARAMETERIIVNV _glGetProgramEnvParameterIivNV_ptr = NULL;

static inline void APIENTRY _glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint * params) {
    const char *_name = "glGetProgramEnvParameterIivNV";
    if (!_glGetProgramEnvParameterIivNV_ptr) {
        _glGetProgramEnvParameterIivNV_ptr = (PFN_GLGETPROGRAMENVPARAMETERIIVNV)_getPrivateProcAddress(_name);
        if (!_glGetProgramEnvParameterIivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramEnvParameterIivNV_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMENVPARAMETERIUIVNV)(GLenum target, GLuint index, GLuint * params);
static PFN_GLGETPROGRAMENVPARAMETERIUIVNV _glGetProgramEnvParameterIuivNV_ptr = NULL;

static inline void APIENTRY _glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint * params) {
    const char *_name = "glGetProgramEnvParameterIuivNV";
    if (!_glGetProgramEnvParameterIuivNV_ptr) {
        _glGetProgramEnvParameterIuivNV_ptr = (PFN_GLGETPROGRAMENVPARAMETERIUIVNV)_getPrivateProcAddress(_name);
        if (!_glGetProgramEnvParameterIuivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramEnvParameterIuivNV_ptr(target, index, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMVERTEXLIMITNV)(GLenum target, GLint limit);
static PFN_GLPROGRAMVERTEXLIMITNV _glProgramVertexLimitNV_ptr = NULL;

static inline void APIENTRY _glProgramVertexLimitNV(GLenum target, GLint limit) {
    const char *_name = "glProgramVertexLimitNV";
    if (!_glProgramVertexLimitNV_ptr) {
        _glProgramVertexLimitNV_ptr = (PFN_GLPROGRAMVERTEXLIMITNV)_getPrivateProcAddress(_name);
        if (!_glProgramVertexLimitNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramVertexLimitNV_ptr(target, limit);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTUREEXT)(GLenum target, GLenum attachment, GLuint texture, GLint level);
static PFN_GLFRAMEBUFFERTEXTUREEXT _glFramebufferTextureEXT_ptr = NULL;

static inline void APIENTRY _glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTextureEXT";
    if (!_glFramebufferTextureEXT_ptr) {
        _glFramebufferTextureEXT_ptr = (PFN_GLFRAMEBUFFERTEXTUREEXT)_getPrivateProcAddress(_name);
        if (!_glFramebufferTextureEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTextureEXT_ptr(target, attachment, texture, level);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTURELAYEREXT)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
static PFN_GLFRAMEBUFFERTEXTURELAYEREXT _glFramebufferTextureLayerEXT_ptr = NULL;

static inline void APIENTRY _glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    const char *_name = "glFramebufferTextureLayerEXT";
    if (!_glFramebufferTextureLayerEXT_ptr) {
        _glFramebufferTextureLayerEXT_ptr = (PFN_GLFRAMEBUFFERTEXTURELAYEREXT)_getPrivateProcAddress(_name);
        if (!_glFramebufferTextureLayerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTextureLayerEXT_ptr(target, attachment, texture, level, layer);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERTEXTUREFACEEXT)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
static PFN_GLFRAMEBUFFERTEXTUREFACEEXT _glFramebufferTextureFaceEXT_ptr = NULL;

static inline void APIENTRY _glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) {
    const char *_name = "glFramebufferTextureFaceEXT";
    if (!_glFramebufferTextureFaceEXT_ptr) {
        _glFramebufferTextureFaceEXT_ptr = (PFN_GLFRAMEBUFFERTEXTUREFACEEXT)_getPrivateProcAddress(_name);
        if (!_glFramebufferTextureFaceEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTextureFaceEXT_ptr(target, attachment, texture, level, face);
}

typedef void (APIENTRY * PFN_GLPROGRAMPARAMETERIEXT)(GLuint program, GLenum pname, GLint value);
static PFN_GLPROGRAMPARAMETERIEXT _glProgramParameteriEXT_ptr = NULL;

static inline void APIENTRY _glProgramParameteriEXT(GLuint program, GLenum pname, GLint value) {
    const char *_name = "glProgramParameteriEXT";
    if (!_glProgramParameteriEXT_ptr) {
        _glProgramParameteriEXT_ptr = (PFN_GLPROGRAMPARAMETERIEXT)_getPrivateProcAddress(_name);
        if (!_glProgramParameteriEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramParameteriEXT_ptr(program, pname, value);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI1IEXT)(GLuint index, GLint x);
static PFN_GLVERTEXATTRIBI1IEXT _glVertexAttribI1iEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI1iEXT(GLuint index, GLint x) {
    const char *_name = "glVertexAttribI1iEXT";
    if (!_glVertexAttribI1iEXT_ptr) {
        _glVertexAttribI1iEXT_ptr = (PFN_GLVERTEXATTRIBI1IEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI1iEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI1iEXT_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI2IEXT)(GLuint index, GLint x, GLint y);
static PFN_GLVERTEXATTRIBI2IEXT _glVertexAttribI2iEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI2iEXT(GLuint index, GLint x, GLint y) {
    const char *_name = "glVertexAttribI2iEXT";
    if (!_glVertexAttribI2iEXT_ptr) {
        _glVertexAttribI2iEXT_ptr = (PFN_GLVERTEXATTRIBI2IEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI2iEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI2iEXT_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI3IEXT)(GLuint index, GLint x, GLint y, GLint z);
static PFN_GLVERTEXATTRIBI3IEXT _glVertexAttribI3iEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z) {
    const char *_name = "glVertexAttribI3iEXT";
    if (!_glVertexAttribI3iEXT_ptr) {
        _glVertexAttribI3iEXT_ptr = (PFN_GLVERTEXATTRIBI3IEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI3iEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI3iEXT_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4IEXT)(GLuint index, GLint x, GLint y, GLint z, GLint w);
static PFN_GLVERTEXATTRIBI4IEXT _glVertexAttribI4iEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glVertexAttribI4iEXT";
    if (!_glVertexAttribI4iEXT_ptr) {
        _glVertexAttribI4iEXT_ptr = (PFN_GLVERTEXATTRIBI4IEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4iEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4iEXT_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI1UIEXT)(GLuint index, GLuint x);
static PFN_GLVERTEXATTRIBI1UIEXT _glVertexAttribI1uiEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI1uiEXT(GLuint index, GLuint x) {
    const char *_name = "glVertexAttribI1uiEXT";
    if (!_glVertexAttribI1uiEXT_ptr) {
        _glVertexAttribI1uiEXT_ptr = (PFN_GLVERTEXATTRIBI1UIEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI1uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI1uiEXT_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI2UIEXT)(GLuint index, GLuint x, GLuint y);
static PFN_GLVERTEXATTRIBI2UIEXT _glVertexAttribI2uiEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y) {
    const char *_name = "glVertexAttribI2uiEXT";
    if (!_glVertexAttribI2uiEXT_ptr) {
        _glVertexAttribI2uiEXT_ptr = (PFN_GLVERTEXATTRIBI2UIEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI2uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI2uiEXT_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI3UIEXT)(GLuint index, GLuint x, GLuint y, GLuint z);
static PFN_GLVERTEXATTRIBI3UIEXT _glVertexAttribI3uiEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z) {
    const char *_name = "glVertexAttribI3uiEXT";
    if (!_glVertexAttribI3uiEXT_ptr) {
        _glVertexAttribI3uiEXT_ptr = (PFN_GLVERTEXATTRIBI3UIEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI3uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI3uiEXT_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4UIEXT)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
static PFN_GLVERTEXATTRIBI4UIEXT _glVertexAttribI4uiEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    const char *_name = "glVertexAttribI4uiEXT";
    if (!_glVertexAttribI4uiEXT_ptr) {
        _glVertexAttribI4uiEXT_ptr = (PFN_GLVERTEXATTRIBI4UIEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4uiEXT_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI1IVEXT)(GLuint index, const GLint * v);
static PFN_GLVERTEXATTRIBI1IVEXT _glVertexAttribI1ivEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI1ivEXT(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI1ivEXT";
    if (!_glVertexAttribI1ivEXT_ptr) {
        _glVertexAttribI1ivEXT_ptr = (PFN_GLVERTEXATTRIBI1IVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI1ivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI1ivEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI2IVEXT)(GLuint index, const GLint * v);
static PFN_GLVERTEXATTRIBI2IVEXT _glVertexAttribI2ivEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI2ivEXT(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI2ivEXT";
    if (!_glVertexAttribI2ivEXT_ptr) {
        _glVertexAttribI2ivEXT_ptr = (PFN_GLVERTEXATTRIBI2IVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI2ivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI2ivEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI3IVEXT)(GLuint index, const GLint * v);
static PFN_GLVERTEXATTRIBI3IVEXT _glVertexAttribI3ivEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI3ivEXT(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI3ivEXT";
    if (!_glVertexAttribI3ivEXT_ptr) {
        _glVertexAttribI3ivEXT_ptr = (PFN_GLVERTEXATTRIBI3IVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI3ivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI3ivEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4IVEXT)(GLuint index, const GLint * v);
static PFN_GLVERTEXATTRIBI4IVEXT _glVertexAttribI4ivEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4ivEXT(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI4ivEXT";
    if (!_glVertexAttribI4ivEXT_ptr) {
        _glVertexAttribI4ivEXT_ptr = (PFN_GLVERTEXATTRIBI4IVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4ivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4ivEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI1UIVEXT)(GLuint index, const GLuint * v);
static PFN_GLVERTEXATTRIBI1UIVEXT _glVertexAttribI1uivEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI1uivEXT(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI1uivEXT";
    if (!_glVertexAttribI1uivEXT_ptr) {
        _glVertexAttribI1uivEXT_ptr = (PFN_GLVERTEXATTRIBI1UIVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI1uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI1uivEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI2UIVEXT)(GLuint index, const GLuint * v);
static PFN_GLVERTEXATTRIBI2UIVEXT _glVertexAttribI2uivEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI2uivEXT(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI2uivEXT";
    if (!_glVertexAttribI2uivEXT_ptr) {
        _glVertexAttribI2uivEXT_ptr = (PFN_GLVERTEXATTRIBI2UIVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI2uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI2uivEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI3UIVEXT)(GLuint index, const GLuint * v);
static PFN_GLVERTEXATTRIBI3UIVEXT _glVertexAttribI3uivEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI3uivEXT(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI3uivEXT";
    if (!_glVertexAttribI3uivEXT_ptr) {
        _glVertexAttribI3uivEXT_ptr = (PFN_GLVERTEXATTRIBI3UIVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI3uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI3uivEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4UIVEXT)(GLuint index, const GLuint * v);
static PFN_GLVERTEXATTRIBI4UIVEXT _glVertexAttribI4uivEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4uivEXT(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI4uivEXT";
    if (!_glVertexAttribI4uivEXT_ptr) {
        _glVertexAttribI4uivEXT_ptr = (PFN_GLVERTEXATTRIBI4UIVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4uivEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4BVEXT)(GLuint index, const GLbyte * v);
static PFN_GLVERTEXATTRIBI4BVEXT _glVertexAttribI4bvEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4bvEXT(GLuint index, const GLbyte * v) {
    const char *_name = "glVertexAttribI4bvEXT";
    if (!_glVertexAttribI4bvEXT_ptr) {
        _glVertexAttribI4bvEXT_ptr = (PFN_GLVERTEXATTRIBI4BVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4bvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4bvEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4SVEXT)(GLuint index, const GLshort * v);
static PFN_GLVERTEXATTRIBI4SVEXT _glVertexAttribI4svEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4svEXT(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttribI4svEXT";
    if (!_glVertexAttribI4svEXT_ptr) {
        _glVertexAttribI4svEXT_ptr = (PFN_GLVERTEXATTRIBI4SVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4svEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4svEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4UBVEXT)(GLuint index, const GLubyte * v);
static PFN_GLVERTEXATTRIBI4UBVEXT _glVertexAttribI4ubvEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4ubvEXT(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttribI4ubvEXT";
    if (!_glVertexAttribI4ubvEXT_ptr) {
        _glVertexAttribI4ubvEXT_ptr = (PFN_GLVERTEXATTRIBI4UBVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4ubvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4ubvEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBI4USVEXT)(GLuint index, const GLushort * v);
static PFN_GLVERTEXATTRIBI4USVEXT _glVertexAttribI4usvEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribI4usvEXT(GLuint index, const GLushort * v) {
    const char *_name = "glVertexAttribI4usvEXT";
    if (!_glVertexAttribI4usvEXT_ptr) {
        _glVertexAttribI4usvEXT_ptr = (PFN_GLVERTEXATTRIBI4USVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribI4usvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribI4usvEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBIPOINTEREXT)(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLVERTEXATTRIBIPOINTEREXT _glVertexAttribIPointerEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribIPointerEXT";
    if (!_glVertexAttribIPointerEXT_ptr) {
        _glVertexAttribIPointerEXT_ptr = (PFN_GLVERTEXATTRIBIPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribIPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribIPointerEXT_ptr(index, size, type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBIIVEXT)(GLuint index, GLenum pname, GLint * params);
static PFN_GLGETVERTEXATTRIBIIVEXT _glGetVertexAttribIivEXT_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetVertexAttribIivEXT";
    if (!_glGetVertexAttribIivEXT_ptr) {
        _glGetVertexAttribIivEXT_ptr = (PFN_GLGETVERTEXATTRIBIIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribIivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribIivEXT_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBIUIVEXT)(GLuint index, GLenum pname, GLuint * params);
static PFN_GLGETVERTEXATTRIBIUIVEXT _glGetVertexAttribIuivEXT_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint * params) {
    const char *_name = "glGetVertexAttribIuivEXT";
    if (!_glGetVertexAttribIuivEXT_ptr) {
        _glGetVertexAttribIuivEXT_ptr = (PFN_GLGETVERTEXATTRIBIUIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribIuivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribIuivEXT_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETUNIFORMUIVEXT)(GLuint program, GLint location, GLuint * params);
static PFN_GLGETUNIFORMUIVEXT _glGetUniformuivEXT_ptr = NULL;

static inline void APIENTRY _glGetUniformuivEXT(GLuint program, GLint location, GLuint * params) {
    const char *_name = "glGetUniformuivEXT";
    if (!_glGetUniformuivEXT_ptr) {
        _glGetUniformuivEXT_ptr = (PFN_GLGETUNIFORMUIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetUniformuivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetUniformuivEXT_ptr(program, location, params);
}

typedef void (APIENTRY * PFN_GLBINDFRAGDATALOCATIONEXT)(GLuint program, GLuint color, const GLchar * name);
static PFN_GLBINDFRAGDATALOCATIONEXT _glBindFragDataLocationEXT_ptr = NULL;

static inline void APIENTRY _glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar * name) {
    const char *_name = "glBindFragDataLocationEXT";
    if (!_glBindFragDataLocationEXT_ptr) {
        _glBindFragDataLocationEXT_ptr = (PFN_GLBINDFRAGDATALOCATIONEXT)_getPrivateProcAddress(_name);
        if (!_glBindFragDataLocationEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindFragDataLocationEXT_ptr(program, color, name);
}

typedef GLint (APIENTRY * PFN_GLGETFRAGDATALOCATIONEXT)(GLuint program, const GLchar * name);
static PFN_GLGETFRAGDATALOCATIONEXT _glGetFragDataLocationEXT_ptr = NULL;

static inline GLint APIENTRY _glGetFragDataLocationEXT(GLuint program, const GLchar * name) {
    const char *_name = "glGetFragDataLocationEXT";
    if (!_glGetFragDataLocationEXT_ptr) {
        _glGetFragDataLocationEXT_ptr = (PFN_GLGETFRAGDATALOCATIONEXT)_getPrivateProcAddress(_name);
        if (!_glGetFragDataLocationEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetFragDataLocationEXT_ptr(program, name);
}

typedef void (APIENTRY * PFN_GLUNIFORM1UIEXT)(GLint location, GLuint v0);
static PFN_GLUNIFORM1UIEXT _glUniform1uiEXT_ptr = NULL;

static inline void APIENTRY _glUniform1uiEXT(GLint location, GLuint v0) {
    const char *_name = "glUniform1uiEXT";
    if (!_glUniform1uiEXT_ptr) {
        _glUniform1uiEXT_ptr = (PFN_GLUNIFORM1UIEXT)_getPrivateProcAddress(_name);
        if (!_glUniform1uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1uiEXT_ptr(location, v0);
}

typedef void (APIENTRY * PFN_GLUNIFORM2UIEXT)(GLint location, GLuint v0, GLuint v1);
static PFN_GLUNIFORM2UIEXT _glUniform2uiEXT_ptr = NULL;

static inline void APIENTRY _glUniform2uiEXT(GLint location, GLuint v0, GLuint v1) {
    const char *_name = "glUniform2uiEXT";
    if (!_glUniform2uiEXT_ptr) {
        _glUniform2uiEXT_ptr = (PFN_GLUNIFORM2UIEXT)_getPrivateProcAddress(_name);
        if (!_glUniform2uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2uiEXT_ptr(location, v0, v1);
}

typedef void (APIENTRY * PFN_GLUNIFORM3UIEXT)(GLint location, GLuint v0, GLuint v1, GLuint v2);
static PFN_GLUNIFORM3UIEXT _glUniform3uiEXT_ptr = NULL;

static inline void APIENTRY _glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2) {
    const char *_name = "glUniform3uiEXT";
    if (!_glUniform3uiEXT_ptr) {
        _glUniform3uiEXT_ptr = (PFN_GLUNIFORM3UIEXT)_getPrivateProcAddress(_name);
        if (!_glUniform3uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3uiEXT_ptr(location, v0, v1, v2);
}

typedef void (APIENTRY * PFN_GLUNIFORM4UIEXT)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
static PFN_GLUNIFORM4UIEXT _glUniform4uiEXT_ptr = NULL;

static inline void APIENTRY _glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
    const char *_name = "glUniform4uiEXT";
    if (!_glUniform4uiEXT_ptr) {
        _glUniform4uiEXT_ptr = (PFN_GLUNIFORM4UIEXT)_getPrivateProcAddress(_name);
        if (!_glUniform4uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4uiEXT_ptr(location, v0, v1, v2, v3);
}

typedef void (APIENTRY * PFN_GLUNIFORM1UIVEXT)(GLint location, GLsizei count, const GLuint * value);
static PFN_GLUNIFORM1UIVEXT _glUniform1uivEXT_ptr = NULL;

static inline void APIENTRY _glUniform1uivEXT(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform1uivEXT";
    if (!_glUniform1uivEXT_ptr) {
        _glUniform1uivEXT_ptr = (PFN_GLUNIFORM1UIVEXT)_getPrivateProcAddress(_name);
        if (!_glUniform1uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1uivEXT_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM2UIVEXT)(GLint location, GLsizei count, const GLuint * value);
static PFN_GLUNIFORM2UIVEXT _glUniform2uivEXT_ptr = NULL;

static inline void APIENTRY _glUniform2uivEXT(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform2uivEXT";
    if (!_glUniform2uivEXT_ptr) {
        _glUniform2uivEXT_ptr = (PFN_GLUNIFORM2UIVEXT)_getPrivateProcAddress(_name);
        if (!_glUniform2uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2uivEXT_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM3UIVEXT)(GLint location, GLsizei count, const GLuint * value);
static PFN_GLUNIFORM3UIVEXT _glUniform3uivEXT_ptr = NULL;

static inline void APIENTRY _glUniform3uivEXT(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform3uivEXT";
    if (!_glUniform3uivEXT_ptr) {
        _glUniform3uivEXT_ptr = (PFN_GLUNIFORM3UIVEXT)_getPrivateProcAddress(_name);
        if (!_glUniform3uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3uivEXT_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM4UIVEXT)(GLint location, GLsizei count, const GLuint * value);
static PFN_GLUNIFORM4UIVEXT _glUniform4uivEXT_ptr = NULL;

static inline void APIENTRY _glUniform4uivEXT(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform4uivEXT";
    if (!_glUniform4uivEXT_ptr) {
        _glUniform4uivEXT_ptr = (PFN_GLUNIFORM4UIVEXT)_getPrivateProcAddress(_name);
        if (!_glUniform4uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4uivEXT_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLDRAWARRAYSINSTANCEDEXT)(GLenum mode, GLint start, GLsizei count, GLsizei primcount);
static PFN_GLDRAWARRAYSINSTANCEDEXT _glDrawArraysInstancedEXT_ptr = NULL;

static inline void APIENTRY _glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount) {
    const char *_name = "glDrawArraysInstancedEXT";
    if (!_glDrawArraysInstancedEXT_ptr) {
        _glDrawArraysInstancedEXT_ptr = (PFN_GLDRAWARRAYSINSTANCEDEXT)_getPrivateProcAddress(_name);
        if (!_glDrawArraysInstancedEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawArraysInstancedEXT_ptr(mode, start, count, primcount);
}

typedef void (APIENTRY * PFN_GLDRAWELEMENTSINSTANCEDEXT)(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount);
static PFN_GLDRAWELEMENTSINSTANCEDEXT _glDrawElementsInstancedEXT_ptr = NULL;

static inline void APIENTRY _glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount) {
    const char *_name = "glDrawElementsInstancedEXT";
    if (!_glDrawElementsInstancedEXT_ptr) {
        _glDrawElementsInstancedEXT_ptr = (PFN_GLDRAWELEMENTSINSTANCEDEXT)_getPrivateProcAddress(_name);
        if (!_glDrawElementsInstancedEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawElementsInstancedEXT_ptr(mode, count, type, indices, primcount);
}

typedef void (APIENTRY * PFN_GLTEXBUFFEREXT)(GLenum target, GLenum internalformat, GLuint buffer);
static PFN_GLTEXBUFFEREXT _glTexBufferEXT_ptr = NULL;

static inline void APIENTRY _glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer) {
    const char *_name = "glTexBufferEXT";
    if (!_glTexBufferEXT_ptr) {
        _glTexBufferEXT_ptr = (PFN_GLTEXBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glTexBufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexBufferEXT_ptr(target, internalformat, buffer);
}

typedef void (APIENTRY * PFN_GLDEPTHRANGEDNV)(GLdouble zNear, GLdouble zFar);
static PFN_GLDEPTHRANGEDNV _glDepthRangedNV_ptr = NULL;

static inline void APIENTRY _glDepthRangedNV(GLdouble zNear, GLdouble zFar) {
    const char *_name = "glDepthRangedNV";
    if (!_glDepthRangedNV_ptr) {
        _glDepthRangedNV_ptr = (PFN_GLDEPTHRANGEDNV)_getPrivateProcAddress(_name);
        if (!_glDepthRangedNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDepthRangedNV_ptr(zNear, zFar);
}

typedef void (APIENTRY * PFN_GLCLEARDEPTHDNV)(GLdouble depth);
static PFN_GLCLEARDEPTHDNV _glClearDepthdNV_ptr = NULL;

static inline void APIENTRY _glClearDepthdNV(GLdouble depth) {
    const char *_name = "glClearDepthdNV";
    if (!_glClearDepthdNV_ptr) {
        _glClearDepthdNV_ptr = (PFN_GLCLEARDEPTHDNV)_getPrivateProcAddress(_name);
        if (!_glClearDepthdNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearDepthdNV_ptr(depth);
}

typedef void (APIENTRY * PFN_GLDEPTHBOUNDSDNV)(GLdouble zmin, GLdouble zmax);
static PFN_GLDEPTHBOUNDSDNV _glDepthBoundsdNV_ptr = NULL;

static inline void APIENTRY _glDepthBoundsdNV(GLdouble zmin, GLdouble zmax) {
    const char *_name = "glDepthBoundsdNV";
    if (!_glDepthBoundsdNV_ptr) {
        _glDepthBoundsdNV_ptr = (PFN_GLDEPTHBOUNDSDNV)_getPrivateProcAddress(_name);
        if (!_glDepthBoundsdNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDepthBoundsdNV_ptr(zmin, zmax);
}

typedef void (APIENTRY * PFN_GLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENV)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENV _glRenderbufferStorageMultisampleCoverageNV_ptr = NULL;

static inline void APIENTRY _glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageMultisampleCoverageNV";
    if (!_glRenderbufferStorageMultisampleCoverageNV_ptr) {
        _glRenderbufferStorageMultisampleCoverageNV_ptr = (PFN_GLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENV)_getPrivateProcAddress(_name);
        if (!_glRenderbufferStorageMultisampleCoverageNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRenderbufferStorageMultisampleCoverageNV_ptr(target, coverageSamples, colorSamples, internalformat, width, height);
}

typedef void (APIENTRY * PFN_GLPROGRAMBUFFERPARAMETERSFVNV)(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat * params);
static PFN_GLPROGRAMBUFFERPARAMETERSFVNV _glProgramBufferParametersfvNV_ptr = NULL;

static inline void APIENTRY _glProgramBufferParametersfvNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat * params) {
    const char *_name = "glProgramBufferParametersfvNV";
    if (!_glProgramBufferParametersfvNV_ptr) {
        _glProgramBufferParametersfvNV_ptr = (PFN_GLPROGRAMBUFFERPARAMETERSFVNV)_getPrivateProcAddress(_name);
        if (!_glProgramBufferParametersfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramBufferParametersfvNV_ptr(target, buffer, index, count, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMBUFFERPARAMETERSIIVNV)(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint * params);
static PFN_GLPROGRAMBUFFERPARAMETERSIIVNV _glProgramBufferParametersIivNV_ptr = NULL;

static inline void APIENTRY _glProgramBufferParametersIivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint * params) {
    const char *_name = "glProgramBufferParametersIivNV";
    if (!_glProgramBufferParametersIivNV_ptr) {
        _glProgramBufferParametersIivNV_ptr = (PFN_GLPROGRAMBUFFERPARAMETERSIIVNV)_getPrivateProcAddress(_name);
        if (!_glProgramBufferParametersIivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramBufferParametersIivNV_ptr(target, buffer, index, count, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMBUFFERPARAMETERSIUIVNV)(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint * params);
static PFN_GLPROGRAMBUFFERPARAMETERSIUIVNV _glProgramBufferParametersIuivNV_ptr = NULL;

static inline void APIENTRY _glProgramBufferParametersIuivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint * params) {
    const char *_name = "glProgramBufferParametersIuivNV";
    if (!_glProgramBufferParametersIuivNV_ptr) {
        _glProgramBufferParametersIuivNV_ptr = (PFN_GLPROGRAMBUFFERPARAMETERSIUIVNV)_getPrivateProcAddress(_name);
        if (!_glProgramBufferParametersIuivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramBufferParametersIuivNV_ptr(target, buffer, index, count, params);
}

typedef void (APIENTRY * PFN_GLCOLORMASKINDEXEDEXT)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
static PFN_GLCOLORMASKINDEXEDEXT _glColorMaskIndexedEXT_ptr = NULL;

static inline void APIENTRY _glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
    const char *_name = "glColorMaskIndexedEXT";
    if (!_glColorMaskIndexedEXT_ptr) {
        _glColorMaskIndexedEXT_ptr = (PFN_GLCOLORMASKINDEXEDEXT)_getPrivateProcAddress(_name);
        if (!_glColorMaskIndexedEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorMaskIndexedEXT_ptr(index, r, g, b, a);
}

typedef void (APIENTRY * PFN_GLGETBOOLEANINDEXEDVEXT)(GLenum target, GLuint index, GLboolean * data);
static PFN_GLGETBOOLEANINDEXEDVEXT _glGetBooleanIndexedvEXT_ptr = NULL;

static inline void APIENTRY _glGetBooleanIndexedvEXT(GLenum target, GLuint index, GLboolean * data) {
    const char *_name = "glGetBooleanIndexedvEXT";
    if (!_glGetBooleanIndexedvEXT_ptr) {
        _glGetBooleanIndexedvEXT_ptr = (PFN_GLGETBOOLEANINDEXEDVEXT)_getPrivateProcAddress(_name);
        if (!_glGetBooleanIndexedvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetBooleanIndexedvEXT_ptr(target, index, data);
}

typedef void (APIENTRY * PFN_GLGETINTEGERINDEXEDVEXT)(GLenum target, GLuint index, GLint * data);
static PFN_GLGETINTEGERINDEXEDVEXT _glGetIntegerIndexedvEXT_ptr = NULL;

static inline void APIENTRY _glGetIntegerIndexedvEXT(GLenum target, GLuint index, GLint * data) {
    const char *_name = "glGetIntegerIndexedvEXT";
    if (!_glGetIntegerIndexedvEXT_ptr) {
        _glGetIntegerIndexedvEXT_ptr = (PFN_GLGETINTEGERINDEXEDVEXT)_getPrivateProcAddress(_name);
        if (!_glGetIntegerIndexedvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetIntegerIndexedvEXT_ptr(target, index, data);
}

typedef void (APIENTRY * PFN_GLENABLEINDEXEDEXT)(GLenum target, GLuint index);
static PFN_GLENABLEINDEXEDEXT _glEnableIndexedEXT_ptr = NULL;

static inline void APIENTRY _glEnableIndexedEXT(GLenum target, GLuint index) {
    const char *_name = "glEnableIndexedEXT";
    if (!_glEnableIndexedEXT_ptr) {
        _glEnableIndexedEXT_ptr = (PFN_GLENABLEINDEXEDEXT)_getPrivateProcAddress(_name);
        if (!_glEnableIndexedEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEnableIndexedEXT_ptr(target, index);
}

typedef void (APIENTRY * PFN_GLDISABLEINDEXEDEXT)(GLenum target, GLuint index);
static PFN_GLDISABLEINDEXEDEXT _glDisableIndexedEXT_ptr = NULL;

static inline void APIENTRY _glDisableIndexedEXT(GLenum target, GLuint index) {
    const char *_name = "glDisableIndexedEXT";
    if (!_glDisableIndexedEXT_ptr) {
        _glDisableIndexedEXT_ptr = (PFN_GLDISABLEINDEXEDEXT)_getPrivateProcAddress(_name);
        if (!_glDisableIndexedEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDisableIndexedEXT_ptr(target, index);
}

typedef GLboolean (APIENTRY * PFN_GLISENABLEDINDEXEDEXT)(GLenum target, GLuint index);
static PFN_GLISENABLEDINDEXEDEXT _glIsEnabledIndexedEXT_ptr = NULL;

static inline GLboolean APIENTRY _glIsEnabledIndexedEXT(GLenum target, GLuint index) {
    const char *_name = "glIsEnabledIndexedEXT";
    if (!_glIsEnabledIndexedEXT_ptr) {
        _glIsEnabledIndexedEXT_ptr = (PFN_GLISENABLEDINDEXEDEXT)_getPrivateProcAddress(_name);
        if (!_glIsEnabledIndexedEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsEnabledIndexedEXT_ptr(target, index);
}

typedef void (APIENTRY * PFN_GLBEGINTRANSFORMFEEDBACKNV)(GLenum primitiveMode);
static PFN_GLBEGINTRANSFORMFEEDBACKNV _glBeginTransformFeedbackNV_ptr = NULL;

static inline void APIENTRY _glBeginTransformFeedbackNV(GLenum primitiveMode) {
    const char *_name = "glBeginTransformFeedbackNV";
    if (!_glBeginTransformFeedbackNV_ptr) {
        _glBeginTransformFeedbackNV_ptr = (PFN_GLBEGINTRANSFORMFEEDBACKNV)_getPrivateProcAddress(_name);
        if (!_glBeginTransformFeedbackNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginTransformFeedbackNV_ptr(primitiveMode);
}

typedef void (APIENTRY * PFN_GLENDTRANSFORMFEEDBACKNV)(void);
static PFN_GLENDTRANSFORMFEEDBACKNV _glEndTransformFeedbackNV_ptr = NULL;

static inline void APIENTRY _glEndTransformFeedbackNV(void) {
    const char *_name = "glEndTransformFeedbackNV";
    if (!_glEndTransformFeedbackNV_ptr) {
        _glEndTransformFeedbackNV_ptr = (PFN_GLENDTRANSFORMFEEDBACKNV)_getPrivateProcAddress(_name);
        if (!_glEndTransformFeedbackNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndTransformFeedbackNV_ptr();
}

typedef void (APIENTRY * PFN_GLTRANSFORMFEEDBACKATTRIBSNV)(GLuint count, const GLint * attribs, GLenum bufferMode);
static PFN_GLTRANSFORMFEEDBACKATTRIBSNV _glTransformFeedbackAttribsNV_ptr = NULL;

static inline void APIENTRY _glTransformFeedbackAttribsNV(GLuint count, const GLint * attribs, GLenum bufferMode) {
    const char *_name = "glTransformFeedbackAttribsNV";
    if (!_glTransformFeedbackAttribsNV_ptr) {
        _glTransformFeedbackAttribsNV_ptr = (PFN_GLTRANSFORMFEEDBACKATTRIBSNV)_getPrivateProcAddress(_name);
        if (!_glTransformFeedbackAttribsNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTransformFeedbackAttribsNV_ptr(count, attribs, bufferMode);
}

typedef void (APIENTRY * PFN_GLBINDBUFFERRANGENV)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
static PFN_GLBINDBUFFERRANGENV _glBindBufferRangeNV_ptr = NULL;

static inline void APIENTRY _glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glBindBufferRangeNV";
    if (!_glBindBufferRangeNV_ptr) {
        _glBindBufferRangeNV_ptr = (PFN_GLBINDBUFFERRANGENV)_getPrivateProcAddress(_name);
        if (!_glBindBufferRangeNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindBufferRangeNV_ptr(target, index, buffer, offset, size);
}

typedef void (APIENTRY * PFN_GLBINDBUFFEROFFSETNV)(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
static PFN_GLBINDBUFFEROFFSETNV _glBindBufferOffsetNV_ptr = NULL;

static inline void APIENTRY _glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset) {
    const char *_name = "glBindBufferOffsetNV";
    if (!_glBindBufferOffsetNV_ptr) {
        _glBindBufferOffsetNV_ptr = (PFN_GLBINDBUFFEROFFSETNV)_getPrivateProcAddress(_name);
        if (!_glBindBufferOffsetNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindBufferOffsetNV_ptr(target, index, buffer, offset);
}

typedef void (APIENTRY * PFN_GLBINDBUFFERBASENV)(GLenum target, GLuint index, GLuint buffer);
static PFN_GLBINDBUFFERBASENV _glBindBufferBaseNV_ptr = NULL;

static inline void APIENTRY _glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer) {
    const char *_name = "glBindBufferBaseNV";
    if (!_glBindBufferBaseNV_ptr) {
        _glBindBufferBaseNV_ptr = (PFN_GLBINDBUFFERBASENV)_getPrivateProcAddress(_name);
        if (!_glBindBufferBaseNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindBufferBaseNV_ptr(target, index, buffer);
}

typedef void (APIENTRY * PFN_GLTRANSFORMFEEDBACKVARYINGSNV)(GLuint program, GLsizei count, const GLint * locations, GLenum bufferMode);
static PFN_GLTRANSFORMFEEDBACKVARYINGSNV _glTransformFeedbackVaryingsNV_ptr = NULL;

static inline void APIENTRY _glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint * locations, GLenum bufferMode) {
    const char *_name = "glTransformFeedbackVaryingsNV";
    if (!_glTransformFeedbackVaryingsNV_ptr) {
        _glTransformFeedbackVaryingsNV_ptr = (PFN_GLTRANSFORMFEEDBACKVARYINGSNV)_getPrivateProcAddress(_name);
        if (!_glTransformFeedbackVaryingsNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTransformFeedbackVaryingsNV_ptr(program, count, locations, bufferMode);
}

typedef void (APIENTRY * PFN_GLACTIVEVARYINGNV)(GLuint program, const GLchar * name);
static PFN_GLACTIVEVARYINGNV _glActiveVaryingNV_ptr = NULL;

static inline void APIENTRY _glActiveVaryingNV(GLuint program, const GLchar * name) {
    const char *_name = "glActiveVaryingNV";
    if (!_glActiveVaryingNV_ptr) {
        _glActiveVaryingNV_ptr = (PFN_GLACTIVEVARYINGNV)_getPrivateProcAddress(_name);
        if (!_glActiveVaryingNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glActiveVaryingNV_ptr(program, name);
}

typedef GLint (APIENTRY * PFN_GLGETVARYINGLOCATIONNV)(GLuint program, const GLchar * name);
static PFN_GLGETVARYINGLOCATIONNV _glGetVaryingLocationNV_ptr = NULL;

static inline GLint APIENTRY _glGetVaryingLocationNV(GLuint program, const GLchar * name) {
    const char *_name = "glGetVaryingLocationNV";
    if (!_glGetVaryingLocationNV_ptr) {
        _glGetVaryingLocationNV_ptr = (PFN_GLGETVARYINGLOCATIONNV)_getPrivateProcAddress(_name);
        if (!_glGetVaryingLocationNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetVaryingLocationNV_ptr(program, name);
}

typedef void (APIENTRY * PFN_GLGETACTIVEVARYINGNV)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
static PFN_GLGETACTIVEVARYINGNV _glGetActiveVaryingNV_ptr = NULL;

static inline void APIENTRY _glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name) {
    const char *_name = "glGetActiveVaryingNV";
    if (!_glGetActiveVaryingNV_ptr) {
        _glGetActiveVaryingNV_ptr = (PFN_GLGETACTIVEVARYINGNV)_getPrivateProcAddress(_name);
        if (!_glGetActiveVaryingNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetActiveVaryingNV_ptr(program, index, bufSize, length, size, type, name);
}

typedef void (APIENTRY * PFN_GLGETTRANSFORMFEEDBACKVARYINGNV)(GLuint program, GLuint index, GLint * location);
static PFN_GLGETTRANSFORMFEEDBACKVARYINGNV _glGetTransformFeedbackVaryingNV_ptr = NULL;

static inline void APIENTRY _glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint * location) {
    const char *_name = "glGetTransformFeedbackVaryingNV";
    if (!_glGetTransformFeedbackVaryingNV_ptr) {
        _glGetTransformFeedbackVaryingNV_ptr = (PFN_GLGETTRANSFORMFEEDBACKVARYINGNV)_getPrivateProcAddress(_name);
        if (!_glGetTransformFeedbackVaryingNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTransformFeedbackVaryingNV_ptr(program, index, location);
}

typedef void (APIENTRY * PFN_GLTRANSFORMFEEDBACKSTREAMATTRIBSNV)(GLsizei count, const GLint * attribs, GLsizei nbuffers, const GLint * bufstreams, GLenum bufferMode);
static PFN_GLTRANSFORMFEEDBACKSTREAMATTRIBSNV _glTransformFeedbackStreamAttribsNV_ptr = NULL;

static inline void APIENTRY _glTransformFeedbackStreamAttribsNV(GLsizei count, const GLint * attribs, GLsizei nbuffers, const GLint * bufstreams, GLenum bufferMode) {
    const char *_name = "glTransformFeedbackStreamAttribsNV";
    if (!_glTransformFeedbackStreamAttribsNV_ptr) {
        _glTransformFeedbackStreamAttribsNV_ptr = (PFN_GLTRANSFORMFEEDBACKSTREAMATTRIBSNV)_getPrivateProcAddress(_name);
        if (!_glTransformFeedbackStreamAttribsNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTransformFeedbackStreamAttribsNV_ptr(count, attribs, nbuffers, bufstreams, bufferMode);
}

typedef void (APIENTRY * PFN_GLUNIFORMBUFFEREXT)(GLuint program, GLint location, GLuint buffer);
static PFN_GLUNIFORMBUFFEREXT _glUniformBufferEXT_ptr = NULL;

static inline void APIENTRY _glUniformBufferEXT(GLuint program, GLint location, GLuint buffer) {
    const char *_name = "glUniformBufferEXT";
    if (!_glUniformBufferEXT_ptr) {
        _glUniformBufferEXT_ptr = (PFN_GLUNIFORMBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glUniformBufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformBufferEXT_ptr(program, location, buffer);
}

typedef GLint (APIENTRY * PFN_GLGETUNIFORMBUFFERSIZEEXT)(GLuint program, GLint location);
static PFN_GLGETUNIFORMBUFFERSIZEEXT _glGetUniformBufferSizeEXT_ptr = NULL;

static inline GLint APIENTRY _glGetUniformBufferSizeEXT(GLuint program, GLint location) {
    const char *_name = "glGetUniformBufferSizeEXT";
    if (!_glGetUniformBufferSizeEXT_ptr) {
        _glGetUniformBufferSizeEXT_ptr = (PFN_GLGETUNIFORMBUFFERSIZEEXT)_getPrivateProcAddress(_name);
        if (!_glGetUniformBufferSizeEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetUniformBufferSizeEXT_ptr(program, location);
}

typedef GLintptr (APIENTRY * PFN_GLGETUNIFORMOFFSETEXT)(GLuint program, GLint location);
static PFN_GLGETUNIFORMOFFSETEXT _glGetUniformOffsetEXT_ptr = NULL;

static inline GLintptr APIENTRY _glGetUniformOffsetEXT(GLuint program, GLint location) {
    const char *_name = "glGetUniformOffsetEXT";
    if (!_glGetUniformOffsetEXT_ptr) {
        _glGetUniformOffsetEXT_ptr = (PFN_GLGETUNIFORMOFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glGetUniformOffsetEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetUniformOffsetEXT_ptr(program, location);
}

typedef void (APIENTRY * PFN_GLTEXPARAMETERIIVEXT)(GLenum target, GLenum pname, const GLint * params);
static PFN_GLTEXPARAMETERIIVEXT _glTexParameterIivEXT_ptr = NULL;

static inline void APIENTRY _glTexParameterIivEXT(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glTexParameterIivEXT";
    if (!_glTexParameterIivEXT_ptr) {
        _glTexParameterIivEXT_ptr = (PFN_GLTEXPARAMETERIIVEXT)_getPrivateProcAddress(_name);
        if (!_glTexParameterIivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexParameterIivEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLTEXPARAMETERIUIVEXT)(GLenum target, GLenum pname, const GLuint * params);
static PFN_GLTEXPARAMETERIUIVEXT _glTexParameterIuivEXT_ptr = NULL;

static inline void APIENTRY _glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint * params) {
    const char *_name = "glTexParameterIuivEXT";
    if (!_glTexParameterIuivEXT_ptr) {
        _glTexParameterIuivEXT_ptr = (PFN_GLTEXPARAMETERIUIVEXT)_getPrivateProcAddress(_name);
        if (!_glTexParameterIuivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexParameterIuivEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXPARAMETERIIVEXT)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETTEXPARAMETERIIVEXT _glGetTexParameterIivEXT_ptr = NULL;

static inline void APIENTRY _glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetTexParameterIivEXT";
    if (!_glGetTexParameterIivEXT_ptr) {
        _glGetTexParameterIivEXT_ptr = (PFN_GLGETTEXPARAMETERIIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetTexParameterIivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexParameterIivEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXPARAMETERIUIVEXT)(GLenum target, GLenum pname, GLuint * params);
static PFN_GLGETTEXPARAMETERIUIVEXT _glGetTexParameterIuivEXT_ptr = NULL;

static inline void APIENTRY _glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint * params) {
    const char *_name = "glGetTexParameterIuivEXT";
    if (!_glGetTexParameterIuivEXT_ptr) {
        _glGetTexParameterIuivEXT_ptr = (PFN_GLGETTEXPARAMETERIUIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetTexParameterIuivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexParameterIuivEXT_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLCLEARCOLORIIEXT)(GLint red, GLint green, GLint blue, GLint alpha);
static PFN_GLCLEARCOLORIIEXT _glClearColorIiEXT_ptr = NULL;

static inline void APIENTRY _glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha) {
    const char *_name = "glClearColorIiEXT";
    if (!_glClearColorIiEXT_ptr) {
        _glClearColorIiEXT_ptr = (PFN_GLCLEARCOLORIIEXT)_getPrivateProcAddress(_name);
        if (!_glClearColorIiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearColorIiEXT_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLCLEARCOLORIUIEXT)(GLuint red, GLuint green, GLuint blue, GLuint alpha);
static PFN_GLCLEARCOLORIUIEXT _glClearColorIuiEXT_ptr = NULL;

static inline void APIENTRY _glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
    const char *_name = "glClearColorIuiEXT";
    if (!_glClearColorIuiEXT_ptr) {
        _glClearColorIuiEXT_ptr = (PFN_GLCLEARCOLORIUIEXT)_getPrivateProcAddress(_name);
        if (!_glClearColorIuiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearColorIuiEXT_ptr(red, green, blue, alpha);
}

typedef void (APIENTRY * PFN_GLFRAMETERMINATORGREMEDY)(void);
static PFN_GLFRAMETERMINATORGREMEDY _glFrameTerminatorGREMEDY_ptr = NULL;

static inline void APIENTRY _glFrameTerminatorGREMEDY(void) {
    const char *_name = "glFrameTerminatorGREMEDY";
    if (!_glFrameTerminatorGREMEDY_ptr) {
        _glFrameTerminatorGREMEDY_ptr = (PFN_GLFRAMETERMINATORGREMEDY)_getPrivateProcAddress(_name);
        if (!_glFrameTerminatorGREMEDY_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFrameTerminatorGREMEDY_ptr();
}

typedef void (APIENTRY * PFN_GLBEGINCONDITIONALRENDERNV)(GLuint id, GLenum mode);
static PFN_GLBEGINCONDITIONALRENDERNV _glBeginConditionalRenderNV_ptr = NULL;

static inline void APIENTRY _glBeginConditionalRenderNV(GLuint id, GLenum mode) {
    const char *_name = "glBeginConditionalRenderNV";
    if (!_glBeginConditionalRenderNV_ptr) {
        _glBeginConditionalRenderNV_ptr = (PFN_GLBEGINCONDITIONALRENDERNV)_getPrivateProcAddress(_name);
        if (!_glBeginConditionalRenderNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginConditionalRenderNV_ptr(id, mode);
}

typedef void (APIENTRY * PFN_GLENDCONDITIONALRENDERNV)(void);
static PFN_GLENDCONDITIONALRENDERNV _glEndConditionalRenderNV_ptr = NULL;

static inline void APIENTRY _glEndConditionalRenderNV(void) {
    const char *_name = "glEndConditionalRenderNV";
    if (!_glEndConditionalRenderNV_ptr) {
        _glEndConditionalRenderNV_ptr = (PFN_GLENDCONDITIONALRENDERNV)_getPrivateProcAddress(_name);
        if (!_glEndConditionalRenderNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndConditionalRenderNV_ptr();
}

typedef void (APIENTRY * PFN_GLPRESENTFRAMEKEYEDNV)(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);
static PFN_GLPRESENTFRAMEKEYEDNV _glPresentFrameKeyedNV_ptr = NULL;

static inline void APIENTRY _glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1) {
    const char *_name = "glPresentFrameKeyedNV";
    if (!_glPresentFrameKeyedNV_ptr) {
        _glPresentFrameKeyedNV_ptr = (PFN_GLPRESENTFRAMEKEYEDNV)_getPrivateProcAddress(_name);
        if (!_glPresentFrameKeyedNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPresentFrameKeyedNV_ptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
}

typedef void (APIENTRY * PFN_GLPRESENTFRAMEDUALFILLNV)(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
static PFN_GLPRESENTFRAMEDUALFILLNV _glPresentFrameDualFillNV_ptr = NULL;

static inline void APIENTRY _glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3) {
    const char *_name = "glPresentFrameDualFillNV";
    if (!_glPresentFrameDualFillNV_ptr) {
        _glPresentFrameDualFillNV_ptr = (PFN_GLPRESENTFRAMEDUALFILLNV)_getPrivateProcAddress(_name);
        if (!_glPresentFrameDualFillNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPresentFrameDualFillNV_ptr(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
}

typedef void (APIENTRY * PFN_GLGETVIDEOIVNV)(GLuint video_slot, GLenum pname, GLint * params);
static PFN_GLGETVIDEOIVNV _glGetVideoivNV_ptr = NULL;

static inline void APIENTRY _glGetVideoivNV(GLuint video_slot, GLenum pname, GLint * params) {
    const char *_name = "glGetVideoivNV";
    if (!_glGetVideoivNV_ptr) {
        _glGetVideoivNV_ptr = (PFN_GLGETVIDEOIVNV)_getPrivateProcAddress(_name);
        if (!_glGetVideoivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVideoivNV_ptr(video_slot, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVIDEOUIVNV)(GLuint video_slot, GLenum pname, GLuint * params);
static PFN_GLGETVIDEOUIVNV _glGetVideouivNV_ptr = NULL;

static inline void APIENTRY _glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint * params) {
    const char *_name = "glGetVideouivNV";
    if (!_glGetVideouivNV_ptr) {
        _glGetVideouivNV_ptr = (PFN_GLGETVIDEOUIVNV)_getPrivateProcAddress(_name);
        if (!_glGetVideouivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVideouivNV_ptr(video_slot, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVIDEOI64VNV)(GLuint video_slot, GLenum pname, GLint64EXT * params);
static PFN_GLGETVIDEOI64VNV _glGetVideoi64vNV_ptr = NULL;

static inline void APIENTRY _glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT * params) {
    const char *_name = "glGetVideoi64vNV";
    if (!_glGetVideoi64vNV_ptr) {
        _glGetVideoi64vNV_ptr = (PFN_GLGETVIDEOI64VNV)_getPrivateProcAddress(_name);
        if (!_glGetVideoi64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVideoi64vNV_ptr(video_slot, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVIDEOUI64VNV)(GLuint video_slot, GLenum pname, GLuint64EXT * params);
static PFN_GLGETVIDEOUI64VNV _glGetVideoui64vNV_ptr = NULL;

static inline void APIENTRY _glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT * params) {
    const char *_name = "glGetVideoui64vNV";
    if (!_glGetVideoui64vNV_ptr) {
        _glGetVideoui64vNV_ptr = (PFN_GLGETVIDEOUI64VNV)_getPrivateProcAddress(_name);
        if (!_glGetVideoui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVideoui64vNV_ptr(video_slot, pname, params);
}

typedef void (APIENTRY * PFN_GLBEGINTRANSFORMFEEDBACKEXT)(GLenum primitiveMode);
static PFN_GLBEGINTRANSFORMFEEDBACKEXT _glBeginTransformFeedbackEXT_ptr = NULL;

static inline void APIENTRY _glBeginTransformFeedbackEXT(GLenum primitiveMode) {
    const char *_name = "glBeginTransformFeedbackEXT";
    if (!_glBeginTransformFeedbackEXT_ptr) {
        _glBeginTransformFeedbackEXT_ptr = (PFN_GLBEGINTRANSFORMFEEDBACKEXT)_getPrivateProcAddress(_name);
        if (!_glBeginTransformFeedbackEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginTransformFeedbackEXT_ptr(primitiveMode);
}

typedef void (APIENTRY * PFN_GLENDTRANSFORMFEEDBACKEXT)(void);
static PFN_GLENDTRANSFORMFEEDBACKEXT _glEndTransformFeedbackEXT_ptr = NULL;

static inline void APIENTRY _glEndTransformFeedbackEXT(void) {
    const char *_name = "glEndTransformFeedbackEXT";
    if (!_glEndTransformFeedbackEXT_ptr) {
        _glEndTransformFeedbackEXT_ptr = (PFN_GLENDTRANSFORMFEEDBACKEXT)_getPrivateProcAddress(_name);
        if (!_glEndTransformFeedbackEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndTransformFeedbackEXT_ptr();
}

typedef void (APIENTRY * PFN_GLBINDBUFFERRANGEEXT)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
static PFN_GLBINDBUFFERRANGEEXT _glBindBufferRangeEXT_ptr = NULL;

static inline void APIENTRY _glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glBindBufferRangeEXT";
    if (!_glBindBufferRangeEXT_ptr) {
        _glBindBufferRangeEXT_ptr = (PFN_GLBINDBUFFERRANGEEXT)_getPrivateProcAddress(_name);
        if (!_glBindBufferRangeEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindBufferRangeEXT_ptr(target, index, buffer, offset, size);
}

typedef void (APIENTRY * PFN_GLBINDBUFFEROFFSETEXT)(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
static PFN_GLBINDBUFFEROFFSETEXT _glBindBufferOffsetEXT_ptr = NULL;

static inline void APIENTRY _glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset) {
    const char *_name = "glBindBufferOffsetEXT";
    if (!_glBindBufferOffsetEXT_ptr) {
        _glBindBufferOffsetEXT_ptr = (PFN_GLBINDBUFFEROFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glBindBufferOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindBufferOffsetEXT_ptr(target, index, buffer, offset);
}

typedef void (APIENTRY * PFN_GLBINDBUFFERBASEEXT)(GLenum target, GLuint index, GLuint buffer);
static PFN_GLBINDBUFFERBASEEXT _glBindBufferBaseEXT_ptr = NULL;

static inline void APIENTRY _glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer) {
    const char *_name = "glBindBufferBaseEXT";
    if (!_glBindBufferBaseEXT_ptr) {
        _glBindBufferBaseEXT_ptr = (PFN_GLBINDBUFFERBASEEXT)_getPrivateProcAddress(_name);
        if (!_glBindBufferBaseEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindBufferBaseEXT_ptr(target, index, buffer);
}

typedef void (APIENTRY * PFN_GLTRANSFORMFEEDBACKVARYINGSEXT)(GLuint program, GLsizei count, const GLchar * * const varyings, GLenum bufferMode);
static PFN_GLTRANSFORMFEEDBACKVARYINGSEXT _glTransformFeedbackVaryingsEXT_ptr = NULL;

static inline void APIENTRY _glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar * * const varyings, GLenum bufferMode) {
    const char *_name = "glTransformFeedbackVaryingsEXT";
    if (!_glTransformFeedbackVaryingsEXT_ptr) {
        _glTransformFeedbackVaryingsEXT_ptr = (PFN_GLTRANSFORMFEEDBACKVARYINGSEXT)_getPrivateProcAddress(_name);
        if (!_glTransformFeedbackVaryingsEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTransformFeedbackVaryingsEXT_ptr(program, count, varyings, bufferMode);
}

typedef void (APIENTRY * PFN_GLGETTRANSFORMFEEDBACKVARYINGEXT)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
static PFN_GLGETTRANSFORMFEEDBACKVARYINGEXT _glGetTransformFeedbackVaryingEXT_ptr = NULL;

static inline void APIENTRY _glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name) {
    const char *_name = "glGetTransformFeedbackVaryingEXT";
    if (!_glGetTransformFeedbackVaryingEXT_ptr) {
        _glGetTransformFeedbackVaryingEXT_ptr = (PFN_GLGETTRANSFORMFEEDBACKVARYINGEXT)_getPrivateProcAddress(_name);
        if (!_glGetTransformFeedbackVaryingEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTransformFeedbackVaryingEXT_ptr(program, index, bufSize, length, size, type, name);
}

typedef void (APIENTRY * PFN_GLCLIENTATTRIBDEFAULTEXT)(GLbitfield mask);
static PFN_GLCLIENTATTRIBDEFAULTEXT _glClientAttribDefaultEXT_ptr = NULL;

static inline void APIENTRY _glClientAttribDefaultEXT(GLbitfield mask) {
    const char *_name = "glClientAttribDefaultEXT";
    if (!_glClientAttribDefaultEXT_ptr) {
        _glClientAttribDefaultEXT_ptr = (PFN_GLCLIENTATTRIBDEFAULTEXT)_getPrivateProcAddress(_name);
        if (!_glClientAttribDefaultEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClientAttribDefaultEXT_ptr(mask);
}

typedef void (APIENTRY * PFN_GLPUSHCLIENTATTRIBDEFAULTEXT)(GLbitfield mask);
static PFN_GLPUSHCLIENTATTRIBDEFAULTEXT _glPushClientAttribDefaultEXT_ptr = NULL;

static inline void APIENTRY _glPushClientAttribDefaultEXT(GLbitfield mask) {
    const char *_name = "glPushClientAttribDefaultEXT";
    if (!_glPushClientAttribDefaultEXT_ptr) {
        _glPushClientAttribDefaultEXT_ptr = (PFN_GLPUSHCLIENTATTRIBDEFAULTEXT)_getPrivateProcAddress(_name);
        if (!_glPushClientAttribDefaultEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPushClientAttribDefaultEXT_ptr(mask);
}

typedef void (APIENTRY * PFN_GLMATRIXLOADFEXT)(GLenum mode, const GLfloat * m);
static PFN_GLMATRIXLOADFEXT _glMatrixLoadfEXT_ptr = NULL;

static inline void APIENTRY _glMatrixLoadfEXT(GLenum mode, const GLfloat * m) {
    const char *_name = "glMatrixLoadfEXT";
    if (!_glMatrixLoadfEXT_ptr) {
        _glMatrixLoadfEXT_ptr = (PFN_GLMATRIXLOADFEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixLoadfEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixLoadfEXT_ptr(mode, m);
}

typedef void (APIENTRY * PFN_GLMATRIXLOADDEXT)(GLenum mode, const GLdouble * m);
static PFN_GLMATRIXLOADDEXT _glMatrixLoaddEXT_ptr = NULL;

static inline void APIENTRY _glMatrixLoaddEXT(GLenum mode, const GLdouble * m) {
    const char *_name = "glMatrixLoaddEXT";
    if (!_glMatrixLoaddEXT_ptr) {
        _glMatrixLoaddEXT_ptr = (PFN_GLMATRIXLOADDEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixLoaddEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixLoaddEXT_ptr(mode, m);
}

typedef void (APIENTRY * PFN_GLMATRIXMULTFEXT)(GLenum mode, const GLfloat * m);
static PFN_GLMATRIXMULTFEXT _glMatrixMultfEXT_ptr = NULL;

static inline void APIENTRY _glMatrixMultfEXT(GLenum mode, const GLfloat * m) {
    const char *_name = "glMatrixMultfEXT";
    if (!_glMatrixMultfEXT_ptr) {
        _glMatrixMultfEXT_ptr = (PFN_GLMATRIXMULTFEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixMultfEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixMultfEXT_ptr(mode, m);
}

typedef void (APIENTRY * PFN_GLMATRIXMULTDEXT)(GLenum mode, const GLdouble * m);
static PFN_GLMATRIXMULTDEXT _glMatrixMultdEXT_ptr = NULL;

static inline void APIENTRY _glMatrixMultdEXT(GLenum mode, const GLdouble * m) {
    const char *_name = "glMatrixMultdEXT";
    if (!_glMatrixMultdEXT_ptr) {
        _glMatrixMultdEXT_ptr = (PFN_GLMATRIXMULTDEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixMultdEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixMultdEXT_ptr(mode, m);
}

typedef void (APIENTRY * PFN_GLMATRIXLOADIDENTITYEXT)(GLenum mode);
static PFN_GLMATRIXLOADIDENTITYEXT _glMatrixLoadIdentityEXT_ptr = NULL;

static inline void APIENTRY _glMatrixLoadIdentityEXT(GLenum mode) {
    const char *_name = "glMatrixLoadIdentityEXT";
    if (!_glMatrixLoadIdentityEXT_ptr) {
        _glMatrixLoadIdentityEXT_ptr = (PFN_GLMATRIXLOADIDENTITYEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixLoadIdentityEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixLoadIdentityEXT_ptr(mode);
}

typedef void (APIENTRY * PFN_GLMATRIXROTATEFEXT)(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLMATRIXROTATEFEXT _glMatrixRotatefEXT_ptr = NULL;

static inline void APIENTRY _glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glMatrixRotatefEXT";
    if (!_glMatrixRotatefEXT_ptr) {
        _glMatrixRotatefEXT_ptr = (PFN_GLMATRIXROTATEFEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixRotatefEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixRotatefEXT_ptr(mode, angle, x, y, z);
}

typedef void (APIENTRY * PFN_GLMATRIXROTATEDEXT)(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
static PFN_GLMATRIXROTATEDEXT _glMatrixRotatedEXT_ptr = NULL;

static inline void APIENTRY _glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glMatrixRotatedEXT";
    if (!_glMatrixRotatedEXT_ptr) {
        _glMatrixRotatedEXT_ptr = (PFN_GLMATRIXROTATEDEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixRotatedEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixRotatedEXT_ptr(mode, angle, x, y, z);
}

typedef void (APIENTRY * PFN_GLMATRIXSCALEFEXT)(GLenum mode, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLMATRIXSCALEFEXT _glMatrixScalefEXT_ptr = NULL;

static inline void APIENTRY _glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glMatrixScalefEXT";
    if (!_glMatrixScalefEXT_ptr) {
        _glMatrixScalefEXT_ptr = (PFN_GLMATRIXSCALEFEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixScalefEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixScalefEXT_ptr(mode, x, y, z);
}

typedef void (APIENTRY * PFN_GLMATRIXSCALEDEXT)(GLenum mode, GLdouble x, GLdouble y, GLdouble z);
static PFN_GLMATRIXSCALEDEXT _glMatrixScaledEXT_ptr = NULL;

static inline void APIENTRY _glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glMatrixScaledEXT";
    if (!_glMatrixScaledEXT_ptr) {
        _glMatrixScaledEXT_ptr = (PFN_GLMATRIXSCALEDEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixScaledEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixScaledEXT_ptr(mode, x, y, z);
}

typedef void (APIENTRY * PFN_GLMATRIXTRANSLATEFEXT)(GLenum mode, GLfloat x, GLfloat y, GLfloat z);
static PFN_GLMATRIXTRANSLATEFEXT _glMatrixTranslatefEXT_ptr = NULL;

static inline void APIENTRY _glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glMatrixTranslatefEXT";
    if (!_glMatrixTranslatefEXT_ptr) {
        _glMatrixTranslatefEXT_ptr = (PFN_GLMATRIXTRANSLATEFEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixTranslatefEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixTranslatefEXT_ptr(mode, x, y, z);
}

typedef void (APIENTRY * PFN_GLMATRIXTRANSLATEDEXT)(GLenum mode, GLdouble x, GLdouble y, GLdouble z);
static PFN_GLMATRIXTRANSLATEDEXT _glMatrixTranslatedEXT_ptr = NULL;

static inline void APIENTRY _glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glMatrixTranslatedEXT";
    if (!_glMatrixTranslatedEXT_ptr) {
        _glMatrixTranslatedEXT_ptr = (PFN_GLMATRIXTRANSLATEDEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixTranslatedEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixTranslatedEXT_ptr(mode, x, y, z);
}

typedef void (APIENTRY * PFN_GLMATRIXFRUSTUMEXT)(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
static PFN_GLMATRIXFRUSTUMEXT _glMatrixFrustumEXT_ptr = NULL;

static inline void APIENTRY _glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    const char *_name = "glMatrixFrustumEXT";
    if (!_glMatrixFrustumEXT_ptr) {
        _glMatrixFrustumEXT_ptr = (PFN_GLMATRIXFRUSTUMEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixFrustumEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixFrustumEXT_ptr(mode, left, right, bottom, top, zNear, zFar);
}

typedef void (APIENTRY * PFN_GLMATRIXORTHOEXT)(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
static PFN_GLMATRIXORTHOEXT _glMatrixOrthoEXT_ptr = NULL;

static inline void APIENTRY _glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    const char *_name = "glMatrixOrthoEXT";
    if (!_glMatrixOrthoEXT_ptr) {
        _glMatrixOrthoEXT_ptr = (PFN_GLMATRIXORTHOEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixOrthoEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixOrthoEXT_ptr(mode, left, right, bottom, top, zNear, zFar);
}

typedef void (APIENTRY * PFN_GLMATRIXPOPEXT)(GLenum mode);
static PFN_GLMATRIXPOPEXT _glMatrixPopEXT_ptr = NULL;

static inline void APIENTRY _glMatrixPopEXT(GLenum mode) {
    const char *_name = "glMatrixPopEXT";
    if (!_glMatrixPopEXT_ptr) {
        _glMatrixPopEXT_ptr = (PFN_GLMATRIXPOPEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixPopEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixPopEXT_ptr(mode);
}

typedef void (APIENTRY * PFN_GLMATRIXPUSHEXT)(GLenum mode);
static PFN_GLMATRIXPUSHEXT _glMatrixPushEXT_ptr = NULL;

static inline void APIENTRY _glMatrixPushEXT(GLenum mode) {
    const char *_name = "glMatrixPushEXT";
    if (!_glMatrixPushEXT_ptr) {
        _glMatrixPushEXT_ptr = (PFN_GLMATRIXPUSHEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixPushEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixPushEXT_ptr(mode);
}

typedef void (APIENTRY * PFN_GLMATRIXLOADTRANSPOSEFEXT)(GLenum mode, const GLfloat * m);
static PFN_GLMATRIXLOADTRANSPOSEFEXT _glMatrixLoadTransposefEXT_ptr = NULL;

static inline void APIENTRY _glMatrixLoadTransposefEXT(GLenum mode, const GLfloat * m) {
    const char *_name = "glMatrixLoadTransposefEXT";
    if (!_glMatrixLoadTransposefEXT_ptr) {
        _glMatrixLoadTransposefEXT_ptr = (PFN_GLMATRIXLOADTRANSPOSEFEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixLoadTransposefEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixLoadTransposefEXT_ptr(mode, m);
}

typedef void (APIENTRY * PFN_GLMATRIXLOADTRANSPOSEDEXT)(GLenum mode, const GLdouble * m);
static PFN_GLMATRIXLOADTRANSPOSEDEXT _glMatrixLoadTransposedEXT_ptr = NULL;

static inline void APIENTRY _glMatrixLoadTransposedEXT(GLenum mode, const GLdouble * m) {
    const char *_name = "glMatrixLoadTransposedEXT";
    if (!_glMatrixLoadTransposedEXT_ptr) {
        _glMatrixLoadTransposedEXT_ptr = (PFN_GLMATRIXLOADTRANSPOSEDEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixLoadTransposedEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixLoadTransposedEXT_ptr(mode, m);
}

typedef void (APIENTRY * PFN_GLMATRIXMULTTRANSPOSEFEXT)(GLenum mode, const GLfloat * m);
static PFN_GLMATRIXMULTTRANSPOSEFEXT _glMatrixMultTransposefEXT_ptr = NULL;

static inline void APIENTRY _glMatrixMultTransposefEXT(GLenum mode, const GLfloat * m) {
    const char *_name = "glMatrixMultTransposefEXT";
    if (!_glMatrixMultTransposefEXT_ptr) {
        _glMatrixMultTransposefEXT_ptr = (PFN_GLMATRIXMULTTRANSPOSEFEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixMultTransposefEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixMultTransposefEXT_ptr(mode, m);
}

typedef void (APIENTRY * PFN_GLMATRIXMULTTRANSPOSEDEXT)(GLenum mode, const GLdouble * m);
static PFN_GLMATRIXMULTTRANSPOSEDEXT _glMatrixMultTransposedEXT_ptr = NULL;

static inline void APIENTRY _glMatrixMultTransposedEXT(GLenum mode, const GLdouble * m) {
    const char *_name = "glMatrixMultTransposedEXT";
    if (!_glMatrixMultTransposedEXT_ptr) {
        _glMatrixMultTransposedEXT_ptr = (PFN_GLMATRIXMULTTRANSPOSEDEXT)_getPrivateProcAddress(_name);
        if (!_glMatrixMultTransposedEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixMultTransposedEXT_ptr(mode, m);
}

typedef void (APIENTRY * PFN_GLTEXTUREPARAMETERFEXT)(GLuint texture, GLenum target, GLenum pname, GLfloat param);
static PFN_GLTEXTUREPARAMETERFEXT _glTextureParameterfEXT_ptr = NULL;

static inline void APIENTRY _glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glTextureParameterfEXT";
    if (!_glTextureParameterfEXT_ptr) {
        _glTextureParameterfEXT_ptr = (PFN_GLTEXTUREPARAMETERFEXT)_getPrivateProcAddress(_name);
        if (!_glTextureParameterfEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureParameterfEXT_ptr(texture, target, pname, param);
}

typedef void (APIENTRY * PFN_GLTEXTUREPARAMETERFVEXT)(GLuint texture, GLenum target, GLenum pname, const GLfloat * params);
static PFN_GLTEXTUREPARAMETERFVEXT _glTextureParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glTextureParameterfvEXT";
    if (!_glTextureParameterfvEXT_ptr) {
        _glTextureParameterfvEXT_ptr = (PFN_GLTEXTUREPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glTextureParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureParameterfvEXT_ptr(texture, target, pname, params);
}

typedef void (APIENTRY * PFN_GLTEXTUREPARAMETERIEXT)(GLuint texture, GLenum target, GLenum pname, GLint param);
static PFN_GLTEXTUREPARAMETERIEXT _glTextureParameteriEXT_ptr = NULL;

static inline void APIENTRY _glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param) {
    const char *_name = "glTextureParameteriEXT";
    if (!_glTextureParameteriEXT_ptr) {
        _glTextureParameteriEXT_ptr = (PFN_GLTEXTUREPARAMETERIEXT)_getPrivateProcAddress(_name);
        if (!_glTextureParameteriEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureParameteriEXT_ptr(texture, target, pname, param);
}

typedef void (APIENTRY * PFN_GLTEXTUREPARAMETERIVEXT)(GLuint texture, GLenum target, GLenum pname, const GLint * params);
static PFN_GLTEXTUREPARAMETERIVEXT _glTextureParameterivEXT_ptr = NULL;

static inline void APIENTRY _glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glTextureParameterivEXT";
    if (!_glTextureParameterivEXT_ptr) {
        _glTextureParameterivEXT_ptr = (PFN_GLTEXTUREPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glTextureParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureParameterivEXT_ptr(texture, target, pname, params);
}

typedef void (APIENTRY * PFN_GLTEXTUREIMAGE1DEXT)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXTUREIMAGE1DEXT _glTextureImage1DEXT_ptr = NULL;

static inline void APIENTRY _glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTextureImage1DEXT";
    if (!_glTextureImage1DEXT_ptr) {
        _glTextureImage1DEXT_ptr = (PFN_GLTEXTUREIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glTextureImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureImage1DEXT_ptr(texture, target, level, internalformat, width, border, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLTEXTUREIMAGE2DEXT)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXTUREIMAGE2DEXT _glTextureImage2DEXT_ptr = NULL;

static inline void APIENTRY _glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTextureImage2DEXT";
    if (!_glTextureImage2DEXT_ptr) {
        _glTextureImage2DEXT_ptr = (PFN_GLTEXTUREIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glTextureImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureImage2DEXT_ptr(texture, target, level, internalformat, width, height, border, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLTEXTURESUBIMAGE1DEXT)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXTURESUBIMAGE1DEXT _glTextureSubImage1DEXT_ptr = NULL;

static inline void APIENTRY _glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTextureSubImage1DEXT";
    if (!_glTextureSubImage1DEXT_ptr) {
        _glTextureSubImage1DEXT_ptr = (PFN_GLTEXTURESUBIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glTextureSubImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureSubImage1DEXT_ptr(texture, target, level, xoffset, width, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLTEXTURESUBIMAGE2DEXT)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXTURESUBIMAGE2DEXT _glTextureSubImage2DEXT_ptr = NULL;

static inline void APIENTRY _glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTextureSubImage2DEXT";
    if (!_glTextureSubImage2DEXT_ptr) {
        _glTextureSubImage2DEXT_ptr = (PFN_GLTEXTURESUBIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glTextureSubImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureSubImage2DEXT_ptr(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLCOPYTEXTUREIMAGE1DEXT)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
static PFN_GLCOPYTEXTUREIMAGE1DEXT _glCopyTextureImage1DEXT_ptr = NULL;

static inline void APIENTRY _glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    const char *_name = "glCopyTextureImage1DEXT";
    if (!_glCopyTextureImage1DEXT_ptr) {
        _glCopyTextureImage1DEXT_ptr = (PFN_GLCOPYTEXTUREIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyTextureImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTextureImage1DEXT_ptr(texture, target, level, internalformat, x, y, width, border);
}

typedef void (APIENTRY * PFN_GLCOPYTEXTUREIMAGE2DEXT)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
static PFN_GLCOPYTEXTUREIMAGE2DEXT _glCopyTextureImage2DEXT_ptr = NULL;

static inline void APIENTRY _glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    const char *_name = "glCopyTextureImage2DEXT";
    if (!_glCopyTextureImage2DEXT_ptr) {
        _glCopyTextureImage2DEXT_ptr = (PFN_GLCOPYTEXTUREIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyTextureImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTextureImage2DEXT_ptr(texture, target, level, internalformat, x, y, width, height, border);
}

typedef void (APIENTRY * PFN_GLCOPYTEXTURESUBIMAGE1DEXT)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
static PFN_GLCOPYTEXTURESUBIMAGE1DEXT _glCopyTextureSubImage1DEXT_ptr = NULL;

static inline void APIENTRY _glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyTextureSubImage1DEXT";
    if (!_glCopyTextureSubImage1DEXT_ptr) {
        _glCopyTextureSubImage1DEXT_ptr = (PFN_GLCOPYTEXTURESUBIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyTextureSubImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTextureSubImage1DEXT_ptr(texture, target, level, xoffset, x, y, width);
}

typedef void (APIENTRY * PFN_GLCOPYTEXTURESUBIMAGE2DEXT)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLCOPYTEXTURESUBIMAGE2DEXT _glCopyTextureSubImage2DEXT_ptr = NULL;

static inline void APIENTRY _glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTextureSubImage2DEXT";
    if (!_glCopyTextureSubImage2DEXT_ptr) {
        _glCopyTextureSubImage2DEXT_ptr = (PFN_GLCOPYTEXTURESUBIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyTextureSubImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTextureSubImage2DEXT_ptr(texture, target, level, xoffset, yoffset, x, y, width, height);
}

typedef void (APIENTRY * PFN_GLGETTEXTUREIMAGEEXT)(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels);
static PFN_GLGETTEXTUREIMAGEEXT _glGetTextureImageEXT_ptr = NULL;

static inline void APIENTRY _glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels) {
    const char *_name = "glGetTextureImageEXT";
    if (!_glGetTextureImageEXT_ptr) {
        _glGetTextureImageEXT_ptr = (PFN_GLGETTEXTUREIMAGEEXT)_getPrivateProcAddress(_name);
        if (!_glGetTextureImageEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTextureImageEXT_ptr(texture, target, level, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLGETTEXTUREPARAMETERFVEXT)(GLuint texture, GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETTEXTUREPARAMETERFVEXT _glGetTextureParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTextureParameterfvEXT";
    if (!_glGetTextureParameterfvEXT_ptr) {
        _glGetTextureParameterfvEXT_ptr = (PFN_GLGETTEXTUREPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glGetTextureParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTextureParameterfvEXT_ptr(texture, target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXTUREPARAMETERIVEXT)(GLuint texture, GLenum target, GLenum pname, GLint * params);
static PFN_GLGETTEXTUREPARAMETERIVEXT _glGetTextureParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetTextureParameterivEXT";
    if (!_glGetTextureParameterivEXT_ptr) {
        _glGetTextureParameterivEXT_ptr = (PFN_GLGETTEXTUREPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetTextureParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTextureParameterivEXT_ptr(texture, target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXTURELEVELPARAMETERFVEXT)(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat * params);
static PFN_GLGETTEXTURELEVELPARAMETERFVEXT _glGetTextureLevelParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTextureLevelParameterfvEXT";
    if (!_glGetTextureLevelParameterfvEXT_ptr) {
        _glGetTextureLevelParameterfvEXT_ptr = (PFN_GLGETTEXTURELEVELPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glGetTextureLevelParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTextureLevelParameterfvEXT_ptr(texture, target, level, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXTURELEVELPARAMETERIVEXT)(GLuint texture, GLenum target, GLint level, GLenum pname, GLint * params);
static PFN_GLGETTEXTURELEVELPARAMETERIVEXT _glGetTextureLevelParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint * params) {
    const char *_name = "glGetTextureLevelParameterivEXT";
    if (!_glGetTextureLevelParameterivEXT_ptr) {
        _glGetTextureLevelParameterivEXT_ptr = (PFN_GLGETTEXTURELEVELPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetTextureLevelParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTextureLevelParameterivEXT_ptr(texture, target, level, pname, params);
}

typedef void (APIENTRY * PFN_GLTEXTUREIMAGE3DEXT)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXTUREIMAGE3DEXT _glTextureImage3DEXT_ptr = NULL;

static inline void APIENTRY _glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTextureImage3DEXT";
    if (!_glTextureImage3DEXT_ptr) {
        _glTextureImage3DEXT_ptr = (PFN_GLTEXTUREIMAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glTextureImage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureImage3DEXT_ptr(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLTEXTURESUBIMAGE3DEXT)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXTURESUBIMAGE3DEXT _glTextureSubImage3DEXT_ptr = NULL;

static inline void APIENTRY _glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTextureSubImage3DEXT";
    if (!_glTextureSubImage3DEXT_ptr) {
        _glTextureSubImage3DEXT_ptr = (PFN_GLTEXTURESUBIMAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glTextureSubImage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureSubImage3DEXT_ptr(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLCOPYTEXTURESUBIMAGE3DEXT)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLCOPYTEXTURESUBIMAGE3DEXT _glCopyTextureSubImage3DEXT_ptr = NULL;

static inline void APIENTRY _glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTextureSubImage3DEXT";
    if (!_glCopyTextureSubImage3DEXT_ptr) {
        _glCopyTextureSubImage3DEXT_ptr = (PFN_GLCOPYTEXTURESUBIMAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyTextureSubImage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTextureSubImage3DEXT_ptr(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

typedef void (APIENTRY * PFN_GLMULTITEXPARAMETERFEXT)(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
static PFN_GLMULTITEXPARAMETERFEXT _glMultiTexParameterfEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glMultiTexParameterfEXT";
    if (!_glMultiTexParameterfEXT_ptr) {
        _glMultiTexParameterfEXT_ptr = (PFN_GLMULTITEXPARAMETERFEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexParameterfEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexParameterfEXT_ptr(texunit, target, pname, param);
}

typedef void (APIENTRY * PFN_GLMULTITEXPARAMETERFVEXT)(GLenum texunit, GLenum target, GLenum pname, const GLfloat * params);
static PFN_GLMULTITEXPARAMETERFVEXT _glMultiTexParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glMultiTexParameterfvEXT";
    if (!_glMultiTexParameterfvEXT_ptr) {
        _glMultiTexParameterfvEXT_ptr = (PFN_GLMULTITEXPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexParameterfvEXT_ptr(texunit, target, pname, params);
}

typedef void (APIENTRY * PFN_GLMULTITEXPARAMETERIEXT)(GLenum texunit, GLenum target, GLenum pname, GLint param);
static PFN_GLMULTITEXPARAMETERIEXT _glMultiTexParameteriEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param) {
    const char *_name = "glMultiTexParameteriEXT";
    if (!_glMultiTexParameteriEXT_ptr) {
        _glMultiTexParameteriEXT_ptr = (PFN_GLMULTITEXPARAMETERIEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexParameteriEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexParameteriEXT_ptr(texunit, target, pname, param);
}

typedef void (APIENTRY * PFN_GLMULTITEXPARAMETERIVEXT)(GLenum texunit, GLenum target, GLenum pname, const GLint * params);
static PFN_GLMULTITEXPARAMETERIVEXT _glMultiTexParameterivEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glMultiTexParameterivEXT";
    if (!_glMultiTexParameterivEXT_ptr) {
        _glMultiTexParameterivEXT_ptr = (PFN_GLMULTITEXPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexParameterivEXT_ptr(texunit, target, pname, params);
}

typedef void (APIENTRY * PFN_GLMULTITEXIMAGE1DEXT)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLMULTITEXIMAGE1DEXT _glMultiTexImage1DEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glMultiTexImage1DEXT";
    if (!_glMultiTexImage1DEXT_ptr) {
        _glMultiTexImage1DEXT_ptr = (PFN_GLMULTITEXIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexImage1DEXT_ptr(texunit, target, level, internalformat, width, border, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLMULTITEXIMAGE2DEXT)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLMULTITEXIMAGE2DEXT _glMultiTexImage2DEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glMultiTexImage2DEXT";
    if (!_glMultiTexImage2DEXT_ptr) {
        _glMultiTexImage2DEXT_ptr = (PFN_GLMULTITEXIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexImage2DEXT_ptr(texunit, target, level, internalformat, width, height, border, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLMULTITEXSUBIMAGE1DEXT)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLMULTITEXSUBIMAGE1DEXT _glMultiTexSubImage1DEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glMultiTexSubImage1DEXT";
    if (!_glMultiTexSubImage1DEXT_ptr) {
        _glMultiTexSubImage1DEXT_ptr = (PFN_GLMULTITEXSUBIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexSubImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexSubImage1DEXT_ptr(texunit, target, level, xoffset, width, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLMULTITEXSUBIMAGE2DEXT)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLMULTITEXSUBIMAGE2DEXT _glMultiTexSubImage2DEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glMultiTexSubImage2DEXT";
    if (!_glMultiTexSubImage2DEXT_ptr) {
        _glMultiTexSubImage2DEXT_ptr = (PFN_GLMULTITEXSUBIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexSubImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexSubImage2DEXT_ptr(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLCOPYMULTITEXIMAGE1DEXT)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
static PFN_GLCOPYMULTITEXIMAGE1DEXT _glCopyMultiTexImage1DEXT_ptr = NULL;

static inline void APIENTRY _glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    const char *_name = "glCopyMultiTexImage1DEXT";
    if (!_glCopyMultiTexImage1DEXT_ptr) {
        _glCopyMultiTexImage1DEXT_ptr = (PFN_GLCOPYMULTITEXIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyMultiTexImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyMultiTexImage1DEXT_ptr(texunit, target, level, internalformat, x, y, width, border);
}

typedef void (APIENTRY * PFN_GLCOPYMULTITEXIMAGE2DEXT)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
static PFN_GLCOPYMULTITEXIMAGE2DEXT _glCopyMultiTexImage2DEXT_ptr = NULL;

static inline void APIENTRY _glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    const char *_name = "glCopyMultiTexImage2DEXT";
    if (!_glCopyMultiTexImage2DEXT_ptr) {
        _glCopyMultiTexImage2DEXT_ptr = (PFN_GLCOPYMULTITEXIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyMultiTexImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyMultiTexImage2DEXT_ptr(texunit, target, level, internalformat, x, y, width, height, border);
}

typedef void (APIENTRY * PFN_GLCOPYMULTITEXSUBIMAGE1DEXT)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
static PFN_GLCOPYMULTITEXSUBIMAGE1DEXT _glCopyMultiTexSubImage1DEXT_ptr = NULL;

static inline void APIENTRY _glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyMultiTexSubImage1DEXT";
    if (!_glCopyMultiTexSubImage1DEXT_ptr) {
        _glCopyMultiTexSubImage1DEXT_ptr = (PFN_GLCOPYMULTITEXSUBIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyMultiTexSubImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyMultiTexSubImage1DEXT_ptr(texunit, target, level, xoffset, x, y, width);
}

typedef void (APIENTRY * PFN_GLCOPYMULTITEXSUBIMAGE2DEXT)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLCOPYMULTITEXSUBIMAGE2DEXT _glCopyMultiTexSubImage2DEXT_ptr = NULL;

static inline void APIENTRY _glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyMultiTexSubImage2DEXT";
    if (!_glCopyMultiTexSubImage2DEXT_ptr) {
        _glCopyMultiTexSubImage2DEXT_ptr = (PFN_GLCOPYMULTITEXSUBIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyMultiTexSubImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyMultiTexSubImage2DEXT_ptr(texunit, target, level, xoffset, yoffset, x, y, width, height);
}

typedef void (APIENTRY * PFN_GLGETMULTITEXIMAGEEXT)(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels);
static PFN_GLGETMULTITEXIMAGEEXT _glGetMultiTexImageEXT_ptr = NULL;

static inline void APIENTRY _glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels) {
    const char *_name = "glGetMultiTexImageEXT";
    if (!_glGetMultiTexImageEXT_ptr) {
        _glGetMultiTexImageEXT_ptr = (PFN_GLGETMULTITEXIMAGEEXT)_getPrivateProcAddress(_name);
        if (!_glGetMultiTexImageEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultiTexImageEXT_ptr(texunit, target, level, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLGETMULTITEXPARAMETERFVEXT)(GLenum texunit, GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETMULTITEXPARAMETERFVEXT _glGetMultiTexParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMultiTexParameterfvEXT";
    if (!_glGetMultiTexParameterfvEXT_ptr) {
        _glGetMultiTexParameterfvEXT_ptr = (PFN_GLGETMULTITEXPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glGetMultiTexParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultiTexParameterfvEXT_ptr(texunit, target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMULTITEXPARAMETERIVEXT)(GLenum texunit, GLenum target, GLenum pname, GLint * params);
static PFN_GLGETMULTITEXPARAMETERIVEXT _glGetMultiTexParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetMultiTexParameterivEXT";
    if (!_glGetMultiTexParameterivEXT_ptr) {
        _glGetMultiTexParameterivEXT_ptr = (PFN_GLGETMULTITEXPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetMultiTexParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultiTexParameterivEXT_ptr(texunit, target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMULTITEXLEVELPARAMETERFVEXT)(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat * params);
static PFN_GLGETMULTITEXLEVELPARAMETERFVEXT _glGetMultiTexLevelParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMultiTexLevelParameterfvEXT";
    if (!_glGetMultiTexLevelParameterfvEXT_ptr) {
        _glGetMultiTexLevelParameterfvEXT_ptr = (PFN_GLGETMULTITEXLEVELPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glGetMultiTexLevelParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultiTexLevelParameterfvEXT_ptr(texunit, target, level, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMULTITEXLEVELPARAMETERIVEXT)(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint * params);
static PFN_GLGETMULTITEXLEVELPARAMETERIVEXT _glGetMultiTexLevelParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint * params) {
    const char *_name = "glGetMultiTexLevelParameterivEXT";
    if (!_glGetMultiTexLevelParameterivEXT_ptr) {
        _glGetMultiTexLevelParameterivEXT_ptr = (PFN_GLGETMULTITEXLEVELPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetMultiTexLevelParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultiTexLevelParameterivEXT_ptr(texunit, target, level, pname, params);
}

typedef void (APIENTRY * PFN_GLMULTITEXIMAGE3DEXT)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLMULTITEXIMAGE3DEXT _glMultiTexImage3DEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glMultiTexImage3DEXT";
    if (!_glMultiTexImage3DEXT_ptr) {
        _glMultiTexImage3DEXT_ptr = (PFN_GLMULTITEXIMAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexImage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexImage3DEXT_ptr(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLMULTITEXSUBIMAGE3DEXT)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLMULTITEXSUBIMAGE3DEXT _glMultiTexSubImage3DEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glMultiTexSubImage3DEXT";
    if (!_glMultiTexSubImage3DEXT_ptr) {
        _glMultiTexSubImage3DEXT_ptr = (PFN_GLMULTITEXSUBIMAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexSubImage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexSubImage3DEXT_ptr(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

typedef void (APIENTRY * PFN_GLCOPYMULTITEXSUBIMAGE3DEXT)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLCOPYMULTITEXSUBIMAGE3DEXT _glCopyMultiTexSubImage3DEXT_ptr = NULL;

static inline void APIENTRY _glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyMultiTexSubImage3DEXT";
    if (!_glCopyMultiTexSubImage3DEXT_ptr) {
        _glCopyMultiTexSubImage3DEXT_ptr = (PFN_GLCOPYMULTITEXSUBIMAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glCopyMultiTexSubImage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyMultiTexSubImage3DEXT_ptr(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

typedef void (APIENTRY * PFN_GLBINDMULTITEXTUREEXT)(GLenum texunit, GLenum target, GLuint texture);
static PFN_GLBINDMULTITEXTUREEXT _glBindMultiTextureEXT_ptr = NULL;

static inline void APIENTRY _glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture) {
    const char *_name = "glBindMultiTextureEXT";
    if (!_glBindMultiTextureEXT_ptr) {
        _glBindMultiTextureEXT_ptr = (PFN_GLBINDMULTITEXTUREEXT)_getPrivateProcAddress(_name);
        if (!_glBindMultiTextureEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindMultiTextureEXT_ptr(texunit, target, texture);
}

typedef void (APIENTRY * PFN_GLENABLECLIENTSTATEINDEXEDEXT)(GLenum array, GLuint index);
static PFN_GLENABLECLIENTSTATEINDEXEDEXT _glEnableClientStateIndexedEXT_ptr = NULL;

static inline void APIENTRY _glEnableClientStateIndexedEXT(GLenum array, GLuint index) {
    const char *_name = "glEnableClientStateIndexedEXT";
    if (!_glEnableClientStateIndexedEXT_ptr) {
        _glEnableClientStateIndexedEXT_ptr = (PFN_GLENABLECLIENTSTATEINDEXEDEXT)_getPrivateProcAddress(_name);
        if (!_glEnableClientStateIndexedEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEnableClientStateIndexedEXT_ptr(array, index);
}

typedef void (APIENTRY * PFN_GLDISABLECLIENTSTATEINDEXEDEXT)(GLenum array, GLuint index);
static PFN_GLDISABLECLIENTSTATEINDEXEDEXT _glDisableClientStateIndexedEXT_ptr = NULL;

static inline void APIENTRY _glDisableClientStateIndexedEXT(GLenum array, GLuint index) {
    const char *_name = "glDisableClientStateIndexedEXT";
    if (!_glDisableClientStateIndexedEXT_ptr) {
        _glDisableClientStateIndexedEXT_ptr = (PFN_GLDISABLECLIENTSTATEINDEXEDEXT)_getPrivateProcAddress(_name);
        if (!_glDisableClientStateIndexedEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDisableClientStateIndexedEXT_ptr(array, index);
}

typedef void (APIENTRY * PFN_GLMULTITEXCOORDPOINTEREXT)(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLMULTITEXCOORDPOINTEREXT _glMultiTexCoordPointerEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glMultiTexCoordPointerEXT";
    if (!_glMultiTexCoordPointerEXT_ptr) {
        _glMultiTexCoordPointerEXT_ptr = (PFN_GLMULTITEXCOORDPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoordPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoordPointerEXT_ptr(texunit, size, type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLMULTITEXENVFEXT)(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
static PFN_GLMULTITEXENVFEXT _glMultiTexEnvfEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glMultiTexEnvfEXT";
    if (!_glMultiTexEnvfEXT_ptr) {
        _glMultiTexEnvfEXT_ptr = (PFN_GLMULTITEXENVFEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexEnvfEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexEnvfEXT_ptr(texunit, target, pname, param);
}

typedef void (APIENTRY * PFN_GLMULTITEXENVFVEXT)(GLenum texunit, GLenum target, GLenum pname, const GLfloat * params);
static PFN_GLMULTITEXENVFVEXT _glMultiTexEnvfvEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glMultiTexEnvfvEXT";
    if (!_glMultiTexEnvfvEXT_ptr) {
        _glMultiTexEnvfvEXT_ptr = (PFN_GLMULTITEXENVFVEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexEnvfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexEnvfvEXT_ptr(texunit, target, pname, params);
}

typedef void (APIENTRY * PFN_GLMULTITEXENVIEXT)(GLenum texunit, GLenum target, GLenum pname, GLint param);
static PFN_GLMULTITEXENVIEXT _glMultiTexEnviEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param) {
    const char *_name = "glMultiTexEnviEXT";
    if (!_glMultiTexEnviEXT_ptr) {
        _glMultiTexEnviEXT_ptr = (PFN_GLMULTITEXENVIEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexEnviEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexEnviEXT_ptr(texunit, target, pname, param);
}

typedef void (APIENTRY * PFN_GLMULTITEXENVIVEXT)(GLenum texunit, GLenum target, GLenum pname, const GLint * params);
static PFN_GLMULTITEXENVIVEXT _glMultiTexEnvivEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glMultiTexEnvivEXT";
    if (!_glMultiTexEnvivEXT_ptr) {
        _glMultiTexEnvivEXT_ptr = (PFN_GLMULTITEXENVIVEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexEnvivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexEnvivEXT_ptr(texunit, target, pname, params);
}

typedef void (APIENTRY * PFN_GLMULTITEXGENDEXT)(GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
static PFN_GLMULTITEXGENDEXT _glMultiTexGendEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param) {
    const char *_name = "glMultiTexGendEXT";
    if (!_glMultiTexGendEXT_ptr) {
        _glMultiTexGendEXT_ptr = (PFN_GLMULTITEXGENDEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexGendEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexGendEXT_ptr(texunit, coord, pname, param);
}

typedef void (APIENTRY * PFN_GLMULTITEXGENDVEXT)(GLenum texunit, GLenum coord, GLenum pname, const GLdouble * params);
static PFN_GLMULTITEXGENDVEXT _glMultiTexGendvEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble * params) {
    const char *_name = "glMultiTexGendvEXT";
    if (!_glMultiTexGendvEXT_ptr) {
        _glMultiTexGendvEXT_ptr = (PFN_GLMULTITEXGENDVEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexGendvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexGendvEXT_ptr(texunit, coord, pname, params);
}

typedef void (APIENTRY * PFN_GLMULTITEXGENFEXT)(GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
static PFN_GLMULTITEXGENFEXT _glMultiTexGenfEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param) {
    const char *_name = "glMultiTexGenfEXT";
    if (!_glMultiTexGenfEXT_ptr) {
        _glMultiTexGenfEXT_ptr = (PFN_GLMULTITEXGENFEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexGenfEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexGenfEXT_ptr(texunit, coord, pname, param);
}

typedef void (APIENTRY * PFN_GLMULTITEXGENFVEXT)(GLenum texunit, GLenum coord, GLenum pname, const GLfloat * params);
static PFN_GLMULTITEXGENFVEXT _glMultiTexGenfvEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat * params) {
    const char *_name = "glMultiTexGenfvEXT";
    if (!_glMultiTexGenfvEXT_ptr) {
        _glMultiTexGenfvEXT_ptr = (PFN_GLMULTITEXGENFVEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexGenfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexGenfvEXT_ptr(texunit, coord, pname, params);
}

typedef void (APIENTRY * PFN_GLMULTITEXGENIEXT)(GLenum texunit, GLenum coord, GLenum pname, GLint param);
static PFN_GLMULTITEXGENIEXT _glMultiTexGeniEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param) {
    const char *_name = "glMultiTexGeniEXT";
    if (!_glMultiTexGeniEXT_ptr) {
        _glMultiTexGeniEXT_ptr = (PFN_GLMULTITEXGENIEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexGeniEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexGeniEXT_ptr(texunit, coord, pname, param);
}

typedef void (APIENTRY * PFN_GLMULTITEXGENIVEXT)(GLenum texunit, GLenum coord, GLenum pname, const GLint * params);
static PFN_GLMULTITEXGENIVEXT _glMultiTexGenivEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint * params) {
    const char *_name = "glMultiTexGenivEXT";
    if (!_glMultiTexGenivEXT_ptr) {
        _glMultiTexGenivEXT_ptr = (PFN_GLMULTITEXGENIVEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexGenivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexGenivEXT_ptr(texunit, coord, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMULTITEXENVFVEXT)(GLenum texunit, GLenum target, GLenum pname, GLfloat * params);
static PFN_GLGETMULTITEXENVFVEXT _glGetMultiTexEnvfvEXT_ptr = NULL;

static inline void APIENTRY _glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMultiTexEnvfvEXT";
    if (!_glGetMultiTexEnvfvEXT_ptr) {
        _glGetMultiTexEnvfvEXT_ptr = (PFN_GLGETMULTITEXENVFVEXT)_getPrivateProcAddress(_name);
        if (!_glGetMultiTexEnvfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultiTexEnvfvEXT_ptr(texunit, target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMULTITEXENVIVEXT)(GLenum texunit, GLenum target, GLenum pname, GLint * params);
static PFN_GLGETMULTITEXENVIVEXT _glGetMultiTexEnvivEXT_ptr = NULL;

static inline void APIENTRY _glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetMultiTexEnvivEXT";
    if (!_glGetMultiTexEnvivEXT_ptr) {
        _glGetMultiTexEnvivEXT_ptr = (PFN_GLGETMULTITEXENVIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetMultiTexEnvivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultiTexEnvivEXT_ptr(texunit, target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMULTITEXGENDVEXT)(GLenum texunit, GLenum coord, GLenum pname, GLdouble * params);
static PFN_GLGETMULTITEXGENDVEXT _glGetMultiTexGendvEXT_ptr = NULL;

static inline void APIENTRY _glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble * params) {
    const char *_name = "glGetMultiTexGendvEXT";
    if (!_glGetMultiTexGendvEXT_ptr) {
        _glGetMultiTexGendvEXT_ptr = (PFN_GLGETMULTITEXGENDVEXT)_getPrivateProcAddress(_name);
        if (!_glGetMultiTexGendvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultiTexGendvEXT_ptr(texunit, coord, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMULTITEXGENFVEXT)(GLenum texunit, GLenum coord, GLenum pname, GLfloat * params);
static PFN_GLGETMULTITEXGENFVEXT _glGetMultiTexGenfvEXT_ptr = NULL;

static inline void APIENTRY _glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMultiTexGenfvEXT";
    if (!_glGetMultiTexGenfvEXT_ptr) {
        _glGetMultiTexGenfvEXT_ptr = (PFN_GLGETMULTITEXGENFVEXT)_getPrivateProcAddress(_name);
        if (!_glGetMultiTexGenfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultiTexGenfvEXT_ptr(texunit, coord, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMULTITEXGENIVEXT)(GLenum texunit, GLenum coord, GLenum pname, GLint * params);
static PFN_GLGETMULTITEXGENIVEXT _glGetMultiTexGenivEXT_ptr = NULL;

static inline void APIENTRY _glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint * params) {
    const char *_name = "glGetMultiTexGenivEXT";
    if (!_glGetMultiTexGenivEXT_ptr) {
        _glGetMultiTexGenivEXT_ptr = (PFN_GLGETMULTITEXGENIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetMultiTexGenivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultiTexGenivEXT_ptr(texunit, coord, pname, params);
}

typedef void (APIENTRY * PFN_GLGETFLOATINDEXEDVEXT)(GLenum target, GLuint index, GLfloat * data);
static PFN_GLGETFLOATINDEXEDVEXT _glGetFloatIndexedvEXT_ptr = NULL;

static inline void APIENTRY _glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat * data) {
    const char *_name = "glGetFloatIndexedvEXT";
    if (!_glGetFloatIndexedvEXT_ptr) {
        _glGetFloatIndexedvEXT_ptr = (PFN_GLGETFLOATINDEXEDVEXT)_getPrivateProcAddress(_name);
        if (!_glGetFloatIndexedvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFloatIndexedvEXT_ptr(target, index, data);
}

typedef void (APIENTRY * PFN_GLGETDOUBLEINDEXEDVEXT)(GLenum target, GLuint index, GLdouble * data);
static PFN_GLGETDOUBLEINDEXEDVEXT _glGetDoubleIndexedvEXT_ptr = NULL;

static inline void APIENTRY _glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble * data) {
    const char *_name = "glGetDoubleIndexedvEXT";
    if (!_glGetDoubleIndexedvEXT_ptr) {
        _glGetDoubleIndexedvEXT_ptr = (PFN_GLGETDOUBLEINDEXEDVEXT)_getPrivateProcAddress(_name);
        if (!_glGetDoubleIndexedvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetDoubleIndexedvEXT_ptr(target, index, data);
}

typedef void (APIENTRY * PFN_GLGETPOINTERINDEXEDVEXT)(GLenum target, GLuint index, GLvoid * * data);
static PFN_GLGETPOINTERINDEXEDVEXT _glGetPointerIndexedvEXT_ptr = NULL;

static inline void APIENTRY _glGetPointerIndexedvEXT(GLenum target, GLuint index, GLvoid * * data) {
    const char *_name = "glGetPointerIndexedvEXT";
    if (!_glGetPointerIndexedvEXT_ptr) {
        _glGetPointerIndexedvEXT_ptr = (PFN_GLGETPOINTERINDEXEDVEXT)_getPrivateProcAddress(_name);
        if (!_glGetPointerIndexedvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPointerIndexedvEXT_ptr(target, index, data);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXTUREIMAGE3DEXT)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits);
static PFN_GLCOMPRESSEDTEXTUREIMAGE3DEXT _glCompressedTextureImage3DEXT_ptr = NULL;

static inline void APIENTRY _glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedTextureImage3DEXT";
    if (!_glCompressedTextureImage3DEXT_ptr) {
        _glCompressedTextureImage3DEXT_ptr = (PFN_GLCOMPRESSEDTEXTUREIMAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glCompressedTextureImage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTextureImage3DEXT_ptr(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXTUREIMAGE2DEXT)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits);
static PFN_GLCOMPRESSEDTEXTUREIMAGE2DEXT _glCompressedTextureImage2DEXT_ptr = NULL;

static inline void APIENTRY _glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedTextureImage2DEXT";
    if (!_glCompressedTextureImage2DEXT_ptr) {
        _glCompressedTextureImage2DEXT_ptr = (PFN_GLCOMPRESSEDTEXTUREIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glCompressedTextureImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTextureImage2DEXT_ptr(texture, target, level, internalformat, width, height, border, imageSize, bits);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXTUREIMAGE1DEXT)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits);
static PFN_GLCOMPRESSEDTEXTUREIMAGE1DEXT _glCompressedTextureImage1DEXT_ptr = NULL;

static inline void APIENTRY _glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedTextureImage1DEXT";
    if (!_glCompressedTextureImage1DEXT_ptr) {
        _glCompressedTextureImage1DEXT_ptr = (PFN_GLCOMPRESSEDTEXTUREIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glCompressedTextureImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTextureImage1DEXT_ptr(texture, target, level, internalformat, width, border, imageSize, bits);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXTURESUBIMAGE3DEXT)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits);
static PFN_GLCOMPRESSEDTEXTURESUBIMAGE3DEXT _glCompressedTextureSubImage3DEXT_ptr = NULL;

static inline void APIENTRY _glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedTextureSubImage3DEXT";
    if (!_glCompressedTextureSubImage3DEXT_ptr) {
        _glCompressedTextureSubImage3DEXT_ptr = (PFN_GLCOMPRESSEDTEXTURESUBIMAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glCompressedTextureSubImage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTextureSubImage3DEXT_ptr(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXTURESUBIMAGE2DEXT)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits);
static PFN_GLCOMPRESSEDTEXTURESUBIMAGE2DEXT _glCompressedTextureSubImage2DEXT_ptr = NULL;

static inline void APIENTRY _glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedTextureSubImage2DEXT";
    if (!_glCompressedTextureSubImage2DEXT_ptr) {
        _glCompressedTextureSubImage2DEXT_ptr = (PFN_GLCOMPRESSEDTEXTURESUBIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glCompressedTextureSubImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTextureSubImage2DEXT_ptr(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDTEXTURESUBIMAGE1DEXT)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits);
static PFN_GLCOMPRESSEDTEXTURESUBIMAGE1DEXT _glCompressedTextureSubImage1DEXT_ptr = NULL;

static inline void APIENTRY _glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedTextureSubImage1DEXT";
    if (!_glCompressedTextureSubImage1DEXT_ptr) {
        _glCompressedTextureSubImage1DEXT_ptr = (PFN_GLCOMPRESSEDTEXTURESUBIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glCompressedTextureSubImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTextureSubImage1DEXT_ptr(texture, target, level, xoffset, width, format, imageSize, bits);
}

typedef void (APIENTRY * PFN_GLGETCOMPRESSEDTEXTUREIMAGEEXT)(GLuint texture, GLenum target, GLint lod, GLvoid * img);
static PFN_GLGETCOMPRESSEDTEXTUREIMAGEEXT _glGetCompressedTextureImageEXT_ptr = NULL;

static inline void APIENTRY _glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, GLvoid * img) {
    const char *_name = "glGetCompressedTextureImageEXT";
    if (!_glGetCompressedTextureImageEXT_ptr) {
        _glGetCompressedTextureImageEXT_ptr = (PFN_GLGETCOMPRESSEDTEXTUREIMAGEEXT)_getPrivateProcAddress(_name);
        if (!_glGetCompressedTextureImageEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetCompressedTextureImageEXT_ptr(texture, target, lod, img);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDMULTITEXIMAGE3DEXT)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits);
static PFN_GLCOMPRESSEDMULTITEXIMAGE3DEXT _glCompressedMultiTexImage3DEXT_ptr = NULL;

static inline void APIENTRY _glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedMultiTexImage3DEXT";
    if (!_glCompressedMultiTexImage3DEXT_ptr) {
        _glCompressedMultiTexImage3DEXT_ptr = (PFN_GLCOMPRESSEDMULTITEXIMAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glCompressedMultiTexImage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedMultiTexImage3DEXT_ptr(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDMULTITEXIMAGE2DEXT)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits);
static PFN_GLCOMPRESSEDMULTITEXIMAGE2DEXT _glCompressedMultiTexImage2DEXT_ptr = NULL;

static inline void APIENTRY _glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedMultiTexImage2DEXT";
    if (!_glCompressedMultiTexImage2DEXT_ptr) {
        _glCompressedMultiTexImage2DEXT_ptr = (PFN_GLCOMPRESSEDMULTITEXIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glCompressedMultiTexImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedMultiTexImage2DEXT_ptr(texunit, target, level, internalformat, width, height, border, imageSize, bits);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDMULTITEXIMAGE1DEXT)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits);
static PFN_GLCOMPRESSEDMULTITEXIMAGE1DEXT _glCompressedMultiTexImage1DEXT_ptr = NULL;

static inline void APIENTRY _glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedMultiTexImage1DEXT";
    if (!_glCompressedMultiTexImage1DEXT_ptr) {
        _glCompressedMultiTexImage1DEXT_ptr = (PFN_GLCOMPRESSEDMULTITEXIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glCompressedMultiTexImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedMultiTexImage1DEXT_ptr(texunit, target, level, internalformat, width, border, imageSize, bits);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDMULTITEXSUBIMAGE3DEXT)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits);
static PFN_GLCOMPRESSEDMULTITEXSUBIMAGE3DEXT _glCompressedMultiTexSubImage3DEXT_ptr = NULL;

static inline void APIENTRY _glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedMultiTexSubImage3DEXT";
    if (!_glCompressedMultiTexSubImage3DEXT_ptr) {
        _glCompressedMultiTexSubImage3DEXT_ptr = (PFN_GLCOMPRESSEDMULTITEXSUBIMAGE3DEXT)_getPrivateProcAddress(_name);
        if (!_glCompressedMultiTexSubImage3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedMultiTexSubImage3DEXT_ptr(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDMULTITEXSUBIMAGE2DEXT)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits);
static PFN_GLCOMPRESSEDMULTITEXSUBIMAGE2DEXT _glCompressedMultiTexSubImage2DEXT_ptr = NULL;

static inline void APIENTRY _glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedMultiTexSubImage2DEXT";
    if (!_glCompressedMultiTexSubImage2DEXT_ptr) {
        _glCompressedMultiTexSubImage2DEXT_ptr = (PFN_GLCOMPRESSEDMULTITEXSUBIMAGE2DEXT)_getPrivateProcAddress(_name);
        if (!_glCompressedMultiTexSubImage2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedMultiTexSubImage2DEXT_ptr(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
}

typedef void (APIENTRY * PFN_GLCOMPRESSEDMULTITEXSUBIMAGE1DEXT)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits);
static PFN_GLCOMPRESSEDMULTITEXSUBIMAGE1DEXT _glCompressedMultiTexSubImage1DEXT_ptr = NULL;

static inline void APIENTRY _glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedMultiTexSubImage1DEXT";
    if (!_glCompressedMultiTexSubImage1DEXT_ptr) {
        _glCompressedMultiTexSubImage1DEXT_ptr = (PFN_GLCOMPRESSEDMULTITEXSUBIMAGE1DEXT)_getPrivateProcAddress(_name);
        if (!_glCompressedMultiTexSubImage1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedMultiTexSubImage1DEXT_ptr(texunit, target, level, xoffset, width, format, imageSize, bits);
}

typedef void (APIENTRY * PFN_GLGETCOMPRESSEDMULTITEXIMAGEEXT)(GLenum texunit, GLenum target, GLint lod, GLvoid * img);
static PFN_GLGETCOMPRESSEDMULTITEXIMAGEEXT _glGetCompressedMultiTexImageEXT_ptr = NULL;

static inline void APIENTRY _glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, GLvoid * img) {
    const char *_name = "glGetCompressedMultiTexImageEXT";
    if (!_glGetCompressedMultiTexImageEXT_ptr) {
        _glGetCompressedMultiTexImageEXT_ptr = (PFN_GLGETCOMPRESSEDMULTITEXIMAGEEXT)_getPrivateProcAddress(_name);
        if (!_glGetCompressedMultiTexImageEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetCompressedMultiTexImageEXT_ptr(texunit, target, lod, img);
}

typedef void (APIENTRY * PFN_GLNAMEDPROGRAMSTRINGEXT)(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid * string);
static PFN_GLNAMEDPROGRAMSTRINGEXT _glNamedProgramStringEXT_ptr = NULL;

static inline void APIENTRY _glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid * string) {
    const char *_name = "glNamedProgramStringEXT";
    if (!_glNamedProgramStringEXT_ptr) {
        _glNamedProgramStringEXT_ptr = (PFN_GLNAMEDPROGRAMSTRINGEXT)_getPrivateProcAddress(_name);
        if (!_glNamedProgramStringEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedProgramStringEXT_ptr(program, target, format, len, string);
}

typedef void (APIENTRY * PFN_GLNAMEDPROGRAMLOCALPARAMETER4DEXT)(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLNAMEDPROGRAMLOCALPARAMETER4DEXT _glNamedProgramLocalParameter4dEXT_ptr = NULL;

static inline void APIENTRY _glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glNamedProgramLocalParameter4dEXT";
    if (!_glNamedProgramLocalParameter4dEXT_ptr) {
        _glNamedProgramLocalParameter4dEXT_ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETER4DEXT)_getPrivateProcAddress(_name);
        if (!_glNamedProgramLocalParameter4dEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedProgramLocalParameter4dEXT_ptr(program, target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLNAMEDPROGRAMLOCALPARAMETER4DVEXT)(GLuint program, GLenum target, GLuint index, const GLdouble * params);
static PFN_GLNAMEDPROGRAMLOCALPARAMETER4DVEXT _glNamedProgramLocalParameter4dvEXT_ptr = NULL;

static inline void APIENTRY _glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble * params) {
    const char *_name = "glNamedProgramLocalParameter4dvEXT";
    if (!_glNamedProgramLocalParameter4dvEXT_ptr) {
        _glNamedProgramLocalParameter4dvEXT_ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETER4DVEXT)_getPrivateProcAddress(_name);
        if (!_glNamedProgramLocalParameter4dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedProgramLocalParameter4dvEXT_ptr(program, target, index, params);
}

typedef void (APIENTRY * PFN_GLNAMEDPROGRAMLOCALPARAMETER4FEXT)(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
static PFN_GLNAMEDPROGRAMLOCALPARAMETER4FEXT _glNamedProgramLocalParameter4fEXT_ptr = NULL;

static inline void APIENTRY _glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glNamedProgramLocalParameter4fEXT";
    if (!_glNamedProgramLocalParameter4fEXT_ptr) {
        _glNamedProgramLocalParameter4fEXT_ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETER4FEXT)_getPrivateProcAddress(_name);
        if (!_glNamedProgramLocalParameter4fEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedProgramLocalParameter4fEXT_ptr(program, target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLNAMEDPROGRAMLOCALPARAMETER4FVEXT)(GLuint program, GLenum target, GLuint index, const GLfloat * params);
static PFN_GLNAMEDPROGRAMLOCALPARAMETER4FVEXT _glNamedProgramLocalParameter4fvEXT_ptr = NULL;

static inline void APIENTRY _glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat * params) {
    const char *_name = "glNamedProgramLocalParameter4fvEXT";
    if (!_glNamedProgramLocalParameter4fvEXT_ptr) {
        _glNamedProgramLocalParameter4fvEXT_ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETER4FVEXT)_getPrivateProcAddress(_name);
        if (!_glNamedProgramLocalParameter4fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedProgramLocalParameter4fvEXT_ptr(program, target, index, params);
}

typedef void (APIENTRY * PFN_GLGETNAMEDPROGRAMLOCALPARAMETERDVEXT)(GLuint program, GLenum target, GLuint index, GLdouble * params);
static PFN_GLGETNAMEDPROGRAMLOCALPARAMETERDVEXT _glGetNamedProgramLocalParameterdvEXT_ptr = NULL;

static inline void APIENTRY _glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble * params) {
    const char *_name = "glGetNamedProgramLocalParameterdvEXT";
    if (!_glGetNamedProgramLocalParameterdvEXT_ptr) {
        _glGetNamedProgramLocalParameterdvEXT_ptr = (PFN_GLGETNAMEDPROGRAMLOCALPARAMETERDVEXT)_getPrivateProcAddress(_name);
        if (!_glGetNamedProgramLocalParameterdvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedProgramLocalParameterdvEXT_ptr(program, target, index, params);
}

typedef void (APIENTRY * PFN_GLGETNAMEDPROGRAMLOCALPARAMETERFVEXT)(GLuint program, GLenum target, GLuint index, GLfloat * params);
static PFN_GLGETNAMEDPROGRAMLOCALPARAMETERFVEXT _glGetNamedProgramLocalParameterfvEXT_ptr = NULL;

static inline void APIENTRY _glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat * params) {
    const char *_name = "glGetNamedProgramLocalParameterfvEXT";
    if (!_glGetNamedProgramLocalParameterfvEXT_ptr) {
        _glGetNamedProgramLocalParameterfvEXT_ptr = (PFN_GLGETNAMEDPROGRAMLOCALPARAMETERFVEXT)_getPrivateProcAddress(_name);
        if (!_glGetNamedProgramLocalParameterfvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedProgramLocalParameterfvEXT_ptr(program, target, index, params);
}

typedef void (APIENTRY * PFN_GLGETNAMEDPROGRAMIVEXT)(GLuint program, GLenum target, GLenum pname, GLint * params);
static PFN_GLGETNAMEDPROGRAMIVEXT _glGetNamedProgramivEXT_ptr = NULL;

static inline void APIENTRY _glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedProgramivEXT";
    if (!_glGetNamedProgramivEXT_ptr) {
        _glGetNamedProgramivEXT_ptr = (PFN_GLGETNAMEDPROGRAMIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetNamedProgramivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedProgramivEXT_ptr(program, target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETNAMEDPROGRAMSTRINGEXT)(GLuint program, GLenum target, GLenum pname, GLvoid * string);
static PFN_GLGETNAMEDPROGRAMSTRINGEXT _glGetNamedProgramStringEXT_ptr = NULL;

static inline void APIENTRY _glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, GLvoid * string) {
    const char *_name = "glGetNamedProgramStringEXT";
    if (!_glGetNamedProgramStringEXT_ptr) {
        _glGetNamedProgramStringEXT_ptr = (PFN_GLGETNAMEDPROGRAMSTRINGEXT)_getPrivateProcAddress(_name);
        if (!_glGetNamedProgramStringEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedProgramStringEXT_ptr(program, target, pname, string);
}

typedef void (APIENTRY * PFN_GLNAMEDPROGRAMLOCALPARAMETERS4FVEXT)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat * params);
static PFN_GLNAMEDPROGRAMLOCALPARAMETERS4FVEXT _glNamedProgramLocalParameters4fvEXT_ptr = NULL;

static inline void APIENTRY _glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat * params) {
    const char *_name = "glNamedProgramLocalParameters4fvEXT";
    if (!_glNamedProgramLocalParameters4fvEXT_ptr) {
        _glNamedProgramLocalParameters4fvEXT_ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERS4FVEXT)_getPrivateProcAddress(_name);
        if (!_glNamedProgramLocalParameters4fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedProgramLocalParameters4fvEXT_ptr(program, target, index, count, params);
}

typedef void (APIENTRY * PFN_GLNAMEDPROGRAMLOCALPARAMETERI4IEXT)(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
static PFN_GLNAMEDPROGRAMLOCALPARAMETERI4IEXT _glNamedProgramLocalParameterI4iEXT_ptr = NULL;

static inline void APIENTRY _glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glNamedProgramLocalParameterI4iEXT";
    if (!_glNamedProgramLocalParameterI4iEXT_ptr) {
        _glNamedProgramLocalParameterI4iEXT_ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERI4IEXT)_getPrivateProcAddress(_name);
        if (!_glNamedProgramLocalParameterI4iEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedProgramLocalParameterI4iEXT_ptr(program, target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLNAMEDPROGRAMLOCALPARAMETERI4IVEXT)(GLuint program, GLenum target, GLuint index, const GLint * params);
static PFN_GLNAMEDPROGRAMLOCALPARAMETERI4IVEXT _glNamedProgramLocalParameterI4ivEXT_ptr = NULL;

static inline void APIENTRY _glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint * params) {
    const char *_name = "glNamedProgramLocalParameterI4ivEXT";
    if (!_glNamedProgramLocalParameterI4ivEXT_ptr) {
        _glNamedProgramLocalParameterI4ivEXT_ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERI4IVEXT)_getPrivateProcAddress(_name);
        if (!_glNamedProgramLocalParameterI4ivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedProgramLocalParameterI4ivEXT_ptr(program, target, index, params);
}

typedef void (APIENTRY * PFN_GLNAMEDPROGRAMLOCALPARAMETERSI4IVEXT)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint * params);
static PFN_GLNAMEDPROGRAMLOCALPARAMETERSI4IVEXT _glNamedProgramLocalParametersI4ivEXT_ptr = NULL;

static inline void APIENTRY _glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint * params) {
    const char *_name = "glNamedProgramLocalParametersI4ivEXT";
    if (!_glNamedProgramLocalParametersI4ivEXT_ptr) {
        _glNamedProgramLocalParametersI4ivEXT_ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERSI4IVEXT)_getPrivateProcAddress(_name);
        if (!_glNamedProgramLocalParametersI4ivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedProgramLocalParametersI4ivEXT_ptr(program, target, index, count, params);
}

typedef void (APIENTRY * PFN_GLNAMEDPROGRAMLOCALPARAMETERI4UIEXT)(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
static PFN_GLNAMEDPROGRAMLOCALPARAMETERI4UIEXT _glNamedProgramLocalParameterI4uiEXT_ptr = NULL;

static inline void APIENTRY _glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    const char *_name = "glNamedProgramLocalParameterI4uiEXT";
    if (!_glNamedProgramLocalParameterI4uiEXT_ptr) {
        _glNamedProgramLocalParameterI4uiEXT_ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERI4UIEXT)_getPrivateProcAddress(_name);
        if (!_glNamedProgramLocalParameterI4uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedProgramLocalParameterI4uiEXT_ptr(program, target, index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLNAMEDPROGRAMLOCALPARAMETERI4UIVEXT)(GLuint program, GLenum target, GLuint index, const GLuint * params);
static PFN_GLNAMEDPROGRAMLOCALPARAMETERI4UIVEXT _glNamedProgramLocalParameterI4uivEXT_ptr = NULL;

static inline void APIENTRY _glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint * params) {
    const char *_name = "glNamedProgramLocalParameterI4uivEXT";
    if (!_glNamedProgramLocalParameterI4uivEXT_ptr) {
        _glNamedProgramLocalParameterI4uivEXT_ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERI4UIVEXT)_getPrivateProcAddress(_name);
        if (!_glNamedProgramLocalParameterI4uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedProgramLocalParameterI4uivEXT_ptr(program, target, index, params);
}

typedef void (APIENTRY * PFN_GLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXT)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint * params);
static PFN_GLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXT _glNamedProgramLocalParametersI4uivEXT_ptr = NULL;

static inline void APIENTRY _glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint * params) {
    const char *_name = "glNamedProgramLocalParametersI4uivEXT";
    if (!_glNamedProgramLocalParametersI4uivEXT_ptr) {
        _glNamedProgramLocalParametersI4uivEXT_ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXT)_getPrivateProcAddress(_name);
        if (!_glNamedProgramLocalParametersI4uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedProgramLocalParametersI4uivEXT_ptr(program, target, index, count, params);
}

typedef void (APIENTRY * PFN_GLGETNAMEDPROGRAMLOCALPARAMETERIIVEXT)(GLuint program, GLenum target, GLuint index, GLint * params);
static PFN_GLGETNAMEDPROGRAMLOCALPARAMETERIIVEXT _glGetNamedProgramLocalParameterIivEXT_ptr = NULL;

static inline void APIENTRY _glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint * params) {
    const char *_name = "glGetNamedProgramLocalParameterIivEXT";
    if (!_glGetNamedProgramLocalParameterIivEXT_ptr) {
        _glGetNamedProgramLocalParameterIivEXT_ptr = (PFN_GLGETNAMEDPROGRAMLOCALPARAMETERIIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetNamedProgramLocalParameterIivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedProgramLocalParameterIivEXT_ptr(program, target, index, params);
}

typedef void (APIENTRY * PFN_GLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXT)(GLuint program, GLenum target, GLuint index, GLuint * params);
static PFN_GLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXT _glGetNamedProgramLocalParameterIuivEXT_ptr = NULL;

static inline void APIENTRY _glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint * params) {
    const char *_name = "glGetNamedProgramLocalParameterIuivEXT";
    if (!_glGetNamedProgramLocalParameterIuivEXT_ptr) {
        _glGetNamedProgramLocalParameterIuivEXT_ptr = (PFN_GLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetNamedProgramLocalParameterIuivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedProgramLocalParameterIuivEXT_ptr(program, target, index, params);
}

typedef void (APIENTRY * PFN_GLTEXTUREPARAMETERIIVEXT)(GLuint texture, GLenum target, GLenum pname, const GLint * params);
static PFN_GLTEXTUREPARAMETERIIVEXT _glTextureParameterIivEXT_ptr = NULL;

static inline void APIENTRY _glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glTextureParameterIivEXT";
    if (!_glTextureParameterIivEXT_ptr) {
        _glTextureParameterIivEXT_ptr = (PFN_GLTEXTUREPARAMETERIIVEXT)_getPrivateProcAddress(_name);
        if (!_glTextureParameterIivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureParameterIivEXT_ptr(texture, target, pname, params);
}

typedef void (APIENTRY * PFN_GLTEXTUREPARAMETERIUIVEXT)(GLuint texture, GLenum target, GLenum pname, const GLuint * params);
static PFN_GLTEXTUREPARAMETERIUIVEXT _glTextureParameterIuivEXT_ptr = NULL;

static inline void APIENTRY _glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint * params) {
    const char *_name = "glTextureParameterIuivEXT";
    if (!_glTextureParameterIuivEXT_ptr) {
        _glTextureParameterIuivEXT_ptr = (PFN_GLTEXTUREPARAMETERIUIVEXT)_getPrivateProcAddress(_name);
        if (!_glTextureParameterIuivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureParameterIuivEXT_ptr(texture, target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXTUREPARAMETERIIVEXT)(GLuint texture, GLenum target, GLenum pname, GLint * params);
static PFN_GLGETTEXTUREPARAMETERIIVEXT _glGetTextureParameterIivEXT_ptr = NULL;

static inline void APIENTRY _glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetTextureParameterIivEXT";
    if (!_glGetTextureParameterIivEXT_ptr) {
        _glGetTextureParameterIivEXT_ptr = (PFN_GLGETTEXTUREPARAMETERIIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetTextureParameterIivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTextureParameterIivEXT_ptr(texture, target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETTEXTUREPARAMETERIUIVEXT)(GLuint texture, GLenum target, GLenum pname, GLuint * params);
static PFN_GLGETTEXTUREPARAMETERIUIVEXT _glGetTextureParameterIuivEXT_ptr = NULL;

static inline void APIENTRY _glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint * params) {
    const char *_name = "glGetTextureParameterIuivEXT";
    if (!_glGetTextureParameterIuivEXT_ptr) {
        _glGetTextureParameterIuivEXT_ptr = (PFN_GLGETTEXTUREPARAMETERIUIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetTextureParameterIuivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTextureParameterIuivEXT_ptr(texture, target, pname, params);
}

typedef void (APIENTRY * PFN_GLMULTITEXPARAMETERIIVEXT)(GLenum texunit, GLenum target, GLenum pname, const GLint * params);
static PFN_GLMULTITEXPARAMETERIIVEXT _glMultiTexParameterIivEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glMultiTexParameterIivEXT";
    if (!_glMultiTexParameterIivEXT_ptr) {
        _glMultiTexParameterIivEXT_ptr = (PFN_GLMULTITEXPARAMETERIIVEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexParameterIivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexParameterIivEXT_ptr(texunit, target, pname, params);
}

typedef void (APIENTRY * PFN_GLMULTITEXPARAMETERIUIVEXT)(GLenum texunit, GLenum target, GLenum pname, const GLuint * params);
static PFN_GLMULTITEXPARAMETERIUIVEXT _glMultiTexParameterIuivEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint * params) {
    const char *_name = "glMultiTexParameterIuivEXT";
    if (!_glMultiTexParameterIuivEXT_ptr) {
        _glMultiTexParameterIuivEXT_ptr = (PFN_GLMULTITEXPARAMETERIUIVEXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexParameterIuivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexParameterIuivEXT_ptr(texunit, target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMULTITEXPARAMETERIIVEXT)(GLenum texunit, GLenum target, GLenum pname, GLint * params);
static PFN_GLGETMULTITEXPARAMETERIIVEXT _glGetMultiTexParameterIivEXT_ptr = NULL;

static inline void APIENTRY _glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetMultiTexParameterIivEXT";
    if (!_glGetMultiTexParameterIivEXT_ptr) {
        _glGetMultiTexParameterIivEXT_ptr = (PFN_GLGETMULTITEXPARAMETERIIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetMultiTexParameterIivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultiTexParameterIivEXT_ptr(texunit, target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETMULTITEXPARAMETERIUIVEXT)(GLenum texunit, GLenum target, GLenum pname, GLuint * params);
static PFN_GLGETMULTITEXPARAMETERIUIVEXT _glGetMultiTexParameterIuivEXT_ptr = NULL;

static inline void APIENTRY _glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint * params) {
    const char *_name = "glGetMultiTexParameterIuivEXT";
    if (!_glGetMultiTexParameterIuivEXT_ptr) {
        _glGetMultiTexParameterIuivEXT_ptr = (PFN_GLGETMULTITEXPARAMETERIUIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetMultiTexParameterIuivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultiTexParameterIuivEXT_ptr(texunit, target, pname, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1FEXT)(GLuint program, GLint location, GLfloat v0);
static PFN_GLPROGRAMUNIFORM1FEXT _glProgramUniform1fEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0) {
    const char *_name = "glProgramUniform1fEXT";
    if (!_glProgramUniform1fEXT_ptr) {
        _glProgramUniform1fEXT_ptr = (PFN_GLPROGRAMUNIFORM1FEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1fEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1fEXT_ptr(program, location, v0);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2FEXT)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
static PFN_GLPROGRAMUNIFORM2FEXT _glProgramUniform2fEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1) {
    const char *_name = "glProgramUniform2fEXT";
    if (!_glProgramUniform2fEXT_ptr) {
        _glProgramUniform2fEXT_ptr = (PFN_GLPROGRAMUNIFORM2FEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2fEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2fEXT_ptr(program, location, v0, v1);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3FEXT)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
static PFN_GLPROGRAMUNIFORM3FEXT _glProgramUniform3fEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
    const char *_name = "glProgramUniform3fEXT";
    if (!_glProgramUniform3fEXT_ptr) {
        _glProgramUniform3fEXT_ptr = (PFN_GLPROGRAMUNIFORM3FEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3fEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3fEXT_ptr(program, location, v0, v1, v2);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4FEXT)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
static PFN_GLPROGRAMUNIFORM4FEXT _glProgramUniform4fEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
    const char *_name = "glProgramUniform4fEXT";
    if (!_glProgramUniform4fEXT_ptr) {
        _glProgramUniform4fEXT_ptr = (PFN_GLPROGRAMUNIFORM4FEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4fEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4fEXT_ptr(program, location, v0, v1, v2, v3);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1IEXT)(GLuint program, GLint location, GLint v0);
static PFN_GLPROGRAMUNIFORM1IEXT _glProgramUniform1iEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform1iEXT(GLuint program, GLint location, GLint v0) {
    const char *_name = "glProgramUniform1iEXT";
    if (!_glProgramUniform1iEXT_ptr) {
        _glProgramUniform1iEXT_ptr = (PFN_GLPROGRAMUNIFORM1IEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1iEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1iEXT_ptr(program, location, v0);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2IEXT)(GLuint program, GLint location, GLint v0, GLint v1);
static PFN_GLPROGRAMUNIFORM2IEXT _glProgramUniform2iEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1) {
    const char *_name = "glProgramUniform2iEXT";
    if (!_glProgramUniform2iEXT_ptr) {
        _glProgramUniform2iEXT_ptr = (PFN_GLPROGRAMUNIFORM2IEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2iEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2iEXT_ptr(program, location, v0, v1);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3IEXT)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
static PFN_GLPROGRAMUNIFORM3IEXT _glProgramUniform3iEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) {
    const char *_name = "glProgramUniform3iEXT";
    if (!_glProgramUniform3iEXT_ptr) {
        _glProgramUniform3iEXT_ptr = (PFN_GLPROGRAMUNIFORM3IEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3iEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3iEXT_ptr(program, location, v0, v1, v2);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4IEXT)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
static PFN_GLPROGRAMUNIFORM4IEXT _glProgramUniform4iEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
    const char *_name = "glProgramUniform4iEXT";
    if (!_glProgramUniform4iEXT_ptr) {
        _glProgramUniform4iEXT_ptr = (PFN_GLPROGRAMUNIFORM4IEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4iEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4iEXT_ptr(program, location, v0, v1, v2, v3);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1FVEXT)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
static PFN_GLPROGRAMUNIFORM1FVEXT _glProgramUniform1fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform1fvEXT";
    if (!_glProgramUniform1fvEXT_ptr) {
        _glProgramUniform1fvEXT_ptr = (PFN_GLPROGRAMUNIFORM1FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1fvEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2FVEXT)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
static PFN_GLPROGRAMUNIFORM2FVEXT _glProgramUniform2fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform2fvEXT";
    if (!_glProgramUniform2fvEXT_ptr) {
        _glProgramUniform2fvEXT_ptr = (PFN_GLPROGRAMUNIFORM2FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2fvEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3FVEXT)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
static PFN_GLPROGRAMUNIFORM3FVEXT _glProgramUniform3fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform3fvEXT";
    if (!_glProgramUniform3fvEXT_ptr) {
        _glProgramUniform3fvEXT_ptr = (PFN_GLPROGRAMUNIFORM3FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3fvEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4FVEXT)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
static PFN_GLPROGRAMUNIFORM4FVEXT _glProgramUniform4fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform4fvEXT";
    if (!_glProgramUniform4fvEXT_ptr) {
        _glProgramUniform4fvEXT_ptr = (PFN_GLPROGRAMUNIFORM4FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4fvEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1IVEXT)(GLuint program, GLint location, GLsizei count, const GLint * value);
static PFN_GLPROGRAMUNIFORM1IVEXT _glProgramUniform1ivEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform1ivEXT";
    if (!_glProgramUniform1ivEXT_ptr) {
        _glProgramUniform1ivEXT_ptr = (PFN_GLPROGRAMUNIFORM1IVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1ivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1ivEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2IVEXT)(GLuint program, GLint location, GLsizei count, const GLint * value);
static PFN_GLPROGRAMUNIFORM2IVEXT _glProgramUniform2ivEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform2ivEXT";
    if (!_glProgramUniform2ivEXT_ptr) {
        _glProgramUniform2ivEXT_ptr = (PFN_GLPROGRAMUNIFORM2IVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2ivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2ivEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3IVEXT)(GLuint program, GLint location, GLsizei count, const GLint * value);
static PFN_GLPROGRAMUNIFORM3IVEXT _glProgramUniform3ivEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform3ivEXT";
    if (!_glProgramUniform3ivEXT_ptr) {
        _glProgramUniform3ivEXT_ptr = (PFN_GLPROGRAMUNIFORM3IVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3ivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3ivEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4IVEXT)(GLuint program, GLint location, GLsizei count, const GLint * value);
static PFN_GLPROGRAMUNIFORM4IVEXT _glProgramUniform4ivEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform4ivEXT";
    if (!_glProgramUniform4ivEXT_ptr) {
        _glProgramUniform4ivEXT_ptr = (PFN_GLPROGRAMUNIFORM4IVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4ivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4ivEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX2FVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX2FVEXT _glProgramUniformMatrix2fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix2fvEXT";
    if (!_glProgramUniformMatrix2fvEXT_ptr) {
        _glProgramUniformMatrix2fvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX2FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix2fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix2fvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX3FVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX3FVEXT _glProgramUniformMatrix3fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix3fvEXT";
    if (!_glProgramUniformMatrix3fvEXT_ptr) {
        _glProgramUniformMatrix3fvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX3FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix3fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix3fvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX4FVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX4FVEXT _glProgramUniformMatrix4fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix4fvEXT";
    if (!_glProgramUniformMatrix4fvEXT_ptr) {
        _glProgramUniformMatrix4fvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX4FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix4fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix4fvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX2X3FVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX2X3FVEXT _glProgramUniformMatrix2x3fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix2x3fvEXT";
    if (!_glProgramUniformMatrix2x3fvEXT_ptr) {
        _glProgramUniformMatrix2x3fvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X3FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix2x3fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix2x3fvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX3X2FVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX3X2FVEXT _glProgramUniformMatrix3x2fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix3x2fvEXT";
    if (!_glProgramUniformMatrix3x2fvEXT_ptr) {
        _glProgramUniformMatrix3x2fvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X2FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix3x2fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix3x2fvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX2X4FVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX2X4FVEXT _glProgramUniformMatrix2x4fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix2x4fvEXT";
    if (!_glProgramUniformMatrix2x4fvEXT_ptr) {
        _glProgramUniformMatrix2x4fvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X4FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix2x4fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix2x4fvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX4X2FVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX4X2FVEXT _glProgramUniformMatrix4x2fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix4x2fvEXT";
    if (!_glProgramUniformMatrix4x2fvEXT_ptr) {
        _glProgramUniformMatrix4x2fvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X2FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix4x2fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix4x2fvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX3X4FVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX3X4FVEXT _glProgramUniformMatrix3x4fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix3x4fvEXT";
    if (!_glProgramUniformMatrix3x4fvEXT_ptr) {
        _glProgramUniformMatrix3x4fvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X4FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix3x4fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix3x4fvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX4X3FVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
static PFN_GLPROGRAMUNIFORMMATRIX4X3FVEXT _glProgramUniformMatrix4x3fvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix4x3fvEXT";
    if (!_glProgramUniformMatrix4x3fvEXT_ptr) {
        _glProgramUniformMatrix4x3fvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X3FVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix4x3fvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix4x3fvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1UIEXT)(GLuint program, GLint location, GLuint v0);
static PFN_GLPROGRAMUNIFORM1UIEXT _glProgramUniform1uiEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0) {
    const char *_name = "glProgramUniform1uiEXT";
    if (!_glProgramUniform1uiEXT_ptr) {
        _glProgramUniform1uiEXT_ptr = (PFN_GLPROGRAMUNIFORM1UIEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1uiEXT_ptr(program, location, v0);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2UIEXT)(GLuint program, GLint location, GLuint v0, GLuint v1);
static PFN_GLPROGRAMUNIFORM2UIEXT _glProgramUniform2uiEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1) {
    const char *_name = "glProgramUniform2uiEXT";
    if (!_glProgramUniform2uiEXT_ptr) {
        _glProgramUniform2uiEXT_ptr = (PFN_GLPROGRAMUNIFORM2UIEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2uiEXT_ptr(program, location, v0, v1);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3UIEXT)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
static PFN_GLPROGRAMUNIFORM3UIEXT _glProgramUniform3uiEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) {
    const char *_name = "glProgramUniform3uiEXT";
    if (!_glProgramUniform3uiEXT_ptr) {
        _glProgramUniform3uiEXT_ptr = (PFN_GLPROGRAMUNIFORM3UIEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3uiEXT_ptr(program, location, v0, v1, v2);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4UIEXT)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
static PFN_GLPROGRAMUNIFORM4UIEXT _glProgramUniform4uiEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
    const char *_name = "glProgramUniform4uiEXT";
    if (!_glProgramUniform4uiEXT_ptr) {
        _glProgramUniform4uiEXT_ptr = (PFN_GLPROGRAMUNIFORM4UIEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4uiEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4uiEXT_ptr(program, location, v0, v1, v2, v3);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1UIVEXT)(GLuint program, GLint location, GLsizei count, const GLuint * value);
static PFN_GLPROGRAMUNIFORM1UIVEXT _glProgramUniform1uivEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform1uivEXT";
    if (!_glProgramUniform1uivEXT_ptr) {
        _glProgramUniform1uivEXT_ptr = (PFN_GLPROGRAMUNIFORM1UIVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1uivEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2UIVEXT)(GLuint program, GLint location, GLsizei count, const GLuint * value);
static PFN_GLPROGRAMUNIFORM2UIVEXT _glProgramUniform2uivEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform2uivEXT";
    if (!_glProgramUniform2uivEXT_ptr) {
        _glProgramUniform2uivEXT_ptr = (PFN_GLPROGRAMUNIFORM2UIVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2uivEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3UIVEXT)(GLuint program, GLint location, GLsizei count, const GLuint * value);
static PFN_GLPROGRAMUNIFORM3UIVEXT _glProgramUniform3uivEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform3uivEXT";
    if (!_glProgramUniform3uivEXT_ptr) {
        _glProgramUniform3uivEXT_ptr = (PFN_GLPROGRAMUNIFORM3UIVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3uivEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4UIVEXT)(GLuint program, GLint location, GLsizei count, const GLuint * value);
static PFN_GLPROGRAMUNIFORM4UIVEXT _glProgramUniform4uivEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform4uivEXT";
    if (!_glProgramUniform4uivEXT_ptr) {
        _glProgramUniform4uivEXT_ptr = (PFN_GLPROGRAMUNIFORM4UIVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4uivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4uivEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLNAMEDBUFFERDATAEXT)(GLuint buffer, GLsizeiptr size, const GLvoid * data, GLenum usage);
static PFN_GLNAMEDBUFFERDATAEXT _glNamedBufferDataEXT_ptr = NULL;

static inline void APIENTRY _glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const GLvoid * data, GLenum usage) {
    const char *_name = "glNamedBufferDataEXT";
    if (!_glNamedBufferDataEXT_ptr) {
        _glNamedBufferDataEXT_ptr = (PFN_GLNAMEDBUFFERDATAEXT)_getPrivateProcAddress(_name);
        if (!_glNamedBufferDataEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedBufferDataEXT_ptr(buffer, size, data, usage);
}

typedef void (APIENTRY * PFN_GLNAMEDBUFFERSUBDATAEXT)(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid * data);
static PFN_GLNAMEDBUFFERSUBDATAEXT _glNamedBufferSubDataEXT_ptr = NULL;

static inline void APIENTRY _glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid * data) {
    const char *_name = "glNamedBufferSubDataEXT";
    if (!_glNamedBufferSubDataEXT_ptr) {
        _glNamedBufferSubDataEXT_ptr = (PFN_GLNAMEDBUFFERSUBDATAEXT)_getPrivateProcAddress(_name);
        if (!_glNamedBufferSubDataEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedBufferSubDataEXT_ptr(buffer, offset, size, data);
}

typedef GLvoid * (APIENTRY * PFN_GLMAPNAMEDBUFFEREXT)(GLuint buffer, GLenum access);
static PFN_GLMAPNAMEDBUFFEREXT _glMapNamedBufferEXT_ptr = NULL;

static inline GLvoid * APIENTRY _glMapNamedBufferEXT(GLuint buffer, GLenum access) {
    const char *_name = "glMapNamedBufferEXT";
    if (!_glMapNamedBufferEXT_ptr) {
        _glMapNamedBufferEXT_ptr = (PFN_GLMAPNAMEDBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glMapNamedBufferEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glMapNamedBufferEXT_ptr(buffer, access);
}

typedef GLboolean (APIENTRY * PFN_GLUNMAPNAMEDBUFFEREXT)(GLuint buffer);
static PFN_GLUNMAPNAMEDBUFFEREXT _glUnmapNamedBufferEXT_ptr = NULL;

static inline GLboolean APIENTRY _glUnmapNamedBufferEXT(GLuint buffer) {
    const char *_name = "glUnmapNamedBufferEXT";
    if (!_glUnmapNamedBufferEXT_ptr) {
        _glUnmapNamedBufferEXT_ptr = (PFN_GLUNMAPNAMEDBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glUnmapNamedBufferEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glUnmapNamedBufferEXT_ptr(buffer);
}

typedef GLvoid * (APIENTRY * PFN_GLMAPNAMEDBUFFERRANGEEXT)(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
static PFN_GLMAPNAMEDBUFFERRANGEEXT _glMapNamedBufferRangeEXT_ptr = NULL;

static inline GLvoid * APIENTRY _glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) {
    const char *_name = "glMapNamedBufferRangeEXT";
    if (!_glMapNamedBufferRangeEXT_ptr) {
        _glMapNamedBufferRangeEXT_ptr = (PFN_GLMAPNAMEDBUFFERRANGEEXT)_getPrivateProcAddress(_name);
        if (!_glMapNamedBufferRangeEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glMapNamedBufferRangeEXT_ptr(buffer, offset, length, access);
}

typedef void (APIENTRY * PFN_GLFLUSHMAPPEDNAMEDBUFFERRANGEEXT)(GLuint buffer, GLintptr offset, GLsizeiptr length);
static PFN_GLFLUSHMAPPEDNAMEDBUFFERRANGEEXT _glFlushMappedNamedBufferRangeEXT_ptr = NULL;

static inline void APIENTRY _glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length) {
    const char *_name = "glFlushMappedNamedBufferRangeEXT";
    if (!_glFlushMappedNamedBufferRangeEXT_ptr) {
        _glFlushMappedNamedBufferRangeEXT_ptr = (PFN_GLFLUSHMAPPEDNAMEDBUFFERRANGEEXT)_getPrivateProcAddress(_name);
        if (!_glFlushMappedNamedBufferRangeEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFlushMappedNamedBufferRangeEXT_ptr(buffer, offset, length);
}

typedef void (APIENTRY * PFN_GLNAMEDCOPYBUFFERSUBDATAEXT)(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
static PFN_GLNAMEDCOPYBUFFERSUBDATAEXT _glNamedCopyBufferSubDataEXT_ptr = NULL;

static inline void APIENTRY _glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
    const char *_name = "glNamedCopyBufferSubDataEXT";
    if (!_glNamedCopyBufferSubDataEXT_ptr) {
        _glNamedCopyBufferSubDataEXT_ptr = (PFN_GLNAMEDCOPYBUFFERSUBDATAEXT)_getPrivateProcAddress(_name);
        if (!_glNamedCopyBufferSubDataEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedCopyBufferSubDataEXT_ptr(readBuffer, writeBuffer, readOffset, writeOffset, size);
}

typedef void (APIENTRY * PFN_GLGETNAMEDBUFFERPARAMETERIVEXT)(GLuint buffer, GLenum pname, GLint * params);
static PFN_GLGETNAMEDBUFFERPARAMETERIVEXT _glGetNamedBufferParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedBufferParameterivEXT";
    if (!_glGetNamedBufferParameterivEXT_ptr) {
        _glGetNamedBufferParameterivEXT_ptr = (PFN_GLGETNAMEDBUFFERPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetNamedBufferParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedBufferParameterivEXT_ptr(buffer, pname, params);
}

typedef void (APIENTRY * PFN_GLGETNAMEDBUFFERPOINTERVEXT)(GLuint buffer, GLenum pname, GLvoid * * params);
static PFN_GLGETNAMEDBUFFERPOINTERVEXT _glGetNamedBufferPointervEXT_ptr = NULL;

static inline void APIENTRY _glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, GLvoid * * params) {
    const char *_name = "glGetNamedBufferPointervEXT";
    if (!_glGetNamedBufferPointervEXT_ptr) {
        _glGetNamedBufferPointervEXT_ptr = (PFN_GLGETNAMEDBUFFERPOINTERVEXT)_getPrivateProcAddress(_name);
        if (!_glGetNamedBufferPointervEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedBufferPointervEXT_ptr(buffer, pname, params);
}

typedef void (APIENTRY * PFN_GLGETNAMEDBUFFERSUBDATAEXT)(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid * data);
static PFN_GLGETNAMEDBUFFERSUBDATAEXT _glGetNamedBufferSubDataEXT_ptr = NULL;

static inline void APIENTRY _glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid * data) {
    const char *_name = "glGetNamedBufferSubDataEXT";
    if (!_glGetNamedBufferSubDataEXT_ptr) {
        _glGetNamedBufferSubDataEXT_ptr = (PFN_GLGETNAMEDBUFFERSUBDATAEXT)_getPrivateProcAddress(_name);
        if (!_glGetNamedBufferSubDataEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedBufferSubDataEXT_ptr(buffer, offset, size, data);
}

typedef void (APIENTRY * PFN_GLTEXTUREBUFFEREXT)(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
static PFN_GLTEXTUREBUFFEREXT _glTextureBufferEXT_ptr = NULL;

static inline void APIENTRY _glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer) {
    const char *_name = "glTextureBufferEXT";
    if (!_glTextureBufferEXT_ptr) {
        _glTextureBufferEXT_ptr = (PFN_GLTEXTUREBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glTextureBufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureBufferEXT_ptr(texture, target, internalformat, buffer);
}

typedef void (APIENTRY * PFN_GLMULTITEXBUFFEREXT)(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
static PFN_GLMULTITEXBUFFEREXT _glMultiTexBufferEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer) {
    const char *_name = "glMultiTexBufferEXT";
    if (!_glMultiTexBufferEXT_ptr) {
        _glMultiTexBufferEXT_ptr = (PFN_GLMULTITEXBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexBufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexBufferEXT_ptr(texunit, target, internalformat, buffer);
}

typedef void (APIENTRY * PFN_GLNAMEDRENDERBUFFERSTORAGEEXT)(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLNAMEDRENDERBUFFERSTORAGEEXT _glNamedRenderbufferStorageEXT_ptr = NULL;

static inline void APIENTRY _glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glNamedRenderbufferStorageEXT";
    if (!_glNamedRenderbufferStorageEXT_ptr) {
        _glNamedRenderbufferStorageEXT_ptr = (PFN_GLNAMEDRENDERBUFFERSTORAGEEXT)_getPrivateProcAddress(_name);
        if (!_glNamedRenderbufferStorageEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedRenderbufferStorageEXT_ptr(renderbuffer, internalformat, width, height);
}

typedef void (APIENTRY * PFN_GLGETNAMEDRENDERBUFFERPARAMETERIVEXT)(GLuint renderbuffer, GLenum pname, GLint * params);
static PFN_GLGETNAMEDRENDERBUFFERPARAMETERIVEXT _glGetNamedRenderbufferParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedRenderbufferParameterivEXT";
    if (!_glGetNamedRenderbufferParameterivEXT_ptr) {
        _glGetNamedRenderbufferParameterivEXT_ptr = (PFN_GLGETNAMEDRENDERBUFFERPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetNamedRenderbufferParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedRenderbufferParameterivEXT_ptr(renderbuffer, pname, params);
}

typedef GLenum (APIENTRY * PFN_GLCHECKNAMEDFRAMEBUFFERSTATUSEXT)(GLuint framebuffer, GLenum target);
static PFN_GLCHECKNAMEDFRAMEBUFFERSTATUSEXT _glCheckNamedFramebufferStatusEXT_ptr = NULL;

static inline GLenum APIENTRY _glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target) {
    const char *_name = "glCheckNamedFramebufferStatusEXT";
    if (!_glCheckNamedFramebufferStatusEXT_ptr) {
        _glCheckNamedFramebufferStatusEXT_ptr = (PFN_GLCHECKNAMEDFRAMEBUFFERSTATUSEXT)_getPrivateProcAddress(_name);
        if (!_glCheckNamedFramebufferStatusEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glCheckNamedFramebufferStatusEXT_ptr(framebuffer, target);
}

typedef void (APIENTRY * PFN_GLNAMEDFRAMEBUFFERTEXTURE1DEXT)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
static PFN_GLNAMEDFRAMEBUFFERTEXTURE1DEXT _glNamedFramebufferTexture1DEXT_ptr = NULL;

static inline void APIENTRY _glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glNamedFramebufferTexture1DEXT";
    if (!_glNamedFramebufferTexture1DEXT_ptr) {
        _glNamedFramebufferTexture1DEXT_ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTURE1DEXT)_getPrivateProcAddress(_name);
        if (!_glNamedFramebufferTexture1DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedFramebufferTexture1DEXT_ptr(framebuffer, attachment, textarget, texture, level);
}

typedef void (APIENTRY * PFN_GLNAMEDFRAMEBUFFERTEXTURE2DEXT)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
static PFN_GLNAMEDFRAMEBUFFERTEXTURE2DEXT _glNamedFramebufferTexture2DEXT_ptr = NULL;

static inline void APIENTRY _glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glNamedFramebufferTexture2DEXT";
    if (!_glNamedFramebufferTexture2DEXT_ptr) {
        _glNamedFramebufferTexture2DEXT_ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTURE2DEXT)_getPrivateProcAddress(_name);
        if (!_glNamedFramebufferTexture2DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedFramebufferTexture2DEXT_ptr(framebuffer, attachment, textarget, texture, level);
}

typedef void (APIENTRY * PFN_GLNAMEDFRAMEBUFFERTEXTURE3DEXT)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
static PFN_GLNAMEDFRAMEBUFFERTEXTURE3DEXT _glNamedFramebufferTexture3DEXT_ptr = NULL;

static inline void APIENTRY _glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
    const char *_name = "glNamedFramebufferTexture3DEXT";
    if (!_glNamedFramebufferTexture3DEXT_ptr) {
        _glNamedFramebufferTexture3DEXT_ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTURE3DEXT)_getPrivateProcAddress(_name);
        if (!_glNamedFramebufferTexture3DEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedFramebufferTexture3DEXT_ptr(framebuffer, attachment, textarget, texture, level, zoffset);
}

typedef void (APIENTRY * PFN_GLNAMEDFRAMEBUFFERRENDERBUFFEREXT)(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
static PFN_GLNAMEDFRAMEBUFFERRENDERBUFFEREXT _glNamedFramebufferRenderbufferEXT_ptr = NULL;

static inline void APIENTRY _glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    const char *_name = "glNamedFramebufferRenderbufferEXT";
    if (!_glNamedFramebufferRenderbufferEXT_ptr) {
        _glNamedFramebufferRenderbufferEXT_ptr = (PFN_GLNAMEDFRAMEBUFFERRENDERBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glNamedFramebufferRenderbufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedFramebufferRenderbufferEXT_ptr(framebuffer, attachment, renderbuffertarget, renderbuffer);
}

typedef void (APIENTRY * PFN_GLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXT)(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params);
static PFN_GLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXT _glGetNamedFramebufferAttachmentParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedFramebufferAttachmentParameterivEXT";
    if (!_glGetNamedFramebufferAttachmentParameterivEXT_ptr) {
        _glGetNamedFramebufferAttachmentParameterivEXT_ptr = (PFN_GLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetNamedFramebufferAttachmentParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedFramebufferAttachmentParameterivEXT_ptr(framebuffer, attachment, pname, params);
}

typedef void (APIENTRY * PFN_GLGENERATETEXTUREMIPMAPEXT)(GLuint texture, GLenum target);
static PFN_GLGENERATETEXTUREMIPMAPEXT _glGenerateTextureMipmapEXT_ptr = NULL;

static inline void APIENTRY _glGenerateTextureMipmapEXT(GLuint texture, GLenum target) {
    const char *_name = "glGenerateTextureMipmapEXT";
    if (!_glGenerateTextureMipmapEXT_ptr) {
        _glGenerateTextureMipmapEXT_ptr = (PFN_GLGENERATETEXTUREMIPMAPEXT)_getPrivateProcAddress(_name);
        if (!_glGenerateTextureMipmapEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenerateTextureMipmapEXT_ptr(texture, target);
}

typedef void (APIENTRY * PFN_GLGENERATEMULTITEXMIPMAPEXT)(GLenum texunit, GLenum target);
static PFN_GLGENERATEMULTITEXMIPMAPEXT _glGenerateMultiTexMipmapEXT_ptr = NULL;

static inline void APIENTRY _glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target) {
    const char *_name = "glGenerateMultiTexMipmapEXT";
    if (!_glGenerateMultiTexMipmapEXT_ptr) {
        _glGenerateMultiTexMipmapEXT_ptr = (PFN_GLGENERATEMULTITEXMIPMAPEXT)_getPrivateProcAddress(_name);
        if (!_glGenerateMultiTexMipmapEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenerateMultiTexMipmapEXT_ptr(texunit, target);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERDRAWBUFFEREXT)(GLuint framebuffer, GLenum mode);
static PFN_GLFRAMEBUFFERDRAWBUFFEREXT _glFramebufferDrawBufferEXT_ptr = NULL;

static inline void APIENTRY _glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode) {
    const char *_name = "glFramebufferDrawBufferEXT";
    if (!_glFramebufferDrawBufferEXT_ptr) {
        _glFramebufferDrawBufferEXT_ptr = (PFN_GLFRAMEBUFFERDRAWBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glFramebufferDrawBufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferDrawBufferEXT_ptr(framebuffer, mode);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERDRAWBUFFERSEXT)(GLuint framebuffer, GLsizei n, const GLenum * bufs);
static PFN_GLFRAMEBUFFERDRAWBUFFERSEXT _glFramebufferDrawBuffersEXT_ptr = NULL;

static inline void APIENTRY _glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum * bufs) {
    const char *_name = "glFramebufferDrawBuffersEXT";
    if (!_glFramebufferDrawBuffersEXT_ptr) {
        _glFramebufferDrawBuffersEXT_ptr = (PFN_GLFRAMEBUFFERDRAWBUFFERSEXT)_getPrivateProcAddress(_name);
        if (!_glFramebufferDrawBuffersEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferDrawBuffersEXT_ptr(framebuffer, n, bufs);
}

typedef void (APIENTRY * PFN_GLFRAMEBUFFERREADBUFFEREXT)(GLuint framebuffer, GLenum mode);
static PFN_GLFRAMEBUFFERREADBUFFEREXT _glFramebufferReadBufferEXT_ptr = NULL;

static inline void APIENTRY _glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode) {
    const char *_name = "glFramebufferReadBufferEXT";
    if (!_glFramebufferReadBufferEXT_ptr) {
        _glFramebufferReadBufferEXT_ptr = (PFN_GLFRAMEBUFFERREADBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glFramebufferReadBufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferReadBufferEXT_ptr(framebuffer, mode);
}

typedef void (APIENTRY * PFN_GLGETFRAMEBUFFERPARAMETERIVEXT)(GLuint framebuffer, GLenum pname, GLint * params);
static PFN_GLGETFRAMEBUFFERPARAMETERIVEXT _glGetFramebufferParameterivEXT_ptr = NULL;

static inline void APIENTRY _glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint * params) {
    const char *_name = "glGetFramebufferParameterivEXT";
    if (!_glGetFramebufferParameterivEXT_ptr) {
        _glGetFramebufferParameterivEXT_ptr = (PFN_GLGETFRAMEBUFFERPARAMETERIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetFramebufferParameterivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFramebufferParameterivEXT_ptr(framebuffer, pname, params);
}

typedef void (APIENTRY * PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXT)(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXT _glNamedRenderbufferStorageMultisampleEXT_ptr = NULL;

static inline void APIENTRY _glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glNamedRenderbufferStorageMultisampleEXT";
    if (!_glNamedRenderbufferStorageMultisampleEXT_ptr) {
        _glNamedRenderbufferStorageMultisampleEXT_ptr = (PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXT)_getPrivateProcAddress(_name);
        if (!_glNamedRenderbufferStorageMultisampleEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedRenderbufferStorageMultisampleEXT_ptr(renderbuffer, samples, internalformat, width, height);
}

typedef void (APIENTRY * PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXT)(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXT _glNamedRenderbufferStorageMultisampleCoverageEXT_ptr = NULL;

static inline void APIENTRY _glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glNamedRenderbufferStorageMultisampleCoverageEXT";
    if (!_glNamedRenderbufferStorageMultisampleCoverageEXT_ptr) {
        _glNamedRenderbufferStorageMultisampleCoverageEXT_ptr = (PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXT)_getPrivateProcAddress(_name);
        if (!_glNamedRenderbufferStorageMultisampleCoverageEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedRenderbufferStorageMultisampleCoverageEXT_ptr(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
}

typedef void (APIENTRY * PFN_GLNAMEDFRAMEBUFFERTEXTUREEXT)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
static PFN_GLNAMEDFRAMEBUFFERTEXTUREEXT _glNamedFramebufferTextureEXT_ptr = NULL;

static inline void APIENTRY _glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) {
    const char *_name = "glNamedFramebufferTextureEXT";
    if (!_glNamedFramebufferTextureEXT_ptr) {
        _glNamedFramebufferTextureEXT_ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTUREEXT)_getPrivateProcAddress(_name);
        if (!_glNamedFramebufferTextureEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedFramebufferTextureEXT_ptr(framebuffer, attachment, texture, level);
}

typedef void (APIENTRY * PFN_GLNAMEDFRAMEBUFFERTEXTURELAYEREXT)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
static PFN_GLNAMEDFRAMEBUFFERTEXTURELAYEREXT _glNamedFramebufferTextureLayerEXT_ptr = NULL;

static inline void APIENTRY _glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    const char *_name = "glNamedFramebufferTextureLayerEXT";
    if (!_glNamedFramebufferTextureLayerEXT_ptr) {
        _glNamedFramebufferTextureLayerEXT_ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTURELAYEREXT)_getPrivateProcAddress(_name);
        if (!_glNamedFramebufferTextureLayerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedFramebufferTextureLayerEXT_ptr(framebuffer, attachment, texture, level, layer);
}

typedef void (APIENTRY * PFN_GLNAMEDFRAMEBUFFERTEXTUREFACEEXT)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
static PFN_GLNAMEDFRAMEBUFFERTEXTUREFACEEXT _glNamedFramebufferTextureFaceEXT_ptr = NULL;

static inline void APIENTRY _glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face) {
    const char *_name = "glNamedFramebufferTextureFaceEXT";
    if (!_glNamedFramebufferTextureFaceEXT_ptr) {
        _glNamedFramebufferTextureFaceEXT_ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTUREFACEEXT)_getPrivateProcAddress(_name);
        if (!_glNamedFramebufferTextureFaceEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNamedFramebufferTextureFaceEXT_ptr(framebuffer, attachment, texture, level, face);
}

typedef void (APIENTRY * PFN_GLTEXTURERENDERBUFFEREXT)(GLuint texture, GLenum target, GLuint renderbuffer);
static PFN_GLTEXTURERENDERBUFFEREXT _glTextureRenderbufferEXT_ptr = NULL;

static inline void APIENTRY _glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer) {
    const char *_name = "glTextureRenderbufferEXT";
    if (!_glTextureRenderbufferEXT_ptr) {
        _glTextureRenderbufferEXT_ptr = (PFN_GLTEXTURERENDERBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glTextureRenderbufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureRenderbufferEXT_ptr(texture, target, renderbuffer);
}

typedef void (APIENTRY * PFN_GLMULTITEXRENDERBUFFEREXT)(GLenum texunit, GLenum target, GLuint renderbuffer);
static PFN_GLMULTITEXRENDERBUFFEREXT _glMultiTexRenderbufferEXT_ptr = NULL;

static inline void APIENTRY _glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer) {
    const char *_name = "glMultiTexRenderbufferEXT";
    if (!_glMultiTexRenderbufferEXT_ptr) {
        _glMultiTexRenderbufferEXT_ptr = (PFN_GLMULTITEXRENDERBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glMultiTexRenderbufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexRenderbufferEXT_ptr(texunit, target, renderbuffer);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1DEXT)(GLuint program, GLint location, GLdouble x);
static PFN_GLPROGRAMUNIFORM1DEXT _glProgramUniform1dEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x) {
    const char *_name = "glProgramUniform1dEXT";
    if (!_glProgramUniform1dEXT_ptr) {
        _glProgramUniform1dEXT_ptr = (PFN_GLPROGRAMUNIFORM1DEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1dEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1dEXT_ptr(program, location, x);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2DEXT)(GLuint program, GLint location, GLdouble x, GLdouble y);
static PFN_GLPROGRAMUNIFORM2DEXT _glProgramUniform2dEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y) {
    const char *_name = "glProgramUniform2dEXT";
    if (!_glProgramUniform2dEXT_ptr) {
        _glProgramUniform2dEXT_ptr = (PFN_GLPROGRAMUNIFORM2DEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2dEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2dEXT_ptr(program, location, x, y);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3DEXT)(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
static PFN_GLPROGRAMUNIFORM3DEXT _glProgramUniform3dEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glProgramUniform3dEXT";
    if (!_glProgramUniform3dEXT_ptr) {
        _glProgramUniform3dEXT_ptr = (PFN_GLPROGRAMUNIFORM3DEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3dEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3dEXT_ptr(program, location, x, y, z);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4DEXT)(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLPROGRAMUNIFORM4DEXT _glProgramUniform4dEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glProgramUniform4dEXT";
    if (!_glProgramUniform4dEXT_ptr) {
        _glProgramUniform4dEXT_ptr = (PFN_GLPROGRAMUNIFORM4DEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4dEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4dEXT_ptr(program, location, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1DVEXT)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
static PFN_GLPROGRAMUNIFORM1DVEXT _glProgramUniform1dvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform1dvEXT";
    if (!_glProgramUniform1dvEXT_ptr) {
        _glProgramUniform1dvEXT_ptr = (PFN_GLPROGRAMUNIFORM1DVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1dvEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2DVEXT)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
static PFN_GLPROGRAMUNIFORM2DVEXT _glProgramUniform2dvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform2dvEXT";
    if (!_glProgramUniform2dvEXT_ptr) {
        _glProgramUniform2dvEXT_ptr = (PFN_GLPROGRAMUNIFORM2DVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2dvEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3DVEXT)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
static PFN_GLPROGRAMUNIFORM3DVEXT _glProgramUniform3dvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform3dvEXT";
    if (!_glProgramUniform3dvEXT_ptr) {
        _glProgramUniform3dvEXT_ptr = (PFN_GLPROGRAMUNIFORM3DVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3dvEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4DVEXT)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
static PFN_GLPROGRAMUNIFORM4DVEXT _glProgramUniform4dvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform4dvEXT";
    if (!_glProgramUniform4dvEXT_ptr) {
        _glProgramUniform4dvEXT_ptr = (PFN_GLPROGRAMUNIFORM4DVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4dvEXT_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX2DVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX2DVEXT _glProgramUniformMatrix2dvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix2dvEXT";
    if (!_glProgramUniformMatrix2dvEXT_ptr) {
        _glProgramUniformMatrix2dvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX2DVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix2dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix2dvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX3DVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX3DVEXT _glProgramUniformMatrix3dvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix3dvEXT";
    if (!_glProgramUniformMatrix3dvEXT_ptr) {
        _glProgramUniformMatrix3dvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX3DVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix3dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix3dvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX4DVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX4DVEXT _glProgramUniformMatrix4dvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix4dvEXT";
    if (!_glProgramUniformMatrix4dvEXT_ptr) {
        _glProgramUniformMatrix4dvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX4DVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix4dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix4dvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX2X3DVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX2X3DVEXT _glProgramUniformMatrix2x3dvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix2x3dvEXT";
    if (!_glProgramUniformMatrix2x3dvEXT_ptr) {
        _glProgramUniformMatrix2x3dvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X3DVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix2x3dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix2x3dvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX2X4DVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX2X4DVEXT _glProgramUniformMatrix2x4dvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix2x4dvEXT";
    if (!_glProgramUniformMatrix2x4dvEXT_ptr) {
        _glProgramUniformMatrix2x4dvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X4DVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix2x4dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix2x4dvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX3X2DVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX3X2DVEXT _glProgramUniformMatrix3x2dvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix3x2dvEXT";
    if (!_glProgramUniformMatrix3x2dvEXT_ptr) {
        _glProgramUniformMatrix3x2dvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X2DVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix3x2dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix3x2dvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX3X4DVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX3X4DVEXT _glProgramUniformMatrix3x4dvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix3x4dvEXT";
    if (!_glProgramUniformMatrix3x4dvEXT_ptr) {
        _glProgramUniformMatrix3x4dvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X4DVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix3x4dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix3x4dvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX4X2DVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX4X2DVEXT _glProgramUniformMatrix4x2dvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix4x2dvEXT";
    if (!_glProgramUniformMatrix4x2dvEXT_ptr) {
        _glProgramUniformMatrix4x2dvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X2DVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix4x2dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix4x2dvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMMATRIX4X3DVEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
static PFN_GLPROGRAMUNIFORMMATRIX4X3DVEXT _glProgramUniformMatrix4x3dvEXT_ptr = NULL;

static inline void APIENTRY _glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix4x3dvEXT";
    if (!_glProgramUniformMatrix4x3dvEXT_ptr) {
        _glProgramUniformMatrix4x3dvEXT_ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X3DVEXT)_getPrivateProcAddress(_name);
        if (!_glProgramUniformMatrix4x3dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformMatrix4x3dvEXT_ptr(program, location, count, transpose, value);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYVERTEXOFFSETEXT)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
static PFN_GLVERTEXARRAYVERTEXOFFSETEXT _glVertexArrayVertexOffsetEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayVertexOffsetEXT";
    if (!_glVertexArrayVertexOffsetEXT_ptr) {
        _glVertexArrayVertexOffsetEXT_ptr = (PFN_GLVERTEXARRAYVERTEXOFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayVertexOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayVertexOffsetEXT_ptr(vaobj, buffer, size, type, stride, offset);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYCOLOROFFSETEXT)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
static PFN_GLVERTEXARRAYCOLOROFFSETEXT _glVertexArrayColorOffsetEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayColorOffsetEXT";
    if (!_glVertexArrayColorOffsetEXT_ptr) {
        _glVertexArrayColorOffsetEXT_ptr = (PFN_GLVERTEXARRAYCOLOROFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayColorOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayColorOffsetEXT_ptr(vaobj, buffer, size, type, stride, offset);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYEDGEFLAGOFFSETEXT)(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
static PFN_GLVERTEXARRAYEDGEFLAGOFFSETEXT _glVertexArrayEdgeFlagOffsetEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayEdgeFlagOffsetEXT";
    if (!_glVertexArrayEdgeFlagOffsetEXT_ptr) {
        _glVertexArrayEdgeFlagOffsetEXT_ptr = (PFN_GLVERTEXARRAYEDGEFLAGOFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayEdgeFlagOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayEdgeFlagOffsetEXT_ptr(vaobj, buffer, stride, offset);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYINDEXOFFSETEXT)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
static PFN_GLVERTEXARRAYINDEXOFFSETEXT _glVertexArrayIndexOffsetEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayIndexOffsetEXT";
    if (!_glVertexArrayIndexOffsetEXT_ptr) {
        _glVertexArrayIndexOffsetEXT_ptr = (PFN_GLVERTEXARRAYINDEXOFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayIndexOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayIndexOffsetEXT_ptr(vaobj, buffer, type, stride, offset);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYNORMALOFFSETEXT)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
static PFN_GLVERTEXARRAYNORMALOFFSETEXT _glVertexArrayNormalOffsetEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayNormalOffsetEXT";
    if (!_glVertexArrayNormalOffsetEXT_ptr) {
        _glVertexArrayNormalOffsetEXT_ptr = (PFN_GLVERTEXARRAYNORMALOFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayNormalOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayNormalOffsetEXT_ptr(vaobj, buffer, type, stride, offset);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYTEXCOORDOFFSETEXT)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
static PFN_GLVERTEXARRAYTEXCOORDOFFSETEXT _glVertexArrayTexCoordOffsetEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayTexCoordOffsetEXT";
    if (!_glVertexArrayTexCoordOffsetEXT_ptr) {
        _glVertexArrayTexCoordOffsetEXT_ptr = (PFN_GLVERTEXARRAYTEXCOORDOFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayTexCoordOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayTexCoordOffsetEXT_ptr(vaobj, buffer, size, type, stride, offset);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYMULTITEXCOORDOFFSETEXT)(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
static PFN_GLVERTEXARRAYMULTITEXCOORDOFFSETEXT _glVertexArrayMultiTexCoordOffsetEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayMultiTexCoordOffsetEXT";
    if (!_glVertexArrayMultiTexCoordOffsetEXT_ptr) {
        _glVertexArrayMultiTexCoordOffsetEXT_ptr = (PFN_GLVERTEXARRAYMULTITEXCOORDOFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayMultiTexCoordOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayMultiTexCoordOffsetEXT_ptr(vaobj, buffer, texunit, size, type, stride, offset);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYFOGCOORDOFFSETEXT)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
static PFN_GLVERTEXARRAYFOGCOORDOFFSETEXT _glVertexArrayFogCoordOffsetEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayFogCoordOffsetEXT";
    if (!_glVertexArrayFogCoordOffsetEXT_ptr) {
        _glVertexArrayFogCoordOffsetEXT_ptr = (PFN_GLVERTEXARRAYFOGCOORDOFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayFogCoordOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayFogCoordOffsetEXT_ptr(vaobj, buffer, type, stride, offset);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYSECONDARYCOLOROFFSETEXT)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
static PFN_GLVERTEXARRAYSECONDARYCOLOROFFSETEXT _glVertexArraySecondaryColorOffsetEXT_ptr = NULL;

static inline void APIENTRY _glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArraySecondaryColorOffsetEXT";
    if (!_glVertexArraySecondaryColorOffsetEXT_ptr) {
        _glVertexArraySecondaryColorOffsetEXT_ptr = (PFN_GLVERTEXARRAYSECONDARYCOLOROFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArraySecondaryColorOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArraySecondaryColorOffsetEXT_ptr(vaobj, buffer, size, type, stride, offset);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYVERTEXATTRIBOFFSETEXT)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
static PFN_GLVERTEXARRAYVERTEXATTRIBOFFSETEXT _glVertexArrayVertexAttribOffsetEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayVertexAttribOffsetEXT";
    if (!_glVertexArrayVertexAttribOffsetEXT_ptr) {
        _glVertexArrayVertexAttribOffsetEXT_ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBOFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayVertexAttribOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayVertexAttribOffsetEXT_ptr(vaobj, buffer, index, size, type, normalized, stride, offset);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYVERTEXATTRIBIOFFSETEXT)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
static PFN_GLVERTEXARRAYVERTEXATTRIBIOFFSETEXT _glVertexArrayVertexAttribIOffsetEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayVertexAttribIOffsetEXT";
    if (!_glVertexArrayVertexAttribIOffsetEXT_ptr) {
        _glVertexArrayVertexAttribIOffsetEXT_ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBIOFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayVertexAttribIOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayVertexAttribIOffsetEXT_ptr(vaobj, buffer, index, size, type, stride, offset);
}

typedef void (APIENTRY * PFN_GLENABLEVERTEXARRAYEXT)(GLuint vaobj, GLenum array);
static PFN_GLENABLEVERTEXARRAYEXT _glEnableVertexArrayEXT_ptr = NULL;

static inline void APIENTRY _glEnableVertexArrayEXT(GLuint vaobj, GLenum array) {
    const char *_name = "glEnableVertexArrayEXT";
    if (!_glEnableVertexArrayEXT_ptr) {
        _glEnableVertexArrayEXT_ptr = (PFN_GLENABLEVERTEXARRAYEXT)_getPrivateProcAddress(_name);
        if (!_glEnableVertexArrayEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEnableVertexArrayEXT_ptr(vaobj, array);
}

typedef void (APIENTRY * PFN_GLDISABLEVERTEXARRAYEXT)(GLuint vaobj, GLenum array);
static PFN_GLDISABLEVERTEXARRAYEXT _glDisableVertexArrayEXT_ptr = NULL;

static inline void APIENTRY _glDisableVertexArrayEXT(GLuint vaobj, GLenum array) {
    const char *_name = "glDisableVertexArrayEXT";
    if (!_glDisableVertexArrayEXT_ptr) {
        _glDisableVertexArrayEXT_ptr = (PFN_GLDISABLEVERTEXARRAYEXT)_getPrivateProcAddress(_name);
        if (!_glDisableVertexArrayEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDisableVertexArrayEXT_ptr(vaobj, array);
}

typedef void (APIENTRY * PFN_GLENABLEVERTEXARRAYATTRIBEXT)(GLuint vaobj, GLuint index);
static PFN_GLENABLEVERTEXARRAYATTRIBEXT _glEnableVertexArrayAttribEXT_ptr = NULL;

static inline void APIENTRY _glEnableVertexArrayAttribEXT(GLuint vaobj, GLuint index) {
    const char *_name = "glEnableVertexArrayAttribEXT";
    if (!_glEnableVertexArrayAttribEXT_ptr) {
        _glEnableVertexArrayAttribEXT_ptr = (PFN_GLENABLEVERTEXARRAYATTRIBEXT)_getPrivateProcAddress(_name);
        if (!_glEnableVertexArrayAttribEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEnableVertexArrayAttribEXT_ptr(vaobj, index);
}

typedef void (APIENTRY * PFN_GLDISABLEVERTEXARRAYATTRIBEXT)(GLuint vaobj, GLuint index);
static PFN_GLDISABLEVERTEXARRAYATTRIBEXT _glDisableVertexArrayAttribEXT_ptr = NULL;

static inline void APIENTRY _glDisableVertexArrayAttribEXT(GLuint vaobj, GLuint index) {
    const char *_name = "glDisableVertexArrayAttribEXT";
    if (!_glDisableVertexArrayAttribEXT_ptr) {
        _glDisableVertexArrayAttribEXT_ptr = (PFN_GLDISABLEVERTEXARRAYATTRIBEXT)_getPrivateProcAddress(_name);
        if (!_glDisableVertexArrayAttribEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDisableVertexArrayAttribEXT_ptr(vaobj, index);
}

typedef void (APIENTRY * PFN_GLGETVERTEXARRAYINTEGERVEXT)(GLuint vaobj, GLenum pname, GLint * param);
static PFN_GLGETVERTEXARRAYINTEGERVEXT _glGetVertexArrayIntegervEXT_ptr = NULL;

static inline void APIENTRY _glGetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint * param) {
    const char *_name = "glGetVertexArrayIntegervEXT";
    if (!_glGetVertexArrayIntegervEXT_ptr) {
        _glGetVertexArrayIntegervEXT_ptr = (PFN_GLGETVERTEXARRAYINTEGERVEXT)_getPrivateProcAddress(_name);
        if (!_glGetVertexArrayIntegervEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexArrayIntegervEXT_ptr(vaobj, pname, param);
}

typedef void (APIENTRY * PFN_GLGETVERTEXARRAYPOINTERVEXT)(GLuint vaobj, GLenum pname, GLvoid * * param);
static PFN_GLGETVERTEXARRAYPOINTERVEXT _glGetVertexArrayPointervEXT_ptr = NULL;

static inline void APIENTRY _glGetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, GLvoid * * param) {
    const char *_name = "glGetVertexArrayPointervEXT";
    if (!_glGetVertexArrayPointervEXT_ptr) {
        _glGetVertexArrayPointervEXT_ptr = (PFN_GLGETVERTEXARRAYPOINTERVEXT)_getPrivateProcAddress(_name);
        if (!_glGetVertexArrayPointervEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexArrayPointervEXT_ptr(vaobj, pname, param);
}

typedef void (APIENTRY * PFN_GLGETVERTEXARRAYINTEGERI_VEXT)(GLuint vaobj, GLuint index, GLenum pname, GLint * param);
static PFN_GLGETVERTEXARRAYINTEGERI_VEXT _glGetVertexArrayIntegeri_vEXT_ptr = NULL;

static inline void APIENTRY _glGetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint * param) {
    const char *_name = "glGetVertexArrayIntegeri_vEXT";
    if (!_glGetVertexArrayIntegeri_vEXT_ptr) {
        _glGetVertexArrayIntegeri_vEXT_ptr = (PFN_GLGETVERTEXARRAYINTEGERI_VEXT)_getPrivateProcAddress(_name);
        if (!_glGetVertexArrayIntegeri_vEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexArrayIntegeri_vEXT_ptr(vaobj, index, pname, param);
}

typedef void (APIENTRY * PFN_GLGETVERTEXARRAYPOINTERI_VEXT)(GLuint vaobj, GLuint index, GLenum pname, GLvoid * * param);
static PFN_GLGETVERTEXARRAYPOINTERI_VEXT _glGetVertexArrayPointeri_vEXT_ptr = NULL;

static inline void APIENTRY _glGetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLvoid * * param) {
    const char *_name = "glGetVertexArrayPointeri_vEXT";
    if (!_glGetVertexArrayPointeri_vEXT_ptr) {
        _glGetVertexArrayPointeri_vEXT_ptr = (PFN_GLGETVERTEXARRAYPOINTERI_VEXT)_getPrivateProcAddress(_name);
        if (!_glGetVertexArrayPointeri_vEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexArrayPointeri_vEXT_ptr(vaobj, index, pname, param);
}

typedef void (APIENTRY * PFN_GLGETMULTISAMPLEFVNV)(GLenum pname, GLuint index, GLfloat * val);
static PFN_GLGETMULTISAMPLEFVNV _glGetMultisamplefvNV_ptr = NULL;

static inline void APIENTRY _glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat * val) {
    const char *_name = "glGetMultisamplefvNV";
    if (!_glGetMultisamplefvNV_ptr) {
        _glGetMultisamplefvNV_ptr = (PFN_GLGETMULTISAMPLEFVNV)_getPrivateProcAddress(_name);
        if (!_glGetMultisamplefvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMultisamplefvNV_ptr(pname, index, val);
}

typedef void (APIENTRY * PFN_GLSAMPLEMASKINDEXEDNV)(GLuint index, GLbitfield mask);
static PFN_GLSAMPLEMASKINDEXEDNV _glSampleMaskIndexedNV_ptr = NULL;

static inline void APIENTRY _glSampleMaskIndexedNV(GLuint index, GLbitfield mask) {
    const char *_name = "glSampleMaskIndexedNV";
    if (!_glSampleMaskIndexedNV_ptr) {
        _glSampleMaskIndexedNV_ptr = (PFN_GLSAMPLEMASKINDEXEDNV)_getPrivateProcAddress(_name);
        if (!_glSampleMaskIndexedNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSampleMaskIndexedNV_ptr(index, mask);
}

typedef void (APIENTRY * PFN_GLTEXRENDERBUFFERNV)(GLenum target, GLuint renderbuffer);
static PFN_GLTEXRENDERBUFFERNV _glTexRenderbufferNV_ptr = NULL;

static inline void APIENTRY _glTexRenderbufferNV(GLenum target, GLuint renderbuffer) {
    const char *_name = "glTexRenderbufferNV";
    if (!_glTexRenderbufferNV_ptr) {
        _glTexRenderbufferNV_ptr = (PFN_GLTEXRENDERBUFFERNV)_getPrivateProcAddress(_name);
        if (!_glTexRenderbufferNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexRenderbufferNV_ptr(target, renderbuffer);
}

typedef void (APIENTRY * PFN_GLBINDTRANSFORMFEEDBACKNV)(GLenum target, GLuint id);
static PFN_GLBINDTRANSFORMFEEDBACKNV _glBindTransformFeedbackNV_ptr = NULL;

static inline void APIENTRY _glBindTransformFeedbackNV(GLenum target, GLuint id) {
    const char *_name = "glBindTransformFeedbackNV";
    if (!_glBindTransformFeedbackNV_ptr) {
        _glBindTransformFeedbackNV_ptr = (PFN_GLBINDTRANSFORMFEEDBACKNV)_getPrivateProcAddress(_name);
        if (!_glBindTransformFeedbackNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindTransformFeedbackNV_ptr(target, id);
}

typedef void (APIENTRY * PFN_GLDELETETRANSFORMFEEDBACKSNV)(GLsizei n, const GLuint * ids);
static PFN_GLDELETETRANSFORMFEEDBACKSNV _glDeleteTransformFeedbacksNV_ptr = NULL;

static inline void APIENTRY _glDeleteTransformFeedbacksNV(GLsizei n, const GLuint * ids) {
    const char *_name = "glDeleteTransformFeedbacksNV";
    if (!_glDeleteTransformFeedbacksNV_ptr) {
        _glDeleteTransformFeedbacksNV_ptr = (PFN_GLDELETETRANSFORMFEEDBACKSNV)_getPrivateProcAddress(_name);
        if (!_glDeleteTransformFeedbacksNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteTransformFeedbacksNV_ptr(n, ids);
}

typedef void (APIENTRY * PFN_GLGENTRANSFORMFEEDBACKSNV)(GLsizei n, GLuint * ids);
static PFN_GLGENTRANSFORMFEEDBACKSNV _glGenTransformFeedbacksNV_ptr = NULL;

static inline void APIENTRY _glGenTransformFeedbacksNV(GLsizei n, GLuint * ids) {
    const char *_name = "glGenTransformFeedbacksNV";
    if (!_glGenTransformFeedbacksNV_ptr) {
        _glGenTransformFeedbacksNV_ptr = (PFN_GLGENTRANSFORMFEEDBACKSNV)_getPrivateProcAddress(_name);
        if (!_glGenTransformFeedbacksNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenTransformFeedbacksNV_ptr(n, ids);
}

typedef GLboolean (APIENTRY * PFN_GLISTRANSFORMFEEDBACKNV)(GLuint id);
static PFN_GLISTRANSFORMFEEDBACKNV _glIsTransformFeedbackNV_ptr = NULL;

static inline GLboolean APIENTRY _glIsTransformFeedbackNV(GLuint id) {
    const char *_name = "glIsTransformFeedbackNV";
    if (!_glIsTransformFeedbackNV_ptr) {
        _glIsTransformFeedbackNV_ptr = (PFN_GLISTRANSFORMFEEDBACKNV)_getPrivateProcAddress(_name);
        if (!_glIsTransformFeedbackNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsTransformFeedbackNV_ptr(id);
}

typedef void (APIENTRY * PFN_GLPAUSETRANSFORMFEEDBACKNV)(void);
static PFN_GLPAUSETRANSFORMFEEDBACKNV _glPauseTransformFeedbackNV_ptr = NULL;

static inline void APIENTRY _glPauseTransformFeedbackNV(void) {
    const char *_name = "glPauseTransformFeedbackNV";
    if (!_glPauseTransformFeedbackNV_ptr) {
        _glPauseTransformFeedbackNV_ptr = (PFN_GLPAUSETRANSFORMFEEDBACKNV)_getPrivateProcAddress(_name);
        if (!_glPauseTransformFeedbackNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPauseTransformFeedbackNV_ptr();
}

typedef void (APIENTRY * PFN_GLRESUMETRANSFORMFEEDBACKNV)(void);
static PFN_GLRESUMETRANSFORMFEEDBACKNV _glResumeTransformFeedbackNV_ptr = NULL;

static inline void APIENTRY _glResumeTransformFeedbackNV(void) {
    const char *_name = "glResumeTransformFeedbackNV";
    if (!_glResumeTransformFeedbackNV_ptr) {
        _glResumeTransformFeedbackNV_ptr = (PFN_GLRESUMETRANSFORMFEEDBACKNV)_getPrivateProcAddress(_name);
        if (!_glResumeTransformFeedbackNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glResumeTransformFeedbackNV_ptr();
}

typedef void (APIENTRY * PFN_GLDRAWTRANSFORMFEEDBACKNV)(GLenum mode, GLuint id);
static PFN_GLDRAWTRANSFORMFEEDBACKNV _glDrawTransformFeedbackNV_ptr = NULL;

static inline void APIENTRY _glDrawTransformFeedbackNV(GLenum mode, GLuint id) {
    const char *_name = "glDrawTransformFeedbackNV";
    if (!_glDrawTransformFeedbackNV_ptr) {
        _glDrawTransformFeedbackNV_ptr = (PFN_GLDRAWTRANSFORMFEEDBACKNV)_getPrivateProcAddress(_name);
        if (!_glDrawTransformFeedbackNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawTransformFeedbackNV_ptr(mode, id);
}

typedef void (APIENTRY * PFN_GLGETPERFMONITORGROUPSAMD)(GLint * numGroups, GLsizei groupsSize, GLuint * groups);
static PFN_GLGETPERFMONITORGROUPSAMD _glGetPerfMonitorGroupsAMD_ptr = NULL;

static inline void APIENTRY _glGetPerfMonitorGroupsAMD(GLint * numGroups, GLsizei groupsSize, GLuint * groups) {
    const char *_name = "glGetPerfMonitorGroupsAMD";
    if (!_glGetPerfMonitorGroupsAMD_ptr) {
        _glGetPerfMonitorGroupsAMD_ptr = (PFN_GLGETPERFMONITORGROUPSAMD)_getPrivateProcAddress(_name);
        if (!_glGetPerfMonitorGroupsAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPerfMonitorGroupsAMD_ptr(numGroups, groupsSize, groups);
}

typedef void (APIENTRY * PFN_GLGETPERFMONITORCOUNTERSAMD)(GLuint group, GLint * numCounters, GLint * maxActiveCounters, GLsizei counterSize, GLuint * counters);
static PFN_GLGETPERFMONITORCOUNTERSAMD _glGetPerfMonitorCountersAMD_ptr = NULL;

static inline void APIENTRY _glGetPerfMonitorCountersAMD(GLuint group, GLint * numCounters, GLint * maxActiveCounters, GLsizei counterSize, GLuint * counters) {
    const char *_name = "glGetPerfMonitorCountersAMD";
    if (!_glGetPerfMonitorCountersAMD_ptr) {
        _glGetPerfMonitorCountersAMD_ptr = (PFN_GLGETPERFMONITORCOUNTERSAMD)_getPrivateProcAddress(_name);
        if (!_glGetPerfMonitorCountersAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPerfMonitorCountersAMD_ptr(group, numCounters, maxActiveCounters, counterSize, counters);
}

typedef void (APIENTRY * PFN_GLGETPERFMONITORGROUPSTRINGAMD)(GLuint group, GLsizei bufSize, GLsizei * length, GLchar * groupString);
static PFN_GLGETPERFMONITORGROUPSTRINGAMD _glGetPerfMonitorGroupStringAMD_ptr = NULL;

static inline void APIENTRY _glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei * length, GLchar * groupString) {
    const char *_name = "glGetPerfMonitorGroupStringAMD";
    if (!_glGetPerfMonitorGroupStringAMD_ptr) {
        _glGetPerfMonitorGroupStringAMD_ptr = (PFN_GLGETPERFMONITORGROUPSTRINGAMD)_getPrivateProcAddress(_name);
        if (!_glGetPerfMonitorGroupStringAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPerfMonitorGroupStringAMD_ptr(group, bufSize, length, groupString);
}

typedef void (APIENTRY * PFN_GLGETPERFMONITORCOUNTERSTRINGAMD)(GLuint group, GLuint counter, GLsizei bufSize, GLsizei * length, GLchar * counterString);
static PFN_GLGETPERFMONITORCOUNTERSTRINGAMD _glGetPerfMonitorCounterStringAMD_ptr = NULL;

static inline void APIENTRY _glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei * length, GLchar * counterString) {
    const char *_name = "glGetPerfMonitorCounterStringAMD";
    if (!_glGetPerfMonitorCounterStringAMD_ptr) {
        _glGetPerfMonitorCounterStringAMD_ptr = (PFN_GLGETPERFMONITORCOUNTERSTRINGAMD)_getPrivateProcAddress(_name);
        if (!_glGetPerfMonitorCounterStringAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPerfMonitorCounterStringAMD_ptr(group, counter, bufSize, length, counterString);
}

typedef void (APIENTRY * PFN_GLGETPERFMONITORCOUNTERINFOAMD)(GLuint group, GLuint counter, GLenum pname, GLvoid * data);
static PFN_GLGETPERFMONITORCOUNTERINFOAMD _glGetPerfMonitorCounterInfoAMD_ptr = NULL;

static inline void APIENTRY _glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid * data) {
    const char *_name = "glGetPerfMonitorCounterInfoAMD";
    if (!_glGetPerfMonitorCounterInfoAMD_ptr) {
        _glGetPerfMonitorCounterInfoAMD_ptr = (PFN_GLGETPERFMONITORCOUNTERINFOAMD)_getPrivateProcAddress(_name);
        if (!_glGetPerfMonitorCounterInfoAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPerfMonitorCounterInfoAMD_ptr(group, counter, pname, data);
}

typedef void (APIENTRY * PFN_GLGENPERFMONITORSAMD)(GLsizei n, GLuint * monitors);
static PFN_GLGENPERFMONITORSAMD _glGenPerfMonitorsAMD_ptr = NULL;

static inline void APIENTRY _glGenPerfMonitorsAMD(GLsizei n, GLuint * monitors) {
    const char *_name = "glGenPerfMonitorsAMD";
    if (!_glGenPerfMonitorsAMD_ptr) {
        _glGenPerfMonitorsAMD_ptr = (PFN_GLGENPERFMONITORSAMD)_getPrivateProcAddress(_name);
        if (!_glGenPerfMonitorsAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenPerfMonitorsAMD_ptr(n, monitors);
}

typedef void (APIENTRY * PFN_GLDELETEPERFMONITORSAMD)(GLsizei n, GLuint * monitors);
static PFN_GLDELETEPERFMONITORSAMD _glDeletePerfMonitorsAMD_ptr = NULL;

static inline void APIENTRY _glDeletePerfMonitorsAMD(GLsizei n, GLuint * monitors) {
    const char *_name = "glDeletePerfMonitorsAMD";
    if (!_glDeletePerfMonitorsAMD_ptr) {
        _glDeletePerfMonitorsAMD_ptr = (PFN_GLDELETEPERFMONITORSAMD)_getPrivateProcAddress(_name);
        if (!_glDeletePerfMonitorsAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeletePerfMonitorsAMD_ptr(n, monitors);
}

typedef void (APIENTRY * PFN_GLSELECTPERFMONITORCOUNTERSAMD)(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint * counterList);
static PFN_GLSELECTPERFMONITORCOUNTERSAMD _glSelectPerfMonitorCountersAMD_ptr = NULL;

static inline void APIENTRY _glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint * counterList) {
    const char *_name = "glSelectPerfMonitorCountersAMD";
    if (!_glSelectPerfMonitorCountersAMD_ptr) {
        _glSelectPerfMonitorCountersAMD_ptr = (PFN_GLSELECTPERFMONITORCOUNTERSAMD)_getPrivateProcAddress(_name);
        if (!_glSelectPerfMonitorCountersAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSelectPerfMonitorCountersAMD_ptr(monitor, enable, group, numCounters, counterList);
}

typedef void (APIENTRY * PFN_GLBEGINPERFMONITORAMD)(GLuint monitor);
static PFN_GLBEGINPERFMONITORAMD _glBeginPerfMonitorAMD_ptr = NULL;

static inline void APIENTRY _glBeginPerfMonitorAMD(GLuint monitor) {
    const char *_name = "glBeginPerfMonitorAMD";
    if (!_glBeginPerfMonitorAMD_ptr) {
        _glBeginPerfMonitorAMD_ptr = (PFN_GLBEGINPERFMONITORAMD)_getPrivateProcAddress(_name);
        if (!_glBeginPerfMonitorAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginPerfMonitorAMD_ptr(monitor);
}

typedef void (APIENTRY * PFN_GLENDPERFMONITORAMD)(GLuint monitor);
static PFN_GLENDPERFMONITORAMD _glEndPerfMonitorAMD_ptr = NULL;

static inline void APIENTRY _glEndPerfMonitorAMD(GLuint monitor) {
    const char *_name = "glEndPerfMonitorAMD";
    if (!_glEndPerfMonitorAMD_ptr) {
        _glEndPerfMonitorAMD_ptr = (PFN_GLENDPERFMONITORAMD)_getPrivateProcAddress(_name);
        if (!_glEndPerfMonitorAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndPerfMonitorAMD_ptr(monitor);
}

typedef void (APIENTRY * PFN_GLGETPERFMONITORCOUNTERDATAAMD)(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint * data, GLint * bytesWritten);
static PFN_GLGETPERFMONITORCOUNTERDATAAMD _glGetPerfMonitorCounterDataAMD_ptr = NULL;

static inline void APIENTRY _glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint * data, GLint * bytesWritten) {
    const char *_name = "glGetPerfMonitorCounterDataAMD";
    if (!_glGetPerfMonitorCounterDataAMD_ptr) {
        _glGetPerfMonitorCounterDataAMD_ptr = (PFN_GLGETPERFMONITORCOUNTERDATAAMD)_getPrivateProcAddress(_name);
        if (!_glGetPerfMonitorCounterDataAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetPerfMonitorCounterDataAMD_ptr(monitor, pname, dataSize, data, bytesWritten);
}

typedef void (APIENTRY * PFN_GLTESSELLATIONFACTORAMD)(GLfloat factor);
static PFN_GLTESSELLATIONFACTORAMD _glTessellationFactorAMD_ptr = NULL;

static inline void APIENTRY _glTessellationFactorAMD(GLfloat factor) {
    const char *_name = "glTessellationFactorAMD";
    if (!_glTessellationFactorAMD_ptr) {
        _glTessellationFactorAMD_ptr = (PFN_GLTESSELLATIONFACTORAMD)_getPrivateProcAddress(_name);
        if (!_glTessellationFactorAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTessellationFactorAMD_ptr(factor);
}

typedef void (APIENTRY * PFN_GLTESSELLATIONMODEAMD)(GLenum mode);
static PFN_GLTESSELLATIONMODEAMD _glTessellationModeAMD_ptr = NULL;

static inline void APIENTRY _glTessellationModeAMD(GLenum mode) {
    const char *_name = "glTessellationModeAMD";
    if (!_glTessellationModeAMD_ptr) {
        _glTessellationModeAMD_ptr = (PFN_GLTESSELLATIONMODEAMD)_getPrivateProcAddress(_name);
        if (!_glTessellationModeAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTessellationModeAMD_ptr(mode);
}

typedef void (APIENTRY * PFN_GLPROVOKINGVERTEXEXT)(GLenum mode);
static PFN_GLPROVOKINGVERTEXEXT _glProvokingVertexEXT_ptr = NULL;

static inline void APIENTRY _glProvokingVertexEXT(GLenum mode) {
    const char *_name = "glProvokingVertexEXT";
    if (!_glProvokingVertexEXT_ptr) {
        _glProvokingVertexEXT_ptr = (PFN_GLPROVOKINGVERTEXEXT)_getPrivateProcAddress(_name);
        if (!_glProvokingVertexEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProvokingVertexEXT_ptr(mode);
}

typedef void (APIENTRY * PFN_GLBLENDFUNCINDEXEDAMD)(GLuint buf, GLenum src, GLenum dst);
static PFN_GLBLENDFUNCINDEXEDAMD _glBlendFuncIndexedAMD_ptr = NULL;

static inline void APIENTRY _glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst) {
    const char *_name = "glBlendFuncIndexedAMD";
    if (!_glBlendFuncIndexedAMD_ptr) {
        _glBlendFuncIndexedAMD_ptr = (PFN_GLBLENDFUNCINDEXEDAMD)_getPrivateProcAddress(_name);
        if (!_glBlendFuncIndexedAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendFuncIndexedAMD_ptr(buf, src, dst);
}

typedef void (APIENTRY * PFN_GLBLENDFUNCSEPARATEINDEXEDAMD)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
static PFN_GLBLENDFUNCSEPARATEINDEXEDAMD _glBlendFuncSeparateIndexedAMD_ptr = NULL;

static inline void APIENTRY _glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) {
    const char *_name = "glBlendFuncSeparateIndexedAMD";
    if (!_glBlendFuncSeparateIndexedAMD_ptr) {
        _glBlendFuncSeparateIndexedAMD_ptr = (PFN_GLBLENDFUNCSEPARATEINDEXEDAMD)_getPrivateProcAddress(_name);
        if (!_glBlendFuncSeparateIndexedAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendFuncSeparateIndexedAMD_ptr(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

typedef void (APIENTRY * PFN_GLBLENDEQUATIONINDEXEDAMD)(GLuint buf, GLenum mode);
static PFN_GLBLENDEQUATIONINDEXEDAMD _glBlendEquationIndexedAMD_ptr = NULL;

static inline void APIENTRY _glBlendEquationIndexedAMD(GLuint buf, GLenum mode) {
    const char *_name = "glBlendEquationIndexedAMD";
    if (!_glBlendEquationIndexedAMD_ptr) {
        _glBlendEquationIndexedAMD_ptr = (PFN_GLBLENDEQUATIONINDEXEDAMD)_getPrivateProcAddress(_name);
        if (!_glBlendEquationIndexedAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendEquationIndexedAMD_ptr(buf, mode);
}

typedef void (APIENTRY * PFN_GLBLENDEQUATIONSEPARATEINDEXEDAMD)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
static PFN_GLBLENDEQUATIONSEPARATEINDEXEDAMD _glBlendEquationSeparateIndexedAMD_ptr = NULL;

static inline void APIENTRY _glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha) {
    const char *_name = "glBlendEquationSeparateIndexedAMD";
    if (!_glBlendEquationSeparateIndexedAMD_ptr) {
        _glBlendEquationSeparateIndexedAMD_ptr = (PFN_GLBLENDEQUATIONSEPARATEINDEXEDAMD)_getPrivateProcAddress(_name);
        if (!_glBlendEquationSeparateIndexedAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendEquationSeparateIndexedAMD_ptr(buf, modeRGB, modeAlpha);
}

typedef void (APIENTRY * PFN_GLTEXTURERANGEAPPLE)(GLenum target, GLsizei length, const GLvoid * pointer);
static PFN_GLTEXTURERANGEAPPLE _glTextureRangeAPPLE_ptr = NULL;

static inline void APIENTRY _glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid * pointer) {
    const char *_name = "glTextureRangeAPPLE";
    if (!_glTextureRangeAPPLE_ptr) {
        _glTextureRangeAPPLE_ptr = (PFN_GLTEXTURERANGEAPPLE)_getPrivateProcAddress(_name);
        if (!_glTextureRangeAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureRangeAPPLE_ptr(target, length, pointer);
}

typedef void (APIENTRY * PFN_GLGETTEXPARAMETERPOINTERVAPPLE)(GLenum target, GLenum pname, GLvoid * * params);
static PFN_GLGETTEXPARAMETERPOINTERVAPPLE _glGetTexParameterPointervAPPLE_ptr = NULL;

static inline void APIENTRY _glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid * * params) {
    const char *_name = "glGetTexParameterPointervAPPLE";
    if (!_glGetTexParameterPointervAPPLE_ptr) {
        _glGetTexParameterPointervAPPLE_ptr = (PFN_GLGETTEXPARAMETERPOINTERVAPPLE)_getPrivateProcAddress(_name);
        if (!_glGetTexParameterPointervAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexParameterPointervAPPLE_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLENABLEVERTEXATTRIBAPPLE)(GLuint index, GLenum pname);
static PFN_GLENABLEVERTEXATTRIBAPPLE _glEnableVertexAttribAPPLE_ptr = NULL;

static inline void APIENTRY _glEnableVertexAttribAPPLE(GLuint index, GLenum pname) {
    const char *_name = "glEnableVertexAttribAPPLE";
    if (!_glEnableVertexAttribAPPLE_ptr) {
        _glEnableVertexAttribAPPLE_ptr = (PFN_GLENABLEVERTEXATTRIBAPPLE)_getPrivateProcAddress(_name);
        if (!_glEnableVertexAttribAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEnableVertexAttribAPPLE_ptr(index, pname);
}

typedef void (APIENTRY * PFN_GLDISABLEVERTEXATTRIBAPPLE)(GLuint index, GLenum pname);
static PFN_GLDISABLEVERTEXATTRIBAPPLE _glDisableVertexAttribAPPLE_ptr = NULL;

static inline void APIENTRY _glDisableVertexAttribAPPLE(GLuint index, GLenum pname) {
    const char *_name = "glDisableVertexAttribAPPLE";
    if (!_glDisableVertexAttribAPPLE_ptr) {
        _glDisableVertexAttribAPPLE_ptr = (PFN_GLDISABLEVERTEXATTRIBAPPLE)_getPrivateProcAddress(_name);
        if (!_glDisableVertexAttribAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDisableVertexAttribAPPLE_ptr(index, pname);
}

typedef GLboolean (APIENTRY * PFN_GLISVERTEXATTRIBENABLEDAPPLE)(GLuint index, GLenum pname);
static PFN_GLISVERTEXATTRIBENABLEDAPPLE _glIsVertexAttribEnabledAPPLE_ptr = NULL;

static inline GLboolean APIENTRY _glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname) {
    const char *_name = "glIsVertexAttribEnabledAPPLE";
    if (!_glIsVertexAttribEnabledAPPLE_ptr) {
        _glIsVertexAttribEnabledAPPLE_ptr = (PFN_GLISVERTEXATTRIBENABLEDAPPLE)_getPrivateProcAddress(_name);
        if (!_glIsVertexAttribEnabledAPPLE_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsVertexAttribEnabledAPPLE_ptr(index, pname);
}

typedef void (APIENTRY * PFN_GLMAPVERTEXATTRIB1DAPPLE)(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points);
static PFN_GLMAPVERTEXATTRIB1DAPPLE _glMapVertexAttrib1dAPPLE_ptr = NULL;

static inline void APIENTRY _glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points) {
    const char *_name = "glMapVertexAttrib1dAPPLE";
    if (!_glMapVertexAttrib1dAPPLE_ptr) {
        _glMapVertexAttrib1dAPPLE_ptr = (PFN_GLMAPVERTEXATTRIB1DAPPLE)_getPrivateProcAddress(_name);
        if (!_glMapVertexAttrib1dAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMapVertexAttrib1dAPPLE_ptr(index, size, u1, u2, stride, order, points);
}

typedef void (APIENTRY * PFN_GLMAPVERTEXATTRIB1FAPPLE)(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points);
static PFN_GLMAPVERTEXATTRIB1FAPPLE _glMapVertexAttrib1fAPPLE_ptr = NULL;

static inline void APIENTRY _glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points) {
    const char *_name = "glMapVertexAttrib1fAPPLE";
    if (!_glMapVertexAttrib1fAPPLE_ptr) {
        _glMapVertexAttrib1fAPPLE_ptr = (PFN_GLMAPVERTEXATTRIB1FAPPLE)_getPrivateProcAddress(_name);
        if (!_glMapVertexAttrib1fAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMapVertexAttrib1fAPPLE_ptr(index, size, u1, u2, stride, order, points);
}

typedef void (APIENTRY * PFN_GLMAPVERTEXATTRIB2DAPPLE)(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points);
static PFN_GLMAPVERTEXATTRIB2DAPPLE _glMapVertexAttrib2dAPPLE_ptr = NULL;

static inline void APIENTRY _glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points) {
    const char *_name = "glMapVertexAttrib2dAPPLE";
    if (!_glMapVertexAttrib2dAPPLE_ptr) {
        _glMapVertexAttrib2dAPPLE_ptr = (PFN_GLMAPVERTEXATTRIB2DAPPLE)_getPrivateProcAddress(_name);
        if (!_glMapVertexAttrib2dAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMapVertexAttrib2dAPPLE_ptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

typedef void (APIENTRY * PFN_GLMAPVERTEXATTRIB2FAPPLE)(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points);
static PFN_GLMAPVERTEXATTRIB2FAPPLE _glMapVertexAttrib2fAPPLE_ptr = NULL;

static inline void APIENTRY _glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points) {
    const char *_name = "glMapVertexAttrib2fAPPLE";
    if (!_glMapVertexAttrib2fAPPLE_ptr) {
        _glMapVertexAttrib2fAPPLE_ptr = (PFN_GLMAPVERTEXATTRIB2FAPPLE)_getPrivateProcAddress(_name);
        if (!_glMapVertexAttrib2fAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMapVertexAttrib2fAPPLE_ptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

typedef GLenum (APIENTRY * PFN_GLOBJECTPURGEABLEAPPLE)(GLenum objectType, GLuint name, GLenum option);
static PFN_GLOBJECTPURGEABLEAPPLE _glObjectPurgeableAPPLE_ptr = NULL;

static inline GLenum APIENTRY _glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option) {
    const char *_name = "glObjectPurgeableAPPLE";
    if (!_glObjectPurgeableAPPLE_ptr) {
        _glObjectPurgeableAPPLE_ptr = (PFN_GLOBJECTPURGEABLEAPPLE)_getPrivateProcAddress(_name);
        if (!_glObjectPurgeableAPPLE_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glObjectPurgeableAPPLE_ptr(objectType, name, option);
}

typedef GLenum (APIENTRY * PFN_GLOBJECTUNPURGEABLEAPPLE)(GLenum objectType, GLuint name, GLenum option);
static PFN_GLOBJECTUNPURGEABLEAPPLE _glObjectUnpurgeableAPPLE_ptr = NULL;

static inline GLenum APIENTRY _glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option) {
    const char *_name = "glObjectUnpurgeableAPPLE";
    if (!_glObjectUnpurgeableAPPLE_ptr) {
        _glObjectUnpurgeableAPPLE_ptr = (PFN_GLOBJECTUNPURGEABLEAPPLE)_getPrivateProcAddress(_name);
        if (!_glObjectUnpurgeableAPPLE_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glObjectUnpurgeableAPPLE_ptr(objectType, name, option);
}

typedef void (APIENTRY * PFN_GLGETOBJECTPARAMETERIVAPPLE)(GLenum objectType, GLuint name, GLenum pname, GLint * params);
static PFN_GLGETOBJECTPARAMETERIVAPPLE _glGetObjectParameterivAPPLE_ptr = NULL;

static inline void APIENTRY _glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint * params) {
    const char *_name = "glGetObjectParameterivAPPLE";
    if (!_glGetObjectParameterivAPPLE_ptr) {
        _glGetObjectParameterivAPPLE_ptr = (PFN_GLGETOBJECTPARAMETERIVAPPLE)_getPrivateProcAddress(_name);
        if (!_glGetObjectParameterivAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetObjectParameterivAPPLE_ptr(objectType, name, pname, params);
}

typedef void (APIENTRY * PFN_GLBEGINVIDEOCAPTURENV)(GLuint video_capture_slot);
static PFN_GLBEGINVIDEOCAPTURENV _glBeginVideoCaptureNV_ptr = NULL;

static inline void APIENTRY _glBeginVideoCaptureNV(GLuint video_capture_slot) {
    const char *_name = "glBeginVideoCaptureNV";
    if (!_glBeginVideoCaptureNV_ptr) {
        _glBeginVideoCaptureNV_ptr = (PFN_GLBEGINVIDEOCAPTURENV)_getPrivateProcAddress(_name);
        if (!_glBeginVideoCaptureNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginVideoCaptureNV_ptr(video_capture_slot);
}

typedef void (APIENTRY * PFN_GLBINDVIDEOCAPTURESTREAMBUFFERNV)(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
static PFN_GLBINDVIDEOCAPTURESTREAMBUFFERNV _glBindVideoCaptureStreamBufferNV_ptr = NULL;

static inline void APIENTRY _glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset) {
    const char *_name = "glBindVideoCaptureStreamBufferNV";
    if (!_glBindVideoCaptureStreamBufferNV_ptr) {
        _glBindVideoCaptureStreamBufferNV_ptr = (PFN_GLBINDVIDEOCAPTURESTREAMBUFFERNV)_getPrivateProcAddress(_name);
        if (!_glBindVideoCaptureStreamBufferNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindVideoCaptureStreamBufferNV_ptr(video_capture_slot, stream, frame_region, offset);
}

typedef void (APIENTRY * PFN_GLBINDVIDEOCAPTURESTREAMTEXTURENV)(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
static PFN_GLBINDVIDEOCAPTURESTREAMTEXTURENV _glBindVideoCaptureStreamTextureNV_ptr = NULL;

static inline void APIENTRY _glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture) {
    const char *_name = "glBindVideoCaptureStreamTextureNV";
    if (!_glBindVideoCaptureStreamTextureNV_ptr) {
        _glBindVideoCaptureStreamTextureNV_ptr = (PFN_GLBINDVIDEOCAPTURESTREAMTEXTURENV)_getPrivateProcAddress(_name);
        if (!_glBindVideoCaptureStreamTextureNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindVideoCaptureStreamTextureNV_ptr(video_capture_slot, stream, frame_region, target, texture);
}

typedef void (APIENTRY * PFN_GLENDVIDEOCAPTURENV)(GLuint video_capture_slot);
static PFN_GLENDVIDEOCAPTURENV _glEndVideoCaptureNV_ptr = NULL;

static inline void APIENTRY _glEndVideoCaptureNV(GLuint video_capture_slot) {
    const char *_name = "glEndVideoCaptureNV";
    if (!_glEndVideoCaptureNV_ptr) {
        _glEndVideoCaptureNV_ptr = (PFN_GLENDVIDEOCAPTURENV)_getPrivateProcAddress(_name);
        if (!_glEndVideoCaptureNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndVideoCaptureNV_ptr(video_capture_slot);
}

typedef void (APIENTRY * PFN_GLGETVIDEOCAPTUREIVNV)(GLuint video_capture_slot, GLenum pname, GLint * params);
static PFN_GLGETVIDEOCAPTUREIVNV _glGetVideoCaptureivNV_ptr = NULL;

static inline void APIENTRY _glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint * params) {
    const char *_name = "glGetVideoCaptureivNV";
    if (!_glGetVideoCaptureivNV_ptr) {
        _glGetVideoCaptureivNV_ptr = (PFN_GLGETVIDEOCAPTUREIVNV)_getPrivateProcAddress(_name);
        if (!_glGetVideoCaptureivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVideoCaptureivNV_ptr(video_capture_slot, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVIDEOCAPTURESTREAMIVNV)(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint * params);
static PFN_GLGETVIDEOCAPTURESTREAMIVNV _glGetVideoCaptureStreamivNV_ptr = NULL;

static inline void APIENTRY _glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint * params) {
    const char *_name = "glGetVideoCaptureStreamivNV";
    if (!_glGetVideoCaptureStreamivNV_ptr) {
        _glGetVideoCaptureStreamivNV_ptr = (PFN_GLGETVIDEOCAPTURESTREAMIVNV)_getPrivateProcAddress(_name);
        if (!_glGetVideoCaptureStreamivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVideoCaptureStreamivNV_ptr(video_capture_slot, stream, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVIDEOCAPTURESTREAMFVNV)(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat * params);
static PFN_GLGETVIDEOCAPTURESTREAMFVNV _glGetVideoCaptureStreamfvNV_ptr = NULL;

static inline void APIENTRY _glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat * params) {
    const char *_name = "glGetVideoCaptureStreamfvNV";
    if (!_glGetVideoCaptureStreamfvNV_ptr) {
        _glGetVideoCaptureStreamfvNV_ptr = (PFN_GLGETVIDEOCAPTURESTREAMFVNV)_getPrivateProcAddress(_name);
        if (!_glGetVideoCaptureStreamfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVideoCaptureStreamfvNV_ptr(video_capture_slot, stream, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVIDEOCAPTURESTREAMDVNV)(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble * params);
static PFN_GLGETVIDEOCAPTURESTREAMDVNV _glGetVideoCaptureStreamdvNV_ptr = NULL;

static inline void APIENTRY _glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble * params) {
    const char *_name = "glGetVideoCaptureStreamdvNV";
    if (!_glGetVideoCaptureStreamdvNV_ptr) {
        _glGetVideoCaptureStreamdvNV_ptr = (PFN_GLGETVIDEOCAPTURESTREAMDVNV)_getPrivateProcAddress(_name);
        if (!_glGetVideoCaptureStreamdvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVideoCaptureStreamdvNV_ptr(video_capture_slot, stream, pname, params);
}

typedef GLenum (APIENTRY * PFN_GLVIDEOCAPTURENV)(GLuint video_capture_slot, GLuint * sequence_num, GLuint64EXT * capture_time);
static PFN_GLVIDEOCAPTURENV _glVideoCaptureNV_ptr = NULL;

static inline GLenum APIENTRY _glVideoCaptureNV(GLuint video_capture_slot, GLuint * sequence_num, GLuint64EXT * capture_time) {
    const char *_name = "glVideoCaptureNV";
    if (!_glVideoCaptureNV_ptr) {
        _glVideoCaptureNV_ptr = (PFN_GLVIDEOCAPTURENV)_getPrivateProcAddress(_name);
        if (!_glVideoCaptureNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glVideoCaptureNV_ptr(video_capture_slot, sequence_num, capture_time);
}

typedef void (APIENTRY * PFN_GLVIDEOCAPTURESTREAMPARAMETERIVNV)(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint * params);
static PFN_GLVIDEOCAPTURESTREAMPARAMETERIVNV _glVideoCaptureStreamParameterivNV_ptr = NULL;

static inline void APIENTRY _glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint * params) {
    const char *_name = "glVideoCaptureStreamParameterivNV";
    if (!_glVideoCaptureStreamParameterivNV_ptr) {
        _glVideoCaptureStreamParameterivNV_ptr = (PFN_GLVIDEOCAPTURESTREAMPARAMETERIVNV)_getPrivateProcAddress(_name);
        if (!_glVideoCaptureStreamParameterivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVideoCaptureStreamParameterivNV_ptr(video_capture_slot, stream, pname, params);
}

typedef void (APIENTRY * PFN_GLVIDEOCAPTURESTREAMPARAMETERFVNV)(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat * params);
static PFN_GLVIDEOCAPTURESTREAMPARAMETERFVNV _glVideoCaptureStreamParameterfvNV_ptr = NULL;

static inline void APIENTRY _glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat * params) {
    const char *_name = "glVideoCaptureStreamParameterfvNV";
    if (!_glVideoCaptureStreamParameterfvNV_ptr) {
        _glVideoCaptureStreamParameterfvNV_ptr = (PFN_GLVIDEOCAPTURESTREAMPARAMETERFVNV)_getPrivateProcAddress(_name);
        if (!_glVideoCaptureStreamParameterfvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVideoCaptureStreamParameterfvNV_ptr(video_capture_slot, stream, pname, params);
}

typedef void (APIENTRY * PFN_GLVIDEOCAPTURESTREAMPARAMETERDVNV)(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble * params);
static PFN_GLVIDEOCAPTURESTREAMPARAMETERDVNV _glVideoCaptureStreamParameterdvNV_ptr = NULL;

static inline void APIENTRY _glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble * params) {
    const char *_name = "glVideoCaptureStreamParameterdvNV";
    if (!_glVideoCaptureStreamParameterdvNV_ptr) {
        _glVideoCaptureStreamParameterdvNV_ptr = (PFN_GLVIDEOCAPTURESTREAMPARAMETERDVNV)_getPrivateProcAddress(_name);
        if (!_glVideoCaptureStreamParameterdvNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVideoCaptureStreamParameterdvNV_ptr(video_capture_slot, stream, pname, params);
}

typedef void (APIENTRY * PFN_GLCOPYIMAGESUBDATANV)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
static PFN_GLCOPYIMAGESUBDATANV _glCopyImageSubDataNV_ptr = NULL;

static inline void APIENTRY _glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) {
    const char *_name = "glCopyImageSubDataNV";
    if (!_glCopyImageSubDataNV_ptr) {
        _glCopyImageSubDataNV_ptr = (PFN_GLCOPYIMAGESUBDATANV)_getPrivateProcAddress(_name);
        if (!_glCopyImageSubDataNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyImageSubDataNV_ptr(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
}

typedef void (APIENTRY * PFN_GLUSESHADERPROGRAMEXT)(GLenum type, GLuint program);
static PFN_GLUSESHADERPROGRAMEXT _glUseShaderProgramEXT_ptr = NULL;

static inline void APIENTRY _glUseShaderProgramEXT(GLenum type, GLuint program) {
    const char *_name = "glUseShaderProgramEXT";
    if (!_glUseShaderProgramEXT_ptr) {
        _glUseShaderProgramEXT_ptr = (PFN_GLUSESHADERPROGRAMEXT)_getPrivateProcAddress(_name);
        if (!_glUseShaderProgramEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUseShaderProgramEXT_ptr(type, program);
}

typedef void (APIENTRY * PFN_GLACTIVEPROGRAMEXT)(GLuint program);
static PFN_GLACTIVEPROGRAMEXT _glActiveProgramEXT_ptr = NULL;

static inline void APIENTRY _glActiveProgramEXT(GLuint program) {
    const char *_name = "glActiveProgramEXT";
    if (!_glActiveProgramEXT_ptr) {
        _glActiveProgramEXT_ptr = (PFN_GLACTIVEPROGRAMEXT)_getPrivateProcAddress(_name);
        if (!_glActiveProgramEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glActiveProgramEXT_ptr(program);
}

typedef GLuint (APIENTRY * PFN_GLCREATESHADERPROGRAMEXT)(GLenum type, const GLchar * string);
static PFN_GLCREATESHADERPROGRAMEXT _glCreateShaderProgramEXT_ptr = NULL;

static inline GLuint APIENTRY _glCreateShaderProgramEXT(GLenum type, const GLchar * string) {
    const char *_name = "glCreateShaderProgramEXT";
    if (!_glCreateShaderProgramEXT_ptr) {
        _glCreateShaderProgramEXT_ptr = (PFN_GLCREATESHADERPROGRAMEXT)_getPrivateProcAddress(_name);
        if (!_glCreateShaderProgramEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glCreateShaderProgramEXT_ptr(type, string);
}

typedef void (APIENTRY * PFN_GLMAKEBUFFERRESIDENTNV)(GLenum target, GLenum access);
static PFN_GLMAKEBUFFERRESIDENTNV _glMakeBufferResidentNV_ptr = NULL;

static inline void APIENTRY _glMakeBufferResidentNV(GLenum target, GLenum access) {
    const char *_name = "glMakeBufferResidentNV";
    if (!_glMakeBufferResidentNV_ptr) {
        _glMakeBufferResidentNV_ptr = (PFN_GLMAKEBUFFERRESIDENTNV)_getPrivateProcAddress(_name);
        if (!_glMakeBufferResidentNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMakeBufferResidentNV_ptr(target, access);
}

typedef void (APIENTRY * PFN_GLMAKEBUFFERNONRESIDENTNV)(GLenum target);
static PFN_GLMAKEBUFFERNONRESIDENTNV _glMakeBufferNonResidentNV_ptr = NULL;

static inline void APIENTRY _glMakeBufferNonResidentNV(GLenum target) {
    const char *_name = "glMakeBufferNonResidentNV";
    if (!_glMakeBufferNonResidentNV_ptr) {
        _glMakeBufferNonResidentNV_ptr = (PFN_GLMAKEBUFFERNONRESIDENTNV)_getPrivateProcAddress(_name);
        if (!_glMakeBufferNonResidentNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMakeBufferNonResidentNV_ptr(target);
}

typedef GLboolean (APIENTRY * PFN_GLISBUFFERRESIDENTNV)(GLenum target);
static PFN_GLISBUFFERRESIDENTNV _glIsBufferResidentNV_ptr = NULL;

static inline GLboolean APIENTRY _glIsBufferResidentNV(GLenum target) {
    const char *_name = "glIsBufferResidentNV";
    if (!_glIsBufferResidentNV_ptr) {
        _glIsBufferResidentNV_ptr = (PFN_GLISBUFFERRESIDENTNV)_getPrivateProcAddress(_name);
        if (!_glIsBufferResidentNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsBufferResidentNV_ptr(target);
}

typedef void (APIENTRY * PFN_GLMAKENAMEDBUFFERRESIDENTNV)(GLuint buffer, GLenum access);
static PFN_GLMAKENAMEDBUFFERRESIDENTNV _glMakeNamedBufferResidentNV_ptr = NULL;

static inline void APIENTRY _glMakeNamedBufferResidentNV(GLuint buffer, GLenum access) {
    const char *_name = "glMakeNamedBufferResidentNV";
    if (!_glMakeNamedBufferResidentNV_ptr) {
        _glMakeNamedBufferResidentNV_ptr = (PFN_GLMAKENAMEDBUFFERRESIDENTNV)_getPrivateProcAddress(_name);
        if (!_glMakeNamedBufferResidentNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMakeNamedBufferResidentNV_ptr(buffer, access);
}

typedef void (APIENTRY * PFN_GLMAKENAMEDBUFFERNONRESIDENTNV)(GLuint buffer);
static PFN_GLMAKENAMEDBUFFERNONRESIDENTNV _glMakeNamedBufferNonResidentNV_ptr = NULL;

static inline void APIENTRY _glMakeNamedBufferNonResidentNV(GLuint buffer) {
    const char *_name = "glMakeNamedBufferNonResidentNV";
    if (!_glMakeNamedBufferNonResidentNV_ptr) {
        _glMakeNamedBufferNonResidentNV_ptr = (PFN_GLMAKENAMEDBUFFERNONRESIDENTNV)_getPrivateProcAddress(_name);
        if (!_glMakeNamedBufferNonResidentNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMakeNamedBufferNonResidentNV_ptr(buffer);
}

typedef GLboolean (APIENTRY * PFN_GLISNAMEDBUFFERRESIDENTNV)(GLuint buffer);
static PFN_GLISNAMEDBUFFERRESIDENTNV _glIsNamedBufferResidentNV_ptr = NULL;

static inline GLboolean APIENTRY _glIsNamedBufferResidentNV(GLuint buffer) {
    const char *_name = "glIsNamedBufferResidentNV";
    if (!_glIsNamedBufferResidentNV_ptr) {
        _glIsNamedBufferResidentNV_ptr = (PFN_GLISNAMEDBUFFERRESIDENTNV)_getPrivateProcAddress(_name);
        if (!_glIsNamedBufferResidentNV_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsNamedBufferResidentNV_ptr(buffer);
}

typedef void (APIENTRY * PFN_GLGETBUFFERPARAMETERUI64VNV)(GLenum target, GLenum pname, GLuint64EXT * params);
static PFN_GLGETBUFFERPARAMETERUI64VNV _glGetBufferParameterui64vNV_ptr = NULL;

static inline void APIENTRY _glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT * params) {
    const char *_name = "glGetBufferParameterui64vNV";
    if (!_glGetBufferParameterui64vNV_ptr) {
        _glGetBufferParameterui64vNV_ptr = (PFN_GLGETBUFFERPARAMETERUI64VNV)_getPrivateProcAddress(_name);
        if (!_glGetBufferParameterui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetBufferParameterui64vNV_ptr(target, pname, params);
}

typedef void (APIENTRY * PFN_GLGETNAMEDBUFFERPARAMETERUI64VNV)(GLuint buffer, GLenum pname, GLuint64EXT * params);
static PFN_GLGETNAMEDBUFFERPARAMETERUI64VNV _glGetNamedBufferParameterui64vNV_ptr = NULL;

static inline void APIENTRY _glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT * params) {
    const char *_name = "glGetNamedBufferParameterui64vNV";
    if (!_glGetNamedBufferParameterui64vNV_ptr) {
        _glGetNamedBufferParameterui64vNV_ptr = (PFN_GLGETNAMEDBUFFERPARAMETERUI64VNV)_getPrivateProcAddress(_name);
        if (!_glGetNamedBufferParameterui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetNamedBufferParameterui64vNV_ptr(buffer, pname, params);
}

typedef void (APIENTRY * PFN_GLGETINTEGERUI64VNV)(GLenum value, GLuint64EXT * result);
static PFN_GLGETINTEGERUI64VNV _glGetIntegerui64vNV_ptr = NULL;

static inline void APIENTRY _glGetIntegerui64vNV(GLenum value, GLuint64EXT * result) {
    const char *_name = "glGetIntegerui64vNV";
    if (!_glGetIntegerui64vNV_ptr) {
        _glGetIntegerui64vNV_ptr = (PFN_GLGETINTEGERUI64VNV)_getPrivateProcAddress(_name);
        if (!_glGetIntegerui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetIntegerui64vNV_ptr(value, result);
}

typedef void (APIENTRY * PFN_GLUNIFORMUI64NV)(GLint location, GLuint64EXT value);
static PFN_GLUNIFORMUI64NV _glUniformui64NV_ptr = NULL;

static inline void APIENTRY _glUniformui64NV(GLint location, GLuint64EXT value) {
    const char *_name = "glUniformui64NV";
    if (!_glUniformui64NV_ptr) {
        _glUniformui64NV_ptr = (PFN_GLUNIFORMUI64NV)_getPrivateProcAddress(_name);
        if (!_glUniformui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformui64NV_ptr(location, value);
}

typedef void (APIENTRY * PFN_GLUNIFORMUI64VNV)(GLint location, GLsizei count, const GLuint64EXT * value);
static PFN_GLUNIFORMUI64VNV _glUniformui64vNV_ptr = NULL;

static inline void APIENTRY _glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glUniformui64vNV";
    if (!_glUniformui64vNV_ptr) {
        _glUniformui64vNV_ptr = (PFN_GLUNIFORMUI64VNV)_getPrivateProcAddress(_name);
        if (!_glUniformui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniformui64vNV_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLGETUNIFORMUI64VNV)(GLuint program, GLint location, GLuint64EXT * params);
static PFN_GLGETUNIFORMUI64VNV _glGetUniformui64vNV_ptr = NULL;

static inline void APIENTRY _glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT * params) {
    const char *_name = "glGetUniformui64vNV";
    if (!_glGetUniformui64vNV_ptr) {
        _glGetUniformui64vNV_ptr = (PFN_GLGETUNIFORMUI64VNV)_getPrivateProcAddress(_name);
        if (!_glGetUniformui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetUniformui64vNV_ptr(program, location, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMUI64NV)(GLuint program, GLint location, GLuint64EXT value);
static PFN_GLPROGRAMUNIFORMUI64NV _glProgramUniformui64NV_ptr = NULL;

static inline void APIENTRY _glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT value) {
    const char *_name = "glProgramUniformui64NV";
    if (!_glProgramUniformui64NV_ptr) {
        _glProgramUniformui64NV_ptr = (PFN_GLPROGRAMUNIFORMUI64NV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformui64NV_ptr(program, location, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORMUI64VNV)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
static PFN_GLPROGRAMUNIFORMUI64VNV _glProgramUniformui64vNV_ptr = NULL;

static inline void APIENTRY _glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glProgramUniformui64vNV";
    if (!_glProgramUniformui64vNV_ptr) {
        _glProgramUniformui64vNV_ptr = (PFN_GLPROGRAMUNIFORMUI64VNV)_getPrivateProcAddress(_name);
        if (!_glProgramUniformui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniformui64vNV_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLBUFFERADDRESSRANGENV)(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
static PFN_GLBUFFERADDRESSRANGENV _glBufferAddressRangeNV_ptr = NULL;

static inline void APIENTRY _glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length) {
    const char *_name = "glBufferAddressRangeNV";
    if (!_glBufferAddressRangeNV_ptr) {
        _glBufferAddressRangeNV_ptr = (PFN_GLBUFFERADDRESSRANGENV)_getPrivateProcAddress(_name);
        if (!_glBufferAddressRangeNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBufferAddressRangeNV_ptr(pname, index, address, length);
}

typedef void (APIENTRY * PFN_GLVERTEXFORMATNV)(GLint size, GLenum type, GLsizei stride);
static PFN_GLVERTEXFORMATNV _glVertexFormatNV_ptr = NULL;

static inline void APIENTRY _glVertexFormatNV(GLint size, GLenum type, GLsizei stride) {
    const char *_name = "glVertexFormatNV";
    if (!_glVertexFormatNV_ptr) {
        _glVertexFormatNV_ptr = (PFN_GLVERTEXFORMATNV)_getPrivateProcAddress(_name);
        if (!_glVertexFormatNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexFormatNV_ptr(size, type, stride);
}

typedef void (APIENTRY * PFN_GLNORMALFORMATNV)(GLenum type, GLsizei stride);
static PFN_GLNORMALFORMATNV _glNormalFormatNV_ptr = NULL;

static inline void APIENTRY _glNormalFormatNV(GLenum type, GLsizei stride) {
    const char *_name = "glNormalFormatNV";
    if (!_glNormalFormatNV_ptr) {
        _glNormalFormatNV_ptr = (PFN_GLNORMALFORMATNV)_getPrivateProcAddress(_name);
        if (!_glNormalFormatNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormalFormatNV_ptr(type, stride);
}

typedef void (APIENTRY * PFN_GLCOLORFORMATNV)(GLint size, GLenum type, GLsizei stride);
static PFN_GLCOLORFORMATNV _glColorFormatNV_ptr = NULL;

static inline void APIENTRY _glColorFormatNV(GLint size, GLenum type, GLsizei stride) {
    const char *_name = "glColorFormatNV";
    if (!_glColorFormatNV_ptr) {
        _glColorFormatNV_ptr = (PFN_GLCOLORFORMATNV)_getPrivateProcAddress(_name);
        if (!_glColorFormatNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColorFormatNV_ptr(size, type, stride);
}

typedef void (APIENTRY * PFN_GLINDEXFORMATNV)(GLenum type, GLsizei stride);
static PFN_GLINDEXFORMATNV _glIndexFormatNV_ptr = NULL;

static inline void APIENTRY _glIndexFormatNV(GLenum type, GLsizei stride) {
    const char *_name = "glIndexFormatNV";
    if (!_glIndexFormatNV_ptr) {
        _glIndexFormatNV_ptr = (PFN_GLINDEXFORMATNV)_getPrivateProcAddress(_name);
        if (!_glIndexFormatNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glIndexFormatNV_ptr(type, stride);
}

typedef void (APIENTRY * PFN_GLTEXCOORDFORMATNV)(GLint size, GLenum type, GLsizei stride);
static PFN_GLTEXCOORDFORMATNV _glTexCoordFormatNV_ptr = NULL;

static inline void APIENTRY _glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride) {
    const char *_name = "glTexCoordFormatNV";
    if (!_glTexCoordFormatNV_ptr) {
        _glTexCoordFormatNV_ptr = (PFN_GLTEXCOORDFORMATNV)_getPrivateProcAddress(_name);
        if (!_glTexCoordFormatNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexCoordFormatNV_ptr(size, type, stride);
}

typedef void (APIENTRY * PFN_GLEDGEFLAGFORMATNV)(GLsizei stride);
static PFN_GLEDGEFLAGFORMATNV _glEdgeFlagFormatNV_ptr = NULL;

static inline void APIENTRY _glEdgeFlagFormatNV(GLsizei stride) {
    const char *_name = "glEdgeFlagFormatNV";
    if (!_glEdgeFlagFormatNV_ptr) {
        _glEdgeFlagFormatNV_ptr = (PFN_GLEDGEFLAGFORMATNV)_getPrivateProcAddress(_name);
        if (!_glEdgeFlagFormatNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEdgeFlagFormatNV_ptr(stride);
}

typedef void (APIENTRY * PFN_GLSECONDARYCOLORFORMATNV)(GLint size, GLenum type, GLsizei stride);
static PFN_GLSECONDARYCOLORFORMATNV _glSecondaryColorFormatNV_ptr = NULL;

static inline void APIENTRY _glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride) {
    const char *_name = "glSecondaryColorFormatNV";
    if (!_glSecondaryColorFormatNV_ptr) {
        _glSecondaryColorFormatNV_ptr = (PFN_GLSECONDARYCOLORFORMATNV)_getPrivateProcAddress(_name);
        if (!_glSecondaryColorFormatNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSecondaryColorFormatNV_ptr(size, type, stride);
}

typedef void (APIENTRY * PFN_GLFOGCOORDFORMATNV)(GLenum type, GLsizei stride);
static PFN_GLFOGCOORDFORMATNV _glFogCoordFormatNV_ptr = NULL;

static inline void APIENTRY _glFogCoordFormatNV(GLenum type, GLsizei stride) {
    const char *_name = "glFogCoordFormatNV";
    if (!_glFogCoordFormatNV_ptr) {
        _glFogCoordFormatNV_ptr = (PFN_GLFOGCOORDFORMATNV)_getPrivateProcAddress(_name);
        if (!_glFogCoordFormatNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogCoordFormatNV_ptr(type, stride);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBFORMATNV)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
static PFN_GLVERTEXATTRIBFORMATNV _glVertexAttribFormatNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride) {
    const char *_name = "glVertexAttribFormatNV";
    if (!_glVertexAttribFormatNV_ptr) {
        _glVertexAttribFormatNV_ptr = (PFN_GLVERTEXATTRIBFORMATNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribFormatNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribFormatNV_ptr(index, size, type, normalized, stride);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBIFORMATNV)(GLuint index, GLint size, GLenum type, GLsizei stride);
static PFN_GLVERTEXATTRIBIFORMATNV _glVertexAttribIFormatNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride) {
    const char *_name = "glVertexAttribIFormatNV";
    if (!_glVertexAttribIFormatNV_ptr) {
        _glVertexAttribIFormatNV_ptr = (PFN_GLVERTEXATTRIBIFORMATNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribIFormatNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribIFormatNV_ptr(index, size, type, stride);
}

typedef void (APIENTRY * PFN_GLGETINTEGERUI64I_VNV)(GLenum value, GLuint index, GLuint64EXT * result);
static PFN_GLGETINTEGERUI64I_VNV _glGetIntegerui64i_vNV_ptr = NULL;

static inline void APIENTRY _glGetIntegerui64i_vNV(GLenum value, GLuint index, GLuint64EXT * result) {
    const char *_name = "glGetIntegerui64i_vNV";
    if (!_glGetIntegerui64i_vNV_ptr) {
        _glGetIntegerui64i_vNV_ptr = (PFN_GLGETINTEGERUI64I_VNV)_getPrivateProcAddress(_name);
        if (!_glGetIntegerui64i_vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetIntegerui64i_vNV_ptr(value, index, result);
}

typedef void (APIENTRY * PFN_GLTEXTUREBARRIERNV)(void);
static PFN_GLTEXTUREBARRIERNV _glTextureBarrierNV_ptr = NULL;

static inline void APIENTRY _glTextureBarrierNV(void) {
    const char *_name = "glTextureBarrierNV";
    if (!_glTextureBarrierNV_ptr) {
        _glTextureBarrierNV_ptr = (PFN_GLTEXTUREBARRIERNV)_getPrivateProcAddress(_name);
        if (!_glTextureBarrierNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureBarrierNV_ptr();
}

typedef void (APIENTRY * PFN_GLBINDIMAGETEXTUREEXT)(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
static PFN_GLBINDIMAGETEXTUREEXT _glBindImageTextureEXT_ptr = NULL;

static inline void APIENTRY _glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format) {
    const char *_name = "glBindImageTextureEXT";
    if (!_glBindImageTextureEXT_ptr) {
        _glBindImageTextureEXT_ptr = (PFN_GLBINDIMAGETEXTUREEXT)_getPrivateProcAddress(_name);
        if (!_glBindImageTextureEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindImageTextureEXT_ptr(index, texture, level, layered, layer, access, format);
}

typedef void (APIENTRY * PFN_GLMEMORYBARRIEREXT)(GLbitfield barriers);
static PFN_GLMEMORYBARRIEREXT _glMemoryBarrierEXT_ptr = NULL;

static inline void APIENTRY _glMemoryBarrierEXT(GLbitfield barriers) {
    const char *_name = "glMemoryBarrierEXT";
    if (!_glMemoryBarrierEXT_ptr) {
        _glMemoryBarrierEXT_ptr = (PFN_GLMEMORYBARRIEREXT)_getPrivateProcAddress(_name);
        if (!_glMemoryBarrierEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMemoryBarrierEXT_ptr(barriers);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL1DEXT)(GLuint index, GLdouble x);
static PFN_GLVERTEXATTRIBL1DEXT _glVertexAttribL1dEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribL1dEXT(GLuint index, GLdouble x) {
    const char *_name = "glVertexAttribL1dEXT";
    if (!_glVertexAttribL1dEXT_ptr) {
        _glVertexAttribL1dEXT_ptr = (PFN_GLVERTEXATTRIBL1DEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL1dEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL1dEXT_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL2DEXT)(GLuint index, GLdouble x, GLdouble y);
static PFN_GLVERTEXATTRIBL2DEXT _glVertexAttribL2dEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y) {
    const char *_name = "glVertexAttribL2dEXT";
    if (!_glVertexAttribL2dEXT_ptr) {
        _glVertexAttribL2dEXT_ptr = (PFN_GLVERTEXATTRIBL2DEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL2dEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL2dEXT_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL3DEXT)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
static PFN_GLVERTEXATTRIBL3DEXT _glVertexAttribL3dEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertexAttribL3dEXT";
    if (!_glVertexAttribL3dEXT_ptr) {
        _glVertexAttribL3dEXT_ptr = (PFN_GLVERTEXATTRIBL3DEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL3dEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL3dEXT_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL4DEXT)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
static PFN_GLVERTEXATTRIBL4DEXT _glVertexAttribL4dEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertexAttribL4dEXT";
    if (!_glVertexAttribL4dEXT_ptr) {
        _glVertexAttribL4dEXT_ptr = (PFN_GLVERTEXATTRIBL4DEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL4dEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL4dEXT_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL1DVEXT)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIBL1DVEXT _glVertexAttribL1dvEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribL1dvEXT(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL1dvEXT";
    if (!_glVertexAttribL1dvEXT_ptr) {
        _glVertexAttribL1dvEXT_ptr = (PFN_GLVERTEXATTRIBL1DVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL1dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL1dvEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL2DVEXT)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIBL2DVEXT _glVertexAttribL2dvEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribL2dvEXT(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL2dvEXT";
    if (!_glVertexAttribL2dvEXT_ptr) {
        _glVertexAttribL2dvEXT_ptr = (PFN_GLVERTEXATTRIBL2DVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL2dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL2dvEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL3DVEXT)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIBL3DVEXT _glVertexAttribL3dvEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribL3dvEXT(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL3dvEXT";
    if (!_glVertexAttribL3dvEXT_ptr) {
        _glVertexAttribL3dvEXT_ptr = (PFN_GLVERTEXATTRIBL3DVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL3dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL3dvEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL4DVEXT)(GLuint index, const GLdouble * v);
static PFN_GLVERTEXATTRIBL4DVEXT _glVertexAttribL4dvEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribL4dvEXT(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL4dvEXT";
    if (!_glVertexAttribL4dvEXT_ptr) {
        _glVertexAttribL4dvEXT_ptr = (PFN_GLVERTEXATTRIBL4DVEXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL4dvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL4dvEXT_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBLPOINTEREXT)(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLVERTEXATTRIBLPOINTEREXT _glVertexAttribLPointerEXT_ptr = NULL;

static inline void APIENTRY _glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribLPointerEXT";
    if (!_glVertexAttribLPointerEXT_ptr) {
        _glVertexAttribLPointerEXT_ptr = (PFN_GLVERTEXATTRIBLPOINTEREXT)_getPrivateProcAddress(_name);
        if (!_glVertexAttribLPointerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribLPointerEXT_ptr(index, size, type, stride, pointer);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBLDVEXT)(GLuint index, GLenum pname, GLdouble * params);
static PFN_GLGETVERTEXATTRIBLDVEXT _glGetVertexAttribLdvEXT_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble * params) {
    const char *_name = "glGetVertexAttribLdvEXT";
    if (!_glGetVertexAttribLdvEXT_ptr) {
        _glGetVertexAttribLdvEXT_ptr = (PFN_GLGETVERTEXATTRIBLDVEXT)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribLdvEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribLdvEXT_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLVERTEXARRAYVERTEXATTRIBLOFFSETEXT)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
static PFN_GLVERTEXARRAYVERTEXATTRIBLOFFSETEXT _glVertexArrayVertexAttribLOffsetEXT_ptr = NULL;

static inline void APIENTRY _glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayVertexAttribLOffsetEXT";
    if (!_glVertexArrayVertexAttribLOffsetEXT_ptr) {
        _glVertexArrayVertexAttribLOffsetEXT_ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBLOFFSETEXT)_getPrivateProcAddress(_name);
        if (!_glVertexArrayVertexAttribLOffsetEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexArrayVertexAttribLOffsetEXT_ptr(vaobj, buffer, index, size, type, stride, offset);
}

typedef void (APIENTRY * PFN_GLPROGRAMSUBROUTINEPARAMETERSUIVNV)(GLenum target, GLsizei count, const GLuint * params);
static PFN_GLPROGRAMSUBROUTINEPARAMETERSUIVNV _glProgramSubroutineParametersuivNV_ptr = NULL;

static inline void APIENTRY _glProgramSubroutineParametersuivNV(GLenum target, GLsizei count, const GLuint * params) {
    const char *_name = "glProgramSubroutineParametersuivNV";
    if (!_glProgramSubroutineParametersuivNV_ptr) {
        _glProgramSubroutineParametersuivNV_ptr = (PFN_GLPROGRAMSUBROUTINEPARAMETERSUIVNV)_getPrivateProcAddress(_name);
        if (!_glProgramSubroutineParametersuivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramSubroutineParametersuivNV_ptr(target, count, params);
}

typedef void (APIENTRY * PFN_GLGETPROGRAMSUBROUTINEPARAMETERUIVNV)(GLenum target, GLuint index, GLuint * param);
static PFN_GLGETPROGRAMSUBROUTINEPARAMETERUIVNV _glGetProgramSubroutineParameteruivNV_ptr = NULL;

static inline void APIENTRY _glGetProgramSubroutineParameteruivNV(GLenum target, GLuint index, GLuint * param) {
    const char *_name = "glGetProgramSubroutineParameteruivNV";
    if (!_glGetProgramSubroutineParameteruivNV_ptr) {
        _glGetProgramSubroutineParameteruivNV_ptr = (PFN_GLGETPROGRAMSUBROUTINEPARAMETERUIVNV)_getPrivateProcAddress(_name);
        if (!_glGetProgramSubroutineParameteruivNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramSubroutineParameteruivNV_ptr(target, index, param);
}

typedef void (APIENTRY * PFN_GLUNIFORM1I64NV)(GLint location, GLint64EXT x);
static PFN_GLUNIFORM1I64NV _glUniform1i64NV_ptr = NULL;

static inline void APIENTRY _glUniform1i64NV(GLint location, GLint64EXT x) {
    const char *_name = "glUniform1i64NV";
    if (!_glUniform1i64NV_ptr) {
        _glUniform1i64NV_ptr = (PFN_GLUNIFORM1I64NV)_getPrivateProcAddress(_name);
        if (!_glUniform1i64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1i64NV_ptr(location, x);
}

typedef void (APIENTRY * PFN_GLUNIFORM2I64NV)(GLint location, GLint64EXT x, GLint64EXT y);
static PFN_GLUNIFORM2I64NV _glUniform2i64NV_ptr = NULL;

static inline void APIENTRY _glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y) {
    const char *_name = "glUniform2i64NV";
    if (!_glUniform2i64NV_ptr) {
        _glUniform2i64NV_ptr = (PFN_GLUNIFORM2I64NV)_getPrivateProcAddress(_name);
        if (!_glUniform2i64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2i64NV_ptr(location, x, y);
}

typedef void (APIENTRY * PFN_GLUNIFORM3I64NV)(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
static PFN_GLUNIFORM3I64NV _glUniform3i64NV_ptr = NULL;

static inline void APIENTRY _glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) {
    const char *_name = "glUniform3i64NV";
    if (!_glUniform3i64NV_ptr) {
        _glUniform3i64NV_ptr = (PFN_GLUNIFORM3I64NV)_getPrivateProcAddress(_name);
        if (!_glUniform3i64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3i64NV_ptr(location, x, y, z);
}

typedef void (APIENTRY * PFN_GLUNIFORM4I64NV)(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
static PFN_GLUNIFORM4I64NV _glUniform4i64NV_ptr = NULL;

static inline void APIENTRY _glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) {
    const char *_name = "glUniform4i64NV";
    if (!_glUniform4i64NV_ptr) {
        _glUniform4i64NV_ptr = (PFN_GLUNIFORM4I64NV)_getPrivateProcAddress(_name);
        if (!_glUniform4i64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4i64NV_ptr(location, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLUNIFORM1I64VNV)(GLint location, GLsizei count, const GLint64EXT * value);
static PFN_GLUNIFORM1I64VNV _glUniform1i64vNV_ptr = NULL;

static inline void APIENTRY _glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glUniform1i64vNV";
    if (!_glUniform1i64vNV_ptr) {
        _glUniform1i64vNV_ptr = (PFN_GLUNIFORM1I64VNV)_getPrivateProcAddress(_name);
        if (!_glUniform1i64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1i64vNV_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM2I64VNV)(GLint location, GLsizei count, const GLint64EXT * value);
static PFN_GLUNIFORM2I64VNV _glUniform2i64vNV_ptr = NULL;

static inline void APIENTRY _glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glUniform2i64vNV";
    if (!_glUniform2i64vNV_ptr) {
        _glUniform2i64vNV_ptr = (PFN_GLUNIFORM2I64VNV)_getPrivateProcAddress(_name);
        if (!_glUniform2i64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2i64vNV_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM3I64VNV)(GLint location, GLsizei count, const GLint64EXT * value);
static PFN_GLUNIFORM3I64VNV _glUniform3i64vNV_ptr = NULL;

static inline void APIENTRY _glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glUniform3i64vNV";
    if (!_glUniform3i64vNV_ptr) {
        _glUniform3i64vNV_ptr = (PFN_GLUNIFORM3I64VNV)_getPrivateProcAddress(_name);
        if (!_glUniform3i64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3i64vNV_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM4I64VNV)(GLint location, GLsizei count, const GLint64EXT * value);
static PFN_GLUNIFORM4I64VNV _glUniform4i64vNV_ptr = NULL;

static inline void APIENTRY _glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glUniform4i64vNV";
    if (!_glUniform4i64vNV_ptr) {
        _glUniform4i64vNV_ptr = (PFN_GLUNIFORM4I64VNV)_getPrivateProcAddress(_name);
        if (!_glUniform4i64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4i64vNV_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM1UI64NV)(GLint location, GLuint64EXT x);
static PFN_GLUNIFORM1UI64NV _glUniform1ui64NV_ptr = NULL;

static inline void APIENTRY _glUniform1ui64NV(GLint location, GLuint64EXT x) {
    const char *_name = "glUniform1ui64NV";
    if (!_glUniform1ui64NV_ptr) {
        _glUniform1ui64NV_ptr = (PFN_GLUNIFORM1UI64NV)_getPrivateProcAddress(_name);
        if (!_glUniform1ui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1ui64NV_ptr(location, x);
}

typedef void (APIENTRY * PFN_GLUNIFORM2UI64NV)(GLint location, GLuint64EXT x, GLuint64EXT y);
static PFN_GLUNIFORM2UI64NV _glUniform2ui64NV_ptr = NULL;

static inline void APIENTRY _glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y) {
    const char *_name = "glUniform2ui64NV";
    if (!_glUniform2ui64NV_ptr) {
        _glUniform2ui64NV_ptr = (PFN_GLUNIFORM2UI64NV)_getPrivateProcAddress(_name);
        if (!_glUniform2ui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2ui64NV_ptr(location, x, y);
}

typedef void (APIENTRY * PFN_GLUNIFORM3UI64NV)(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
static PFN_GLUNIFORM3UI64NV _glUniform3ui64NV_ptr = NULL;

static inline void APIENTRY _glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) {
    const char *_name = "glUniform3ui64NV";
    if (!_glUniform3ui64NV_ptr) {
        _glUniform3ui64NV_ptr = (PFN_GLUNIFORM3UI64NV)_getPrivateProcAddress(_name);
        if (!_glUniform3ui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3ui64NV_ptr(location, x, y, z);
}

typedef void (APIENTRY * PFN_GLUNIFORM4UI64NV)(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
static PFN_GLUNIFORM4UI64NV _glUniform4ui64NV_ptr = NULL;

static inline void APIENTRY _glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) {
    const char *_name = "glUniform4ui64NV";
    if (!_glUniform4ui64NV_ptr) {
        _glUniform4ui64NV_ptr = (PFN_GLUNIFORM4UI64NV)_getPrivateProcAddress(_name);
        if (!_glUniform4ui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4ui64NV_ptr(location, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLUNIFORM1UI64VNV)(GLint location, GLsizei count, const GLuint64EXT * value);
static PFN_GLUNIFORM1UI64VNV _glUniform1ui64vNV_ptr = NULL;

static inline void APIENTRY _glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glUniform1ui64vNV";
    if (!_glUniform1ui64vNV_ptr) {
        _glUniform1ui64vNV_ptr = (PFN_GLUNIFORM1UI64VNV)_getPrivateProcAddress(_name);
        if (!_glUniform1ui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform1ui64vNV_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM2UI64VNV)(GLint location, GLsizei count, const GLuint64EXT * value);
static PFN_GLUNIFORM2UI64VNV _glUniform2ui64vNV_ptr = NULL;

static inline void APIENTRY _glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glUniform2ui64vNV";
    if (!_glUniform2ui64vNV_ptr) {
        _glUniform2ui64vNV_ptr = (PFN_GLUNIFORM2UI64VNV)_getPrivateProcAddress(_name);
        if (!_glUniform2ui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform2ui64vNV_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM3UI64VNV)(GLint location, GLsizei count, const GLuint64EXT * value);
static PFN_GLUNIFORM3UI64VNV _glUniform3ui64vNV_ptr = NULL;

static inline void APIENTRY _glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glUniform3ui64vNV";
    if (!_glUniform3ui64vNV_ptr) {
        _glUniform3ui64vNV_ptr = (PFN_GLUNIFORM3UI64VNV)_getPrivateProcAddress(_name);
        if (!_glUniform3ui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform3ui64vNV_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLUNIFORM4UI64VNV)(GLint location, GLsizei count, const GLuint64EXT * value);
static PFN_GLUNIFORM4UI64VNV _glUniform4ui64vNV_ptr = NULL;

static inline void APIENTRY _glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glUniform4ui64vNV";
    if (!_glUniform4ui64vNV_ptr) {
        _glUniform4ui64vNV_ptr = (PFN_GLUNIFORM4UI64VNV)_getPrivateProcAddress(_name);
        if (!_glUniform4ui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUniform4ui64vNV_ptr(location, count, value);
}

typedef void (APIENTRY * PFN_GLGETUNIFORMI64VNV)(GLuint program, GLint location, GLint64EXT * params);
static PFN_GLGETUNIFORMI64VNV _glGetUniformi64vNV_ptr = NULL;

static inline void APIENTRY _glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT * params) {
    const char *_name = "glGetUniformi64vNV";
    if (!_glGetUniformi64vNV_ptr) {
        _glGetUniformi64vNV_ptr = (PFN_GLGETUNIFORMI64VNV)_getPrivateProcAddress(_name);
        if (!_glGetUniformi64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetUniformi64vNV_ptr(program, location, params);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1I64NV)(GLuint program, GLint location, GLint64EXT x);
static PFN_GLPROGRAMUNIFORM1I64NV _glProgramUniform1i64NV_ptr = NULL;

static inline void APIENTRY _glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x) {
    const char *_name = "glProgramUniform1i64NV";
    if (!_glProgramUniform1i64NV_ptr) {
        _glProgramUniform1i64NV_ptr = (PFN_GLPROGRAMUNIFORM1I64NV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1i64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1i64NV_ptr(program, location, x);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2I64NV)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
static PFN_GLPROGRAMUNIFORM2I64NV _glProgramUniform2i64NV_ptr = NULL;

static inline void APIENTRY _glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y) {
    const char *_name = "glProgramUniform2i64NV";
    if (!_glProgramUniform2i64NV_ptr) {
        _glProgramUniform2i64NV_ptr = (PFN_GLPROGRAMUNIFORM2I64NV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2i64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2i64NV_ptr(program, location, x, y);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3I64NV)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
static PFN_GLPROGRAMUNIFORM3I64NV _glProgramUniform3i64NV_ptr = NULL;

static inline void APIENTRY _glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) {
    const char *_name = "glProgramUniform3i64NV";
    if (!_glProgramUniform3i64NV_ptr) {
        _glProgramUniform3i64NV_ptr = (PFN_GLPROGRAMUNIFORM3I64NV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3i64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3i64NV_ptr(program, location, x, y, z);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4I64NV)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
static PFN_GLPROGRAMUNIFORM4I64NV _glProgramUniform4i64NV_ptr = NULL;

static inline void APIENTRY _glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) {
    const char *_name = "glProgramUniform4i64NV";
    if (!_glProgramUniform4i64NV_ptr) {
        _glProgramUniform4i64NV_ptr = (PFN_GLPROGRAMUNIFORM4I64NV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4i64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4i64NV_ptr(program, location, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1I64VNV)(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
static PFN_GLPROGRAMUNIFORM1I64VNV _glProgramUniform1i64vNV_ptr = NULL;

static inline void APIENTRY _glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glProgramUniform1i64vNV";
    if (!_glProgramUniform1i64vNV_ptr) {
        _glProgramUniform1i64vNV_ptr = (PFN_GLPROGRAMUNIFORM1I64VNV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1i64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1i64vNV_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2I64VNV)(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
static PFN_GLPROGRAMUNIFORM2I64VNV _glProgramUniform2i64vNV_ptr = NULL;

static inline void APIENTRY _glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glProgramUniform2i64vNV";
    if (!_glProgramUniform2i64vNV_ptr) {
        _glProgramUniform2i64vNV_ptr = (PFN_GLPROGRAMUNIFORM2I64VNV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2i64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2i64vNV_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3I64VNV)(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
static PFN_GLPROGRAMUNIFORM3I64VNV _glProgramUniform3i64vNV_ptr = NULL;

static inline void APIENTRY _glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glProgramUniform3i64vNV";
    if (!_glProgramUniform3i64vNV_ptr) {
        _glProgramUniform3i64vNV_ptr = (PFN_GLPROGRAMUNIFORM3I64VNV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3i64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3i64vNV_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4I64VNV)(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
static PFN_GLPROGRAMUNIFORM4I64VNV _glProgramUniform4i64vNV_ptr = NULL;

static inline void APIENTRY _glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glProgramUniform4i64vNV";
    if (!_glProgramUniform4i64vNV_ptr) {
        _glProgramUniform4i64vNV_ptr = (PFN_GLPROGRAMUNIFORM4I64VNV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4i64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4i64vNV_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1UI64NV)(GLuint program, GLint location, GLuint64EXT x);
static PFN_GLPROGRAMUNIFORM1UI64NV _glProgramUniform1ui64NV_ptr = NULL;

static inline void APIENTRY _glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x) {
    const char *_name = "glProgramUniform1ui64NV";
    if (!_glProgramUniform1ui64NV_ptr) {
        _glProgramUniform1ui64NV_ptr = (PFN_GLPROGRAMUNIFORM1UI64NV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1ui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1ui64NV_ptr(program, location, x);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2UI64NV)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
static PFN_GLPROGRAMUNIFORM2UI64NV _glProgramUniform2ui64NV_ptr = NULL;

static inline void APIENTRY _glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y) {
    const char *_name = "glProgramUniform2ui64NV";
    if (!_glProgramUniform2ui64NV_ptr) {
        _glProgramUniform2ui64NV_ptr = (PFN_GLPROGRAMUNIFORM2UI64NV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2ui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2ui64NV_ptr(program, location, x, y);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3UI64NV)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
static PFN_GLPROGRAMUNIFORM3UI64NV _glProgramUniform3ui64NV_ptr = NULL;

static inline void APIENTRY _glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) {
    const char *_name = "glProgramUniform3ui64NV";
    if (!_glProgramUniform3ui64NV_ptr) {
        _glProgramUniform3ui64NV_ptr = (PFN_GLPROGRAMUNIFORM3UI64NV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3ui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3ui64NV_ptr(program, location, x, y, z);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4UI64NV)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
static PFN_GLPROGRAMUNIFORM4UI64NV _glProgramUniform4ui64NV_ptr = NULL;

static inline void APIENTRY _glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) {
    const char *_name = "glProgramUniform4ui64NV";
    if (!_glProgramUniform4ui64NV_ptr) {
        _glProgramUniform4ui64NV_ptr = (PFN_GLPROGRAMUNIFORM4UI64NV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4ui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4ui64NV_ptr(program, location, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM1UI64VNV)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
static PFN_GLPROGRAMUNIFORM1UI64VNV _glProgramUniform1ui64vNV_ptr = NULL;

static inline void APIENTRY _glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glProgramUniform1ui64vNV";
    if (!_glProgramUniform1ui64vNV_ptr) {
        _glProgramUniform1ui64vNV_ptr = (PFN_GLPROGRAMUNIFORM1UI64VNV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform1ui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform1ui64vNV_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM2UI64VNV)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
static PFN_GLPROGRAMUNIFORM2UI64VNV _glProgramUniform2ui64vNV_ptr = NULL;

static inline void APIENTRY _glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glProgramUniform2ui64vNV";
    if (!_glProgramUniform2ui64vNV_ptr) {
        _glProgramUniform2ui64vNV_ptr = (PFN_GLPROGRAMUNIFORM2UI64VNV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform2ui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform2ui64vNV_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM3UI64VNV)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
static PFN_GLPROGRAMUNIFORM3UI64VNV _glProgramUniform3ui64vNV_ptr = NULL;

static inline void APIENTRY _glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glProgramUniform3ui64vNV";
    if (!_glProgramUniform3ui64vNV_ptr) {
        _glProgramUniform3ui64vNV_ptr = (PFN_GLPROGRAMUNIFORM3UI64VNV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform3ui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform3ui64vNV_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLPROGRAMUNIFORM4UI64VNV)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
static PFN_GLPROGRAMUNIFORM4UI64VNV _glProgramUniform4ui64vNV_ptr = NULL;

static inline void APIENTRY _glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glProgramUniform4ui64vNV";
    if (!_glProgramUniform4ui64vNV_ptr) {
        _glProgramUniform4ui64vNV_ptr = (PFN_GLPROGRAMUNIFORM4UI64VNV)_getPrivateProcAddress(_name);
        if (!_glProgramUniform4ui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramUniform4ui64vNV_ptr(program, location, count, value);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL1I64NV)(GLuint index, GLint64EXT x);
static PFN_GLVERTEXATTRIBL1I64NV _glVertexAttribL1i64NV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL1i64NV(GLuint index, GLint64EXT x) {
    const char *_name = "glVertexAttribL1i64NV";
    if (!_glVertexAttribL1i64NV_ptr) {
        _glVertexAttribL1i64NV_ptr = (PFN_GLVERTEXATTRIBL1I64NV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL1i64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL1i64NV_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL2I64NV)(GLuint index, GLint64EXT x, GLint64EXT y);
static PFN_GLVERTEXATTRIBL2I64NV _glVertexAttribL2i64NV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y) {
    const char *_name = "glVertexAttribL2i64NV";
    if (!_glVertexAttribL2i64NV_ptr) {
        _glVertexAttribL2i64NV_ptr = (PFN_GLVERTEXATTRIBL2I64NV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL2i64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL2i64NV_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL3I64NV)(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
static PFN_GLVERTEXATTRIBL3I64NV _glVertexAttribL3i64NV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z) {
    const char *_name = "glVertexAttribL3i64NV";
    if (!_glVertexAttribL3i64NV_ptr) {
        _glVertexAttribL3i64NV_ptr = (PFN_GLVERTEXATTRIBL3I64NV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL3i64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL3i64NV_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL4I64NV)(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
static PFN_GLVERTEXATTRIBL4I64NV _glVertexAttribL4i64NV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) {
    const char *_name = "glVertexAttribL4i64NV";
    if (!_glVertexAttribL4i64NV_ptr) {
        _glVertexAttribL4i64NV_ptr = (PFN_GLVERTEXATTRIBL4I64NV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL4i64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL4i64NV_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL1I64VNV)(GLuint index, const GLint64EXT * v);
static PFN_GLVERTEXATTRIBL1I64VNV _glVertexAttribL1i64vNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL1i64vNV(GLuint index, const GLint64EXT * v) {
    const char *_name = "glVertexAttribL1i64vNV";
    if (!_glVertexAttribL1i64vNV_ptr) {
        _glVertexAttribL1i64vNV_ptr = (PFN_GLVERTEXATTRIBL1I64VNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL1i64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL1i64vNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL2I64VNV)(GLuint index, const GLint64EXT * v);
static PFN_GLVERTEXATTRIBL2I64VNV _glVertexAttribL2i64vNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL2i64vNV(GLuint index, const GLint64EXT * v) {
    const char *_name = "glVertexAttribL2i64vNV";
    if (!_glVertexAttribL2i64vNV_ptr) {
        _glVertexAttribL2i64vNV_ptr = (PFN_GLVERTEXATTRIBL2I64VNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL2i64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL2i64vNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL3I64VNV)(GLuint index, const GLint64EXT * v);
static PFN_GLVERTEXATTRIBL3I64VNV _glVertexAttribL3i64vNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL3i64vNV(GLuint index, const GLint64EXT * v) {
    const char *_name = "glVertexAttribL3i64vNV";
    if (!_glVertexAttribL3i64vNV_ptr) {
        _glVertexAttribL3i64vNV_ptr = (PFN_GLVERTEXATTRIBL3I64VNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL3i64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL3i64vNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL4I64VNV)(GLuint index, const GLint64EXT * v);
static PFN_GLVERTEXATTRIBL4I64VNV _glVertexAttribL4i64vNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL4i64vNV(GLuint index, const GLint64EXT * v) {
    const char *_name = "glVertexAttribL4i64vNV";
    if (!_glVertexAttribL4i64vNV_ptr) {
        _glVertexAttribL4i64vNV_ptr = (PFN_GLVERTEXATTRIBL4I64VNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL4i64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL4i64vNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL1UI64NV)(GLuint index, GLuint64EXT x);
static PFN_GLVERTEXATTRIBL1UI64NV _glVertexAttribL1ui64NV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x) {
    const char *_name = "glVertexAttribL1ui64NV";
    if (!_glVertexAttribL1ui64NV_ptr) {
        _glVertexAttribL1ui64NV_ptr = (PFN_GLVERTEXATTRIBL1UI64NV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL1ui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL1ui64NV_ptr(index, x);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL2UI64NV)(GLuint index, GLuint64EXT x, GLuint64EXT y);
static PFN_GLVERTEXATTRIBL2UI64NV _glVertexAttribL2ui64NV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y) {
    const char *_name = "glVertexAttribL2ui64NV";
    if (!_glVertexAttribL2ui64NV_ptr) {
        _glVertexAttribL2ui64NV_ptr = (PFN_GLVERTEXATTRIBL2UI64NV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL2ui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL2ui64NV_ptr(index, x, y);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL3UI64NV)(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
static PFN_GLVERTEXATTRIBL3UI64NV _glVertexAttribL3ui64NV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) {
    const char *_name = "glVertexAttribL3ui64NV";
    if (!_glVertexAttribL3ui64NV_ptr) {
        _glVertexAttribL3ui64NV_ptr = (PFN_GLVERTEXATTRIBL3UI64NV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL3ui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL3ui64NV_ptr(index, x, y, z);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL4UI64NV)(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
static PFN_GLVERTEXATTRIBL4UI64NV _glVertexAttribL4ui64NV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) {
    const char *_name = "glVertexAttribL4ui64NV";
    if (!_glVertexAttribL4ui64NV_ptr) {
        _glVertexAttribL4ui64NV_ptr = (PFN_GLVERTEXATTRIBL4UI64NV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL4ui64NV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL4ui64NV_ptr(index, x, y, z, w);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL1UI64VNV)(GLuint index, const GLuint64EXT * v);
static PFN_GLVERTEXATTRIBL1UI64VNV _glVertexAttribL1ui64vNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT * v) {
    const char *_name = "glVertexAttribL1ui64vNV";
    if (!_glVertexAttribL1ui64vNV_ptr) {
        _glVertexAttribL1ui64vNV_ptr = (PFN_GLVERTEXATTRIBL1UI64VNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL1ui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL1ui64vNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL2UI64VNV)(GLuint index, const GLuint64EXT * v);
static PFN_GLVERTEXATTRIBL2UI64VNV _glVertexAttribL2ui64vNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT * v) {
    const char *_name = "glVertexAttribL2ui64vNV";
    if (!_glVertexAttribL2ui64vNV_ptr) {
        _glVertexAttribL2ui64vNV_ptr = (PFN_GLVERTEXATTRIBL2UI64VNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL2ui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL2ui64vNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL3UI64VNV)(GLuint index, const GLuint64EXT * v);
static PFN_GLVERTEXATTRIBL3UI64VNV _glVertexAttribL3ui64vNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT * v) {
    const char *_name = "glVertexAttribL3ui64vNV";
    if (!_glVertexAttribL3ui64vNV_ptr) {
        _glVertexAttribL3ui64vNV_ptr = (PFN_GLVERTEXATTRIBL3UI64VNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL3ui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL3ui64vNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBL4UI64VNV)(GLuint index, const GLuint64EXT * v);
static PFN_GLVERTEXATTRIBL4UI64VNV _glVertexAttribL4ui64vNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT * v) {
    const char *_name = "glVertexAttribL4ui64vNV";
    if (!_glVertexAttribL4ui64vNV_ptr) {
        _glVertexAttribL4ui64vNV_ptr = (PFN_GLVERTEXATTRIBL4UI64VNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribL4ui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribL4ui64vNV_ptr(index, v);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBLI64VNV)(GLuint index, GLenum pname, GLint64EXT * params);
static PFN_GLGETVERTEXATTRIBLI64VNV _glGetVertexAttribLi64vNV_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT * params) {
    const char *_name = "glGetVertexAttribLi64vNV";
    if (!_glGetVertexAttribLi64vNV_ptr) {
        _glGetVertexAttribLi64vNV_ptr = (PFN_GLGETVERTEXATTRIBLI64VNV)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribLi64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribLi64vNV_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLGETVERTEXATTRIBLUI64VNV)(GLuint index, GLenum pname, GLuint64EXT * params);
static PFN_GLGETVERTEXATTRIBLUI64VNV _glGetVertexAttribLui64vNV_ptr = NULL;

static inline void APIENTRY _glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT * params) {
    const char *_name = "glGetVertexAttribLui64vNV";
    if (!_glGetVertexAttribLui64vNV_ptr) {
        _glGetVertexAttribLui64vNV_ptr = (PFN_GLGETVERTEXATTRIBLUI64VNV)_getPrivateProcAddress(_name);
        if (!_glGetVertexAttribLui64vNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetVertexAttribLui64vNV_ptr(index, pname, params);
}

typedef void (APIENTRY * PFN_GLVERTEXATTRIBLFORMATNV)(GLuint index, GLint size, GLenum type, GLsizei stride);
static PFN_GLVERTEXATTRIBLFORMATNV _glVertexAttribLFormatNV_ptr = NULL;

static inline void APIENTRY _glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride) {
    const char *_name = "glVertexAttribLFormatNV";
    if (!_glVertexAttribLFormatNV_ptr) {
        _glVertexAttribLFormatNV_ptr = (PFN_GLVERTEXATTRIBLFORMATNV)_getPrivateProcAddress(_name);
        if (!_glVertexAttribLFormatNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glVertexAttribLFormatNV_ptr(index, size, type, stride);
}

typedef void (APIENTRY * PFN_GLGENNAMESAMD)(GLenum identifier, GLuint num, GLuint * names);
static PFN_GLGENNAMESAMD _glGenNamesAMD_ptr = NULL;

static inline void APIENTRY _glGenNamesAMD(GLenum identifier, GLuint num, GLuint * names) {
    const char *_name = "glGenNamesAMD";
    if (!_glGenNamesAMD_ptr) {
        _glGenNamesAMD_ptr = (PFN_GLGENNAMESAMD)_getPrivateProcAddress(_name);
        if (!_glGenNamesAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenNamesAMD_ptr(identifier, num, names);
}

typedef void (APIENTRY * PFN_GLDELETENAMESAMD)(GLenum identifier, GLuint num, const GLuint * names);
static PFN_GLDELETENAMESAMD _glDeleteNamesAMD_ptr = NULL;

static inline void APIENTRY _glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint * names) {
    const char *_name = "glDeleteNamesAMD";
    if (!_glDeleteNamesAMD_ptr) {
        _glDeleteNamesAMD_ptr = (PFN_GLDELETENAMESAMD)_getPrivateProcAddress(_name);
        if (!_glDeleteNamesAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteNamesAMD_ptr(identifier, num, names);
}

typedef GLboolean (APIENTRY * PFN_GLISNAMEAMD)(GLenum identifier, GLuint name);
static PFN_GLISNAMEAMD _glIsNameAMD_ptr = NULL;

static inline GLboolean APIENTRY _glIsNameAMD(GLenum identifier, GLuint name) {
    const char *_name = "glIsNameAMD";
    if (!_glIsNameAMD_ptr) {
        _glIsNameAMD_ptr = (PFN_GLISNAMEAMD)_getPrivateProcAddress(_name);
        if (!_glIsNameAMD_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsNameAMD_ptr(identifier, name);
}

typedef void (APIENTRY * PFN_GLDEBUGMESSAGEENABLEAMD)(GLenum category, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);
static PFN_GLDEBUGMESSAGEENABLEAMD _glDebugMessageEnableAMD_ptr = NULL;

static inline void APIENTRY _glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled) {
    const char *_name = "glDebugMessageEnableAMD";
    if (!_glDebugMessageEnableAMD_ptr) {
        _glDebugMessageEnableAMD_ptr = (PFN_GLDEBUGMESSAGEENABLEAMD)_getPrivateProcAddress(_name);
        if (!_glDebugMessageEnableAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDebugMessageEnableAMD_ptr(category, severity, count, ids, enabled);
}

typedef void (APIENTRY * PFN_GLDEBUGMESSAGEINSERTAMD)(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar * buf);
static PFN_GLDEBUGMESSAGEINSERTAMD _glDebugMessageInsertAMD_ptr = NULL;

static inline void APIENTRY _glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar * buf) {
    const char *_name = "glDebugMessageInsertAMD";
    if (!_glDebugMessageInsertAMD_ptr) {
        _glDebugMessageInsertAMD_ptr = (PFN_GLDEBUGMESSAGEINSERTAMD)_getPrivateProcAddress(_name);
        if (!_glDebugMessageInsertAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDebugMessageInsertAMD_ptr(category, severity, id, length, buf);
}

typedef void (APIENTRY * PFN_GLDEBUGMESSAGECALLBACKAMD)(GLDEBUGPROCAMD callback, GLvoid * userParam);
static PFN_GLDEBUGMESSAGECALLBACKAMD _glDebugMessageCallbackAMD_ptr = NULL;

static inline void APIENTRY _glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, GLvoid * userParam) {
    const char *_name = "glDebugMessageCallbackAMD";
    if (!_glDebugMessageCallbackAMD_ptr) {
        _glDebugMessageCallbackAMD_ptr = (PFN_GLDEBUGMESSAGECALLBACKAMD)_getPrivateProcAddress(_name);
        if (!_glDebugMessageCallbackAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDebugMessageCallbackAMD_ptr(callback, userParam);
}

typedef GLuint (APIENTRY * PFN_GLGETDEBUGMESSAGELOGAMD)(GLuint count, GLsizei bufsize, GLenum * categories, GLuint * severities, GLuint * ids, GLsizei * lengths, GLchar * message);
static PFN_GLGETDEBUGMESSAGELOGAMD _glGetDebugMessageLogAMD_ptr = NULL;

static inline GLuint APIENTRY _glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum * categories, GLuint * severities, GLuint * ids, GLsizei * lengths, GLchar * message) {
    const char *_name = "glGetDebugMessageLogAMD";
    if (!_glGetDebugMessageLogAMD_ptr) {
        _glGetDebugMessageLogAMD_ptr = (PFN_GLGETDEBUGMESSAGELOGAMD)_getPrivateProcAddress(_name);
        if (!_glGetDebugMessageLogAMD_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glGetDebugMessageLogAMD_ptr(count, bufsize, categories, severities, ids, lengths, message);
}

typedef void (APIENTRY * PFN_GLTEXIMAGE2DMULTISAMPLECOVERAGENV)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
static PFN_GLTEXIMAGE2DMULTISAMPLECOVERAGENV _glTexImage2DMultisampleCoverageNV_ptr = NULL;

static inline void APIENTRY _glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) {
    const char *_name = "glTexImage2DMultisampleCoverageNV";
    if (!_glTexImage2DMultisampleCoverageNV_ptr) {
        _glTexImage2DMultisampleCoverageNV_ptr = (PFN_GLTEXIMAGE2DMULTISAMPLECOVERAGENV)_getPrivateProcAddress(_name);
        if (!_glTexImage2DMultisampleCoverageNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexImage2DMultisampleCoverageNV_ptr(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
}

typedef void (APIENTRY * PFN_GLTEXIMAGE3DMULTISAMPLECOVERAGENV)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
static PFN_GLTEXIMAGE3DMULTISAMPLECOVERAGENV _glTexImage3DMultisampleCoverageNV_ptr = NULL;

static inline void APIENTRY _glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) {
    const char *_name = "glTexImage3DMultisampleCoverageNV";
    if (!_glTexImage3DMultisampleCoverageNV_ptr) {
        _glTexImage3DMultisampleCoverageNV_ptr = (PFN_GLTEXIMAGE3DMULTISAMPLECOVERAGENV)_getPrivateProcAddress(_name);
        if (!_glTexImage3DMultisampleCoverageNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexImage3DMultisampleCoverageNV_ptr(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
}

typedef void (APIENTRY * PFN_GLTEXTUREIMAGE2DMULTISAMPLENV)(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
static PFN_GLTEXTUREIMAGE2DMULTISAMPLENV _glTextureImage2DMultisampleNV_ptr = NULL;

static inline void APIENTRY _glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) {
    const char *_name = "glTextureImage2DMultisampleNV";
    if (!_glTextureImage2DMultisampleNV_ptr) {
        _glTextureImage2DMultisampleNV_ptr = (PFN_GLTEXTUREIMAGE2DMULTISAMPLENV)_getPrivateProcAddress(_name);
        if (!_glTextureImage2DMultisampleNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureImage2DMultisampleNV_ptr(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
}

typedef void (APIENTRY * PFN_GLTEXTUREIMAGE3DMULTISAMPLENV)(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
static PFN_GLTEXTUREIMAGE3DMULTISAMPLENV _glTextureImage3DMultisampleNV_ptr = NULL;

static inline void APIENTRY _glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) {
    const char *_name = "glTextureImage3DMultisampleNV";
    if (!_glTextureImage3DMultisampleNV_ptr) {
        _glTextureImage3DMultisampleNV_ptr = (PFN_GLTEXTUREIMAGE3DMULTISAMPLENV)_getPrivateProcAddress(_name);
        if (!_glTextureImage3DMultisampleNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureImage3DMultisampleNV_ptr(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
}

typedef void (APIENTRY * PFN_GLTEXTUREIMAGE2DMULTISAMPLECOVERAGENV)(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
static PFN_GLTEXTUREIMAGE2DMULTISAMPLECOVERAGENV _glTextureImage2DMultisampleCoverageNV_ptr = NULL;

static inline void APIENTRY _glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) {
    const char *_name = "glTextureImage2DMultisampleCoverageNV";
    if (!_glTextureImage2DMultisampleCoverageNV_ptr) {
        _glTextureImage2DMultisampleCoverageNV_ptr = (PFN_GLTEXTUREIMAGE2DMULTISAMPLECOVERAGENV)_getPrivateProcAddress(_name);
        if (!_glTextureImage2DMultisampleCoverageNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureImage2DMultisampleCoverageNV_ptr(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
}

typedef void (APIENTRY * PFN_GLTEXTUREIMAGE3DMULTISAMPLECOVERAGENV)(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
static PFN_GLTEXTUREIMAGE3DMULTISAMPLECOVERAGENV _glTextureImage3DMultisampleCoverageNV_ptr = NULL;

static inline void APIENTRY _glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) {
    const char *_name = "glTextureImage3DMultisampleCoverageNV";
    if (!_glTextureImage3DMultisampleCoverageNV_ptr) {
        _glTextureImage3DMultisampleCoverageNV_ptr = (PFN_GLTEXTUREIMAGE3DMULTISAMPLECOVERAGENV)_getPrivateProcAddress(_name);
        if (!_glTextureImage3DMultisampleCoverageNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTextureImage3DMultisampleCoverageNV_ptr(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
}

typedef void (APIENTRY * PFN_GLSETMULTISAMPLEFVAMD)(GLenum pname, GLuint index, const GLfloat * val);
static PFN_GLSETMULTISAMPLEFVAMD _glSetMultisamplefvAMD_ptr = NULL;

static inline void APIENTRY _glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat * val) {
    const char *_name = "glSetMultisamplefvAMD";
    if (!_glSetMultisamplefvAMD_ptr) {
        _glSetMultisamplefvAMD_ptr = (PFN_GLSETMULTISAMPLEFVAMD)_getPrivateProcAddress(_name);
        if (!_glSetMultisamplefvAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSetMultisamplefvAMD_ptr(pname, index, val);
}

typedef GLsync (APIENTRY * PFN_GLIMPORTSYNCEXT)(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);
static PFN_GLIMPORTSYNCEXT _glImportSyncEXT_ptr = NULL;

static inline GLsync APIENTRY _glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags) {
    const char *_name = "glImportSyncEXT";
    if (!_glImportSyncEXT_ptr) {
        _glImportSyncEXT_ptr = (PFN_GLIMPORTSYNCEXT)_getPrivateProcAddress(_name);
        if (!_glImportSyncEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glImportSyncEXT_ptr(external_sync_type, external_sync, flags);
}

typedef void (APIENTRY * PFN_GLMULTIDRAWARRAYSINDIRECTAMD)(GLenum mode, const GLvoid * indirect, GLsizei primcount, GLsizei stride);
static PFN_GLMULTIDRAWARRAYSINDIRECTAMD _glMultiDrawArraysIndirectAMD_ptr = NULL;

static inline void APIENTRY _glMultiDrawArraysIndirectAMD(GLenum mode, const GLvoid * indirect, GLsizei primcount, GLsizei stride) {
    const char *_name = "glMultiDrawArraysIndirectAMD";
    if (!_glMultiDrawArraysIndirectAMD_ptr) {
        _glMultiDrawArraysIndirectAMD_ptr = (PFN_GLMULTIDRAWARRAYSINDIRECTAMD)_getPrivateProcAddress(_name);
        if (!_glMultiDrawArraysIndirectAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiDrawArraysIndirectAMD_ptr(mode, indirect, primcount, stride);
}

typedef void (APIENTRY * PFN_GLMULTIDRAWELEMENTSINDIRECTAMD)(GLenum mode, GLenum type, const GLvoid * indirect, GLsizei primcount, GLsizei stride);
static PFN_GLMULTIDRAWELEMENTSINDIRECTAMD _glMultiDrawElementsIndirectAMD_ptr = NULL;

static inline void APIENTRY _glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const GLvoid * indirect, GLsizei primcount, GLsizei stride) {
    const char *_name = "glMultiDrawElementsIndirectAMD";
    if (!_glMultiDrawElementsIndirectAMD_ptr) {
        _glMultiDrawElementsIndirectAMD_ptr = (PFN_GLMULTIDRAWELEMENTSINDIRECTAMD)_getPrivateProcAddress(_name);
        if (!_glMultiDrawElementsIndirectAMD_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiDrawElementsIndirectAMD_ptr(mode, type, indirect, primcount, stride);
}

typedef GLuint (APIENTRY * PFN_GLNEWBUFFERREGION)(GLenum type);
static PFN_GLNEWBUFFERREGION _glNewBufferRegion_ptr = NULL;

static inline GLuint APIENTRY _glNewBufferRegion(GLenum type) {
    const char *_name = "glNewBufferRegion";
    if (!_glNewBufferRegion_ptr) {
        _glNewBufferRegion_ptr = (PFN_GLNEWBUFFERREGION)_getPrivateProcAddress(_name);
        if (!_glNewBufferRegion_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glNewBufferRegion_ptr(type);
}

typedef void (APIENTRY * PFN_GLDELETEBUFFERREGION)(GLuint region);
static PFN_GLDELETEBUFFERREGION _glDeleteBufferRegion_ptr = NULL;

static inline void APIENTRY _glDeleteBufferRegion(GLuint region) {
    const char *_name = "glDeleteBufferRegion";
    if (!_glDeleteBufferRegion_ptr) {
        _glDeleteBufferRegion_ptr = (PFN_GLDELETEBUFFERREGION)_getPrivateProcAddress(_name);
        if (!_glDeleteBufferRegion_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteBufferRegion_ptr(region);
}

typedef void (APIENTRY * PFN_GLREADBUFFERREGION)(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLREADBUFFERREGION _glReadBufferRegion_ptr = NULL;

static inline void APIENTRY _glReadBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glReadBufferRegion";
    if (!_glReadBufferRegion_ptr) {
        _glReadBufferRegion_ptr = (PFN_GLREADBUFFERREGION)_getPrivateProcAddress(_name);
        if (!_glReadBufferRegion_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReadBufferRegion_ptr(region, x, y, width, height);
}

typedef void (APIENTRY * PFN_GLDRAWBUFFERREGION)(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest);
static PFN_GLDRAWBUFFERREGION _glDrawBufferRegion_ptr = NULL;

static inline void APIENTRY _glDrawBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest) {
    const char *_name = "glDrawBufferRegion";
    if (!_glDrawBufferRegion_ptr) {
        _glDrawBufferRegion_ptr = (PFN_GLDRAWBUFFERREGION)_getPrivateProcAddress(_name);
        if (!_glDrawBufferRegion_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawBufferRegion_ptr(region, x, y, width, height, xDest, yDest);
}

typedef GLuint (APIENTRY * PFN_GLBUFFERREGIONENABLED)(void);
static PFN_GLBUFFERREGIONENABLED _glBufferRegionEnabled_ptr = NULL;

static inline GLuint APIENTRY _glBufferRegionEnabled(void) {
    const char *_name = "glBufferRegionEnabled";
    if (!_glBufferRegionEnabled_ptr) {
        _glBufferRegionEnabled_ptr = (PFN_GLBUFFERREGIONENABLED)_getPrivateProcAddress(_name);
        if (!_glBufferRegionEnabled_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glBufferRegionEnabled_ptr();
}

typedef void (APIENTRY * PFN_GLADDSWAPHINTRECTWIN)(GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLADDSWAPHINTRECTWIN _glAddSwapHintRectWIN_ptr = NULL;

static inline void APIENTRY _glAddSwapHintRectWIN(GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glAddSwapHintRectWIN";
    if (!_glAddSwapHintRectWIN_ptr) {
        _glAddSwapHintRectWIN_ptr = (PFN_GLADDSWAPHINTRECTWIN)_getPrivateProcAddress(_name);
        if (!_glAddSwapHintRectWIN_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glAddSwapHintRectWIN_ptr(x, y, width, height);
}

#ifdef RETRACE
#define glCullFace _glCullFace
#define glFrontFace _glFrontFace
#define glHint _glHint
#define glLineWidth _glLineWidth
#define glPointSize _glPointSize
#define glPolygonMode _glPolygonMode
#define glScissor _glScissor
#define glTexParameterf _glTexParameterf
#define glTexParameterfv _glTexParameterfv
#define glTexParameteri _glTexParameteri
#define glTexParameteriv _glTexParameteriv
#define glTexImage1D _glTexImage1D
#define glTexImage2D _glTexImage2D
#define glDrawBuffer _glDrawBuffer
#define glClear _glClear
#define glClearColor _glClearColor
#define glClearStencil _glClearStencil
#define glClearDepth _glClearDepth
#define glStencilMask _glStencilMask
#define glColorMask _glColorMask
#define glDepthMask _glDepthMask
#define glDisable _glDisable
#define glEnable _glEnable
#define glFinish _glFinish
#define glFlush _glFlush
#define glBlendFunc _glBlendFunc
#define glLogicOp _glLogicOp
#define glStencilFunc _glStencilFunc
#define glStencilOp _glStencilOp
#define glDepthFunc _glDepthFunc
#define glPixelStoref _glPixelStoref
#define glPixelStorei _glPixelStorei
#define glReadBuffer _glReadBuffer
#define glReadPixels _glReadPixels
#define glGetBooleanv _glGetBooleanv
#define glGetDoublev _glGetDoublev
#define glGetError _glGetError
#define glGetFloatv _glGetFloatv
#define glGetIntegerv _glGetIntegerv
#define glGetString _glGetString
#define glGetTexImage _glGetTexImage
#define glGetTexParameterfv _glGetTexParameterfv
#define glGetTexParameteriv _glGetTexParameteriv
#define glGetTexLevelParameterfv _glGetTexLevelParameterfv
#define glGetTexLevelParameteriv _glGetTexLevelParameteriv
#define glIsEnabled _glIsEnabled
#define glDepthRange _glDepthRange
#define glViewport _glViewport
#define glNewList _glNewList
#define glEndList _glEndList
#define glCallList _glCallList
#define glCallLists _glCallLists
#define glDeleteLists _glDeleteLists
#define glGenLists _glGenLists
#define glListBase _glListBase
#define glBegin _glBegin
#define glBitmap _glBitmap
#define glColor3b _glColor3b
#define glColor3bv _glColor3bv
#define glColor3d _glColor3d
#define glColor3dv _glColor3dv
#define glColor3f _glColor3f
#define glColor3fv _glColor3fv
#define glColor3i _glColor3i
#define glColor3iv _glColor3iv
#define glColor3s _glColor3s
#define glColor3sv _glColor3sv
#define glColor3ub _glColor3ub
#define glColor3ubv _glColor3ubv
#define glColor3ui _glColor3ui
#define glColor3uiv _glColor3uiv
#define glColor3us _glColor3us
#define glColor3usv _glColor3usv
#define glColor4b _glColor4b
#define glColor4bv _glColor4bv
#define glColor4d _glColor4d
#define glColor4dv _glColor4dv
#define glColor4f _glColor4f
#define glColor4fv _glColor4fv
#define glColor4i _glColor4i
#define glColor4iv _glColor4iv
#define glColor4s _glColor4s
#define glColor4sv _glColor4sv
#define glColor4ub _glColor4ub
#define glColor4ubv _glColor4ubv
#define glColor4ui _glColor4ui
#define glColor4uiv _glColor4uiv
#define glColor4us _glColor4us
#define glColor4usv _glColor4usv
#define glEdgeFlag _glEdgeFlag
#define glEdgeFlagv _glEdgeFlagv
#define glEnd _glEnd
#define glIndexd _glIndexd
#define glIndexdv _glIndexdv
#define glIndexf _glIndexf
#define glIndexfv _glIndexfv
#define glIndexi _glIndexi
#define glIndexiv _glIndexiv
#define glIndexs _glIndexs
#define glIndexsv _glIndexsv
#define glNormal3b _glNormal3b
#define glNormal3bv _glNormal3bv
#define glNormal3d _glNormal3d
#define glNormal3dv _glNormal3dv
#define glNormal3f _glNormal3f
#define glNormal3fv _glNormal3fv
#define glNormal3i _glNormal3i
#define glNormal3iv _glNormal3iv
#define glNormal3s _glNormal3s
#define glNormal3sv _glNormal3sv
#define glRasterPos2d _glRasterPos2d
#define glRasterPos2dv _glRasterPos2dv
#define glRasterPos2f _glRasterPos2f
#define glRasterPos2fv _glRasterPos2fv
#define glRasterPos2i _glRasterPos2i
#define glRasterPos2iv _glRasterPos2iv
#define glRasterPos2s _glRasterPos2s
#define glRasterPos2sv _glRasterPos2sv
#define glRasterPos3d _glRasterPos3d
#define glRasterPos3dv _glRasterPos3dv
#define glRasterPos3f _glRasterPos3f
#define glRasterPos3fv _glRasterPos3fv
#define glRasterPos3i _glRasterPos3i
#define glRasterPos3iv _glRasterPos3iv
#define glRasterPos3s _glRasterPos3s
#define glRasterPos3sv _glRasterPos3sv
#define glRasterPos4d _glRasterPos4d
#define glRasterPos4dv _glRasterPos4dv
#define glRasterPos4f _glRasterPos4f
#define glRasterPos4fv _glRasterPos4fv
#define glRasterPos4i _glRasterPos4i
#define glRasterPos4iv _glRasterPos4iv
#define glRasterPos4s _glRasterPos4s
#define glRasterPos4sv _glRasterPos4sv
#define glRectd _glRectd
#define glRectdv _glRectdv
#define glRectf _glRectf
#define glRectfv _glRectfv
#define glRecti _glRecti
#define glRectiv _glRectiv
#define glRects _glRects
#define glRectsv _glRectsv
#define glTexCoord1d _glTexCoord1d
#define glTexCoord1dv _glTexCoord1dv
#define glTexCoord1f _glTexCoord1f
#define glTexCoord1fv _glTexCoord1fv
#define glTexCoord1i _glTexCoord1i
#define glTexCoord1iv _glTexCoord1iv
#define glTexCoord1s _glTexCoord1s
#define glTexCoord1sv _glTexCoord1sv
#define glTexCoord2d _glTexCoord2d
#define glTexCoord2dv _glTexCoord2dv
#define glTexCoord2f _glTexCoord2f
#define glTexCoord2fv _glTexCoord2fv
#define glTexCoord2i _glTexCoord2i
#define glTexCoord2iv _glTexCoord2iv
#define glTexCoord2s _glTexCoord2s
#define glTexCoord2sv _glTexCoord2sv
#define glTexCoord3d _glTexCoord3d
#define glTexCoord3dv _glTexCoord3dv
#define glTexCoord3f _glTexCoord3f
#define glTexCoord3fv _glTexCoord3fv
#define glTexCoord3i _glTexCoord3i
#define glTexCoord3iv _glTexCoord3iv
#define glTexCoord3s _glTexCoord3s
#define glTexCoord3sv _glTexCoord3sv
#define glTexCoord4d _glTexCoord4d
#define glTexCoord4dv _glTexCoord4dv
#define glTexCoord4f _glTexCoord4f
#define glTexCoord4fv _glTexCoord4fv
#define glTexCoord4i _glTexCoord4i
#define glTexCoord4iv _glTexCoord4iv
#define glTexCoord4s _glTexCoord4s
#define glTexCoord4sv _glTexCoord4sv
#define glVertex2d _glVertex2d
#define glVertex2dv _glVertex2dv
#define glVertex2f _glVertex2f
#define glVertex2fv _glVertex2fv
#define glVertex2i _glVertex2i
#define glVertex2iv _glVertex2iv
#define glVertex2s _glVertex2s
#define glVertex2sv _glVertex2sv
#define glVertex3d _glVertex3d
#define glVertex3dv _glVertex3dv
#define glVertex3f _glVertex3f
#define glVertex3fv _glVertex3fv
#define glVertex3i _glVertex3i
#define glVertex3iv _glVertex3iv
#define glVertex3s _glVertex3s
#define glVertex3sv _glVertex3sv
#define glVertex4d _glVertex4d
#define glVertex4dv _glVertex4dv
#define glVertex4f _glVertex4f
#define glVertex4fv _glVertex4fv
#define glVertex4i _glVertex4i
#define glVertex4iv _glVertex4iv
#define glVertex4s _glVertex4s
#define glVertex4sv _glVertex4sv
#define glClipPlane _glClipPlane
#define glColorMaterial _glColorMaterial
#define glFogf _glFogf
#define glFogfv _glFogfv
#define glFogi _glFogi
#define glFogiv _glFogiv
#define glLightf _glLightf
#define glLightfv _glLightfv
#define glLighti _glLighti
#define glLightiv _glLightiv
#define glLightModelf _glLightModelf
#define glLightModelfv _glLightModelfv
#define glLightModeli _glLightModeli
#define glLightModeliv _glLightModeliv
#define glLineStipple _glLineStipple
#define glMaterialf _glMaterialf
#define glMaterialfv _glMaterialfv
#define glMateriali _glMateriali
#define glMaterialiv _glMaterialiv
#define glPolygonStipple _glPolygonStipple
#define glShadeModel _glShadeModel
#define glTexEnvf _glTexEnvf
#define glTexEnvfv _glTexEnvfv
#define glTexEnvi _glTexEnvi
#define glTexEnviv _glTexEnviv
#define glTexGend _glTexGend
#define glTexGendv _glTexGendv
#define glTexGenf _glTexGenf
#define glTexGenfv _glTexGenfv
#define glTexGeni _glTexGeni
#define glTexGeniv _glTexGeniv
#define glFeedbackBuffer _glFeedbackBuffer
#define glSelectBuffer _glSelectBuffer
#define glRenderMode _glRenderMode
#define glInitNames _glInitNames
#define glLoadName _glLoadName
#define glPassThrough _glPassThrough
#define glPopName _glPopName
#define glPushName _glPushName
#define glClearAccum _glClearAccum
#define glClearIndex _glClearIndex
#define glIndexMask _glIndexMask
#define glAccum _glAccum
#define glPopAttrib _glPopAttrib
#define glPushAttrib _glPushAttrib
#define glMap1d _glMap1d
#define glMap1f _glMap1f
#define glMap2d _glMap2d
#define glMap2f _glMap2f
#define glMapGrid1d _glMapGrid1d
#define glMapGrid1f _glMapGrid1f
#define glMapGrid2d _glMapGrid2d
#define glMapGrid2f _glMapGrid2f
#define glEvalCoord1d _glEvalCoord1d
#define glEvalCoord1dv _glEvalCoord1dv
#define glEvalCoord1f _glEvalCoord1f
#define glEvalCoord1fv _glEvalCoord1fv
#define glEvalCoord2d _glEvalCoord2d
#define glEvalCoord2dv _glEvalCoord2dv
#define glEvalCoord2f _glEvalCoord2f
#define glEvalCoord2fv _glEvalCoord2fv
#define glEvalMesh1 _glEvalMesh1
#define glEvalPoint1 _glEvalPoint1
#define glEvalMesh2 _glEvalMesh2
#define glEvalPoint2 _glEvalPoint2
#define glAlphaFunc _glAlphaFunc
#define glPixelZoom _glPixelZoom
#define glPixelTransferf _glPixelTransferf
#define glPixelTransferi _glPixelTransferi
#define glPixelMapfv _glPixelMapfv
#define glPixelMapuiv _glPixelMapuiv
#define glPixelMapusv _glPixelMapusv
#define glCopyPixels _glCopyPixels
#define glDrawPixels _glDrawPixels
#define glGetClipPlane _glGetClipPlane
#define glGetLightfv _glGetLightfv
#define glGetLightiv _glGetLightiv
#define glGetMapdv _glGetMapdv
#define glGetMapfv _glGetMapfv
#define glGetMapiv _glGetMapiv
#define glGetMaterialfv _glGetMaterialfv
#define glGetMaterialiv _glGetMaterialiv
#define glGetPixelMapfv _glGetPixelMapfv
#define glGetPixelMapuiv _glGetPixelMapuiv
#define glGetPixelMapusv _glGetPixelMapusv
#define glGetPolygonStipple _glGetPolygonStipple
#define glGetTexEnvfv _glGetTexEnvfv
#define glGetTexEnviv _glGetTexEnviv
#define glGetTexGendv _glGetTexGendv
#define glGetTexGenfv _glGetTexGenfv
#define glGetTexGeniv _glGetTexGeniv
#define glIsList _glIsList
#define glFrustum _glFrustum
#define glLoadIdentity _glLoadIdentity
#define glLoadMatrixf _glLoadMatrixf
#define glLoadMatrixd _glLoadMatrixd
#define glMatrixMode _glMatrixMode
#define glMultMatrixf _glMultMatrixf
#define glMultMatrixd _glMultMatrixd
#define glOrtho _glOrtho
#define glPopMatrix _glPopMatrix
#define glPushMatrix _glPushMatrix
#define glRotated _glRotated
#define glRotatef _glRotatef
#define glScaled _glScaled
#define glScalef _glScalef
#define glTranslated _glTranslated
#define glTranslatef _glTranslatef
#define glDrawArrays _glDrawArrays
#define glDrawElements _glDrawElements
#define glGetPointerv _glGetPointerv
#define glPolygonOffset _glPolygonOffset
#define glCopyTexImage1D _glCopyTexImage1D
#define glCopyTexImage2D _glCopyTexImage2D
#define glCopyTexSubImage1D _glCopyTexSubImage1D
#define glCopyTexSubImage2D _glCopyTexSubImage2D
#define glTexSubImage1D _glTexSubImage1D
#define glTexSubImage2D _glTexSubImage2D
#define glBindTexture _glBindTexture
#define glDeleteTextures _glDeleteTextures
#define glGenTextures _glGenTextures
#define glIsTexture _glIsTexture
#define glArrayElement _glArrayElement
#define glColorPointer _glColorPointer
#define glDisableClientState _glDisableClientState
#define glEdgeFlagPointer _glEdgeFlagPointer
#define glEnableClientState _glEnableClientState
#define glIndexPointer _glIndexPointer
#define glInterleavedArrays _glInterleavedArrays
#define glNormalPointer _glNormalPointer
#define glTexCoordPointer _glTexCoordPointer
#define glVertexPointer _glVertexPointer
#define glAreTexturesResident _glAreTexturesResident
#define glPrioritizeTextures _glPrioritizeTextures
#define glIndexub _glIndexub
#define glIndexubv _glIndexubv
#define glPopClientAttrib _glPopClientAttrib
#define glPushClientAttrib _glPushClientAttrib
#define glBlendColor _glBlendColor
#define glBlendEquation _glBlendEquation
#define glDrawRangeElements _glDrawRangeElements
#define glTexImage3D _glTexImage3D
#define glTexSubImage3D _glTexSubImage3D
#define glCopyTexSubImage3D _glCopyTexSubImage3D
#define glColorTable _glColorTable
#define glColorTableParameterfv _glColorTableParameterfv
#define glColorTableParameteriv _glColorTableParameteriv
#define glCopyColorTable _glCopyColorTable
#define glGetColorTable _glGetColorTable
#define glGetColorTableParameterfv _glGetColorTableParameterfv
#define glGetColorTableParameteriv _glGetColorTableParameteriv
#define glColorSubTable _glColorSubTable
#define glCopyColorSubTable _glCopyColorSubTable
#define glConvolutionFilter1D _glConvolutionFilter1D
#define glConvolutionFilter2D _glConvolutionFilter2D
#define glConvolutionParameterf _glConvolutionParameterf
#define glConvolutionParameterfv _glConvolutionParameterfv
#define glConvolutionParameteri _glConvolutionParameteri
#define glConvolutionParameteriv _glConvolutionParameteriv
#define glCopyConvolutionFilter1D _glCopyConvolutionFilter1D
#define glCopyConvolutionFilter2D _glCopyConvolutionFilter2D
#define glGetConvolutionFilter _glGetConvolutionFilter
#define glGetConvolutionParameterfv _glGetConvolutionParameterfv
#define glGetConvolutionParameteriv _glGetConvolutionParameteriv
#define glGetSeparableFilter _glGetSeparableFilter
#define glSeparableFilter2D _glSeparableFilter2D
#define glGetHistogram _glGetHistogram
#define glGetHistogramParameterfv _glGetHistogramParameterfv
#define glGetHistogramParameteriv _glGetHistogramParameteriv
#define glGetMinmax _glGetMinmax
#define glGetMinmaxParameterfv _glGetMinmaxParameterfv
#define glGetMinmaxParameteriv _glGetMinmaxParameteriv
#define glHistogram _glHistogram
#define glMinmax _glMinmax
#define glResetHistogram _glResetHistogram
#define glResetMinmax _glResetMinmax
#define glActiveTexture _glActiveTexture
#define glSampleCoverage _glSampleCoverage
#define glCompressedTexImage3D _glCompressedTexImage3D
#define glCompressedTexImage2D _glCompressedTexImage2D
#define glCompressedTexImage1D _glCompressedTexImage1D
#define glCompressedTexSubImage3D _glCompressedTexSubImage3D
#define glCompressedTexSubImage2D _glCompressedTexSubImage2D
#define glCompressedTexSubImage1D _glCompressedTexSubImage1D
#define glGetCompressedTexImage _glGetCompressedTexImage
#define glClientActiveTexture _glClientActiveTexture
#define glMultiTexCoord1d _glMultiTexCoord1d
#define glMultiTexCoord1dv _glMultiTexCoord1dv
#define glMultiTexCoord1f _glMultiTexCoord1f
#define glMultiTexCoord1fv _glMultiTexCoord1fv
#define glMultiTexCoord1i _glMultiTexCoord1i
#define glMultiTexCoord1iv _glMultiTexCoord1iv
#define glMultiTexCoord1s _glMultiTexCoord1s
#define glMultiTexCoord1sv _glMultiTexCoord1sv
#define glMultiTexCoord2d _glMultiTexCoord2d
#define glMultiTexCoord2dv _glMultiTexCoord2dv
#define glMultiTexCoord2f _glMultiTexCoord2f
#define glMultiTexCoord2fv _glMultiTexCoord2fv
#define glMultiTexCoord2i _glMultiTexCoord2i
#define glMultiTexCoord2iv _glMultiTexCoord2iv
#define glMultiTexCoord2s _glMultiTexCoord2s
#define glMultiTexCoord2sv _glMultiTexCoord2sv
#define glMultiTexCoord3d _glMultiTexCoord3d
#define glMultiTexCoord3dv _glMultiTexCoord3dv
#define glMultiTexCoord3f _glMultiTexCoord3f
#define glMultiTexCoord3fv _glMultiTexCoord3fv
#define glMultiTexCoord3i _glMultiTexCoord3i
#define glMultiTexCoord3iv _glMultiTexCoord3iv
#define glMultiTexCoord3s _glMultiTexCoord3s
#define glMultiTexCoord3sv _glMultiTexCoord3sv
#define glMultiTexCoord4d _glMultiTexCoord4d
#define glMultiTexCoord4dv _glMultiTexCoord4dv
#define glMultiTexCoord4f _glMultiTexCoord4f
#define glMultiTexCoord4fv _glMultiTexCoord4fv
#define glMultiTexCoord4i _glMultiTexCoord4i
#define glMultiTexCoord4iv _glMultiTexCoord4iv
#define glMultiTexCoord4s _glMultiTexCoord4s
#define glMultiTexCoord4sv _glMultiTexCoord4sv
#define glLoadTransposeMatrixf _glLoadTransposeMatrixf
#define glLoadTransposeMatrixd _glLoadTransposeMatrixd
#define glMultTransposeMatrixf _glMultTransposeMatrixf
#define glMultTransposeMatrixd _glMultTransposeMatrixd
#define glBlendFuncSeparate _glBlendFuncSeparate
#define glMultiDrawArrays _glMultiDrawArrays
#define glMultiDrawElements _glMultiDrawElements
#define glPointParameterf _glPointParameterf
#define glPointParameterfv _glPointParameterfv
#define glPointParameteri _glPointParameteri
#define glPointParameteriv _glPointParameteriv
#define glFogCoordf _glFogCoordf
#define glFogCoordfv _glFogCoordfv
#define glFogCoordd _glFogCoordd
#define glFogCoorddv _glFogCoorddv
#define glFogCoordPointer _glFogCoordPointer
#define glSecondaryColor3b _glSecondaryColor3b
#define glSecondaryColor3bv _glSecondaryColor3bv
#define glSecondaryColor3d _glSecondaryColor3d
#define glSecondaryColor3dv _glSecondaryColor3dv
#define glSecondaryColor3f _glSecondaryColor3f
#define glSecondaryColor3fv _glSecondaryColor3fv
#define glSecondaryColor3i _glSecondaryColor3i
#define glSecondaryColor3iv _glSecondaryColor3iv
#define glSecondaryColor3s _glSecondaryColor3s
#define glSecondaryColor3sv _glSecondaryColor3sv
#define glSecondaryColor3ub _glSecondaryColor3ub
#define glSecondaryColor3ubv _glSecondaryColor3ubv
#define glSecondaryColor3ui _glSecondaryColor3ui
#define glSecondaryColor3uiv _glSecondaryColor3uiv
#define glSecondaryColor3us _glSecondaryColor3us
#define glSecondaryColor3usv _glSecondaryColor3usv
#define glSecondaryColorPointer _glSecondaryColorPointer
#define glWindowPos2d _glWindowPos2d
#define glWindowPos2dv _glWindowPos2dv
#define glWindowPos2f _glWindowPos2f
#define glWindowPos2fv _glWindowPos2fv
#define glWindowPos2i _glWindowPos2i
#define glWindowPos2iv _glWindowPos2iv
#define glWindowPos2s _glWindowPos2s
#define glWindowPos2sv _glWindowPos2sv
#define glWindowPos3d _glWindowPos3d
#define glWindowPos3dv _glWindowPos3dv
#define glWindowPos3f _glWindowPos3f
#define glWindowPos3fv _glWindowPos3fv
#define glWindowPos3i _glWindowPos3i
#define glWindowPos3iv _glWindowPos3iv
#define glWindowPos3s _glWindowPos3s
#define glWindowPos3sv _glWindowPos3sv
#define glGenQueries _glGenQueries
#define glDeleteQueries _glDeleteQueries
#define glIsQuery _glIsQuery
#define glBeginQuery _glBeginQuery
#define glEndQuery _glEndQuery
#define glGetQueryiv _glGetQueryiv
#define glGetQueryObjectiv _glGetQueryObjectiv
#define glGetQueryObjectuiv _glGetQueryObjectuiv
#define glBindBuffer _glBindBuffer
#define glDeleteBuffers _glDeleteBuffers
#define glGenBuffers _glGenBuffers
#define glIsBuffer _glIsBuffer
#define glBufferData _glBufferData
#define glBufferSubData _glBufferSubData
#define glGetBufferSubData _glGetBufferSubData
#define glMapBuffer _glMapBuffer
#define glUnmapBuffer _glUnmapBuffer
#define glGetBufferParameteriv _glGetBufferParameteriv
#define glGetBufferPointerv _glGetBufferPointerv
#define glBlendEquationSeparate _glBlendEquationSeparate
#define glDrawBuffers _glDrawBuffers
#define glStencilOpSeparate _glStencilOpSeparate
#define glStencilFuncSeparate _glStencilFuncSeparate
#define glStencilMaskSeparate _glStencilMaskSeparate
#define glAttachShader _glAttachShader
#define glBindAttribLocation _glBindAttribLocation
#define glCompileShader _glCompileShader
#define glCreateProgram _glCreateProgram
#define glCreateShader _glCreateShader
#define glDeleteProgram _glDeleteProgram
#define glDeleteShader _glDeleteShader
#define glDetachShader _glDetachShader
#define glDisableVertexAttribArray _glDisableVertexAttribArray
#define glEnableVertexAttribArray _glEnableVertexAttribArray
#define glGetActiveAttrib _glGetActiveAttrib
#define glGetActiveUniform _glGetActiveUniform
#define glGetAttachedShaders _glGetAttachedShaders
#define glGetAttribLocation _glGetAttribLocation
#define glGetProgramiv _glGetProgramiv
#define glGetProgramInfoLog _glGetProgramInfoLog
#define glGetShaderiv _glGetShaderiv
#define glGetShaderInfoLog _glGetShaderInfoLog
#define glGetShaderSource _glGetShaderSource
#define glGetUniformLocation _glGetUniformLocation
#define glGetUniformfv _glGetUniformfv
#define glGetUniformiv _glGetUniformiv
#define glGetVertexAttribdv _glGetVertexAttribdv
#define glGetVertexAttribfv _glGetVertexAttribfv
#define glGetVertexAttribiv _glGetVertexAttribiv
#define glGetVertexAttribPointerv _glGetVertexAttribPointerv
#define glIsProgram _glIsProgram
#define glIsShader _glIsShader
#define glLinkProgram _glLinkProgram
#define glShaderSource _glShaderSource
#define glUseProgram _glUseProgram
#define glUniform1f _glUniform1f
#define glUniform2f _glUniform2f
#define glUniform3f _glUniform3f
#define glUniform4f _glUniform4f
#define glUniform1i _glUniform1i
#define glUniform2i _glUniform2i
#define glUniform3i _glUniform3i
#define glUniform4i _glUniform4i
#define glUniform1fv _glUniform1fv
#define glUniform2fv _glUniform2fv
#define glUniform3fv _glUniform3fv
#define glUniform4fv _glUniform4fv
#define glUniform1iv _glUniform1iv
#define glUniform2iv _glUniform2iv
#define glUniform3iv _glUniform3iv
#define glUniform4iv _glUniform4iv
#define glUniformMatrix2fv _glUniformMatrix2fv
#define glUniformMatrix3fv _glUniformMatrix3fv
#define glUniformMatrix4fv _glUniformMatrix4fv
#define glValidateProgram _glValidateProgram
#define glVertexAttrib1d _glVertexAttrib1d
#define glVertexAttrib1dv _glVertexAttrib1dv
#define glVertexAttrib1f _glVertexAttrib1f
#define glVertexAttrib1fv _glVertexAttrib1fv
#define glVertexAttrib1s _glVertexAttrib1s
#define glVertexAttrib1sv _glVertexAttrib1sv
#define glVertexAttrib2d _glVertexAttrib2d
#define glVertexAttrib2dv _glVertexAttrib2dv
#define glVertexAttrib2f _glVertexAttrib2f
#define glVertexAttrib2fv _glVertexAttrib2fv
#define glVertexAttrib2s _glVertexAttrib2s
#define glVertexAttrib2sv _glVertexAttrib2sv
#define glVertexAttrib3d _glVertexAttrib3d
#define glVertexAttrib3dv _glVertexAttrib3dv
#define glVertexAttrib3f _glVertexAttrib3f
#define glVertexAttrib3fv _glVertexAttrib3fv
#define glVertexAttrib3s _glVertexAttrib3s
#define glVertexAttrib3sv _glVertexAttrib3sv
#define glVertexAttrib4Nbv _glVertexAttrib4Nbv
#define glVertexAttrib4Niv _glVertexAttrib4Niv
#define glVertexAttrib4Nsv _glVertexAttrib4Nsv
#define glVertexAttrib4Nub _glVertexAttrib4Nub
#define glVertexAttrib4Nubv _glVertexAttrib4Nubv
#define glVertexAttrib4Nuiv _glVertexAttrib4Nuiv
#define glVertexAttrib4Nusv _glVertexAttrib4Nusv
#define glVertexAttrib4bv _glVertexAttrib4bv
#define glVertexAttrib4d _glVertexAttrib4d
#define glVertexAttrib4dv _glVertexAttrib4dv
#define glVertexAttrib4f _glVertexAttrib4f
#define glVertexAttrib4fv _glVertexAttrib4fv
#define glVertexAttrib4iv _glVertexAttrib4iv
#define glVertexAttrib4s _glVertexAttrib4s
#define glVertexAttrib4sv _glVertexAttrib4sv
#define glVertexAttrib4ubv _glVertexAttrib4ubv
#define glVertexAttrib4uiv _glVertexAttrib4uiv
#define glVertexAttrib4usv _glVertexAttrib4usv
#define glVertexAttribPointer _glVertexAttribPointer
#define glUniformMatrix2x3fv _glUniformMatrix2x3fv
#define glUniformMatrix3x2fv _glUniformMatrix3x2fv
#define glUniformMatrix2x4fv _glUniformMatrix2x4fv
#define glUniformMatrix4x2fv _glUniformMatrix4x2fv
#define glUniformMatrix3x4fv _glUniformMatrix3x4fv
#define glUniformMatrix4x3fv _glUniformMatrix4x3fv
#define glColorMaski _glColorMaski
#define glGetBooleani_v _glGetBooleani_v
#define glGetIntegeri_v _glGetIntegeri_v
#define glEnablei _glEnablei
#define glDisablei _glDisablei
#define glIsEnabledi _glIsEnabledi
#define glBeginTransformFeedback _glBeginTransformFeedback
#define glEndTransformFeedback _glEndTransformFeedback
#define glBindBufferRange _glBindBufferRange
#define glBindBufferBase _glBindBufferBase
#define glTransformFeedbackVaryings _glTransformFeedbackVaryings
#define glGetTransformFeedbackVarying _glGetTransformFeedbackVarying
#define glClampColor _glClampColor
#define glBeginConditionalRender _glBeginConditionalRender
#define glEndConditionalRender _glEndConditionalRender
#define glVertexAttribIPointer _glVertexAttribIPointer
#define glGetVertexAttribIiv _glGetVertexAttribIiv
#define glGetVertexAttribIuiv _glGetVertexAttribIuiv
#define glVertexAttribI1i _glVertexAttribI1i
#define glVertexAttribI2i _glVertexAttribI2i
#define glVertexAttribI3i _glVertexAttribI3i
#define glVertexAttribI4i _glVertexAttribI4i
#define glVertexAttribI1ui _glVertexAttribI1ui
#define glVertexAttribI2ui _glVertexAttribI2ui
#define glVertexAttribI3ui _glVertexAttribI3ui
#define glVertexAttribI4ui _glVertexAttribI4ui
#define glVertexAttribI1iv _glVertexAttribI1iv
#define glVertexAttribI2iv _glVertexAttribI2iv
#define glVertexAttribI3iv _glVertexAttribI3iv
#define glVertexAttribI4iv _glVertexAttribI4iv
#define glVertexAttribI1uiv _glVertexAttribI1uiv
#define glVertexAttribI2uiv _glVertexAttribI2uiv
#define glVertexAttribI3uiv _glVertexAttribI3uiv
#define glVertexAttribI4uiv _glVertexAttribI4uiv
#define glVertexAttribI4bv _glVertexAttribI4bv
#define glVertexAttribI4sv _glVertexAttribI4sv
#define glVertexAttribI4ubv _glVertexAttribI4ubv
#define glVertexAttribI4usv _glVertexAttribI4usv
#define glGetUniformuiv _glGetUniformuiv
#define glBindFragDataLocation _glBindFragDataLocation
#define glGetFragDataLocation _glGetFragDataLocation
#define glUniform1ui _glUniform1ui
#define glUniform2ui _glUniform2ui
#define glUniform3ui _glUniform3ui
#define glUniform4ui _glUniform4ui
#define glUniform1uiv _glUniform1uiv
#define glUniform2uiv _glUniform2uiv
#define glUniform3uiv _glUniform3uiv
#define glUniform4uiv _glUniform4uiv
#define glTexParameterIiv _glTexParameterIiv
#define glTexParameterIuiv _glTexParameterIuiv
#define glGetTexParameterIiv _glGetTexParameterIiv
#define glGetTexParameterIuiv _glGetTexParameterIuiv
#define glClearBufferiv _glClearBufferiv
#define glClearBufferuiv _glClearBufferuiv
#define glClearBufferfv _glClearBufferfv
#define glClearBufferfi _glClearBufferfi
#define glGetStringi _glGetStringi
#define glDrawArraysInstanced _glDrawArraysInstanced
#define glDrawElementsInstanced _glDrawElementsInstanced
#define glTexBuffer _glTexBuffer
#define glPrimitiveRestartIndex _glPrimitiveRestartIndex
#define glGetInteger64i_v _glGetInteger64i_v
#define glGetBufferParameteri64v _glGetBufferParameteri64v
#define glFramebufferTexture _glFramebufferTexture
#define glVertexAttribDivisor _glVertexAttribDivisor
#define glMinSampleShading _glMinSampleShading
#define glBlendEquationi _glBlendEquationi
#define glBlendEquationSeparatei _glBlendEquationSeparatei
#define glBlendFunci _glBlendFunci
#define glBlendFuncSeparatei _glBlendFuncSeparatei
#define glActiveTextureARB _glActiveTextureARB
#define glClientActiveTextureARB _glClientActiveTextureARB
#define glMultiTexCoord1dARB _glMultiTexCoord1dARB
#define glMultiTexCoord1dvARB _glMultiTexCoord1dvARB
#define glMultiTexCoord1fARB _glMultiTexCoord1fARB
#define glMultiTexCoord1fvARB _glMultiTexCoord1fvARB
#define glMultiTexCoord1iARB _glMultiTexCoord1iARB
#define glMultiTexCoord1ivARB _glMultiTexCoord1ivARB
#define glMultiTexCoord1sARB _glMultiTexCoord1sARB
#define glMultiTexCoord1svARB _glMultiTexCoord1svARB
#define glMultiTexCoord2dARB _glMultiTexCoord2dARB
#define glMultiTexCoord2dvARB _glMultiTexCoord2dvARB
#define glMultiTexCoord2fARB _glMultiTexCoord2fARB
#define glMultiTexCoord2fvARB _glMultiTexCoord2fvARB
#define glMultiTexCoord2iARB _glMultiTexCoord2iARB
#define glMultiTexCoord2ivARB _glMultiTexCoord2ivARB
#define glMultiTexCoord2sARB _glMultiTexCoord2sARB
#define glMultiTexCoord2svARB _glMultiTexCoord2svARB
#define glMultiTexCoord3dARB _glMultiTexCoord3dARB
#define glMultiTexCoord3dvARB _glMultiTexCoord3dvARB
#define glMultiTexCoord3fARB _glMultiTexCoord3fARB
#define glMultiTexCoord3fvARB _glMultiTexCoord3fvARB
#define glMultiTexCoord3iARB _glMultiTexCoord3iARB
#define glMultiTexCoord3ivARB _glMultiTexCoord3ivARB
#define glMultiTexCoord3sARB _glMultiTexCoord3sARB
#define glMultiTexCoord3svARB _glMultiTexCoord3svARB
#define glMultiTexCoord4dARB _glMultiTexCoord4dARB
#define glMultiTexCoord4dvARB _glMultiTexCoord4dvARB
#define glMultiTexCoord4fARB _glMultiTexCoord4fARB
#define glMultiTexCoord4fvARB _glMultiTexCoord4fvARB
#define glMultiTexCoord4iARB _glMultiTexCoord4iARB
#define glMultiTexCoord4ivARB _glMultiTexCoord4ivARB
#define glMultiTexCoord4sARB _glMultiTexCoord4sARB
#define glMultiTexCoord4svARB _glMultiTexCoord4svARB
#define glLoadTransposeMatrixfARB _glLoadTransposeMatrixfARB
#define glLoadTransposeMatrixdARB _glLoadTransposeMatrixdARB
#define glMultTransposeMatrixfARB _glMultTransposeMatrixfARB
#define glMultTransposeMatrixdARB _glMultTransposeMatrixdARB
#define glSampleCoverageARB _glSampleCoverageARB
#define glCompressedTexImage3DARB _glCompressedTexImage3DARB
#define glCompressedTexImage2DARB _glCompressedTexImage2DARB
#define glCompressedTexImage1DARB _glCompressedTexImage1DARB
#define glCompressedTexSubImage3DARB _glCompressedTexSubImage3DARB
#define glCompressedTexSubImage2DARB _glCompressedTexSubImage2DARB
#define glCompressedTexSubImage1DARB _glCompressedTexSubImage1DARB
#define glGetCompressedTexImageARB _glGetCompressedTexImageARB
#define glPointParameterfARB _glPointParameterfARB
#define glPointParameterfvARB _glPointParameterfvARB
#define glWeightbvARB _glWeightbvARB
#define glWeightsvARB _glWeightsvARB
#define glWeightivARB _glWeightivARB
#define glWeightfvARB _glWeightfvARB
#define glWeightdvARB _glWeightdvARB
#define glWeightubvARB _glWeightubvARB
#define glWeightusvARB _glWeightusvARB
#define glWeightuivARB _glWeightuivARB
#define glWeightPointerARB _glWeightPointerARB
#define glVertexBlendARB _glVertexBlendARB
#define glCurrentPaletteMatrixARB _glCurrentPaletteMatrixARB
#define glMatrixIndexubvARB _glMatrixIndexubvARB
#define glMatrixIndexusvARB _glMatrixIndexusvARB
#define glMatrixIndexuivARB _glMatrixIndexuivARB
#define glMatrixIndexPointerARB _glMatrixIndexPointerARB
#define glWindowPos2dARB _glWindowPos2dARB
#define glWindowPos2dvARB _glWindowPos2dvARB
#define glWindowPos2fARB _glWindowPos2fARB
#define glWindowPos2fvARB _glWindowPos2fvARB
#define glWindowPos2iARB _glWindowPos2iARB
#define glWindowPos2ivARB _glWindowPos2ivARB
#define glWindowPos2sARB _glWindowPos2sARB
#define glWindowPos2svARB _glWindowPos2svARB
#define glWindowPos3dARB _glWindowPos3dARB
#define glWindowPos3dvARB _glWindowPos3dvARB
#define glWindowPos3fARB _glWindowPos3fARB
#define glWindowPos3fvARB _glWindowPos3fvARB
#define glWindowPos3iARB _glWindowPos3iARB
#define glWindowPos3ivARB _glWindowPos3ivARB
#define glWindowPos3sARB _glWindowPos3sARB
#define glWindowPos3svARB _glWindowPos3svARB
#define glVertexAttrib1dARB _glVertexAttrib1dARB
#define glVertexAttrib1dvARB _glVertexAttrib1dvARB
#define glVertexAttrib1fARB _glVertexAttrib1fARB
#define glVertexAttrib1fvARB _glVertexAttrib1fvARB
#define glVertexAttrib1sARB _glVertexAttrib1sARB
#define glVertexAttrib1svARB _glVertexAttrib1svARB
#define glVertexAttrib2dARB _glVertexAttrib2dARB
#define glVertexAttrib2dvARB _glVertexAttrib2dvARB
#define glVertexAttrib2fARB _glVertexAttrib2fARB
#define glVertexAttrib2fvARB _glVertexAttrib2fvARB
#define glVertexAttrib2sARB _glVertexAttrib2sARB
#define glVertexAttrib2svARB _glVertexAttrib2svARB
#define glVertexAttrib3dARB _glVertexAttrib3dARB
#define glVertexAttrib3dvARB _glVertexAttrib3dvARB
#define glVertexAttrib3fARB _glVertexAttrib3fARB
#define glVertexAttrib3fvARB _glVertexAttrib3fvARB
#define glVertexAttrib3sARB _glVertexAttrib3sARB
#define glVertexAttrib3svARB _glVertexAttrib3svARB
#define glVertexAttrib4NbvARB _glVertexAttrib4NbvARB
#define glVertexAttrib4NivARB _glVertexAttrib4NivARB
#define glVertexAttrib4NsvARB _glVertexAttrib4NsvARB
#define glVertexAttrib4NubARB _glVertexAttrib4NubARB
#define glVertexAttrib4NubvARB _glVertexAttrib4NubvARB
#define glVertexAttrib4NuivARB _glVertexAttrib4NuivARB
#define glVertexAttrib4NusvARB _glVertexAttrib4NusvARB
#define glVertexAttrib4bvARB _glVertexAttrib4bvARB
#define glVertexAttrib4dARB _glVertexAttrib4dARB
#define glVertexAttrib4dvARB _glVertexAttrib4dvARB
#define glVertexAttrib4fARB _glVertexAttrib4fARB
#define glVertexAttrib4fvARB _glVertexAttrib4fvARB
#define glVertexAttrib4ivARB _glVertexAttrib4ivARB
#define glVertexAttrib4sARB _glVertexAttrib4sARB
#define glVertexAttrib4svARB _glVertexAttrib4svARB
#define glVertexAttrib4ubvARB _glVertexAttrib4ubvARB
#define glVertexAttrib4uivARB _glVertexAttrib4uivARB
#define glVertexAttrib4usvARB _glVertexAttrib4usvARB
#define glVertexAttribPointerARB _glVertexAttribPointerARB
#define glEnableVertexAttribArrayARB _glEnableVertexAttribArrayARB
#define glDisableVertexAttribArrayARB _glDisableVertexAttribArrayARB
#define glProgramStringARB _glProgramStringARB
#define glBindProgramARB _glBindProgramARB
#define glDeleteProgramsARB _glDeleteProgramsARB
#define glGenProgramsARB _glGenProgramsARB
#define glProgramEnvParameter4dARB _glProgramEnvParameter4dARB
#define glProgramEnvParameter4dvARB _glProgramEnvParameter4dvARB
#define glProgramEnvParameter4fARB _glProgramEnvParameter4fARB
#define glProgramEnvParameter4fvARB _glProgramEnvParameter4fvARB
#define glProgramLocalParameter4dARB _glProgramLocalParameter4dARB
#define glProgramLocalParameter4dvARB _glProgramLocalParameter4dvARB
#define glProgramLocalParameter4fARB _glProgramLocalParameter4fARB
#define glProgramLocalParameter4fvARB _glProgramLocalParameter4fvARB
#define glGetProgramEnvParameterdvARB _glGetProgramEnvParameterdvARB
#define glGetProgramEnvParameterfvARB _glGetProgramEnvParameterfvARB
#define glGetProgramLocalParameterdvARB _glGetProgramLocalParameterdvARB
#define glGetProgramLocalParameterfvARB _glGetProgramLocalParameterfvARB
#define glGetProgramivARB _glGetProgramivARB
#define glGetProgramStringARB _glGetProgramStringARB
#define glGetVertexAttribdvARB _glGetVertexAttribdvARB
#define glGetVertexAttribfvARB _glGetVertexAttribfvARB
#define glGetVertexAttribivARB _glGetVertexAttribivARB
#define glGetVertexAttribPointervARB _glGetVertexAttribPointervARB
#define glIsProgramARB _glIsProgramARB
#define glBindBufferARB _glBindBufferARB
#define glDeleteBuffersARB _glDeleteBuffersARB
#define glGenBuffersARB _glGenBuffersARB
#define glIsBufferARB _glIsBufferARB
#define glBufferDataARB _glBufferDataARB
#define glBufferSubDataARB _glBufferSubDataARB
#define glGetBufferSubDataARB _glGetBufferSubDataARB
#define glMapBufferARB _glMapBufferARB
#define glUnmapBufferARB _glUnmapBufferARB
#define glGetBufferParameterivARB _glGetBufferParameterivARB
#define glGetBufferPointervARB _glGetBufferPointervARB
#define glGenQueriesARB _glGenQueriesARB
#define glDeleteQueriesARB _glDeleteQueriesARB
#define glIsQueryARB _glIsQueryARB
#define glBeginQueryARB _glBeginQueryARB
#define glEndQueryARB _glEndQueryARB
#define glGetQueryivARB _glGetQueryivARB
#define glGetQueryObjectivARB _glGetQueryObjectivARB
#define glGetQueryObjectuivARB _glGetQueryObjectuivARB
#define glDeleteObjectARB _glDeleteObjectARB
#define glGetHandleARB _glGetHandleARB
#define glDetachObjectARB _glDetachObjectARB
#define glCreateShaderObjectARB _glCreateShaderObjectARB
#define glShaderSourceARB _glShaderSourceARB
#define glCompileShaderARB _glCompileShaderARB
#define glCreateProgramObjectARB _glCreateProgramObjectARB
#define glAttachObjectARB _glAttachObjectARB
#define glLinkProgramARB _glLinkProgramARB
#define glUseProgramObjectARB _glUseProgramObjectARB
#define glValidateProgramARB _glValidateProgramARB
#define glUniform1fARB _glUniform1fARB
#define glUniform2fARB _glUniform2fARB
#define glUniform3fARB _glUniform3fARB
#define glUniform4fARB _glUniform4fARB
#define glUniform1iARB _glUniform1iARB
#define glUniform2iARB _glUniform2iARB
#define glUniform3iARB _glUniform3iARB
#define glUniform4iARB _glUniform4iARB
#define glUniform1fvARB _glUniform1fvARB
#define glUniform2fvARB _glUniform2fvARB
#define glUniform3fvARB _glUniform3fvARB
#define glUniform4fvARB _glUniform4fvARB
#define glUniform1ivARB _glUniform1ivARB
#define glUniform2ivARB _glUniform2ivARB
#define glUniform3ivARB _glUniform3ivARB
#define glUniform4ivARB _glUniform4ivARB
#define glUniformMatrix2fvARB _glUniformMatrix2fvARB
#define glUniformMatrix3fvARB _glUniformMatrix3fvARB
#define glUniformMatrix4fvARB _glUniformMatrix4fvARB
#define glGetObjectParameterfvARB _glGetObjectParameterfvARB
#define glGetObjectParameterivARB _glGetObjectParameterivARB
#define glGetInfoLogARB _glGetInfoLogARB
#define glGetAttachedObjectsARB _glGetAttachedObjectsARB
#define glGetUniformLocationARB _glGetUniformLocationARB
#define glGetActiveUniformARB _glGetActiveUniformARB
#define glGetUniformfvARB _glGetUniformfvARB
#define glGetUniformivARB _glGetUniformivARB
#define glGetShaderSourceARB _glGetShaderSourceARB
#define glBindAttribLocationARB _glBindAttribLocationARB
#define glGetActiveAttribARB _glGetActiveAttribARB
#define glGetAttribLocationARB _glGetAttribLocationARB
#define glDrawBuffersARB _glDrawBuffersARB
#define glClampColorARB _glClampColorARB
#define glDrawArraysInstancedARB _glDrawArraysInstancedARB
#define glDrawElementsInstancedARB _glDrawElementsInstancedARB
#define glIsRenderbuffer _glIsRenderbuffer
#define glBindRenderbuffer _glBindRenderbuffer
#define glDeleteRenderbuffers _glDeleteRenderbuffers
#define glGenRenderbuffers _glGenRenderbuffers
#define glRenderbufferStorage _glRenderbufferStorage
#define glGetRenderbufferParameteriv _glGetRenderbufferParameteriv
#define glIsFramebuffer _glIsFramebuffer
#define glBindFramebuffer _glBindFramebuffer
#define glDeleteFramebuffers _glDeleteFramebuffers
#define glGenFramebuffers _glGenFramebuffers
#define glCheckFramebufferStatus _glCheckFramebufferStatus
#define glFramebufferTexture1D _glFramebufferTexture1D
#define glFramebufferTexture2D _glFramebufferTexture2D
#define glFramebufferTexture3D _glFramebufferTexture3D
#define glFramebufferRenderbuffer _glFramebufferRenderbuffer
#define glGetFramebufferAttachmentParameteriv _glGetFramebufferAttachmentParameteriv
#define glGenerateMipmap _glGenerateMipmap
#define glBlitFramebuffer _glBlitFramebuffer
#define glRenderbufferStorageMultisample _glRenderbufferStorageMultisample
#define glFramebufferTextureLayer _glFramebufferTextureLayer
#define glProgramParameteriARB _glProgramParameteriARB
#define glFramebufferTextureARB _glFramebufferTextureARB
#define glFramebufferTextureLayerARB _glFramebufferTextureLayerARB
#define glFramebufferTextureFaceARB _glFramebufferTextureFaceARB
#define glVertexAttribDivisorARB _glVertexAttribDivisorARB
#define glMapBufferRange _glMapBufferRange
#define glFlushMappedBufferRange _glFlushMappedBufferRange
#define glTexBufferARB _glTexBufferARB
#define glBindVertexArray _glBindVertexArray
#define glDeleteVertexArrays _glDeleteVertexArrays
#define glGenVertexArrays _glGenVertexArrays
#define glIsVertexArray _glIsVertexArray
#define glGetUniformIndices _glGetUniformIndices
#define glGetActiveUniformsiv _glGetActiveUniformsiv
#define glGetActiveUniformName _glGetActiveUniformName
#define glGetUniformBlockIndex _glGetUniformBlockIndex
#define glGetActiveUniformBlockiv _glGetActiveUniformBlockiv
#define glGetActiveUniformBlockName _glGetActiveUniformBlockName
#define glUniformBlockBinding _glUniformBlockBinding
#define glCopyBufferSubData _glCopyBufferSubData
#define glDrawElementsBaseVertex _glDrawElementsBaseVertex
#define glDrawRangeElementsBaseVertex _glDrawRangeElementsBaseVertex
#define glDrawElementsInstancedBaseVertex _glDrawElementsInstancedBaseVertex
#define glMultiDrawElementsBaseVertex _glMultiDrawElementsBaseVertex
#define glProvokingVertex _glProvokingVertex
#define glFenceSync _glFenceSync
#define glIsSync _glIsSync
#define glDeleteSync _glDeleteSync
#define glClientWaitSync _glClientWaitSync
#define glWaitSync _glWaitSync
#define glGetInteger64v _glGetInteger64v
#define glGetSynciv _glGetSynciv
#define glTexImage2DMultisample _glTexImage2DMultisample
#define glTexImage3DMultisample _glTexImage3DMultisample
#define glGetMultisamplefv _glGetMultisamplefv
#define glSampleMaski _glSampleMaski
#define glBlendEquationiARB _glBlendEquationiARB
#define glBlendEquationSeparateiARB _glBlendEquationSeparateiARB
#define glBlendFunciARB _glBlendFunciARB
#define glBlendFuncSeparateiARB _glBlendFuncSeparateiARB
#define glMinSampleShadingARB _glMinSampleShadingARB
#define glNamedStringARB _glNamedStringARB
#define glDeleteNamedStringARB _glDeleteNamedStringARB
#define glCompileShaderIncludeARB _glCompileShaderIncludeARB
#define glIsNamedStringARB _glIsNamedStringARB
#define glGetNamedStringARB _glGetNamedStringARB
#define glGetNamedStringivARB _glGetNamedStringivARB
#define glBindFragDataLocationIndexed _glBindFragDataLocationIndexed
#define glGetFragDataIndex _glGetFragDataIndex
#define glGenSamplers _glGenSamplers
#define glDeleteSamplers _glDeleteSamplers
#define glIsSampler _glIsSampler
#define glBindSampler _glBindSampler
#define glSamplerParameteri _glSamplerParameteri
#define glSamplerParameteriv _glSamplerParameteriv
#define glSamplerParameterf _glSamplerParameterf
#define glSamplerParameterfv _glSamplerParameterfv
#define glSamplerParameterIiv _glSamplerParameterIiv
#define glSamplerParameterIuiv _glSamplerParameterIuiv
#define glGetSamplerParameteriv _glGetSamplerParameteriv
#define glGetSamplerParameterIiv _glGetSamplerParameterIiv
#define glGetSamplerParameterfv _glGetSamplerParameterfv
#define glGetSamplerParameterIuiv _glGetSamplerParameterIuiv
#define glQueryCounter _glQueryCounter
#define glGetQueryObjecti64v _glGetQueryObjecti64v
#define glGetQueryObjectui64v _glGetQueryObjectui64v
#define glVertexP2ui _glVertexP2ui
#define glVertexP2uiv _glVertexP2uiv
#define glVertexP3ui _glVertexP3ui
#define glVertexP3uiv _glVertexP3uiv
#define glVertexP4ui _glVertexP4ui
#define glVertexP4uiv _glVertexP4uiv
#define glTexCoordP1ui _glTexCoordP1ui
#define glTexCoordP1uiv _glTexCoordP1uiv
#define glTexCoordP2ui _glTexCoordP2ui
#define glTexCoordP2uiv _glTexCoordP2uiv
#define glTexCoordP3ui _glTexCoordP3ui
#define glTexCoordP3uiv _glTexCoordP3uiv
#define glTexCoordP4ui _glTexCoordP4ui
#define glTexCoordP4uiv _glTexCoordP4uiv
#define glMultiTexCoordP1ui _glMultiTexCoordP1ui
#define glMultiTexCoordP1uiv _glMultiTexCoordP1uiv
#define glMultiTexCoordP2ui _glMultiTexCoordP2ui
#define glMultiTexCoordP2uiv _glMultiTexCoordP2uiv
#define glMultiTexCoordP3ui _glMultiTexCoordP3ui
#define glMultiTexCoordP3uiv _glMultiTexCoordP3uiv
#define glMultiTexCoordP4ui _glMultiTexCoordP4ui
#define glMultiTexCoordP4uiv _glMultiTexCoordP4uiv
#define glNormalP3ui _glNormalP3ui
#define glNormalP3uiv _glNormalP3uiv
#define glColorP3ui _glColorP3ui
#define glColorP3uiv _glColorP3uiv
#define glColorP4ui _glColorP4ui
#define glColorP4uiv _glColorP4uiv
#define glSecondaryColorP3ui _glSecondaryColorP3ui
#define glSecondaryColorP3uiv _glSecondaryColorP3uiv
#define glVertexAttribP1ui _glVertexAttribP1ui
#define glVertexAttribP1uiv _glVertexAttribP1uiv
#define glVertexAttribP2ui _glVertexAttribP2ui
#define glVertexAttribP2uiv _glVertexAttribP2uiv
#define glVertexAttribP3ui _glVertexAttribP3ui
#define glVertexAttribP3uiv _glVertexAttribP3uiv
#define glVertexAttribP4ui _glVertexAttribP4ui
#define glVertexAttribP4uiv _glVertexAttribP4uiv
#define glDrawArraysIndirect _glDrawArraysIndirect
#define glDrawElementsIndirect _glDrawElementsIndirect
#define glUniform1d _glUniform1d
#define glUniform2d _glUniform2d
#define glUniform3d _glUniform3d
#define glUniform4d _glUniform4d
#define glUniform1dv _glUniform1dv
#define glUniform2dv _glUniform2dv
#define glUniform3dv _glUniform3dv
#define glUniform4dv _glUniform4dv
#define glUniformMatrix2dv _glUniformMatrix2dv
#define glUniformMatrix3dv _glUniformMatrix3dv
#define glUniformMatrix4dv _glUniformMatrix4dv
#define glUniformMatrix2x3dv _glUniformMatrix2x3dv
#define glUniformMatrix2x4dv _glUniformMatrix2x4dv
#define glUniformMatrix3x2dv _glUniformMatrix3x2dv
#define glUniformMatrix3x4dv _glUniformMatrix3x4dv
#define glUniformMatrix4x2dv _glUniformMatrix4x2dv
#define glUniformMatrix4x3dv _glUniformMatrix4x3dv
#define glGetUniformdv _glGetUniformdv
#define glGetSubroutineUniformLocation _glGetSubroutineUniformLocation
#define glGetSubroutineIndex _glGetSubroutineIndex
#define glGetActiveSubroutineUniformiv _glGetActiveSubroutineUniformiv
#define glGetActiveSubroutineUniformName _glGetActiveSubroutineUniformName
#define glGetActiveSubroutineName _glGetActiveSubroutineName
#define glUniformSubroutinesuiv _glUniformSubroutinesuiv
#define glGetUniformSubroutineuiv _glGetUniformSubroutineuiv
#define glGetProgramStageiv _glGetProgramStageiv
#define glPatchParameteri _glPatchParameteri
#define glPatchParameterfv _glPatchParameterfv
#define glBindTransformFeedback _glBindTransformFeedback
#define glDeleteTransformFeedbacks _glDeleteTransformFeedbacks
#define glGenTransformFeedbacks _glGenTransformFeedbacks
#define glIsTransformFeedback _glIsTransformFeedback
#define glPauseTransformFeedback _glPauseTransformFeedback
#define glResumeTransformFeedback _glResumeTransformFeedback
#define glDrawTransformFeedback _glDrawTransformFeedback
#define glDrawTransformFeedbackStream _glDrawTransformFeedbackStream
#define glBeginQueryIndexed _glBeginQueryIndexed
#define glEndQueryIndexed _glEndQueryIndexed
#define glGetQueryIndexediv _glGetQueryIndexediv
#define glReleaseShaderCompiler _glReleaseShaderCompiler
#define glShaderBinary _glShaderBinary
#define glGetShaderPrecisionFormat _glGetShaderPrecisionFormat
#define glDepthRangef _glDepthRangef
#define glClearDepthf _glClearDepthf
#define glGetProgramBinary _glGetProgramBinary
#define glProgramBinary _glProgramBinary
#define glProgramParameteri _glProgramParameteri
#define glUseProgramStages _glUseProgramStages
#define glActiveShaderProgram _glActiveShaderProgram
#define glCreateShaderProgramv _glCreateShaderProgramv
#define glBindProgramPipeline _glBindProgramPipeline
#define glDeleteProgramPipelines _glDeleteProgramPipelines
#define glGenProgramPipelines _glGenProgramPipelines
#define glIsProgramPipeline _glIsProgramPipeline
#define glGetProgramPipelineiv _glGetProgramPipelineiv
#define glProgramUniform1i _glProgramUniform1i
#define glProgramUniform1iv _glProgramUniform1iv
#define glProgramUniform1f _glProgramUniform1f
#define glProgramUniform1fv _glProgramUniform1fv
#define glProgramUniform1d _glProgramUniform1d
#define glProgramUniform1dv _glProgramUniform1dv
#define glProgramUniform1ui _glProgramUniform1ui
#define glProgramUniform1uiv _glProgramUniform1uiv
#define glProgramUniform2i _glProgramUniform2i
#define glProgramUniform2iv _glProgramUniform2iv
#define glProgramUniform2f _glProgramUniform2f
#define glProgramUniform2fv _glProgramUniform2fv
#define glProgramUniform2d _glProgramUniform2d
#define glProgramUniform2dv _glProgramUniform2dv
#define glProgramUniform2ui _glProgramUniform2ui
#define glProgramUniform2uiv _glProgramUniform2uiv
#define glProgramUniform3i _glProgramUniform3i
#define glProgramUniform3iv _glProgramUniform3iv
#define glProgramUniform3f _glProgramUniform3f
#define glProgramUniform3fv _glProgramUniform3fv
#define glProgramUniform3d _glProgramUniform3d
#define glProgramUniform3dv _glProgramUniform3dv
#define glProgramUniform3ui _glProgramUniform3ui
#define glProgramUniform3uiv _glProgramUniform3uiv
#define glProgramUniform4i _glProgramUniform4i
#define glProgramUniform4iv _glProgramUniform4iv
#define glProgramUniform4f _glProgramUniform4f
#define glProgramUniform4fv _glProgramUniform4fv
#define glProgramUniform4d _glProgramUniform4d
#define glProgramUniform4dv _glProgramUniform4dv
#define glProgramUniform4ui _glProgramUniform4ui
#define glProgramUniform4uiv _glProgramUniform4uiv
#define glProgramUniformMatrix2fv _glProgramUniformMatrix2fv
#define glProgramUniformMatrix3fv _glProgramUniformMatrix3fv
#define glProgramUniformMatrix4fv _glProgramUniformMatrix4fv
#define glProgramUniformMatrix2dv _glProgramUniformMatrix2dv
#define glProgramUniformMatrix3dv _glProgramUniformMatrix3dv
#define glProgramUniformMatrix4dv _glProgramUniformMatrix4dv
#define glProgramUniformMatrix2x3fv _glProgramUniformMatrix2x3fv
#define glProgramUniformMatrix3x2fv _glProgramUniformMatrix3x2fv
#define glProgramUniformMatrix2x4fv _glProgramUniformMatrix2x4fv
#define glProgramUniformMatrix4x2fv _glProgramUniformMatrix4x2fv
#define glProgramUniformMatrix3x4fv _glProgramUniformMatrix3x4fv
#define glProgramUniformMatrix4x3fv _glProgramUniformMatrix4x3fv
#define glProgramUniformMatrix2x3dv _glProgramUniformMatrix2x3dv
#define glProgramUniformMatrix3x2dv _glProgramUniformMatrix3x2dv
#define glProgramUniformMatrix2x4dv _glProgramUniformMatrix2x4dv
#define glProgramUniformMatrix4x2dv _glProgramUniformMatrix4x2dv
#define glProgramUniformMatrix3x4dv _glProgramUniformMatrix3x4dv
#define glProgramUniformMatrix4x3dv _glProgramUniformMatrix4x3dv
#define glValidateProgramPipeline _glValidateProgramPipeline
#define glGetProgramPipelineInfoLog _glGetProgramPipelineInfoLog
#define glVertexAttribL1d _glVertexAttribL1d
#define glVertexAttribL2d _glVertexAttribL2d
#define glVertexAttribL3d _glVertexAttribL3d
#define glVertexAttribL4d _glVertexAttribL4d
#define glVertexAttribL1dv _glVertexAttribL1dv
#define glVertexAttribL2dv _glVertexAttribL2dv
#define glVertexAttribL3dv _glVertexAttribL3dv
#define glVertexAttribL4dv _glVertexAttribL4dv
#define glVertexAttribLPointer _glVertexAttribLPointer
#define glGetVertexAttribLdv _glGetVertexAttribLdv
#define glViewportArrayv _glViewportArrayv
#define glViewportIndexedf _glViewportIndexedf
#define glViewportIndexedfv _glViewportIndexedfv
#define glScissorArrayv _glScissorArrayv
#define glScissorIndexed _glScissorIndexed
#define glScissorIndexedv _glScissorIndexedv
#define glDepthRangeArrayv _glDepthRangeArrayv
#define glDepthRangeIndexed _glDepthRangeIndexed
#define glGetFloati_v _glGetFloati_v
#define glGetDoublei_v _glGetDoublei_v
#define glDebugMessageControlARB _glDebugMessageControlARB
#define glDebugMessageInsertARB _glDebugMessageInsertARB
#define glDebugMessageCallbackARB _glDebugMessageCallbackARB
#define glGetDebugMessageLogARB _glGetDebugMessageLogARB
#define glGetGraphicsResetStatusARB _glGetGraphicsResetStatusARB
#define glGetnMapdvARB _glGetnMapdvARB
#define glGetnMapfvARB _glGetnMapfvARB
#define glGetnMapivARB _glGetnMapivARB
#define glGetnPixelMapfvARB _glGetnPixelMapfvARB
#define glGetnPixelMapuivARB _glGetnPixelMapuivARB
#define glGetnPixelMapusvARB _glGetnPixelMapusvARB
#define glGetnPolygonStippleARB _glGetnPolygonStippleARB
#define glGetnColorTableARB _glGetnColorTableARB
#define glGetnConvolutionFilterARB _glGetnConvolutionFilterARB
#define glGetnSeparableFilterARB _glGetnSeparableFilterARB
#define glGetnHistogramARB _glGetnHistogramARB
#define glGetnMinmaxARB _glGetnMinmaxARB
#define glGetnTexImageARB _glGetnTexImageARB
#define glReadnPixelsARB _glReadnPixelsARB
#define glGetnCompressedTexImageARB _glGetnCompressedTexImageARB
#define glGetnUniformfvARB _glGetnUniformfvARB
#define glGetnUniformivARB _glGetnUniformivARB
#define glGetnUniformuivARB _glGetnUniformuivARB
#define glGetnUniformdvARB _glGetnUniformdvARB
#define glDrawArraysInstancedBaseInstance _glDrawArraysInstancedBaseInstance
#define glDrawElementsInstancedBaseInstance _glDrawElementsInstancedBaseInstance
#define glDrawElementsInstancedBaseVertexBaseInstance _glDrawElementsInstancedBaseVertexBaseInstance
#define glDrawTransformFeedbackInstanced _glDrawTransformFeedbackInstanced
#define glDrawTransformFeedbackStreamInstanced _glDrawTransformFeedbackStreamInstanced
#define glGetInternalformativ _glGetInternalformativ
#define glGetActiveAtomicCounterBufferiv _glGetActiveAtomicCounterBufferiv
#define glBindImageTexture _glBindImageTexture
#define glMemoryBarrier _glMemoryBarrier
#define glTexStorage1D _glTexStorage1D
#define glTexStorage2D _glTexStorage2D
#define glTexStorage3D _glTexStorage3D
#define glTextureStorage1DEXT _glTextureStorage1DEXT
#define glTextureStorage2DEXT _glTextureStorage2DEXT
#define glTextureStorage3DEXT _glTextureStorage3DEXT
#define glDebugMessageControl _glDebugMessageControl
#define glDebugMessageInsert _glDebugMessageInsert
#define glDebugMessageCallback _glDebugMessageCallback
#define glGetDebugMessageLog _glGetDebugMessageLog
#define glPushDebugGroup _glPushDebugGroup
#define glPopDebugGroup _glPopDebugGroup
#define glObjectLabel _glObjectLabel
#define glGetObjectLabel _glGetObjectLabel
#define glObjectPtrLabel _glObjectPtrLabel
#define glGetObjectPtrLabel _glGetObjectPtrLabel
#define glClearBufferData _glClearBufferData
#define glClearBufferSubData _glClearBufferSubData
#define glClearNamedBufferDataEXT _glClearNamedBufferDataEXT
#define glClearNamedBufferSubDataEXT _glClearNamedBufferSubDataEXT
#define glDispatchCompute _glDispatchCompute
#define glDispatchComputeIndirect _glDispatchComputeIndirect
#define glCopyImageSubData _glCopyImageSubData
#define glFramebufferParameteri _glFramebufferParameteri
#define glGetFramebufferParameteriv _glGetFramebufferParameteriv
#define glNamedFramebufferParameteriEXT _glNamedFramebufferParameteriEXT
#define glGetNamedFramebufferParameterivEXT _glGetNamedFramebufferParameterivEXT
#define glGetInternalformati64v _glGetInternalformati64v
#define glInvalidateTexSubImage _glInvalidateTexSubImage
#define glInvalidateTexImage _glInvalidateTexImage
#define glInvalidateBufferSubData _glInvalidateBufferSubData
#define glInvalidateBufferData _glInvalidateBufferData
#define glInvalidateFramebuffer _glInvalidateFramebuffer
#define glInvalidateSubFramebuffer _glInvalidateSubFramebuffer
#define glMultiDrawArraysIndirect _glMultiDrawArraysIndirect
#define glMultiDrawElementsIndirect _glMultiDrawElementsIndirect
#define glGetProgramInterfaceiv _glGetProgramInterfaceiv
#define glGetProgramResourceIndex _glGetProgramResourceIndex
#define glGetProgramResourceName _glGetProgramResourceName
#define glGetProgramResourceiv _glGetProgramResourceiv
#define glGetProgramResourceLocation _glGetProgramResourceLocation
#define glGetProgramResourceLocationIndex _glGetProgramResourceLocationIndex
#define glShaderStorageBlockBinding _glShaderStorageBlockBinding
#define glTexBufferRange _glTexBufferRange
#define glTextureBufferRangeEXT _glTextureBufferRangeEXT
#define glTexStorage2DMultisample _glTexStorage2DMultisample
#define glTexStorage3DMultisample _glTexStorage3DMultisample
#define glTextureStorage2DMultisampleEXT _glTextureStorage2DMultisampleEXT
#define glTextureStorage3DMultisampleEXT _glTextureStorage3DMultisampleEXT
#define glTextureView _glTextureView
#define glBindVertexBuffer _glBindVertexBuffer
#define glVertexAttribFormat _glVertexAttribFormat
#define glVertexAttribIFormat _glVertexAttribIFormat
#define glVertexAttribLFormat _glVertexAttribLFormat
#define glVertexAttribBinding _glVertexAttribBinding
#define glVertexBindingDivisor _glVertexBindingDivisor
#define glVertexArrayBindVertexBufferEXT _glVertexArrayBindVertexBufferEXT
#define glVertexArrayVertexAttribFormatEXT _glVertexArrayVertexAttribFormatEXT
#define glVertexArrayVertexAttribIFormatEXT _glVertexArrayVertexAttribIFormatEXT
#define glVertexArrayVertexAttribLFormatEXT _glVertexArrayVertexAttribLFormatEXT
#define glVertexArrayVertexAttribBindingEXT _glVertexArrayVertexAttribBindingEXT
#define glVertexArrayVertexBindingDivisorEXT _glVertexArrayVertexBindingDivisorEXT
#define glBlendColorEXT _glBlendColorEXT
#define glPolygonOffsetEXT _glPolygonOffsetEXT
#define glTexImage3DEXT _glTexImage3DEXT
#define glTexSubImage3DEXT _glTexSubImage3DEXT
#define glGetTexFilterFuncSGIS _glGetTexFilterFuncSGIS
#define glTexFilterFuncSGIS _glTexFilterFuncSGIS
#define glTexSubImage1DEXT _glTexSubImage1DEXT
#define glTexSubImage2DEXT _glTexSubImage2DEXT
#define glCopyTexImage1DEXT _glCopyTexImage1DEXT
#define glCopyTexImage2DEXT _glCopyTexImage2DEXT
#define glCopyTexSubImage1DEXT _glCopyTexSubImage1DEXT
#define glCopyTexSubImage2DEXT _glCopyTexSubImage2DEXT
#define glCopyTexSubImage3DEXT _glCopyTexSubImage3DEXT
#define glGetHistogramEXT _glGetHistogramEXT
#define glGetHistogramParameterfvEXT _glGetHistogramParameterfvEXT
#define glGetHistogramParameterivEXT _glGetHistogramParameterivEXT
#define glGetMinmaxEXT _glGetMinmaxEXT
#define glGetMinmaxParameterfvEXT _glGetMinmaxParameterfvEXT
#define glGetMinmaxParameterivEXT _glGetMinmaxParameterivEXT
#define glHistogramEXT _glHistogramEXT
#define glMinmaxEXT _glMinmaxEXT
#define glResetHistogramEXT _glResetHistogramEXT
#define glResetMinmaxEXT _glResetMinmaxEXT
#define glConvolutionFilter1DEXT _glConvolutionFilter1DEXT
#define glConvolutionFilter2DEXT _glConvolutionFilter2DEXT
#define glConvolutionParameterfEXT _glConvolutionParameterfEXT
#define glConvolutionParameterfvEXT _glConvolutionParameterfvEXT
#define glConvolutionParameteriEXT _glConvolutionParameteriEXT
#define glConvolutionParameterivEXT _glConvolutionParameterivEXT
#define glCopyConvolutionFilter1DEXT _glCopyConvolutionFilter1DEXT
#define glCopyConvolutionFilter2DEXT _glCopyConvolutionFilter2DEXT
#define glGetConvolutionFilterEXT _glGetConvolutionFilterEXT
#define glGetConvolutionParameterfvEXT _glGetConvolutionParameterfvEXT
#define glGetConvolutionParameterivEXT _glGetConvolutionParameterivEXT
#define glGetSeparableFilterEXT _glGetSeparableFilterEXT
#define glSeparableFilter2DEXT _glSeparableFilter2DEXT
#define glColorTableSGI _glColorTableSGI
#define glColorTableParameterfvSGI _glColorTableParameterfvSGI
#define glColorTableParameterivSGI _glColorTableParameterivSGI
#define glCopyColorTableSGI _glCopyColorTableSGI
#define glGetColorTableSGI _glGetColorTableSGI
#define glGetColorTableParameterfvSGI _glGetColorTableParameterfvSGI
#define glGetColorTableParameterivSGI _glGetColorTableParameterivSGI
#define glPixelTexGenSGIX _glPixelTexGenSGIX
#define glPixelTexGenParameteriSGIS _glPixelTexGenParameteriSGIS
#define glPixelTexGenParameterivSGIS _glPixelTexGenParameterivSGIS
#define glPixelTexGenParameterfSGIS _glPixelTexGenParameterfSGIS
#define glPixelTexGenParameterfvSGIS _glPixelTexGenParameterfvSGIS
#define glGetPixelTexGenParameterivSGIS _glGetPixelTexGenParameterivSGIS
#define glGetPixelTexGenParameterfvSGIS _glGetPixelTexGenParameterfvSGIS
#define glTexImage4DSGIS _glTexImage4DSGIS
#define glTexSubImage4DSGIS _glTexSubImage4DSGIS
#define glAreTexturesResidentEXT _glAreTexturesResidentEXT
#define glBindTextureEXT _glBindTextureEXT
#define glDeleteTexturesEXT _glDeleteTexturesEXT
#define glGenTexturesEXT _glGenTexturesEXT
#define glIsTextureEXT _glIsTextureEXT
#define glPrioritizeTexturesEXT _glPrioritizeTexturesEXT
#define glDetailTexFuncSGIS _glDetailTexFuncSGIS
#define glGetDetailTexFuncSGIS _glGetDetailTexFuncSGIS
#define glSharpenTexFuncSGIS _glSharpenTexFuncSGIS
#define glGetSharpenTexFuncSGIS _glGetSharpenTexFuncSGIS
#define glSampleMaskSGIS _glSampleMaskSGIS
#define glSamplePatternSGIS _glSamplePatternSGIS
#define glArrayElementEXT _glArrayElementEXT
#define glColorPointerEXT _glColorPointerEXT
#define glDrawArraysEXT _glDrawArraysEXT
#define glEdgeFlagPointerEXT _glEdgeFlagPointerEXT
#define glGetPointervEXT _glGetPointervEXT
#define glIndexPointerEXT _glIndexPointerEXT
#define glNormalPointerEXT _glNormalPointerEXT
#define glTexCoordPointerEXT _glTexCoordPointerEXT
#define glVertexPointerEXT _glVertexPointerEXT
#define glBlendEquationEXT _glBlendEquationEXT
#define glSpriteParameterfSGIX _glSpriteParameterfSGIX
#define glSpriteParameterfvSGIX _glSpriteParameterfvSGIX
#define glSpriteParameteriSGIX _glSpriteParameteriSGIX
#define glSpriteParameterivSGIX _glSpriteParameterivSGIX
#define glPointParameterfEXT _glPointParameterfEXT
#define glPointParameterfvEXT _glPointParameterfvEXT
#define glPointParameterfSGIS _glPointParameterfSGIS
#define glPointParameterfvSGIS _glPointParameterfvSGIS
#define glGetInstrumentsSGIX _glGetInstrumentsSGIX
#define glInstrumentsBufferSGIX _glInstrumentsBufferSGIX
#define glPollInstrumentsSGIX _glPollInstrumentsSGIX
#define glReadInstrumentsSGIX _glReadInstrumentsSGIX
#define glStartInstrumentsSGIX _glStartInstrumentsSGIX
#define glStopInstrumentsSGIX _glStopInstrumentsSGIX
#define glFrameZoomSGIX _glFrameZoomSGIX
#define glTagSampleBufferSGIX _glTagSampleBufferSGIX
#define glDeformationMap3dSGIX _glDeformationMap3dSGIX
#define glDeformationMap3fSGIX _glDeformationMap3fSGIX
#define glDeformSGIX _glDeformSGIX
#define glLoadIdentityDeformationMapSGIX _glLoadIdentityDeformationMapSGIX
#define glReferencePlaneSGIX _glReferencePlaneSGIX
#define glFlushRasterSGIX _glFlushRasterSGIX
#define glFogFuncSGIS _glFogFuncSGIS
#define glGetFogFuncSGIS _glGetFogFuncSGIS
#define glImageTransformParameteriHP _glImageTransformParameteriHP
#define glImageTransformParameterfHP _glImageTransformParameterfHP
#define glImageTransformParameterivHP _glImageTransformParameterivHP
#define glImageTransformParameterfvHP _glImageTransformParameterfvHP
#define glGetImageTransformParameterivHP _glGetImageTransformParameterivHP
#define glGetImageTransformParameterfvHP _glGetImageTransformParameterfvHP
#define glColorSubTableEXT _glColorSubTableEXT
#define glCopyColorSubTableEXT _glCopyColorSubTableEXT
#define glHintPGI _glHintPGI
#define glColorTableEXT _glColorTableEXT
#define glGetColorTableEXT _glGetColorTableEXT
#define glGetColorTableParameterivEXT _glGetColorTableParameterivEXT
#define glGetColorTableParameterfvEXT _glGetColorTableParameterfvEXT
#define glGetListParameterfvSGIX _glGetListParameterfvSGIX
#define glGetListParameterivSGIX _glGetListParameterivSGIX
#define glListParameterfSGIX _glListParameterfSGIX
#define glListParameterfvSGIX _glListParameterfvSGIX
#define glListParameteriSGIX _glListParameteriSGIX
#define glListParameterivSGIX _glListParameterivSGIX
#define glIndexMaterialEXT _glIndexMaterialEXT
#define glIndexFuncEXT _glIndexFuncEXT
#define glLockArraysEXT _glLockArraysEXT
#define glUnlockArraysEXT _glUnlockArraysEXT
#define glCullParameterdvEXT _glCullParameterdvEXT
#define glCullParameterfvEXT _glCullParameterfvEXT
#define glFragmentColorMaterialSGIX _glFragmentColorMaterialSGIX
#define glFragmentLightfSGIX _glFragmentLightfSGIX
#define glFragmentLightfvSGIX _glFragmentLightfvSGIX
#define glFragmentLightiSGIX _glFragmentLightiSGIX
#define glFragmentLightivSGIX _glFragmentLightivSGIX
#define glFragmentLightModelfSGIX _glFragmentLightModelfSGIX
#define glFragmentLightModelfvSGIX _glFragmentLightModelfvSGIX
#define glFragmentLightModeliSGIX _glFragmentLightModeliSGIX
#define glFragmentLightModelivSGIX _glFragmentLightModelivSGIX
#define glFragmentMaterialfSGIX _glFragmentMaterialfSGIX
#define glFragmentMaterialfvSGIX _glFragmentMaterialfvSGIX
#define glFragmentMaterialiSGIX _glFragmentMaterialiSGIX
#define glFragmentMaterialivSGIX _glFragmentMaterialivSGIX
#define glGetFragmentLightfvSGIX _glGetFragmentLightfvSGIX
#define glGetFragmentLightivSGIX _glGetFragmentLightivSGIX
#define glGetFragmentMaterialfvSGIX _glGetFragmentMaterialfvSGIX
#define glGetFragmentMaterialivSGIX _glGetFragmentMaterialivSGIX
#define glLightEnviSGIX _glLightEnviSGIX
#define glDrawRangeElementsEXT _glDrawRangeElementsEXT
#define glApplyTextureEXT _glApplyTextureEXT
#define glTextureLightEXT _glTextureLightEXT
#define glTextureMaterialEXT _glTextureMaterialEXT
#define glAsyncMarkerSGIX _glAsyncMarkerSGIX
#define glFinishAsyncSGIX _glFinishAsyncSGIX
#define glPollAsyncSGIX _glPollAsyncSGIX
#define glGenAsyncMarkersSGIX _glGenAsyncMarkersSGIX
#define glDeleteAsyncMarkersSGIX _glDeleteAsyncMarkersSGIX
#define glIsAsyncMarkerSGIX _glIsAsyncMarkerSGIX
#define glVertexPointervINTEL _glVertexPointervINTEL
#define glNormalPointervINTEL _glNormalPointervINTEL
#define glColorPointervINTEL _glColorPointervINTEL
#define glTexCoordPointervINTEL _glTexCoordPointervINTEL
#define glPixelTransformParameteriEXT _glPixelTransformParameteriEXT
#define glPixelTransformParameterfEXT _glPixelTransformParameterfEXT
#define glPixelTransformParameterivEXT _glPixelTransformParameterivEXT
#define glPixelTransformParameterfvEXT _glPixelTransformParameterfvEXT
#define glSecondaryColor3bEXT _glSecondaryColor3bEXT
#define glSecondaryColor3bvEXT _glSecondaryColor3bvEXT
#define glSecondaryColor3dEXT _glSecondaryColor3dEXT
#define glSecondaryColor3dvEXT _glSecondaryColor3dvEXT
#define glSecondaryColor3fEXT _glSecondaryColor3fEXT
#define glSecondaryColor3fvEXT _glSecondaryColor3fvEXT
#define glSecondaryColor3iEXT _glSecondaryColor3iEXT
#define glSecondaryColor3ivEXT _glSecondaryColor3ivEXT
#define glSecondaryColor3sEXT _glSecondaryColor3sEXT
#define glSecondaryColor3svEXT _glSecondaryColor3svEXT
#define glSecondaryColor3ubEXT _glSecondaryColor3ubEXT
#define glSecondaryColor3ubvEXT _glSecondaryColor3ubvEXT
#define glSecondaryColor3uiEXT _glSecondaryColor3uiEXT
#define glSecondaryColor3uivEXT _glSecondaryColor3uivEXT
#define glSecondaryColor3usEXT _glSecondaryColor3usEXT
#define glSecondaryColor3usvEXT _glSecondaryColor3usvEXT
#define glSecondaryColorPointerEXT _glSecondaryColorPointerEXT
#define glTextureNormalEXT _glTextureNormalEXT
#define glMultiDrawArraysEXT _glMultiDrawArraysEXT
#define glMultiDrawElementsEXT _glMultiDrawElementsEXT
#define glFogCoordfEXT _glFogCoordfEXT
#define glFogCoordfvEXT _glFogCoordfvEXT
#define glFogCoorddEXT _glFogCoorddEXT
#define glFogCoorddvEXT _glFogCoorddvEXT
#define glFogCoordPointerEXT _glFogCoordPointerEXT
#define glTangent3bEXT _glTangent3bEXT
#define glTangent3bvEXT _glTangent3bvEXT
#define glTangent3dEXT _glTangent3dEXT
#define glTangent3dvEXT _glTangent3dvEXT
#define glTangent3fEXT _glTangent3fEXT
#define glTangent3fvEXT _glTangent3fvEXT
#define glTangent3iEXT _glTangent3iEXT
#define glTangent3ivEXT _glTangent3ivEXT
#define glTangent3sEXT _glTangent3sEXT
#define glTangent3svEXT _glTangent3svEXT
#define glBinormal3bEXT _glBinormal3bEXT
#define glBinormal3bvEXT _glBinormal3bvEXT
#define glBinormal3dEXT _glBinormal3dEXT
#define glBinormal3dvEXT _glBinormal3dvEXT
#define glBinormal3fEXT _glBinormal3fEXT
#define glBinormal3fvEXT _glBinormal3fvEXT
#define glBinormal3iEXT _glBinormal3iEXT
#define glBinormal3ivEXT _glBinormal3ivEXT
#define glBinormal3sEXT _glBinormal3sEXT
#define glBinormal3svEXT _glBinormal3svEXT
#define glTangentPointerEXT _glTangentPointerEXT
#define glBinormalPointerEXT _glBinormalPointerEXT
#define glFinishTextureSUNX _glFinishTextureSUNX
#define glGlobalAlphaFactorbSUN _glGlobalAlphaFactorbSUN
#define glGlobalAlphaFactorsSUN _glGlobalAlphaFactorsSUN
#define glGlobalAlphaFactoriSUN _glGlobalAlphaFactoriSUN
#define glGlobalAlphaFactorfSUN _glGlobalAlphaFactorfSUN
#define glGlobalAlphaFactordSUN _glGlobalAlphaFactordSUN
#define glGlobalAlphaFactorubSUN _glGlobalAlphaFactorubSUN
#define glGlobalAlphaFactorusSUN _glGlobalAlphaFactorusSUN
#define glGlobalAlphaFactoruiSUN _glGlobalAlphaFactoruiSUN
#define glReplacementCodeuiSUN _glReplacementCodeuiSUN
#define glReplacementCodeusSUN _glReplacementCodeusSUN
#define glReplacementCodeubSUN _glReplacementCodeubSUN
#define glReplacementCodeuivSUN _glReplacementCodeuivSUN
#define glReplacementCodeusvSUN _glReplacementCodeusvSUN
#define glReplacementCodeubvSUN _glReplacementCodeubvSUN
#define glReplacementCodePointerSUN _glReplacementCodePointerSUN
#define glColor4ubVertex2fSUN _glColor4ubVertex2fSUN
#define glColor4ubVertex2fvSUN _glColor4ubVertex2fvSUN
#define glColor4ubVertex3fSUN _glColor4ubVertex3fSUN
#define glColor4ubVertex3fvSUN _glColor4ubVertex3fvSUN
#define glColor3fVertex3fSUN _glColor3fVertex3fSUN
#define glColor3fVertex3fvSUN _glColor3fVertex3fvSUN
#define glNormal3fVertex3fSUN _glNormal3fVertex3fSUN
#define glNormal3fVertex3fvSUN _glNormal3fVertex3fvSUN
#define glColor4fNormal3fVertex3fSUN _glColor4fNormal3fVertex3fSUN
#define glColor4fNormal3fVertex3fvSUN _glColor4fNormal3fVertex3fvSUN
#define glTexCoord2fVertex3fSUN _glTexCoord2fVertex3fSUN
#define glTexCoord2fVertex3fvSUN _glTexCoord2fVertex3fvSUN
#define glTexCoord4fVertex4fSUN _glTexCoord4fVertex4fSUN
#define glTexCoord4fVertex4fvSUN _glTexCoord4fVertex4fvSUN
#define glTexCoord2fColor4ubVertex3fSUN _glTexCoord2fColor4ubVertex3fSUN
#define glTexCoord2fColor4ubVertex3fvSUN _glTexCoord2fColor4ubVertex3fvSUN
#define glTexCoord2fColor3fVertex3fSUN _glTexCoord2fColor3fVertex3fSUN
#define glTexCoord2fColor3fVertex3fvSUN _glTexCoord2fColor3fVertex3fvSUN
#define glTexCoord2fNormal3fVertex3fSUN _glTexCoord2fNormal3fVertex3fSUN
#define glTexCoord2fNormal3fVertex3fvSUN _glTexCoord2fNormal3fVertex3fvSUN
#define glTexCoord2fColor4fNormal3fVertex3fSUN _glTexCoord2fColor4fNormal3fVertex3fSUN
#define glTexCoord2fColor4fNormal3fVertex3fvSUN _glTexCoord2fColor4fNormal3fVertex3fvSUN
#define glTexCoord4fColor4fNormal3fVertex4fSUN _glTexCoord4fColor4fNormal3fVertex4fSUN
#define glTexCoord4fColor4fNormal3fVertex4fvSUN _glTexCoord4fColor4fNormal3fVertex4fvSUN
#define glReplacementCodeuiVertex3fSUN _glReplacementCodeuiVertex3fSUN
#define glReplacementCodeuiVertex3fvSUN _glReplacementCodeuiVertex3fvSUN
#define glReplacementCodeuiColor4ubVertex3fSUN _glReplacementCodeuiColor4ubVertex3fSUN
#define glReplacementCodeuiColor4ubVertex3fvSUN _glReplacementCodeuiColor4ubVertex3fvSUN
#define glReplacementCodeuiColor3fVertex3fSUN _glReplacementCodeuiColor3fVertex3fSUN
#define glReplacementCodeuiColor3fVertex3fvSUN _glReplacementCodeuiColor3fVertex3fvSUN
#define glReplacementCodeuiNormal3fVertex3fSUN _glReplacementCodeuiNormal3fVertex3fSUN
#define glReplacementCodeuiNormal3fVertex3fvSUN _glReplacementCodeuiNormal3fVertex3fvSUN
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN _glReplacementCodeuiColor4fNormal3fVertex3fSUN
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN _glReplacementCodeuiColor4fNormal3fVertex3fvSUN
#define glReplacementCodeuiTexCoord2fVertex3fSUN _glReplacementCodeuiTexCoord2fVertex3fSUN
#define glReplacementCodeuiTexCoord2fVertex3fvSUN _glReplacementCodeuiTexCoord2fVertex3fvSUN
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN _glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN _glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN
#define glBlendFuncSeparateEXT _glBlendFuncSeparateEXT
#define glBlendFuncSeparateINGR _glBlendFuncSeparateINGR
#define glVertexWeightfEXT _glVertexWeightfEXT
#define glVertexWeightfvEXT _glVertexWeightfvEXT
#define glVertexWeightPointerEXT _glVertexWeightPointerEXT
#define glFlushVertexArrayRangeNV _glFlushVertexArrayRangeNV
#define glVertexArrayRangeNV _glVertexArrayRangeNV
#define glCombinerParameterfvNV _glCombinerParameterfvNV
#define glCombinerParameterfNV _glCombinerParameterfNV
#define glCombinerParameterivNV _glCombinerParameterivNV
#define glCombinerParameteriNV _glCombinerParameteriNV
#define glCombinerInputNV _glCombinerInputNV
#define glCombinerOutputNV _glCombinerOutputNV
#define glFinalCombinerInputNV _glFinalCombinerInputNV
#define glGetCombinerInputParameterfvNV _glGetCombinerInputParameterfvNV
#define glGetCombinerInputParameterivNV _glGetCombinerInputParameterivNV
#define glGetCombinerOutputParameterfvNV _glGetCombinerOutputParameterfvNV
#define glGetCombinerOutputParameterivNV _glGetCombinerOutputParameterivNV
#define glGetFinalCombinerInputParameterfvNV _glGetFinalCombinerInputParameterfvNV
#define glGetFinalCombinerInputParameterivNV _glGetFinalCombinerInputParameterivNV
#define glResizeBuffersMESA _glResizeBuffersMESA
#define glWindowPos2dMESA _glWindowPos2dMESA
#define glWindowPos2dvMESA _glWindowPos2dvMESA
#define glWindowPos2fMESA _glWindowPos2fMESA
#define glWindowPos2fvMESA _glWindowPos2fvMESA
#define glWindowPos2iMESA _glWindowPos2iMESA
#define glWindowPos2ivMESA _glWindowPos2ivMESA
#define glWindowPos2sMESA _glWindowPos2sMESA
#define glWindowPos2svMESA _glWindowPos2svMESA
#define glWindowPos3dMESA _glWindowPos3dMESA
#define glWindowPos3dvMESA _glWindowPos3dvMESA
#define glWindowPos3fMESA _glWindowPos3fMESA
#define glWindowPos3fvMESA _glWindowPos3fvMESA
#define glWindowPos3iMESA _glWindowPos3iMESA
#define glWindowPos3ivMESA _glWindowPos3ivMESA
#define glWindowPos3sMESA _glWindowPos3sMESA
#define glWindowPos3svMESA _glWindowPos3svMESA
#define glWindowPos4dMESA _glWindowPos4dMESA
#define glWindowPos4dvMESA _glWindowPos4dvMESA
#define glWindowPos4fMESA _glWindowPos4fMESA
#define glWindowPos4fvMESA _glWindowPos4fvMESA
#define glWindowPos4iMESA _glWindowPos4iMESA
#define glWindowPos4ivMESA _glWindowPos4ivMESA
#define glWindowPos4sMESA _glWindowPos4sMESA
#define glWindowPos4svMESA _glWindowPos4svMESA
#define glMultiModeDrawArraysIBM _glMultiModeDrawArraysIBM
#define glMultiModeDrawElementsIBM _glMultiModeDrawElementsIBM
#define glColorPointerListIBM _glColorPointerListIBM
#define glSecondaryColorPointerListIBM _glSecondaryColorPointerListIBM
#define glEdgeFlagPointerListIBM _glEdgeFlagPointerListIBM
#define glFogCoordPointerListIBM _glFogCoordPointerListIBM
#define glIndexPointerListIBM _glIndexPointerListIBM
#define glNormalPointerListIBM _glNormalPointerListIBM
#define glTexCoordPointerListIBM _glTexCoordPointerListIBM
#define glVertexPointerListIBM _glVertexPointerListIBM
#define glTbufferMask3DFX _glTbufferMask3DFX
#define glSampleMaskEXT _glSampleMaskEXT
#define glSamplePatternEXT _glSamplePatternEXT
#define glTextureColorMaskSGIS _glTextureColorMaskSGIS
#define glIglooInterfaceSGIX _glIglooInterfaceSGIX
#define glDeleteFencesNV _glDeleteFencesNV
#define glGenFencesNV _glGenFencesNV
#define glIsFenceNV _glIsFenceNV
#define glTestFenceNV _glTestFenceNV
#define glGetFenceivNV _glGetFenceivNV
#define glFinishFenceNV _glFinishFenceNV
#define glSetFenceNV _glSetFenceNV
#define glMapControlPointsNV _glMapControlPointsNV
#define glMapParameterivNV _glMapParameterivNV
#define glMapParameterfvNV _glMapParameterfvNV
#define glGetMapControlPointsNV _glGetMapControlPointsNV
#define glGetMapParameterivNV _glGetMapParameterivNV
#define glGetMapParameterfvNV _glGetMapParameterfvNV
#define glGetMapAttribParameterivNV _glGetMapAttribParameterivNV
#define glGetMapAttribParameterfvNV _glGetMapAttribParameterfvNV
#define glEvalMapsNV _glEvalMapsNV
#define glCombinerStageParameterfvNV _glCombinerStageParameterfvNV
#define glGetCombinerStageParameterfvNV _glGetCombinerStageParameterfvNV
#define glAreProgramsResidentNV _glAreProgramsResidentNV
#define glBindProgramNV _glBindProgramNV
#define glDeleteProgramsNV _glDeleteProgramsNV
#define glExecuteProgramNV _glExecuteProgramNV
#define glGenProgramsNV _glGenProgramsNV
#define glGetProgramParameterdvNV _glGetProgramParameterdvNV
#define glGetProgramParameterfvNV _glGetProgramParameterfvNV
#define glGetProgramivNV _glGetProgramivNV
#define glGetProgramStringNV _glGetProgramStringNV
#define glGetTrackMatrixivNV _glGetTrackMatrixivNV
#define glGetVertexAttribdvNV _glGetVertexAttribdvNV
#define glGetVertexAttribfvNV _glGetVertexAttribfvNV
#define glGetVertexAttribivNV _glGetVertexAttribivNV
#define glGetVertexAttribPointervNV _glGetVertexAttribPointervNV
#define glIsProgramNV _glIsProgramNV
#define glLoadProgramNV _glLoadProgramNV
#define glProgramParameter4dNV _glProgramParameter4dNV
#define glProgramParameter4dvNV _glProgramParameter4dvNV
#define glProgramParameter4fNV _glProgramParameter4fNV
#define glProgramParameter4fvNV _glProgramParameter4fvNV
#define glProgramParameters4dvNV _glProgramParameters4dvNV
#define glProgramParameters4fvNV _glProgramParameters4fvNV
#define glRequestResidentProgramsNV _glRequestResidentProgramsNV
#define glTrackMatrixNV _glTrackMatrixNV
#define glVertexAttribPointerNV _glVertexAttribPointerNV
#define glVertexAttrib1dNV _glVertexAttrib1dNV
#define glVertexAttrib1dvNV _glVertexAttrib1dvNV
#define glVertexAttrib1fNV _glVertexAttrib1fNV
#define glVertexAttrib1fvNV _glVertexAttrib1fvNV
#define glVertexAttrib1sNV _glVertexAttrib1sNV
#define glVertexAttrib1svNV _glVertexAttrib1svNV
#define glVertexAttrib2dNV _glVertexAttrib2dNV
#define glVertexAttrib2dvNV _glVertexAttrib2dvNV
#define glVertexAttrib2fNV _glVertexAttrib2fNV
#define glVertexAttrib2fvNV _glVertexAttrib2fvNV
#define glVertexAttrib2sNV _glVertexAttrib2sNV
#define glVertexAttrib2svNV _glVertexAttrib2svNV
#define glVertexAttrib3dNV _glVertexAttrib3dNV
#define glVertexAttrib3dvNV _glVertexAttrib3dvNV
#define glVertexAttrib3fNV _glVertexAttrib3fNV
#define glVertexAttrib3fvNV _glVertexAttrib3fvNV
#define glVertexAttrib3sNV _glVertexAttrib3sNV
#define glVertexAttrib3svNV _glVertexAttrib3svNV
#define glVertexAttrib4dNV _glVertexAttrib4dNV
#define glVertexAttrib4dvNV _glVertexAttrib4dvNV
#define glVertexAttrib4fNV _glVertexAttrib4fNV
#define glVertexAttrib4fvNV _glVertexAttrib4fvNV
#define glVertexAttrib4sNV _glVertexAttrib4sNV
#define glVertexAttrib4svNV _glVertexAttrib4svNV
#define glVertexAttrib4ubNV _glVertexAttrib4ubNV
#define glVertexAttrib4ubvNV _glVertexAttrib4ubvNV
#define glVertexAttribs1dvNV _glVertexAttribs1dvNV
#define glVertexAttribs1fvNV _glVertexAttribs1fvNV
#define glVertexAttribs1svNV _glVertexAttribs1svNV
#define glVertexAttribs2dvNV _glVertexAttribs2dvNV
#define glVertexAttribs2fvNV _glVertexAttribs2fvNV
#define glVertexAttribs2svNV _glVertexAttribs2svNV
#define glVertexAttribs3dvNV _glVertexAttribs3dvNV
#define glVertexAttribs3fvNV _glVertexAttribs3fvNV
#define glVertexAttribs3svNV _glVertexAttribs3svNV
#define glVertexAttribs4dvNV _glVertexAttribs4dvNV
#define glVertexAttribs4fvNV _glVertexAttribs4fvNV
#define glVertexAttribs4svNV _glVertexAttribs4svNV
#define glVertexAttribs4ubvNV _glVertexAttribs4ubvNV
#define glTexBumpParameterivATI _glTexBumpParameterivATI
#define glTexBumpParameterfvATI _glTexBumpParameterfvATI
#define glGetTexBumpParameterivATI _glGetTexBumpParameterivATI
#define glGetTexBumpParameterfvATI _glGetTexBumpParameterfvATI
#define glGenFragmentShadersATI _glGenFragmentShadersATI
#define glBindFragmentShaderATI _glBindFragmentShaderATI
#define glDeleteFragmentShaderATI _glDeleteFragmentShaderATI
#define glBeginFragmentShaderATI _glBeginFragmentShaderATI
#define glEndFragmentShaderATI _glEndFragmentShaderATI
#define glPassTexCoordATI _glPassTexCoordATI
#define glSampleMapATI _glSampleMapATI
#define glColorFragmentOp1ATI _glColorFragmentOp1ATI
#define glColorFragmentOp2ATI _glColorFragmentOp2ATI
#define glColorFragmentOp3ATI _glColorFragmentOp3ATI
#define glAlphaFragmentOp1ATI _glAlphaFragmentOp1ATI
#define glAlphaFragmentOp2ATI _glAlphaFragmentOp2ATI
#define glAlphaFragmentOp3ATI _glAlphaFragmentOp3ATI
#define glSetFragmentShaderConstantATI _glSetFragmentShaderConstantATI
#define glPNTrianglesiATI _glPNTrianglesiATI
#define glPNTrianglesfATI _glPNTrianglesfATI
#define glNewObjectBufferATI _glNewObjectBufferATI
#define glIsObjectBufferATI _glIsObjectBufferATI
#define glUpdateObjectBufferATI _glUpdateObjectBufferATI
#define glGetObjectBufferfvATI _glGetObjectBufferfvATI
#define glGetObjectBufferivATI _glGetObjectBufferivATI
#define glFreeObjectBufferATI _glFreeObjectBufferATI
#define glArrayObjectATI _glArrayObjectATI
#define glGetArrayObjectfvATI _glGetArrayObjectfvATI
#define glGetArrayObjectivATI _glGetArrayObjectivATI
#define glVariantArrayObjectATI _glVariantArrayObjectATI
#define glGetVariantArrayObjectfvATI _glGetVariantArrayObjectfvATI
#define glGetVariantArrayObjectivATI _glGetVariantArrayObjectivATI
#define glBeginVertexShaderEXT _glBeginVertexShaderEXT
#define glEndVertexShaderEXT _glEndVertexShaderEXT
#define glBindVertexShaderEXT _glBindVertexShaderEXT
#define glGenVertexShadersEXT _glGenVertexShadersEXT
#define glDeleteVertexShaderEXT _glDeleteVertexShaderEXT
#define glShaderOp1EXT _glShaderOp1EXT
#define glShaderOp2EXT _glShaderOp2EXT
#define glShaderOp3EXT _glShaderOp3EXT
#define glSwizzleEXT _glSwizzleEXT
#define glWriteMaskEXT _glWriteMaskEXT
#define glInsertComponentEXT _glInsertComponentEXT
#define glExtractComponentEXT _glExtractComponentEXT
#define glGenSymbolsEXT _glGenSymbolsEXT
#define glSetInvariantEXT _glSetInvariantEXT
#define glSetLocalConstantEXT _glSetLocalConstantEXT
#define glVariantbvEXT _glVariantbvEXT
#define glVariantsvEXT _glVariantsvEXT
#define glVariantivEXT _glVariantivEXT
#define glVariantfvEXT _glVariantfvEXT
#define glVariantdvEXT _glVariantdvEXT
#define glVariantubvEXT _glVariantubvEXT
#define glVariantusvEXT _glVariantusvEXT
#define glVariantuivEXT _glVariantuivEXT
#define glVariantPointerEXT _glVariantPointerEXT
#define glEnableVariantClientStateEXT _glEnableVariantClientStateEXT
#define glDisableVariantClientStateEXT _glDisableVariantClientStateEXT
#define glBindLightParameterEXT _glBindLightParameterEXT
#define glBindMaterialParameterEXT _glBindMaterialParameterEXT
#define glBindTexGenParameterEXT _glBindTexGenParameterEXT
#define glBindTextureUnitParameterEXT _glBindTextureUnitParameterEXT
#define glBindParameterEXT _glBindParameterEXT
#define glIsVariantEnabledEXT _glIsVariantEnabledEXT
#define glGetVariantBooleanvEXT _glGetVariantBooleanvEXT
#define glGetVariantIntegervEXT _glGetVariantIntegervEXT
#define glGetVariantFloatvEXT _glGetVariantFloatvEXT
#define glGetVariantPointervEXT _glGetVariantPointervEXT
#define glGetInvariantBooleanvEXT _glGetInvariantBooleanvEXT
#define glGetInvariantIntegervEXT _glGetInvariantIntegervEXT
#define glGetInvariantFloatvEXT _glGetInvariantFloatvEXT
#define glGetLocalConstantBooleanvEXT _glGetLocalConstantBooleanvEXT
#define glGetLocalConstantIntegervEXT _glGetLocalConstantIntegervEXT
#define glGetLocalConstantFloatvEXT _glGetLocalConstantFloatvEXT
#define glVertexStream1sATI _glVertexStream1sATI
#define glVertexStream1svATI _glVertexStream1svATI
#define glVertexStream1iATI _glVertexStream1iATI
#define glVertexStream1ivATI _glVertexStream1ivATI
#define glVertexStream1fATI _glVertexStream1fATI
#define glVertexStream1fvATI _glVertexStream1fvATI
#define glVertexStream1dATI _glVertexStream1dATI
#define glVertexStream1dvATI _glVertexStream1dvATI
#define glVertexStream2sATI _glVertexStream2sATI
#define glVertexStream2svATI _glVertexStream2svATI
#define glVertexStream2iATI _glVertexStream2iATI
#define glVertexStream2ivATI _glVertexStream2ivATI
#define glVertexStream2fATI _glVertexStream2fATI
#define glVertexStream2fvATI _glVertexStream2fvATI
#define glVertexStream2dATI _glVertexStream2dATI
#define glVertexStream2dvATI _glVertexStream2dvATI
#define glVertexStream3sATI _glVertexStream3sATI
#define glVertexStream3svATI _glVertexStream3svATI
#define glVertexStream3iATI _glVertexStream3iATI
#define glVertexStream3ivATI _glVertexStream3ivATI
#define glVertexStream3fATI _glVertexStream3fATI
#define glVertexStream3fvATI _glVertexStream3fvATI
#define glVertexStream3dATI _glVertexStream3dATI
#define glVertexStream3dvATI _glVertexStream3dvATI
#define glVertexStream4sATI _glVertexStream4sATI
#define glVertexStream4svATI _glVertexStream4svATI
#define glVertexStream4iATI _glVertexStream4iATI
#define glVertexStream4ivATI _glVertexStream4ivATI
#define glVertexStream4fATI _glVertexStream4fATI
#define glVertexStream4fvATI _glVertexStream4fvATI
#define glVertexStream4dATI _glVertexStream4dATI
#define glVertexStream4dvATI _glVertexStream4dvATI
#define glNormalStream3bATI _glNormalStream3bATI
#define glNormalStream3bvATI _glNormalStream3bvATI
#define glNormalStream3sATI _glNormalStream3sATI
#define glNormalStream3svATI _glNormalStream3svATI
#define glNormalStream3iATI _glNormalStream3iATI
#define glNormalStream3ivATI _glNormalStream3ivATI
#define glNormalStream3fATI _glNormalStream3fATI
#define glNormalStream3fvATI _glNormalStream3fvATI
#define glNormalStream3dATI _glNormalStream3dATI
#define glNormalStream3dvATI _glNormalStream3dvATI
#define glClientActiveVertexStreamATI _glClientActiveVertexStreamATI
#define glVertexBlendEnviATI _glVertexBlendEnviATI
#define glVertexBlendEnvfATI _glVertexBlendEnvfATI
#define glElementPointerATI _glElementPointerATI
#define glDrawElementArrayATI _glDrawElementArrayATI
#define glDrawRangeElementArrayATI _glDrawRangeElementArrayATI
#define glDrawMeshArraysSUN _glDrawMeshArraysSUN
#define glGenOcclusionQueriesNV _glGenOcclusionQueriesNV
#define glDeleteOcclusionQueriesNV _glDeleteOcclusionQueriesNV
#define glIsOcclusionQueryNV _glIsOcclusionQueryNV
#define glBeginOcclusionQueryNV _glBeginOcclusionQueryNV
#define glEndOcclusionQueryNV _glEndOcclusionQueryNV
#define glGetOcclusionQueryivNV _glGetOcclusionQueryivNV
#define glGetOcclusionQueryuivNV _glGetOcclusionQueryuivNV
#define glPointParameteriNV _glPointParameteriNV
#define glPointParameterivNV _glPointParameterivNV
#define glActiveStencilFaceEXT _glActiveStencilFaceEXT
#define glElementPointerAPPLE _glElementPointerAPPLE
#define glDrawElementArrayAPPLE _glDrawElementArrayAPPLE
#define glDrawRangeElementArrayAPPLE _glDrawRangeElementArrayAPPLE
#define glMultiDrawElementArrayAPPLE _glMultiDrawElementArrayAPPLE
#define glMultiDrawRangeElementArrayAPPLE _glMultiDrawRangeElementArrayAPPLE
#define glGenFencesAPPLE _glGenFencesAPPLE
#define glDeleteFencesAPPLE _glDeleteFencesAPPLE
#define glSetFenceAPPLE _glSetFenceAPPLE
#define glIsFenceAPPLE _glIsFenceAPPLE
#define glTestFenceAPPLE _glTestFenceAPPLE
#define glFinishFenceAPPLE _glFinishFenceAPPLE
#define glTestObjectAPPLE _glTestObjectAPPLE
#define glFinishObjectAPPLE _glFinishObjectAPPLE
#define glBindVertexArrayAPPLE _glBindVertexArrayAPPLE
#define glDeleteVertexArraysAPPLE _glDeleteVertexArraysAPPLE
#define glGenVertexArraysAPPLE _glGenVertexArraysAPPLE
#define glIsVertexArrayAPPLE _glIsVertexArrayAPPLE
#define glVertexArrayRangeAPPLE _glVertexArrayRangeAPPLE
#define glFlushVertexArrayRangeAPPLE _glFlushVertexArrayRangeAPPLE
#define glVertexArrayParameteriAPPLE _glVertexArrayParameteriAPPLE
#define glFlushRenderAPPLE _glFlushRenderAPPLE
#define glFinishRenderAPPLE _glFinishRenderAPPLE
#define glSwapAPPLE _glSwapAPPLE
#define glDrawBuffersATI _glDrawBuffersATI
#define glProgramNamedParameter4fNV _glProgramNamedParameter4fNV
#define glProgramNamedParameter4dNV _glProgramNamedParameter4dNV
#define glProgramNamedParameter4fvNV _glProgramNamedParameter4fvNV
#define glProgramNamedParameter4dvNV _glProgramNamedParameter4dvNV
#define glGetProgramNamedParameterdvNV _glGetProgramNamedParameterdvNV
#define glGetProgramNamedParameterfvNV _glGetProgramNamedParameterfvNV
#define glVertex2hNV _glVertex2hNV
#define glVertex2hvNV _glVertex2hvNV
#define glVertex3hNV _glVertex3hNV
#define glVertex3hvNV _glVertex3hvNV
#define glVertex4hNV _glVertex4hNV
#define glVertex4hvNV _glVertex4hvNV
#define glNormal3hNV _glNormal3hNV
#define glNormal3hvNV _glNormal3hvNV
#define glColor3hNV _glColor3hNV
#define glColor3hvNV _glColor3hvNV
#define glColor4hNV _glColor4hNV
#define glColor4hvNV _glColor4hvNV
#define glTexCoord1hNV _glTexCoord1hNV
#define glTexCoord1hvNV _glTexCoord1hvNV
#define glTexCoord2hNV _glTexCoord2hNV
#define glTexCoord2hvNV _glTexCoord2hvNV
#define glTexCoord3hNV _glTexCoord3hNV
#define glTexCoord3hvNV _glTexCoord3hvNV
#define glTexCoord4hNV _glTexCoord4hNV
#define glTexCoord4hvNV _glTexCoord4hvNV
#define glMultiTexCoord1hNV _glMultiTexCoord1hNV
#define glMultiTexCoord1hvNV _glMultiTexCoord1hvNV
#define glMultiTexCoord2hNV _glMultiTexCoord2hNV
#define glMultiTexCoord2hvNV _glMultiTexCoord2hvNV
#define glMultiTexCoord3hNV _glMultiTexCoord3hNV
#define glMultiTexCoord3hvNV _glMultiTexCoord3hvNV
#define glMultiTexCoord4hNV _glMultiTexCoord4hNV
#define glMultiTexCoord4hvNV _glMultiTexCoord4hvNV
#define glFogCoordhNV _glFogCoordhNV
#define glFogCoordhvNV _glFogCoordhvNV
#define glSecondaryColor3hNV _glSecondaryColor3hNV
#define glSecondaryColor3hvNV _glSecondaryColor3hvNV
#define glVertexWeighthNV _glVertexWeighthNV
#define glVertexWeighthvNV _glVertexWeighthvNV
#define glVertexAttrib1hNV _glVertexAttrib1hNV
#define glVertexAttrib1hvNV _glVertexAttrib1hvNV
#define glVertexAttrib2hNV _glVertexAttrib2hNV
#define glVertexAttrib2hvNV _glVertexAttrib2hvNV
#define glVertexAttrib3hNV _glVertexAttrib3hNV
#define glVertexAttrib3hvNV _glVertexAttrib3hvNV
#define glVertexAttrib4hNV _glVertexAttrib4hNV
#define glVertexAttrib4hvNV _glVertexAttrib4hvNV
#define glVertexAttribs1hvNV _glVertexAttribs1hvNV
#define glVertexAttribs2hvNV _glVertexAttribs2hvNV
#define glVertexAttribs3hvNV _glVertexAttribs3hvNV
#define glVertexAttribs4hvNV _glVertexAttribs4hvNV
#define glPixelDataRangeNV _glPixelDataRangeNV
#define glFlushPixelDataRangeNV _glFlushPixelDataRangeNV
#define glPrimitiveRestartNV _glPrimitiveRestartNV
#define glPrimitiveRestartIndexNV _glPrimitiveRestartIndexNV
#define glMapObjectBufferATI _glMapObjectBufferATI
#define glUnmapObjectBufferATI _glUnmapObjectBufferATI
#define glStencilOpSeparateATI _glStencilOpSeparateATI
#define glStencilFuncSeparateATI _glStencilFuncSeparateATI
#define glVertexAttribArrayObjectATI _glVertexAttribArrayObjectATI
#define glGetVertexAttribArrayObjectfvATI _glGetVertexAttribArrayObjectfvATI
#define glGetVertexAttribArrayObjectivATI _glGetVertexAttribArrayObjectivATI
#define glDepthBoundsEXT _glDepthBoundsEXT
#define glBlendEquationSeparateEXT _glBlendEquationSeparateEXT
#define glIsRenderbufferEXT _glIsRenderbufferEXT
#define glBindRenderbufferEXT _glBindRenderbufferEXT
#define glDeleteRenderbuffersEXT _glDeleteRenderbuffersEXT
#define glGenRenderbuffersEXT _glGenRenderbuffersEXT
#define glRenderbufferStorageEXT _glRenderbufferStorageEXT
#define glGetRenderbufferParameterivEXT _glGetRenderbufferParameterivEXT
#define glIsFramebufferEXT _glIsFramebufferEXT
#define glBindFramebufferEXT _glBindFramebufferEXT
#define glDeleteFramebuffersEXT _glDeleteFramebuffersEXT
#define glGenFramebuffersEXT _glGenFramebuffersEXT
#define glCheckFramebufferStatusEXT _glCheckFramebufferStatusEXT
#define glFramebufferTexture1DEXT _glFramebufferTexture1DEXT
#define glFramebufferTexture2DEXT _glFramebufferTexture2DEXT
#define glFramebufferTexture3DEXT _glFramebufferTexture3DEXT
#define glFramebufferRenderbufferEXT _glFramebufferRenderbufferEXT
#define glGetFramebufferAttachmentParameterivEXT _glGetFramebufferAttachmentParameterivEXT
#define glGenerateMipmapEXT _glGenerateMipmapEXT
#define glStringMarkerGREMEDY _glStringMarkerGREMEDY
#define glStencilClearTagEXT _glStencilClearTagEXT
#define glBlitFramebufferEXT _glBlitFramebufferEXT
#define glRenderbufferStorageMultisampleEXT _glRenderbufferStorageMultisampleEXT
#define glGetQueryObjecti64vEXT _glGetQueryObjecti64vEXT
#define glGetQueryObjectui64vEXT _glGetQueryObjectui64vEXT
#define glProgramEnvParameters4fvEXT _glProgramEnvParameters4fvEXT
#define glProgramLocalParameters4fvEXT _glProgramLocalParameters4fvEXT
#define glBufferParameteriAPPLE _glBufferParameteriAPPLE
#define glFlushMappedBufferRangeAPPLE _glFlushMappedBufferRangeAPPLE
#define glProgramLocalParameterI4iNV _glProgramLocalParameterI4iNV
#define glProgramLocalParameterI4ivNV _glProgramLocalParameterI4ivNV
#define glProgramLocalParametersI4ivNV _glProgramLocalParametersI4ivNV
#define glProgramLocalParameterI4uiNV _glProgramLocalParameterI4uiNV
#define glProgramLocalParameterI4uivNV _glProgramLocalParameterI4uivNV
#define glProgramLocalParametersI4uivNV _glProgramLocalParametersI4uivNV
#define glProgramEnvParameterI4iNV _glProgramEnvParameterI4iNV
#define glProgramEnvParameterI4ivNV _glProgramEnvParameterI4ivNV
#define glProgramEnvParametersI4ivNV _glProgramEnvParametersI4ivNV
#define glProgramEnvParameterI4uiNV _glProgramEnvParameterI4uiNV
#define glProgramEnvParameterI4uivNV _glProgramEnvParameterI4uivNV
#define glProgramEnvParametersI4uivNV _glProgramEnvParametersI4uivNV
#define glGetProgramLocalParameterIivNV _glGetProgramLocalParameterIivNV
#define glGetProgramLocalParameterIuivNV _glGetProgramLocalParameterIuivNV
#define glGetProgramEnvParameterIivNV _glGetProgramEnvParameterIivNV
#define glGetProgramEnvParameterIuivNV _glGetProgramEnvParameterIuivNV
#define glProgramVertexLimitNV _glProgramVertexLimitNV
#define glFramebufferTextureEXT _glFramebufferTextureEXT
#define glFramebufferTextureLayerEXT _glFramebufferTextureLayerEXT
#define glFramebufferTextureFaceEXT _glFramebufferTextureFaceEXT
#define glProgramParameteriEXT _glProgramParameteriEXT
#define glVertexAttribI1iEXT _glVertexAttribI1iEXT
#define glVertexAttribI2iEXT _glVertexAttribI2iEXT
#define glVertexAttribI3iEXT _glVertexAttribI3iEXT
#define glVertexAttribI4iEXT _glVertexAttribI4iEXT
#define glVertexAttribI1uiEXT _glVertexAttribI1uiEXT
#define glVertexAttribI2uiEXT _glVertexAttribI2uiEXT
#define glVertexAttribI3uiEXT _glVertexAttribI3uiEXT
#define glVertexAttribI4uiEXT _glVertexAttribI4uiEXT
#define glVertexAttribI1ivEXT _glVertexAttribI1ivEXT
#define glVertexAttribI2ivEXT _glVertexAttribI2ivEXT
#define glVertexAttribI3ivEXT _glVertexAttribI3ivEXT
#define glVertexAttribI4ivEXT _glVertexAttribI4ivEXT
#define glVertexAttribI1uivEXT _glVertexAttribI1uivEXT
#define glVertexAttribI2uivEXT _glVertexAttribI2uivEXT
#define glVertexAttribI3uivEXT _glVertexAttribI3uivEXT
#define glVertexAttribI4uivEXT _glVertexAttribI4uivEXT
#define glVertexAttribI4bvEXT _glVertexAttribI4bvEXT
#define glVertexAttribI4svEXT _glVertexAttribI4svEXT
#define glVertexAttribI4ubvEXT _glVertexAttribI4ubvEXT
#define glVertexAttribI4usvEXT _glVertexAttribI4usvEXT
#define glVertexAttribIPointerEXT _glVertexAttribIPointerEXT
#define glGetVertexAttribIivEXT _glGetVertexAttribIivEXT
#define glGetVertexAttribIuivEXT _glGetVertexAttribIuivEXT
#define glGetUniformuivEXT _glGetUniformuivEXT
#define glBindFragDataLocationEXT _glBindFragDataLocationEXT
#define glGetFragDataLocationEXT _glGetFragDataLocationEXT
#define glUniform1uiEXT _glUniform1uiEXT
#define glUniform2uiEXT _glUniform2uiEXT
#define glUniform3uiEXT _glUniform3uiEXT
#define glUniform4uiEXT _glUniform4uiEXT
#define glUniform1uivEXT _glUniform1uivEXT
#define glUniform2uivEXT _glUniform2uivEXT
#define glUniform3uivEXT _glUniform3uivEXT
#define glUniform4uivEXT _glUniform4uivEXT
#define glDrawArraysInstancedEXT _glDrawArraysInstancedEXT
#define glDrawElementsInstancedEXT _glDrawElementsInstancedEXT
#define glTexBufferEXT _glTexBufferEXT
#define glDepthRangedNV _glDepthRangedNV
#define glClearDepthdNV _glClearDepthdNV
#define glDepthBoundsdNV _glDepthBoundsdNV
#define glRenderbufferStorageMultisampleCoverageNV _glRenderbufferStorageMultisampleCoverageNV
#define glProgramBufferParametersfvNV _glProgramBufferParametersfvNV
#define glProgramBufferParametersIivNV _glProgramBufferParametersIivNV
#define glProgramBufferParametersIuivNV _glProgramBufferParametersIuivNV
#define glColorMaskIndexedEXT _glColorMaskIndexedEXT
#define glGetBooleanIndexedvEXT _glGetBooleanIndexedvEXT
#define glGetIntegerIndexedvEXT _glGetIntegerIndexedvEXT
#define glEnableIndexedEXT _glEnableIndexedEXT
#define glDisableIndexedEXT _glDisableIndexedEXT
#define glIsEnabledIndexedEXT _glIsEnabledIndexedEXT
#define glBeginTransformFeedbackNV _glBeginTransformFeedbackNV
#define glEndTransformFeedbackNV _glEndTransformFeedbackNV
#define glTransformFeedbackAttribsNV _glTransformFeedbackAttribsNV
#define glBindBufferRangeNV _glBindBufferRangeNV
#define glBindBufferOffsetNV _glBindBufferOffsetNV
#define glBindBufferBaseNV _glBindBufferBaseNV
#define glTransformFeedbackVaryingsNV _glTransformFeedbackVaryingsNV
#define glActiveVaryingNV _glActiveVaryingNV
#define glGetVaryingLocationNV _glGetVaryingLocationNV
#define glGetActiveVaryingNV _glGetActiveVaryingNV
#define glGetTransformFeedbackVaryingNV _glGetTransformFeedbackVaryingNV
#define glTransformFeedbackStreamAttribsNV _glTransformFeedbackStreamAttribsNV
#define glUniformBufferEXT _glUniformBufferEXT
#define glGetUniformBufferSizeEXT _glGetUniformBufferSizeEXT
#define glGetUniformOffsetEXT _glGetUniformOffsetEXT
#define glTexParameterIivEXT _glTexParameterIivEXT
#define glTexParameterIuivEXT _glTexParameterIuivEXT
#define glGetTexParameterIivEXT _glGetTexParameterIivEXT
#define glGetTexParameterIuivEXT _glGetTexParameterIuivEXT
#define glClearColorIiEXT _glClearColorIiEXT
#define glClearColorIuiEXT _glClearColorIuiEXT
#define glFrameTerminatorGREMEDY _glFrameTerminatorGREMEDY
#define glBeginConditionalRenderNV _glBeginConditionalRenderNV
#define glEndConditionalRenderNV _glEndConditionalRenderNV
#define glPresentFrameKeyedNV _glPresentFrameKeyedNV
#define glPresentFrameDualFillNV _glPresentFrameDualFillNV
#define glGetVideoivNV _glGetVideoivNV
#define glGetVideouivNV _glGetVideouivNV
#define glGetVideoi64vNV _glGetVideoi64vNV
#define glGetVideoui64vNV _glGetVideoui64vNV
#define glBeginTransformFeedbackEXT _glBeginTransformFeedbackEXT
#define glEndTransformFeedbackEXT _glEndTransformFeedbackEXT
#define glBindBufferRangeEXT _glBindBufferRangeEXT
#define glBindBufferOffsetEXT _glBindBufferOffsetEXT
#define glBindBufferBaseEXT _glBindBufferBaseEXT
#define glTransformFeedbackVaryingsEXT _glTransformFeedbackVaryingsEXT
#define glGetTransformFeedbackVaryingEXT _glGetTransformFeedbackVaryingEXT
#define glClientAttribDefaultEXT _glClientAttribDefaultEXT
#define glPushClientAttribDefaultEXT _glPushClientAttribDefaultEXT
#define glMatrixLoadfEXT _glMatrixLoadfEXT
#define glMatrixLoaddEXT _glMatrixLoaddEXT
#define glMatrixMultfEXT _glMatrixMultfEXT
#define glMatrixMultdEXT _glMatrixMultdEXT
#define glMatrixLoadIdentityEXT _glMatrixLoadIdentityEXT
#define glMatrixRotatefEXT _glMatrixRotatefEXT
#define glMatrixRotatedEXT _glMatrixRotatedEXT
#define glMatrixScalefEXT _glMatrixScalefEXT
#define glMatrixScaledEXT _glMatrixScaledEXT
#define glMatrixTranslatefEXT _glMatrixTranslatefEXT
#define glMatrixTranslatedEXT _glMatrixTranslatedEXT
#define glMatrixFrustumEXT _glMatrixFrustumEXT
#define glMatrixOrthoEXT _glMatrixOrthoEXT
#define glMatrixPopEXT _glMatrixPopEXT
#define glMatrixPushEXT _glMatrixPushEXT
#define glMatrixLoadTransposefEXT _glMatrixLoadTransposefEXT
#define glMatrixLoadTransposedEXT _glMatrixLoadTransposedEXT
#define glMatrixMultTransposefEXT _glMatrixMultTransposefEXT
#define glMatrixMultTransposedEXT _glMatrixMultTransposedEXT
#define glTextureParameterfEXT _glTextureParameterfEXT
#define glTextureParameterfvEXT _glTextureParameterfvEXT
#define glTextureParameteriEXT _glTextureParameteriEXT
#define glTextureParameterivEXT _glTextureParameterivEXT
#define glTextureImage1DEXT _glTextureImage1DEXT
#define glTextureImage2DEXT _glTextureImage2DEXT
#define glTextureSubImage1DEXT _glTextureSubImage1DEXT
#define glTextureSubImage2DEXT _glTextureSubImage2DEXT
#define glCopyTextureImage1DEXT _glCopyTextureImage1DEXT
#define glCopyTextureImage2DEXT _glCopyTextureImage2DEXT
#define glCopyTextureSubImage1DEXT _glCopyTextureSubImage1DEXT
#define glCopyTextureSubImage2DEXT _glCopyTextureSubImage2DEXT
#define glGetTextureImageEXT _glGetTextureImageEXT
#define glGetTextureParameterfvEXT _glGetTextureParameterfvEXT
#define glGetTextureParameterivEXT _glGetTextureParameterivEXT
#define glGetTextureLevelParameterfvEXT _glGetTextureLevelParameterfvEXT
#define glGetTextureLevelParameterivEXT _glGetTextureLevelParameterivEXT
#define glTextureImage3DEXT _glTextureImage3DEXT
#define glTextureSubImage3DEXT _glTextureSubImage3DEXT
#define glCopyTextureSubImage3DEXT _glCopyTextureSubImage3DEXT
#define glMultiTexParameterfEXT _glMultiTexParameterfEXT
#define glMultiTexParameterfvEXT _glMultiTexParameterfvEXT
#define glMultiTexParameteriEXT _glMultiTexParameteriEXT
#define glMultiTexParameterivEXT _glMultiTexParameterivEXT
#define glMultiTexImage1DEXT _glMultiTexImage1DEXT
#define glMultiTexImage2DEXT _glMultiTexImage2DEXT
#define glMultiTexSubImage1DEXT _glMultiTexSubImage1DEXT
#define glMultiTexSubImage2DEXT _glMultiTexSubImage2DEXT
#define glCopyMultiTexImage1DEXT _glCopyMultiTexImage1DEXT
#define glCopyMultiTexImage2DEXT _glCopyMultiTexImage2DEXT
#define glCopyMultiTexSubImage1DEXT _glCopyMultiTexSubImage1DEXT
#define glCopyMultiTexSubImage2DEXT _glCopyMultiTexSubImage2DEXT
#define glGetMultiTexImageEXT _glGetMultiTexImageEXT
#define glGetMultiTexParameterfvEXT _glGetMultiTexParameterfvEXT
#define glGetMultiTexParameterivEXT _glGetMultiTexParameterivEXT
#define glGetMultiTexLevelParameterfvEXT _glGetMultiTexLevelParameterfvEXT
#define glGetMultiTexLevelParameterivEXT _glGetMultiTexLevelParameterivEXT
#define glMultiTexImage3DEXT _glMultiTexImage3DEXT
#define glMultiTexSubImage3DEXT _glMultiTexSubImage3DEXT
#define glCopyMultiTexSubImage3DEXT _glCopyMultiTexSubImage3DEXT
#define glBindMultiTextureEXT _glBindMultiTextureEXT
#define glEnableClientStateIndexedEXT _glEnableClientStateIndexedEXT
#define glDisableClientStateIndexedEXT _glDisableClientStateIndexedEXT
#define glMultiTexCoordPointerEXT _glMultiTexCoordPointerEXT
#define glMultiTexEnvfEXT _glMultiTexEnvfEXT
#define glMultiTexEnvfvEXT _glMultiTexEnvfvEXT
#define glMultiTexEnviEXT _glMultiTexEnviEXT
#define glMultiTexEnvivEXT _glMultiTexEnvivEXT
#define glMultiTexGendEXT _glMultiTexGendEXT
#define glMultiTexGendvEXT _glMultiTexGendvEXT
#define glMultiTexGenfEXT _glMultiTexGenfEXT
#define glMultiTexGenfvEXT _glMultiTexGenfvEXT
#define glMultiTexGeniEXT _glMultiTexGeniEXT
#define glMultiTexGenivEXT _glMultiTexGenivEXT
#define glGetMultiTexEnvfvEXT _glGetMultiTexEnvfvEXT
#define glGetMultiTexEnvivEXT _glGetMultiTexEnvivEXT
#define glGetMultiTexGendvEXT _glGetMultiTexGendvEXT
#define glGetMultiTexGenfvEXT _glGetMultiTexGenfvEXT
#define glGetMultiTexGenivEXT _glGetMultiTexGenivEXT
#define glGetFloatIndexedvEXT _glGetFloatIndexedvEXT
#define glGetDoubleIndexedvEXT _glGetDoubleIndexedvEXT
#define glGetPointerIndexedvEXT _glGetPointerIndexedvEXT
#define glCompressedTextureImage3DEXT _glCompressedTextureImage3DEXT
#define glCompressedTextureImage2DEXT _glCompressedTextureImage2DEXT
#define glCompressedTextureImage1DEXT _glCompressedTextureImage1DEXT
#define glCompressedTextureSubImage3DEXT _glCompressedTextureSubImage3DEXT
#define glCompressedTextureSubImage2DEXT _glCompressedTextureSubImage2DEXT
#define glCompressedTextureSubImage1DEXT _glCompressedTextureSubImage1DEXT
#define glGetCompressedTextureImageEXT _glGetCompressedTextureImageEXT
#define glCompressedMultiTexImage3DEXT _glCompressedMultiTexImage3DEXT
#define glCompressedMultiTexImage2DEXT _glCompressedMultiTexImage2DEXT
#define glCompressedMultiTexImage1DEXT _glCompressedMultiTexImage1DEXT
#define glCompressedMultiTexSubImage3DEXT _glCompressedMultiTexSubImage3DEXT
#define glCompressedMultiTexSubImage2DEXT _glCompressedMultiTexSubImage2DEXT
#define glCompressedMultiTexSubImage1DEXT _glCompressedMultiTexSubImage1DEXT
#define glGetCompressedMultiTexImageEXT _glGetCompressedMultiTexImageEXT
#define glNamedProgramStringEXT _glNamedProgramStringEXT
#define glNamedProgramLocalParameter4dEXT _glNamedProgramLocalParameter4dEXT
#define glNamedProgramLocalParameter4dvEXT _glNamedProgramLocalParameter4dvEXT
#define glNamedProgramLocalParameter4fEXT _glNamedProgramLocalParameter4fEXT
#define glNamedProgramLocalParameter4fvEXT _glNamedProgramLocalParameter4fvEXT
#define glGetNamedProgramLocalParameterdvEXT _glGetNamedProgramLocalParameterdvEXT
#define glGetNamedProgramLocalParameterfvEXT _glGetNamedProgramLocalParameterfvEXT
#define glGetNamedProgramivEXT _glGetNamedProgramivEXT
#define glGetNamedProgramStringEXT _glGetNamedProgramStringEXT
#define glNamedProgramLocalParameters4fvEXT _glNamedProgramLocalParameters4fvEXT
#define glNamedProgramLocalParameterI4iEXT _glNamedProgramLocalParameterI4iEXT
#define glNamedProgramLocalParameterI4ivEXT _glNamedProgramLocalParameterI4ivEXT
#define glNamedProgramLocalParametersI4ivEXT _glNamedProgramLocalParametersI4ivEXT
#define glNamedProgramLocalParameterI4uiEXT _glNamedProgramLocalParameterI4uiEXT
#define glNamedProgramLocalParameterI4uivEXT _glNamedProgramLocalParameterI4uivEXT
#define glNamedProgramLocalParametersI4uivEXT _glNamedProgramLocalParametersI4uivEXT
#define glGetNamedProgramLocalParameterIivEXT _glGetNamedProgramLocalParameterIivEXT
#define glGetNamedProgramLocalParameterIuivEXT _glGetNamedProgramLocalParameterIuivEXT
#define glTextureParameterIivEXT _glTextureParameterIivEXT
#define glTextureParameterIuivEXT _glTextureParameterIuivEXT
#define glGetTextureParameterIivEXT _glGetTextureParameterIivEXT
#define glGetTextureParameterIuivEXT _glGetTextureParameterIuivEXT
#define glMultiTexParameterIivEXT _glMultiTexParameterIivEXT
#define glMultiTexParameterIuivEXT _glMultiTexParameterIuivEXT
#define glGetMultiTexParameterIivEXT _glGetMultiTexParameterIivEXT
#define glGetMultiTexParameterIuivEXT _glGetMultiTexParameterIuivEXT
#define glProgramUniform1fEXT _glProgramUniform1fEXT
#define glProgramUniform2fEXT _glProgramUniform2fEXT
#define glProgramUniform3fEXT _glProgramUniform3fEXT
#define glProgramUniform4fEXT _glProgramUniform4fEXT
#define glProgramUniform1iEXT _glProgramUniform1iEXT
#define glProgramUniform2iEXT _glProgramUniform2iEXT
#define glProgramUniform3iEXT _glProgramUniform3iEXT
#define glProgramUniform4iEXT _glProgramUniform4iEXT
#define glProgramUniform1fvEXT _glProgramUniform1fvEXT
#define glProgramUniform2fvEXT _glProgramUniform2fvEXT
#define glProgramUniform3fvEXT _glProgramUniform3fvEXT
#define glProgramUniform4fvEXT _glProgramUniform4fvEXT
#define glProgramUniform1ivEXT _glProgramUniform1ivEXT
#define glProgramUniform2ivEXT _glProgramUniform2ivEXT
#define glProgramUniform3ivEXT _glProgramUniform3ivEXT
#define glProgramUniform4ivEXT _glProgramUniform4ivEXT
#define glProgramUniformMatrix2fvEXT _glProgramUniformMatrix2fvEXT
#define glProgramUniformMatrix3fvEXT _glProgramUniformMatrix3fvEXT
#define glProgramUniformMatrix4fvEXT _glProgramUniformMatrix4fvEXT
#define glProgramUniformMatrix2x3fvEXT _glProgramUniformMatrix2x3fvEXT
#define glProgramUniformMatrix3x2fvEXT _glProgramUniformMatrix3x2fvEXT
#define glProgramUniformMatrix2x4fvEXT _glProgramUniformMatrix2x4fvEXT
#define glProgramUniformMatrix4x2fvEXT _glProgramUniformMatrix4x2fvEXT
#define glProgramUniformMatrix3x4fvEXT _glProgramUniformMatrix3x4fvEXT
#define glProgramUniformMatrix4x3fvEXT _glProgramUniformMatrix4x3fvEXT
#define glProgramUniform1uiEXT _glProgramUniform1uiEXT
#define glProgramUniform2uiEXT _glProgramUniform2uiEXT
#define glProgramUniform3uiEXT _glProgramUniform3uiEXT
#define glProgramUniform4uiEXT _glProgramUniform4uiEXT
#define glProgramUniform1uivEXT _glProgramUniform1uivEXT
#define glProgramUniform2uivEXT _glProgramUniform2uivEXT
#define glProgramUniform3uivEXT _glProgramUniform3uivEXT
#define glProgramUniform4uivEXT _glProgramUniform4uivEXT
#define glNamedBufferDataEXT _glNamedBufferDataEXT
#define glNamedBufferSubDataEXT _glNamedBufferSubDataEXT
#define glMapNamedBufferEXT _glMapNamedBufferEXT
#define glUnmapNamedBufferEXT _glUnmapNamedBufferEXT
#define glMapNamedBufferRangeEXT _glMapNamedBufferRangeEXT
#define glFlushMappedNamedBufferRangeEXT _glFlushMappedNamedBufferRangeEXT
#define glNamedCopyBufferSubDataEXT _glNamedCopyBufferSubDataEXT
#define glGetNamedBufferParameterivEXT _glGetNamedBufferParameterivEXT
#define glGetNamedBufferPointervEXT _glGetNamedBufferPointervEXT
#define glGetNamedBufferSubDataEXT _glGetNamedBufferSubDataEXT
#define glTextureBufferEXT _glTextureBufferEXT
#define glMultiTexBufferEXT _glMultiTexBufferEXT
#define glNamedRenderbufferStorageEXT _glNamedRenderbufferStorageEXT
#define glGetNamedRenderbufferParameterivEXT _glGetNamedRenderbufferParameterivEXT
#define glCheckNamedFramebufferStatusEXT _glCheckNamedFramebufferStatusEXT
#define glNamedFramebufferTexture1DEXT _glNamedFramebufferTexture1DEXT
#define glNamedFramebufferTexture2DEXT _glNamedFramebufferTexture2DEXT
#define glNamedFramebufferTexture3DEXT _glNamedFramebufferTexture3DEXT
#define glNamedFramebufferRenderbufferEXT _glNamedFramebufferRenderbufferEXT
#define glGetNamedFramebufferAttachmentParameterivEXT _glGetNamedFramebufferAttachmentParameterivEXT
#define glGenerateTextureMipmapEXT _glGenerateTextureMipmapEXT
#define glGenerateMultiTexMipmapEXT _glGenerateMultiTexMipmapEXT
#define glFramebufferDrawBufferEXT _glFramebufferDrawBufferEXT
#define glFramebufferDrawBuffersEXT _glFramebufferDrawBuffersEXT
#define glFramebufferReadBufferEXT _glFramebufferReadBufferEXT
#define glGetFramebufferParameterivEXT _glGetFramebufferParameterivEXT
#define glNamedRenderbufferStorageMultisampleEXT _glNamedRenderbufferStorageMultisampleEXT
#define glNamedRenderbufferStorageMultisampleCoverageEXT _glNamedRenderbufferStorageMultisampleCoverageEXT
#define glNamedFramebufferTextureEXT _glNamedFramebufferTextureEXT
#define glNamedFramebufferTextureLayerEXT _glNamedFramebufferTextureLayerEXT
#define glNamedFramebufferTextureFaceEXT _glNamedFramebufferTextureFaceEXT
#define glTextureRenderbufferEXT _glTextureRenderbufferEXT
#define glMultiTexRenderbufferEXT _glMultiTexRenderbufferEXT
#define glProgramUniform1dEXT _glProgramUniform1dEXT
#define glProgramUniform2dEXT _glProgramUniform2dEXT
#define glProgramUniform3dEXT _glProgramUniform3dEXT
#define glProgramUniform4dEXT _glProgramUniform4dEXT
#define glProgramUniform1dvEXT _glProgramUniform1dvEXT
#define glProgramUniform2dvEXT _glProgramUniform2dvEXT
#define glProgramUniform3dvEXT _glProgramUniform3dvEXT
#define glProgramUniform4dvEXT _glProgramUniform4dvEXT
#define glProgramUniformMatrix2dvEXT _glProgramUniformMatrix2dvEXT
#define glProgramUniformMatrix3dvEXT _glProgramUniformMatrix3dvEXT
#define glProgramUniformMatrix4dvEXT _glProgramUniformMatrix4dvEXT
#define glProgramUniformMatrix2x3dvEXT _glProgramUniformMatrix2x3dvEXT
#define glProgramUniformMatrix2x4dvEXT _glProgramUniformMatrix2x4dvEXT
#define glProgramUniformMatrix3x2dvEXT _glProgramUniformMatrix3x2dvEXT
#define glProgramUniformMatrix3x4dvEXT _glProgramUniformMatrix3x4dvEXT
#define glProgramUniformMatrix4x2dvEXT _glProgramUniformMatrix4x2dvEXT
#define glProgramUniformMatrix4x3dvEXT _glProgramUniformMatrix4x3dvEXT
#define glVertexArrayVertexOffsetEXT _glVertexArrayVertexOffsetEXT
#define glVertexArrayColorOffsetEXT _glVertexArrayColorOffsetEXT
#define glVertexArrayEdgeFlagOffsetEXT _glVertexArrayEdgeFlagOffsetEXT
#define glVertexArrayIndexOffsetEXT _glVertexArrayIndexOffsetEXT
#define glVertexArrayNormalOffsetEXT _glVertexArrayNormalOffsetEXT
#define glVertexArrayTexCoordOffsetEXT _glVertexArrayTexCoordOffsetEXT
#define glVertexArrayMultiTexCoordOffsetEXT _glVertexArrayMultiTexCoordOffsetEXT
#define glVertexArrayFogCoordOffsetEXT _glVertexArrayFogCoordOffsetEXT
#define glVertexArraySecondaryColorOffsetEXT _glVertexArraySecondaryColorOffsetEXT
#define glVertexArrayVertexAttribOffsetEXT _glVertexArrayVertexAttribOffsetEXT
#define glVertexArrayVertexAttribIOffsetEXT _glVertexArrayVertexAttribIOffsetEXT
#define glEnableVertexArrayEXT _glEnableVertexArrayEXT
#define glDisableVertexArrayEXT _glDisableVertexArrayEXT
#define glEnableVertexArrayAttribEXT _glEnableVertexArrayAttribEXT
#define glDisableVertexArrayAttribEXT _glDisableVertexArrayAttribEXT
#define glGetVertexArrayIntegervEXT _glGetVertexArrayIntegervEXT
#define glGetVertexArrayPointervEXT _glGetVertexArrayPointervEXT
#define glGetVertexArrayIntegeri_vEXT _glGetVertexArrayIntegeri_vEXT
#define glGetVertexArrayPointeri_vEXT _glGetVertexArrayPointeri_vEXT
#define glGetMultisamplefvNV _glGetMultisamplefvNV
#define glSampleMaskIndexedNV _glSampleMaskIndexedNV
#define glTexRenderbufferNV _glTexRenderbufferNV
#define glBindTransformFeedbackNV _glBindTransformFeedbackNV
#define glDeleteTransformFeedbacksNV _glDeleteTransformFeedbacksNV
#define glGenTransformFeedbacksNV _glGenTransformFeedbacksNV
#define glIsTransformFeedbackNV _glIsTransformFeedbackNV
#define glPauseTransformFeedbackNV _glPauseTransformFeedbackNV
#define glResumeTransformFeedbackNV _glResumeTransformFeedbackNV
#define glDrawTransformFeedbackNV _glDrawTransformFeedbackNV
#define glGetPerfMonitorGroupsAMD _glGetPerfMonitorGroupsAMD
#define glGetPerfMonitorCountersAMD _glGetPerfMonitorCountersAMD
#define glGetPerfMonitorGroupStringAMD _glGetPerfMonitorGroupStringAMD
#define glGetPerfMonitorCounterStringAMD _glGetPerfMonitorCounterStringAMD
#define glGetPerfMonitorCounterInfoAMD _glGetPerfMonitorCounterInfoAMD
#define glGenPerfMonitorsAMD _glGenPerfMonitorsAMD
#define glDeletePerfMonitorsAMD _glDeletePerfMonitorsAMD
#define glSelectPerfMonitorCountersAMD _glSelectPerfMonitorCountersAMD
#define glBeginPerfMonitorAMD _glBeginPerfMonitorAMD
#define glEndPerfMonitorAMD _glEndPerfMonitorAMD
#define glGetPerfMonitorCounterDataAMD _glGetPerfMonitorCounterDataAMD
#define glTessellationFactorAMD _glTessellationFactorAMD
#define glTessellationModeAMD _glTessellationModeAMD
#define glProvokingVertexEXT _glProvokingVertexEXT
#define glBlendFuncIndexedAMD _glBlendFuncIndexedAMD
#define glBlendFuncSeparateIndexedAMD _glBlendFuncSeparateIndexedAMD
#define glBlendEquationIndexedAMD _glBlendEquationIndexedAMD
#define glBlendEquationSeparateIndexedAMD _glBlendEquationSeparateIndexedAMD
#define glTextureRangeAPPLE _glTextureRangeAPPLE
#define glGetTexParameterPointervAPPLE _glGetTexParameterPointervAPPLE
#define glEnableVertexAttribAPPLE _glEnableVertexAttribAPPLE
#define glDisableVertexAttribAPPLE _glDisableVertexAttribAPPLE
#define glIsVertexAttribEnabledAPPLE _glIsVertexAttribEnabledAPPLE
#define glMapVertexAttrib1dAPPLE _glMapVertexAttrib1dAPPLE
#define glMapVertexAttrib1fAPPLE _glMapVertexAttrib1fAPPLE
#define glMapVertexAttrib2dAPPLE _glMapVertexAttrib2dAPPLE
#define glMapVertexAttrib2fAPPLE _glMapVertexAttrib2fAPPLE
#define glObjectPurgeableAPPLE _glObjectPurgeableAPPLE
#define glObjectUnpurgeableAPPLE _glObjectUnpurgeableAPPLE
#define glGetObjectParameterivAPPLE _glGetObjectParameterivAPPLE
#define glBeginVideoCaptureNV _glBeginVideoCaptureNV
#define glBindVideoCaptureStreamBufferNV _glBindVideoCaptureStreamBufferNV
#define glBindVideoCaptureStreamTextureNV _glBindVideoCaptureStreamTextureNV
#define glEndVideoCaptureNV _glEndVideoCaptureNV
#define glGetVideoCaptureivNV _glGetVideoCaptureivNV
#define glGetVideoCaptureStreamivNV _glGetVideoCaptureStreamivNV
#define glGetVideoCaptureStreamfvNV _glGetVideoCaptureStreamfvNV
#define glGetVideoCaptureStreamdvNV _glGetVideoCaptureStreamdvNV
#define glVideoCaptureNV _glVideoCaptureNV
#define glVideoCaptureStreamParameterivNV _glVideoCaptureStreamParameterivNV
#define glVideoCaptureStreamParameterfvNV _glVideoCaptureStreamParameterfvNV
#define glVideoCaptureStreamParameterdvNV _glVideoCaptureStreamParameterdvNV
#define glCopyImageSubDataNV _glCopyImageSubDataNV
#define glUseShaderProgramEXT _glUseShaderProgramEXT
#define glActiveProgramEXT _glActiveProgramEXT
#define glCreateShaderProgramEXT _glCreateShaderProgramEXT
#define glMakeBufferResidentNV _glMakeBufferResidentNV
#define glMakeBufferNonResidentNV _glMakeBufferNonResidentNV
#define glIsBufferResidentNV _glIsBufferResidentNV
#define glMakeNamedBufferResidentNV _glMakeNamedBufferResidentNV
#define glMakeNamedBufferNonResidentNV _glMakeNamedBufferNonResidentNV
#define glIsNamedBufferResidentNV _glIsNamedBufferResidentNV
#define glGetBufferParameterui64vNV _glGetBufferParameterui64vNV
#define glGetNamedBufferParameterui64vNV _glGetNamedBufferParameterui64vNV
#define glGetIntegerui64vNV _glGetIntegerui64vNV
#define glUniformui64NV _glUniformui64NV
#define glUniformui64vNV _glUniformui64vNV
#define glGetUniformui64vNV _glGetUniformui64vNV
#define glProgramUniformui64NV _glProgramUniformui64NV
#define glProgramUniformui64vNV _glProgramUniformui64vNV
#define glBufferAddressRangeNV _glBufferAddressRangeNV
#define glVertexFormatNV _glVertexFormatNV
#define glNormalFormatNV _glNormalFormatNV
#define glColorFormatNV _glColorFormatNV
#define glIndexFormatNV _glIndexFormatNV
#define glTexCoordFormatNV _glTexCoordFormatNV
#define glEdgeFlagFormatNV _glEdgeFlagFormatNV
#define glSecondaryColorFormatNV _glSecondaryColorFormatNV
#define glFogCoordFormatNV _glFogCoordFormatNV
#define glVertexAttribFormatNV _glVertexAttribFormatNV
#define glVertexAttribIFormatNV _glVertexAttribIFormatNV
#define glGetIntegerui64i_vNV _glGetIntegerui64i_vNV
#define glTextureBarrierNV _glTextureBarrierNV
#define glBindImageTextureEXT _glBindImageTextureEXT
#define glMemoryBarrierEXT _glMemoryBarrierEXT
#define glVertexAttribL1dEXT _glVertexAttribL1dEXT
#define glVertexAttribL2dEXT _glVertexAttribL2dEXT
#define glVertexAttribL3dEXT _glVertexAttribL3dEXT
#define glVertexAttribL4dEXT _glVertexAttribL4dEXT
#define glVertexAttribL1dvEXT _glVertexAttribL1dvEXT
#define glVertexAttribL2dvEXT _glVertexAttribL2dvEXT
#define glVertexAttribL3dvEXT _glVertexAttribL3dvEXT
#define glVertexAttribL4dvEXT _glVertexAttribL4dvEXT
#define glVertexAttribLPointerEXT _glVertexAttribLPointerEXT
#define glGetVertexAttribLdvEXT _glGetVertexAttribLdvEXT
#define glVertexArrayVertexAttribLOffsetEXT _glVertexArrayVertexAttribLOffsetEXT
#define glProgramSubroutineParametersuivNV _glProgramSubroutineParametersuivNV
#define glGetProgramSubroutineParameteruivNV _glGetProgramSubroutineParameteruivNV
#define glUniform1i64NV _glUniform1i64NV
#define glUniform2i64NV _glUniform2i64NV
#define glUniform3i64NV _glUniform3i64NV
#define glUniform4i64NV _glUniform4i64NV
#define glUniform1i64vNV _glUniform1i64vNV
#define glUniform2i64vNV _glUniform2i64vNV
#define glUniform3i64vNV _glUniform3i64vNV
#define glUniform4i64vNV _glUniform4i64vNV
#define glUniform1ui64NV _glUniform1ui64NV
#define glUniform2ui64NV _glUniform2ui64NV
#define glUniform3ui64NV _glUniform3ui64NV
#define glUniform4ui64NV _glUniform4ui64NV
#define glUniform1ui64vNV _glUniform1ui64vNV
#define glUniform2ui64vNV _glUniform2ui64vNV
#define glUniform3ui64vNV _glUniform3ui64vNV
#define glUniform4ui64vNV _glUniform4ui64vNV
#define glGetUniformi64vNV _glGetUniformi64vNV
#define glProgramUniform1i64NV _glProgramUniform1i64NV
#define glProgramUniform2i64NV _glProgramUniform2i64NV
#define glProgramUniform3i64NV _glProgramUniform3i64NV
#define glProgramUniform4i64NV _glProgramUniform4i64NV
#define glProgramUniform1i64vNV _glProgramUniform1i64vNV
#define glProgramUniform2i64vNV _glProgramUniform2i64vNV
#define glProgramUniform3i64vNV _glProgramUniform3i64vNV
#define glProgramUniform4i64vNV _glProgramUniform4i64vNV
#define glProgramUniform1ui64NV _glProgramUniform1ui64NV
#define glProgramUniform2ui64NV _glProgramUniform2ui64NV
#define glProgramUniform3ui64NV _glProgramUniform3ui64NV
#define glProgramUniform4ui64NV _glProgramUniform4ui64NV
#define glProgramUniform1ui64vNV _glProgramUniform1ui64vNV
#define glProgramUniform2ui64vNV _glProgramUniform2ui64vNV
#define glProgramUniform3ui64vNV _glProgramUniform3ui64vNV
#define glProgramUniform4ui64vNV _glProgramUniform4ui64vNV
#define glVertexAttribL1i64NV _glVertexAttribL1i64NV
#define glVertexAttribL2i64NV _glVertexAttribL2i64NV
#define glVertexAttribL3i64NV _glVertexAttribL3i64NV
#define glVertexAttribL4i64NV _glVertexAttribL4i64NV
#define glVertexAttribL1i64vNV _glVertexAttribL1i64vNV
#define glVertexAttribL2i64vNV _glVertexAttribL2i64vNV
#define glVertexAttribL3i64vNV _glVertexAttribL3i64vNV
#define glVertexAttribL4i64vNV _glVertexAttribL4i64vNV
#define glVertexAttribL1ui64NV _glVertexAttribL1ui64NV
#define glVertexAttribL2ui64NV _glVertexAttribL2ui64NV
#define glVertexAttribL3ui64NV _glVertexAttribL3ui64NV
#define glVertexAttribL4ui64NV _glVertexAttribL4ui64NV
#define glVertexAttribL1ui64vNV _glVertexAttribL1ui64vNV
#define glVertexAttribL2ui64vNV _glVertexAttribL2ui64vNV
#define glVertexAttribL3ui64vNV _glVertexAttribL3ui64vNV
#define glVertexAttribL4ui64vNV _glVertexAttribL4ui64vNV
#define glGetVertexAttribLi64vNV _glGetVertexAttribLi64vNV
#define glGetVertexAttribLui64vNV _glGetVertexAttribLui64vNV
#define glVertexAttribLFormatNV _glVertexAttribLFormatNV
#define glGenNamesAMD _glGenNamesAMD
#define glDeleteNamesAMD _glDeleteNamesAMD
#define glIsNameAMD _glIsNameAMD
#define glDebugMessageEnableAMD _glDebugMessageEnableAMD
#define glDebugMessageInsertAMD _glDebugMessageInsertAMD
#define glDebugMessageCallbackAMD _glDebugMessageCallbackAMD
#define glGetDebugMessageLogAMD _glGetDebugMessageLogAMD
#define glTexImage2DMultisampleCoverageNV _glTexImage2DMultisampleCoverageNV
#define glTexImage3DMultisampleCoverageNV _glTexImage3DMultisampleCoverageNV
#define glTextureImage2DMultisampleNV _glTextureImage2DMultisampleNV
#define glTextureImage3DMultisampleNV _glTextureImage3DMultisampleNV
#define glTextureImage2DMultisampleCoverageNV _glTextureImage2DMultisampleCoverageNV
#define glTextureImage3DMultisampleCoverageNV _glTextureImage3DMultisampleCoverageNV
#define glSetMultisamplefvAMD _glSetMultisamplefvAMD
#define glImportSyncEXT _glImportSyncEXT
#define glMultiDrawArraysIndirectAMD _glMultiDrawArraysIndirectAMD
#define glMultiDrawElementsIndirectAMD _glMultiDrawElementsIndirectAMD
#define glNewBufferRegion _glNewBufferRegion
#define glDeleteBufferRegion _glDeleteBufferRegion
#define glReadBufferRegion _glReadBufferRegion
#define glDrawBufferRegion _glDrawBufferRegion
#define glBufferRegionEnabled _glBufferRegionEnabled
#define glAddSwapHintRectWIN _glAddSwapHintRectWIN
#endif /* RETRACE */


typedef void (GL_APIENTRY * PFN_GLFRUSTUMF)(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
static PFN_GLFRUSTUMF _glFrustumf_ptr = NULL;

static inline void GL_APIENTRY _glFrustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar) {
    const char *_name = "glFrustumf";
    if (!_glFrustumf_ptr) {
        _glFrustumf_ptr = (PFN_GLFRUSTUMF)_getPrivateProcAddress(_name);
        if (!_glFrustumf_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFrustumf_ptr(left, right, bottom, top, zNear, zFar);
}

typedef void (GL_APIENTRY * PFN_GLORTHOF)(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
static PFN_GLORTHOF _glOrthof_ptr = NULL;

static inline void GL_APIENTRY _glOrthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar) {
    const char *_name = "glOrthof";
    if (!_glOrthof_ptr) {
        _glOrthof_ptr = (PFN_GLORTHOF)_getPrivateProcAddress(_name);
        if (!_glOrthof_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glOrthof_ptr(left, right, bottom, top, zNear, zFar);
}

typedef void (GL_APIENTRY * PFN_GLCLIPPLANEF)(GLenum plane, const GLfloat * equation);
static PFN_GLCLIPPLANEF _glClipPlanef_ptr = NULL;

static inline void GL_APIENTRY _glClipPlanef(GLenum plane, const GLfloat * equation) {
    const char *_name = "glClipPlanef";
    if (!_glClipPlanef_ptr) {
        _glClipPlanef_ptr = (PFN_GLCLIPPLANEF)_getPrivateProcAddress(_name);
        if (!_glClipPlanef_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClipPlanef_ptr(plane, equation);
}

typedef void (GL_APIENTRY * PFN_GLGETCLIPPLANEF)(GLenum plane, GLfloat * equation);
static PFN_GLGETCLIPPLANEF _glGetClipPlanef_ptr = NULL;

static inline void GL_APIENTRY _glGetClipPlanef(GLenum plane, GLfloat * equation) {
    const char *_name = "glGetClipPlanef";
    if (!_glGetClipPlanef_ptr) {
        _glGetClipPlanef_ptr = (PFN_GLGETCLIPPLANEF)_getPrivateProcAddress(_name);
        if (!_glGetClipPlanef_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetClipPlanef_ptr(plane, equation);
}

typedef void (GL_APIENTRY * PFN_GLALPHAFUNCX)(GLenum func, GLclampx ref);
static PFN_GLALPHAFUNCX _glAlphaFuncx_ptr = NULL;

static inline void GL_APIENTRY _glAlphaFuncx(GLenum func, GLclampx ref) {
    const char *_name = "glAlphaFuncx";
    if (!_glAlphaFuncx_ptr) {
        _glAlphaFuncx_ptr = (PFN_GLALPHAFUNCX)_getPrivateProcAddress(_name);
        if (!_glAlphaFuncx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glAlphaFuncx_ptr(func, ref);
}

typedef void (GL_APIENTRY * PFN_GLCLEARCOLORX)(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
static PFN_GLCLEARCOLORX _glClearColorx_ptr = NULL;

static inline void GL_APIENTRY _glClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha) {
    const char *_name = "glClearColorx";
    if (!_glClearColorx_ptr) {
        _glClearColorx_ptr = (PFN_GLCLEARCOLORX)_getPrivateProcAddress(_name);
        if (!_glClearColorx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearColorx_ptr(red, green, blue, alpha);
}

typedef void (GL_APIENTRY * PFN_GLCLEARDEPTHX)(GLclampx depth);
static PFN_GLCLEARDEPTHX _glClearDepthx_ptr = NULL;

static inline void GL_APIENTRY _glClearDepthx(GLclampx depth) {
    const char *_name = "glClearDepthx";
    if (!_glClearDepthx_ptr) {
        _glClearDepthx_ptr = (PFN_GLCLEARDEPTHX)_getPrivateProcAddress(_name);
        if (!_glClearDepthx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClearDepthx_ptr(depth);
}

typedef void (GL_APIENTRY * PFN_GLCOLOR4X)(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
static PFN_GLCOLOR4X _glColor4x_ptr = NULL;

static inline void GL_APIENTRY _glColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) {
    const char *_name = "glColor4x";
    if (!_glColor4x_ptr) {
        _glColor4x_ptr = (PFN_GLCOLOR4X)_getPrivateProcAddress(_name);
        if (!_glColor4x_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glColor4x_ptr(red, green, blue, alpha);
}

typedef void (GL_APIENTRY * PFN_GLDEPTHRANGEX)(GLclampx zNear, GLclampx zFar);
static PFN_GLDEPTHRANGEX _glDepthRangex_ptr = NULL;

static inline void GL_APIENTRY _glDepthRangex(GLclampx zNear, GLclampx zFar) {
    const char *_name = "glDepthRangex";
    if (!_glDepthRangex_ptr) {
        _glDepthRangex_ptr = (PFN_GLDEPTHRANGEX)_getPrivateProcAddress(_name);
        if (!_glDepthRangex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDepthRangex_ptr(zNear, zFar);
}

typedef void (GL_APIENTRY * PFN_GLFOGX)(GLenum pname, GLfixed param);
static PFN_GLFOGX _glFogx_ptr = NULL;

static inline void GL_APIENTRY _glFogx(GLenum pname, GLfixed param) {
    const char *_name = "glFogx";
    if (!_glFogx_ptr) {
        _glFogx_ptr = (PFN_GLFOGX)_getPrivateProcAddress(_name);
        if (!_glFogx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogx_ptr(pname, param);
}

typedef void (GL_APIENTRY * PFN_GLFOGXV)(GLenum pname, const GLfixed * params);
static PFN_GLFOGXV _glFogxv_ptr = NULL;

static inline void GL_APIENTRY _glFogxv(GLenum pname, const GLfixed * params) {
    const char *_name = "glFogxv";
    if (!_glFogxv_ptr) {
        _glFogxv_ptr = (PFN_GLFOGXV)_getPrivateProcAddress(_name);
        if (!_glFogxv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFogxv_ptr(pname, params);
}

typedef void (GL_APIENTRY * PFN_GLFRUSTUMX)(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
static PFN_GLFRUSTUMX _glFrustumx_ptr = NULL;

static inline void GL_APIENTRY _glFrustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar) {
    const char *_name = "glFrustumx";
    if (!_glFrustumx_ptr) {
        _glFrustumx_ptr = (PFN_GLFRUSTUMX)_getPrivateProcAddress(_name);
        if (!_glFrustumx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFrustumx_ptr(left, right, bottom, top, zNear, zFar);
}

typedef void (GL_APIENTRY * PFN_GLLIGHTMODELX)(GLenum pname, GLfixed param);
static PFN_GLLIGHTMODELX _glLightModelx_ptr = NULL;

static inline void GL_APIENTRY _glLightModelx(GLenum pname, GLfixed param) {
    const char *_name = "glLightModelx";
    if (!_glLightModelx_ptr) {
        _glLightModelx_ptr = (PFN_GLLIGHTMODELX)_getPrivateProcAddress(_name);
        if (!_glLightModelx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLightModelx_ptr(pname, param);
}

typedef void (GL_APIENTRY * PFN_GLLIGHTMODELXV)(GLenum pname, const GLfixed * params);
static PFN_GLLIGHTMODELXV _glLightModelxv_ptr = NULL;

static inline void GL_APIENTRY _glLightModelxv(GLenum pname, const GLfixed * params) {
    const char *_name = "glLightModelxv";
    if (!_glLightModelxv_ptr) {
        _glLightModelxv_ptr = (PFN_GLLIGHTMODELXV)_getPrivateProcAddress(_name);
        if (!_glLightModelxv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLightModelxv_ptr(pname, params);
}

typedef void (GL_APIENTRY * PFN_GLLIGHTX)(GLenum light, GLenum pname, GLfixed param);
static PFN_GLLIGHTX _glLightx_ptr = NULL;

static inline void GL_APIENTRY _glLightx(GLenum light, GLenum pname, GLfixed param) {
    const char *_name = "glLightx";
    if (!_glLightx_ptr) {
        _glLightx_ptr = (PFN_GLLIGHTX)_getPrivateProcAddress(_name);
        if (!_glLightx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLightx_ptr(light, pname, param);
}

typedef void (GL_APIENTRY * PFN_GLLIGHTXV)(GLenum light, GLenum pname, const GLfixed * params);
static PFN_GLLIGHTXV _glLightxv_ptr = NULL;

static inline void GL_APIENTRY _glLightxv(GLenum light, GLenum pname, const GLfixed * params) {
    const char *_name = "glLightxv";
    if (!_glLightxv_ptr) {
        _glLightxv_ptr = (PFN_GLLIGHTXV)_getPrivateProcAddress(_name);
        if (!_glLightxv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLightxv_ptr(light, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLLINEWIDTHX)(GLfixed width);
static PFN_GLLINEWIDTHX _glLineWidthx_ptr = NULL;

static inline void GL_APIENTRY _glLineWidthx(GLfixed width) {
    const char *_name = "glLineWidthx";
    if (!_glLineWidthx_ptr) {
        _glLineWidthx_ptr = (PFN_GLLINEWIDTHX)_getPrivateProcAddress(_name);
        if (!_glLineWidthx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLineWidthx_ptr(width);
}

typedef void (GL_APIENTRY * PFN_GLLOADMATRIXX)(const GLfixed * m);
static PFN_GLLOADMATRIXX _glLoadMatrixx_ptr = NULL;

static inline void GL_APIENTRY _glLoadMatrixx(const GLfixed * m) {
    const char *_name = "glLoadMatrixx";
    if (!_glLoadMatrixx_ptr) {
        _glLoadMatrixx_ptr = (PFN_GLLOADMATRIXX)_getPrivateProcAddress(_name);
        if (!_glLoadMatrixx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLoadMatrixx_ptr(m);
}

typedef void (GL_APIENTRY * PFN_GLMATERIALX)(GLenum face, GLenum pname, GLfixed param);
static PFN_GLMATERIALX _glMaterialx_ptr = NULL;

static inline void GL_APIENTRY _glMaterialx(GLenum face, GLenum pname, GLfixed param) {
    const char *_name = "glMaterialx";
    if (!_glMaterialx_ptr) {
        _glMaterialx_ptr = (PFN_GLMATERIALX)_getPrivateProcAddress(_name);
        if (!_glMaterialx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMaterialx_ptr(face, pname, param);
}

typedef void (GL_APIENTRY * PFN_GLMATERIALXV)(GLenum face, GLenum pname, const GLfixed * params);
static PFN_GLMATERIALXV _glMaterialxv_ptr = NULL;

static inline void GL_APIENTRY _glMaterialxv(GLenum face, GLenum pname, const GLfixed * params) {
    const char *_name = "glMaterialxv";
    if (!_glMaterialxv_ptr) {
        _glMaterialxv_ptr = (PFN_GLMATERIALXV)_getPrivateProcAddress(_name);
        if (!_glMaterialxv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMaterialxv_ptr(face, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLMULTMATRIXX)(const GLfixed * m);
static PFN_GLMULTMATRIXX _glMultMatrixx_ptr = NULL;

static inline void GL_APIENTRY _glMultMatrixx(const GLfixed * m) {
    const char *_name = "glMultMatrixx";
    if (!_glMultMatrixx_ptr) {
        _glMultMatrixx_ptr = (PFN_GLMULTMATRIXX)_getPrivateProcAddress(_name);
        if (!_glMultMatrixx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultMatrixx_ptr(m);
}

typedef void (GL_APIENTRY * PFN_GLMULTITEXCOORD4X)(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
static PFN_GLMULTITEXCOORD4X _glMultiTexCoord4x_ptr = NULL;

static inline void GL_APIENTRY _glMultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q) {
    const char *_name = "glMultiTexCoord4x";
    if (!_glMultiTexCoord4x_ptr) {
        _glMultiTexCoord4x_ptr = (PFN_GLMULTITEXCOORD4X)_getPrivateProcAddress(_name);
        if (!_glMultiTexCoord4x_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMultiTexCoord4x_ptr(target, s, t, r, q);
}

typedef void (GL_APIENTRY * PFN_GLNORMAL3X)(GLfixed nx, GLfixed ny, GLfixed nz);
static PFN_GLNORMAL3X _glNormal3x_ptr = NULL;

static inline void GL_APIENTRY _glNormal3x(GLfixed nx, GLfixed ny, GLfixed nz) {
    const char *_name = "glNormal3x";
    if (!_glNormal3x_ptr) {
        _glNormal3x_ptr = (PFN_GLNORMAL3X)_getPrivateProcAddress(_name);
        if (!_glNormal3x_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glNormal3x_ptr(nx, ny, nz);
}

typedef void (GL_APIENTRY * PFN_GLORTHOX)(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
static PFN_GLORTHOX _glOrthox_ptr = NULL;

static inline void GL_APIENTRY _glOrthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar) {
    const char *_name = "glOrthox";
    if (!_glOrthox_ptr) {
        _glOrthox_ptr = (PFN_GLORTHOX)_getPrivateProcAddress(_name);
        if (!_glOrthox_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glOrthox_ptr(left, right, bottom, top, zNear, zFar);
}

typedef void (GL_APIENTRY * PFN_GLPOINTSIZEX)(GLfixed size);
static PFN_GLPOINTSIZEX _glPointSizex_ptr = NULL;

static inline void GL_APIENTRY _glPointSizex(GLfixed size) {
    const char *_name = "glPointSizex";
    if (!_glPointSizex_ptr) {
        _glPointSizex_ptr = (PFN_GLPOINTSIZEX)_getPrivateProcAddress(_name);
        if (!_glPointSizex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointSizex_ptr(size);
}

typedef void (GL_APIENTRY * PFN_GLPOLYGONOFFSETX)(GLfixed factor, GLfixed units);
static PFN_GLPOLYGONOFFSETX _glPolygonOffsetx_ptr = NULL;

static inline void GL_APIENTRY _glPolygonOffsetx(GLfixed factor, GLfixed units) {
    const char *_name = "glPolygonOffsetx";
    if (!_glPolygonOffsetx_ptr) {
        _glPolygonOffsetx_ptr = (PFN_GLPOLYGONOFFSETX)_getPrivateProcAddress(_name);
        if (!_glPolygonOffsetx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPolygonOffsetx_ptr(factor, units);
}

typedef void (GL_APIENTRY * PFN_GLROTATEX)(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
static PFN_GLROTATEX _glRotatex_ptr = NULL;

static inline void GL_APIENTRY _glRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z) {
    const char *_name = "glRotatex";
    if (!_glRotatex_ptr) {
        _glRotatex_ptr = (PFN_GLROTATEX)_getPrivateProcAddress(_name);
        if (!_glRotatex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRotatex_ptr(angle, x, y, z);
}

typedef void (GL_APIENTRY * PFN_GLSAMPLECOVERAGEX)(GLclampx value, GLboolean invert);
static PFN_GLSAMPLECOVERAGEX _glSampleCoveragex_ptr = NULL;

static inline void GL_APIENTRY _glSampleCoveragex(GLclampx value, GLboolean invert) {
    const char *_name = "glSampleCoveragex";
    if (!_glSampleCoveragex_ptr) {
        _glSampleCoveragex_ptr = (PFN_GLSAMPLECOVERAGEX)_getPrivateProcAddress(_name);
        if (!_glSampleCoveragex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glSampleCoveragex_ptr(value, invert);
}

typedef void (GL_APIENTRY * PFN_GLSCALEX)(GLfixed x, GLfixed y, GLfixed z);
static PFN_GLSCALEX _glScalex_ptr = NULL;

static inline void GL_APIENTRY _glScalex(GLfixed x, GLfixed y, GLfixed z) {
    const char *_name = "glScalex";
    if (!_glScalex_ptr) {
        _glScalex_ptr = (PFN_GLSCALEX)_getPrivateProcAddress(_name);
        if (!_glScalex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glScalex_ptr(x, y, z);
}

typedef void (GL_APIENTRY * PFN_GLTEXENVX)(GLenum target, GLenum pname, GLfixed param);
static PFN_GLTEXENVX _glTexEnvx_ptr = NULL;

static inline void GL_APIENTRY _glTexEnvx(GLenum target, GLenum pname, GLfixed param) {
    const char *_name = "glTexEnvx";
    if (!_glTexEnvx_ptr) {
        _glTexEnvx_ptr = (PFN_GLTEXENVX)_getPrivateProcAddress(_name);
        if (!_glTexEnvx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexEnvx_ptr(target, pname, param);
}

typedef void (GL_APIENTRY * PFN_GLTEXENVXV)(GLenum target, GLenum pname, const GLfixed * params);
static PFN_GLTEXENVXV _glTexEnvxv_ptr = NULL;

static inline void GL_APIENTRY _glTexEnvxv(GLenum target, GLenum pname, const GLfixed * params) {
    const char *_name = "glTexEnvxv";
    if (!_glTexEnvxv_ptr) {
        _glTexEnvxv_ptr = (PFN_GLTEXENVXV)_getPrivateProcAddress(_name);
        if (!_glTexEnvxv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexEnvxv_ptr(target, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLTEXPARAMETERX)(GLenum target, GLenum pname, GLfixed param);
static PFN_GLTEXPARAMETERX _glTexParameterx_ptr = NULL;

static inline void GL_APIENTRY _glTexParameterx(GLenum target, GLenum pname, GLfixed param) {
    const char *_name = "glTexParameterx";
    if (!_glTexParameterx_ptr) {
        _glTexParameterx_ptr = (PFN_GLTEXPARAMETERX)_getPrivateProcAddress(_name);
        if (!_glTexParameterx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexParameterx_ptr(target, pname, param);
}

typedef void (GL_APIENTRY * PFN_GLTRANSLATEX)(GLfixed x, GLfixed y, GLfixed z);
static PFN_GLTRANSLATEX _glTranslatex_ptr = NULL;

static inline void GL_APIENTRY _glTranslatex(GLfixed x, GLfixed y, GLfixed z) {
    const char *_name = "glTranslatex";
    if (!_glTranslatex_ptr) {
        _glTranslatex_ptr = (PFN_GLTRANSLATEX)_getPrivateProcAddress(_name);
        if (!_glTranslatex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTranslatex_ptr(x, y, z);
}

typedef void (GL_APIENTRY * PFN_GLCLIPPLANEX)(GLenum plane, const GLfixed * equation);
static PFN_GLCLIPPLANEX _glClipPlanex_ptr = NULL;

static inline void GL_APIENTRY _glClipPlanex(GLenum plane, const GLfixed * equation) {
    const char *_name = "glClipPlanex";
    if (!_glClipPlanex_ptr) {
        _glClipPlanex_ptr = (PFN_GLCLIPPLANEX)_getPrivateProcAddress(_name);
        if (!_glClipPlanex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glClipPlanex_ptr(plane, equation);
}

typedef void (GL_APIENTRY * PFN_GLGETCLIPPLANEX)(GLenum plane, GLfixed * equation);
static PFN_GLGETCLIPPLANEX _glGetClipPlanex_ptr = NULL;

static inline void GL_APIENTRY _glGetClipPlanex(GLenum plane, GLfixed * equation) {
    const char *_name = "glGetClipPlanex";
    if (!_glGetClipPlanex_ptr) {
        _glGetClipPlanex_ptr = (PFN_GLGETCLIPPLANEX)_getPrivateProcAddress(_name);
        if (!_glGetClipPlanex_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetClipPlanex_ptr(plane, equation);
}

typedef void (GL_APIENTRY * PFN_GLGETFIXEDV)(GLenum pname, GLfixed * params);
static PFN_GLGETFIXEDV _glGetFixedv_ptr = NULL;

static inline void GL_APIENTRY _glGetFixedv(GLenum pname, GLfixed * params) {
    const char *_name = "glGetFixedv";
    if (!_glGetFixedv_ptr) {
        _glGetFixedv_ptr = (PFN_GLGETFIXEDV)_getPrivateProcAddress(_name);
        if (!_glGetFixedv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFixedv_ptr(pname, params);
}

typedef void (GL_APIENTRY * PFN_GLGETLIGHTXV)(GLenum light, GLenum pname, GLfixed * params);
static PFN_GLGETLIGHTXV _glGetLightxv_ptr = NULL;

static inline void GL_APIENTRY _glGetLightxv(GLenum light, GLenum pname, GLfixed * params) {
    const char *_name = "glGetLightxv";
    if (!_glGetLightxv_ptr) {
        _glGetLightxv_ptr = (PFN_GLGETLIGHTXV)_getPrivateProcAddress(_name);
        if (!_glGetLightxv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetLightxv_ptr(light, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLGETMATERIALXV)(GLenum face, GLenum pname, GLfixed * params);
static PFN_GLGETMATERIALXV _glGetMaterialxv_ptr = NULL;

static inline void GL_APIENTRY _glGetMaterialxv(GLenum face, GLenum pname, GLfixed * params) {
    const char *_name = "glGetMaterialxv";
    if (!_glGetMaterialxv_ptr) {
        _glGetMaterialxv_ptr = (PFN_GLGETMATERIALXV)_getPrivateProcAddress(_name);
        if (!_glGetMaterialxv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetMaterialxv_ptr(face, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLGETTEXENVXV)(GLenum target, GLenum pname, GLfixed * params);
static PFN_GLGETTEXENVXV _glGetTexEnvxv_ptr = NULL;

static inline void GL_APIENTRY _glGetTexEnvxv(GLenum target, GLenum pname, GLfixed * params) {
    const char *_name = "glGetTexEnvxv";
    if (!_glGetTexEnvxv_ptr) {
        _glGetTexEnvxv_ptr = (PFN_GLGETTEXENVXV)_getPrivateProcAddress(_name);
        if (!_glGetTexEnvxv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexEnvxv_ptr(target, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLGETTEXPARAMETERXV)(GLenum target, GLenum pname, GLfixed * params);
static PFN_GLGETTEXPARAMETERXV _glGetTexParameterxv_ptr = NULL;

static inline void GL_APIENTRY _glGetTexParameterxv(GLenum target, GLenum pname, GLfixed * params) {
    const char *_name = "glGetTexParameterxv";
    if (!_glGetTexParameterxv_ptr) {
        _glGetTexParameterxv_ptr = (PFN_GLGETTEXPARAMETERXV)_getPrivateProcAddress(_name);
        if (!_glGetTexParameterxv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexParameterxv_ptr(target, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLPOINTPARAMETERX)(GLenum pname, GLfixed param);
static PFN_GLPOINTPARAMETERX _glPointParameterx_ptr = NULL;

static inline void GL_APIENTRY _glPointParameterx(GLenum pname, GLfixed param) {
    const char *_name = "glPointParameterx";
    if (!_glPointParameterx_ptr) {
        _glPointParameterx_ptr = (PFN_GLPOINTPARAMETERX)_getPrivateProcAddress(_name);
        if (!_glPointParameterx_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameterx_ptr(pname, param);
}

typedef void (GL_APIENTRY * PFN_GLPOINTPARAMETERXV)(GLenum pname, const GLfixed * params);
static PFN_GLPOINTPARAMETERXV _glPointParameterxv_ptr = NULL;

static inline void GL_APIENTRY _glPointParameterxv(GLenum pname, const GLfixed * params) {
    const char *_name = "glPointParameterxv";
    if (!_glPointParameterxv_ptr) {
        _glPointParameterxv_ptr = (PFN_GLPOINTPARAMETERXV)_getPrivateProcAddress(_name);
        if (!_glPointParameterxv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointParameterxv_ptr(pname, params);
}

typedef void (GL_APIENTRY * PFN_GLTEXPARAMETERXV)(GLenum target, GLenum pname, const GLfixed * params);
static PFN_GLTEXPARAMETERXV _glTexParameterxv_ptr = NULL;

static inline void GL_APIENTRY _glTexParameterxv(GLenum target, GLenum pname, const GLfixed * params) {
    const char *_name = "glTexParameterxv";
    if (!_glTexParameterxv_ptr) {
        _glTexParameterxv_ptr = (PFN_GLTEXPARAMETERXV)_getPrivateProcAddress(_name);
        if (!_glTexParameterxv_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexParameterxv_ptr(target, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLBLENDEQUATIONSEPARATEOES)(GLenum modeRGB, GLenum modeAlpha);
static PFN_GLBLENDEQUATIONSEPARATEOES _glBlendEquationSeparateOES_ptr = NULL;

static inline void GL_APIENTRY _glBlendEquationSeparateOES(GLenum modeRGB, GLenum modeAlpha) {
    const char *_name = "glBlendEquationSeparateOES";
    if (!_glBlendEquationSeparateOES_ptr) {
        _glBlendEquationSeparateOES_ptr = (PFN_GLBLENDEQUATIONSEPARATEOES)_getPrivateProcAddress(_name);
        if (!_glBlendEquationSeparateOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendEquationSeparateOES_ptr(modeRGB, modeAlpha);
}

typedef void (GL_APIENTRY * PFN_GLBLENDFUNCSEPARATEOES)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
static PFN_GLBLENDFUNCSEPARATEOES _glBlendFuncSeparateOES_ptr = NULL;

static inline void GL_APIENTRY _glBlendFuncSeparateOES(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
    const char *_name = "glBlendFuncSeparateOES";
    if (!_glBlendFuncSeparateOES_ptr) {
        _glBlendFuncSeparateOES_ptr = (PFN_GLBLENDFUNCSEPARATEOES)_getPrivateProcAddress(_name);
        if (!_glBlendFuncSeparateOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendFuncSeparateOES_ptr(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

typedef void (GL_APIENTRY * PFN_GLBLENDEQUATIONOES)(GLenum mode);
static PFN_GLBLENDEQUATIONOES _glBlendEquationOES_ptr = NULL;

static inline void GL_APIENTRY _glBlendEquationOES(GLenum mode) {
    const char *_name = "glBlendEquationOES";
    if (!_glBlendEquationOES_ptr) {
        _glBlendEquationOES_ptr = (PFN_GLBLENDEQUATIONOES)_getPrivateProcAddress(_name);
        if (!_glBlendEquationOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlendEquationOES_ptr(mode);
}

typedef GLboolean (GL_APIENTRY * PFN_GLISRENDERBUFFEROES)(GLuint renderbuffer);
static PFN_GLISRENDERBUFFEROES _glIsRenderbufferOES_ptr = NULL;

static inline GLboolean GL_APIENTRY _glIsRenderbufferOES(GLuint renderbuffer) {
    const char *_name = "glIsRenderbufferOES";
    if (!_glIsRenderbufferOES_ptr) {
        _glIsRenderbufferOES_ptr = (PFN_GLISRENDERBUFFEROES)_getPrivateProcAddress(_name);
        if (!_glIsRenderbufferOES_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsRenderbufferOES_ptr(renderbuffer);
}

typedef void (GL_APIENTRY * PFN_GLBINDRENDERBUFFEROES)(GLenum target, GLuint renderbuffer);
static PFN_GLBINDRENDERBUFFEROES _glBindRenderbufferOES_ptr = NULL;

static inline void GL_APIENTRY _glBindRenderbufferOES(GLenum target, GLuint renderbuffer) {
    const char *_name = "glBindRenderbufferOES";
    if (!_glBindRenderbufferOES_ptr) {
        _glBindRenderbufferOES_ptr = (PFN_GLBINDRENDERBUFFEROES)_getPrivateProcAddress(_name);
        if (!_glBindRenderbufferOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindRenderbufferOES_ptr(target, renderbuffer);
}

typedef void (GL_APIENTRY * PFN_GLDELETERENDERBUFFERSOES)(GLsizei n, const GLuint * renderbuffers);
static PFN_GLDELETERENDERBUFFERSOES _glDeleteRenderbuffersOES_ptr = NULL;

static inline void GL_APIENTRY _glDeleteRenderbuffersOES(GLsizei n, const GLuint * renderbuffers) {
    const char *_name = "glDeleteRenderbuffersOES";
    if (!_glDeleteRenderbuffersOES_ptr) {
        _glDeleteRenderbuffersOES_ptr = (PFN_GLDELETERENDERBUFFERSOES)_getPrivateProcAddress(_name);
        if (!_glDeleteRenderbuffersOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteRenderbuffersOES_ptr(n, renderbuffers);
}

typedef void (GL_APIENTRY * PFN_GLGENRENDERBUFFERSOES)(GLsizei n, GLuint * renderbuffers);
static PFN_GLGENRENDERBUFFERSOES _glGenRenderbuffersOES_ptr = NULL;

static inline void GL_APIENTRY _glGenRenderbuffersOES(GLsizei n, GLuint * renderbuffers) {
    const char *_name = "glGenRenderbuffersOES";
    if (!_glGenRenderbuffersOES_ptr) {
        _glGenRenderbuffersOES_ptr = (PFN_GLGENRENDERBUFFERSOES)_getPrivateProcAddress(_name);
        if (!_glGenRenderbuffersOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenRenderbuffersOES_ptr(n, renderbuffers);
}

typedef void (GL_APIENTRY * PFN_GLRENDERBUFFERSTORAGEOES)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLRENDERBUFFERSTORAGEOES _glRenderbufferStorageOES_ptr = NULL;

static inline void GL_APIENTRY _glRenderbufferStorageOES(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageOES";
    if (!_glRenderbufferStorageOES_ptr) {
        _glRenderbufferStorageOES_ptr = (PFN_GLRENDERBUFFERSTORAGEOES)_getPrivateProcAddress(_name);
        if (!_glRenderbufferStorageOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRenderbufferStorageOES_ptr(target, internalformat, width, height);
}

typedef void (GL_APIENTRY * PFN_GLGETRENDERBUFFERPARAMETERIVOES)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETRENDERBUFFERPARAMETERIVOES _glGetRenderbufferParameterivOES_ptr = NULL;

static inline void GL_APIENTRY _glGetRenderbufferParameterivOES(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetRenderbufferParameterivOES";
    if (!_glGetRenderbufferParameterivOES_ptr) {
        _glGetRenderbufferParameterivOES_ptr = (PFN_GLGETRENDERBUFFERPARAMETERIVOES)_getPrivateProcAddress(_name);
        if (!_glGetRenderbufferParameterivOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetRenderbufferParameterivOES_ptr(target, pname, params);
}

typedef GLboolean (GL_APIENTRY * PFN_GLISFRAMEBUFFEROES)(GLuint framebuffer);
static PFN_GLISFRAMEBUFFEROES _glIsFramebufferOES_ptr = NULL;

static inline GLboolean GL_APIENTRY _glIsFramebufferOES(GLuint framebuffer) {
    const char *_name = "glIsFramebufferOES";
    if (!_glIsFramebufferOES_ptr) {
        _glIsFramebufferOES_ptr = (PFN_GLISFRAMEBUFFEROES)_getPrivateProcAddress(_name);
        if (!_glIsFramebufferOES_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsFramebufferOES_ptr(framebuffer);
}

typedef void (GL_APIENTRY * PFN_GLBINDFRAMEBUFFEROES)(GLenum target, GLuint framebuffer);
static PFN_GLBINDFRAMEBUFFEROES _glBindFramebufferOES_ptr = NULL;

static inline void GL_APIENTRY _glBindFramebufferOES(GLenum target, GLuint framebuffer) {
    const char *_name = "glBindFramebufferOES";
    if (!_glBindFramebufferOES_ptr) {
        _glBindFramebufferOES_ptr = (PFN_GLBINDFRAMEBUFFEROES)_getPrivateProcAddress(_name);
        if (!_glBindFramebufferOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindFramebufferOES_ptr(target, framebuffer);
}

typedef void (GL_APIENTRY * PFN_GLDELETEFRAMEBUFFERSOES)(GLsizei n, const GLuint * framebuffers);
static PFN_GLDELETEFRAMEBUFFERSOES _glDeleteFramebuffersOES_ptr = NULL;

static inline void GL_APIENTRY _glDeleteFramebuffersOES(GLsizei n, const GLuint * framebuffers) {
    const char *_name = "glDeleteFramebuffersOES";
    if (!_glDeleteFramebuffersOES_ptr) {
        _glDeleteFramebuffersOES_ptr = (PFN_GLDELETEFRAMEBUFFERSOES)_getPrivateProcAddress(_name);
        if (!_glDeleteFramebuffersOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteFramebuffersOES_ptr(n, framebuffers);
}

typedef void (GL_APIENTRY * PFN_GLGENFRAMEBUFFERSOES)(GLsizei n, GLuint * framebuffers);
static PFN_GLGENFRAMEBUFFERSOES _glGenFramebuffersOES_ptr = NULL;

static inline void GL_APIENTRY _glGenFramebuffersOES(GLsizei n, GLuint * framebuffers) {
    const char *_name = "glGenFramebuffersOES";
    if (!_glGenFramebuffersOES_ptr) {
        _glGenFramebuffersOES_ptr = (PFN_GLGENFRAMEBUFFERSOES)_getPrivateProcAddress(_name);
        if (!_glGenFramebuffersOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenFramebuffersOES_ptr(n, framebuffers);
}

typedef GLenum (GL_APIENTRY * PFN_GLCHECKFRAMEBUFFERSTATUSOES)(GLenum target);
static PFN_GLCHECKFRAMEBUFFERSTATUSOES _glCheckFramebufferStatusOES_ptr = NULL;

static inline GLenum GL_APIENTRY _glCheckFramebufferStatusOES(GLenum target) {
    const char *_name = "glCheckFramebufferStatusOES";
    if (!_glCheckFramebufferStatusOES_ptr) {
        _glCheckFramebufferStatusOES_ptr = (PFN_GLCHECKFRAMEBUFFERSTATUSOES)_getPrivateProcAddress(_name);
        if (!_glCheckFramebufferStatusOES_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glCheckFramebufferStatusOES_ptr(target);
}

typedef void (GL_APIENTRY * PFN_GLFRAMEBUFFERTEXTURE2DOES)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
static PFN_GLFRAMEBUFFERTEXTURE2DOES _glFramebufferTexture2DOES_ptr = NULL;

static inline void GL_APIENTRY _glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTexture2DOES";
    if (!_glFramebufferTexture2DOES_ptr) {
        _glFramebufferTexture2DOES_ptr = (PFN_GLFRAMEBUFFERTEXTURE2DOES)_getPrivateProcAddress(_name);
        if (!_glFramebufferTexture2DOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTexture2DOES_ptr(target, attachment, textarget, texture, level);
}

typedef void (GL_APIENTRY * PFN_GLFRAMEBUFFERRENDERBUFFEROES)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
static PFN_GLFRAMEBUFFERRENDERBUFFEROES _glFramebufferRenderbufferOES_ptr = NULL;

static inline void GL_APIENTRY _glFramebufferRenderbufferOES(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    const char *_name = "glFramebufferRenderbufferOES";
    if (!_glFramebufferRenderbufferOES_ptr) {
        _glFramebufferRenderbufferOES_ptr = (PFN_GLFRAMEBUFFERRENDERBUFFEROES)_getPrivateProcAddress(_name);
        if (!_glFramebufferRenderbufferOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferRenderbufferOES_ptr(target, attachment, renderbuffertarget, renderbuffer);
}

typedef void (GL_APIENTRY * PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIVOES)(GLenum target, GLenum attachment, GLenum pname, GLint * params);
static PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIVOES _glGetFramebufferAttachmentParameterivOES_ptr = NULL;

static inline void GL_APIENTRY _glGetFramebufferAttachmentParameterivOES(GLenum target, GLenum attachment, GLenum pname, GLint * params) {
    const char *_name = "glGetFramebufferAttachmentParameterivOES";
    if (!_glGetFramebufferAttachmentParameterivOES_ptr) {
        _glGetFramebufferAttachmentParameterivOES_ptr = (PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIVOES)_getPrivateProcAddress(_name);
        if (!_glGetFramebufferAttachmentParameterivOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetFramebufferAttachmentParameterivOES_ptr(target, attachment, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLGENERATEMIPMAPOES)(GLenum target);
static PFN_GLGENERATEMIPMAPOES _glGenerateMipmapOES_ptr = NULL;

static inline void GL_APIENTRY _glGenerateMipmapOES(GLenum target) {
    const char *_name = "glGenerateMipmapOES";
    if (!_glGenerateMipmapOES_ptr) {
        _glGenerateMipmapOES_ptr = (PFN_GLGENERATEMIPMAPOES)_getPrivateProcAddress(_name);
        if (!_glGenerateMipmapOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenerateMipmapOES_ptr(target);
}

typedef void (GL_APIENTRY * PFN_GLCURRENTPALETTEMATRIXOES)(GLuint index);
static PFN_GLCURRENTPALETTEMATRIXOES _glCurrentPaletteMatrixOES_ptr = NULL;

static inline void GL_APIENTRY _glCurrentPaletteMatrixOES(GLuint index) {
    const char *_name = "glCurrentPaletteMatrixOES";
    if (!_glCurrentPaletteMatrixOES_ptr) {
        _glCurrentPaletteMatrixOES_ptr = (PFN_GLCURRENTPALETTEMATRIXOES)_getPrivateProcAddress(_name);
        if (!_glCurrentPaletteMatrixOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCurrentPaletteMatrixOES_ptr(index);
}

typedef void (GL_APIENTRY * PFN_GLLOADPALETTEFROMMODELVIEWMATRIXOES)(void);
static PFN_GLLOADPALETTEFROMMODELVIEWMATRIXOES _glLoadPaletteFromModelViewMatrixOES_ptr = NULL;

static inline void GL_APIENTRY _glLoadPaletteFromModelViewMatrixOES(void) {
    const char *_name = "glLoadPaletteFromModelViewMatrixOES";
    if (!_glLoadPaletteFromModelViewMatrixOES_ptr) {
        _glLoadPaletteFromModelViewMatrixOES_ptr = (PFN_GLLOADPALETTEFROMMODELVIEWMATRIXOES)_getPrivateProcAddress(_name);
        if (!_glLoadPaletteFromModelViewMatrixOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLoadPaletteFromModelViewMatrixOES_ptr();
}

typedef void (GL_APIENTRY * PFN_GLMATRIXINDEXPOINTEROES)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLMATRIXINDEXPOINTEROES _glMatrixIndexPointerOES_ptr = NULL;

static inline void GL_APIENTRY _glMatrixIndexPointerOES(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glMatrixIndexPointerOES";
    if (!_glMatrixIndexPointerOES_ptr) {
        _glMatrixIndexPointerOES_ptr = (PFN_GLMATRIXINDEXPOINTEROES)_getPrivateProcAddress(_name);
        if (!_glMatrixIndexPointerOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glMatrixIndexPointerOES_ptr(size, type, stride, pointer);
}

typedef void (GL_APIENTRY * PFN_GLWEIGHTPOINTEROES)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
static PFN_GLWEIGHTPOINTEROES _glWeightPointerOES_ptr = NULL;

static inline void GL_APIENTRY _glWeightPointerOES(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glWeightPointerOES";
    if (!_glWeightPointerOES_ptr) {
        _glWeightPointerOES_ptr = (PFN_GLWEIGHTPOINTEROES)_getPrivateProcAddress(_name);
        if (!_glWeightPointerOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glWeightPointerOES_ptr(size, type, stride, pointer);
}

typedef void (GL_APIENTRY * PFN_GLPOINTSIZEPOINTEROES)(GLenum type, GLsizei stride, const GLvoid * ptr);
static PFN_GLPOINTSIZEPOINTEROES _glPointSizePointerOES_ptr = NULL;

static inline void GL_APIENTRY _glPointSizePointerOES(GLenum type, GLsizei stride, const GLvoid * ptr) {
    const char *_name = "glPointSizePointerOES";
    if (!_glPointSizePointerOES_ptr) {
        _glPointSizePointerOES_ptr = (PFN_GLPOINTSIZEPOINTEROES)_getPrivateProcAddress(_name);
        if (!_glPointSizePointerOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPointSizePointerOES_ptr(type, stride, ptr);
}

typedef GLbitfield (GL_APIENTRY * PFN_GLQUERYMATRIXXOES)(GLfixed * mantissa, GLint * exponent);
static PFN_GLQUERYMATRIXXOES _glQueryMatrixxOES_ptr = NULL;

static inline GLbitfield GL_APIENTRY _glQueryMatrixxOES(GLfixed * mantissa, GLint * exponent) {
    const char *_name = "glQueryMatrixxOES";
    if (!_glQueryMatrixxOES_ptr) {
        _glQueryMatrixxOES_ptr = (PFN_GLQUERYMATRIXXOES)_getPrivateProcAddress(_name);
        if (!_glQueryMatrixxOES_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glQueryMatrixxOES_ptr(mantissa, exponent);
}

typedef void (GL_APIENTRY * PFN_GLTEXGENFOES)(GLenum coord, GLenum pname, GLfloat param);
static PFN_GLTEXGENFOES _glTexGenfOES_ptr = NULL;

static inline void GL_APIENTRY _glTexGenfOES(GLenum coord, GLenum pname, GLfloat param) {
    const char *_name = "glTexGenfOES";
    if (!_glTexGenfOES_ptr) {
        _glTexGenfOES_ptr = (PFN_GLTEXGENFOES)_getPrivateProcAddress(_name);
        if (!_glTexGenfOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexGenfOES_ptr(coord, pname, param);
}

typedef void (GL_APIENTRY * PFN_GLTEXGENFVOES)(GLenum coord, GLenum pname, const GLfloat * params);
static PFN_GLTEXGENFVOES _glTexGenfvOES_ptr = NULL;

static inline void GL_APIENTRY _glTexGenfvOES(GLenum coord, GLenum pname, const GLfloat * params) {
    const char *_name = "glTexGenfvOES";
    if (!_glTexGenfvOES_ptr) {
        _glTexGenfvOES_ptr = (PFN_GLTEXGENFVOES)_getPrivateProcAddress(_name);
        if (!_glTexGenfvOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexGenfvOES_ptr(coord, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLTEXGENIOES)(GLenum coord, GLenum pname, GLint param);
static PFN_GLTEXGENIOES _glTexGeniOES_ptr = NULL;

static inline void GL_APIENTRY _glTexGeniOES(GLenum coord, GLenum pname, GLint param) {
    const char *_name = "glTexGeniOES";
    if (!_glTexGeniOES_ptr) {
        _glTexGeniOES_ptr = (PFN_GLTEXGENIOES)_getPrivateProcAddress(_name);
        if (!_glTexGeniOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexGeniOES_ptr(coord, pname, param);
}

typedef void (GL_APIENTRY * PFN_GLTEXGENIVOES)(GLenum coord, GLenum pname, const GLint * params);
static PFN_GLTEXGENIVOES _glTexGenivOES_ptr = NULL;

static inline void GL_APIENTRY _glTexGenivOES(GLenum coord, GLenum pname, const GLint * params) {
    const char *_name = "glTexGenivOES";
    if (!_glTexGenivOES_ptr) {
        _glTexGenivOES_ptr = (PFN_GLTEXGENIVOES)_getPrivateProcAddress(_name);
        if (!_glTexGenivOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexGenivOES_ptr(coord, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLTEXGENXOES)(GLenum coord, GLenum pname, GLfixed param);
static PFN_GLTEXGENXOES _glTexGenxOES_ptr = NULL;

static inline void GL_APIENTRY _glTexGenxOES(GLenum coord, GLenum pname, GLfixed param) {
    const char *_name = "glTexGenxOES";
    if (!_glTexGenxOES_ptr) {
        _glTexGenxOES_ptr = (PFN_GLTEXGENXOES)_getPrivateProcAddress(_name);
        if (!_glTexGenxOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexGenxOES_ptr(coord, pname, param);
}

typedef void (GL_APIENTRY * PFN_GLTEXGENXVOES)(GLenum coord, GLenum pname, const GLfixed * params);
static PFN_GLTEXGENXVOES _glTexGenxvOES_ptr = NULL;

static inline void GL_APIENTRY _glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed * params) {
    const char *_name = "glTexGenxvOES";
    if (!_glTexGenxvOES_ptr) {
        _glTexGenxvOES_ptr = (PFN_GLTEXGENXVOES)_getPrivateProcAddress(_name);
        if (!_glTexGenxvOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexGenxvOES_ptr(coord, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLGETTEXGENFVOES)(GLenum coord, GLenum pname, GLfloat * params);
static PFN_GLGETTEXGENFVOES _glGetTexGenfvOES_ptr = NULL;

static inline void GL_APIENTRY _glGetTexGenfvOES(GLenum coord, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTexGenfvOES";
    if (!_glGetTexGenfvOES_ptr) {
        _glGetTexGenfvOES_ptr = (PFN_GLGETTEXGENFVOES)_getPrivateProcAddress(_name);
        if (!_glGetTexGenfvOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexGenfvOES_ptr(coord, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLGETTEXGENIVOES)(GLenum coord, GLenum pname, GLint * params);
static PFN_GLGETTEXGENIVOES _glGetTexGenivOES_ptr = NULL;

static inline void GL_APIENTRY _glGetTexGenivOES(GLenum coord, GLenum pname, GLint * params) {
    const char *_name = "glGetTexGenivOES";
    if (!_glGetTexGenivOES_ptr) {
        _glGetTexGenivOES_ptr = (PFN_GLGETTEXGENIVOES)_getPrivateProcAddress(_name);
        if (!_glGetTexGenivOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexGenivOES_ptr(coord, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLGETTEXGENXVOES)(GLenum coord, GLenum pname, GLfixed * params);
static PFN_GLGETTEXGENXVOES _glGetTexGenxvOES_ptr = NULL;

static inline void GL_APIENTRY _glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed * params) {
    const char *_name = "glGetTexGenxvOES";
    if (!_glGetTexGenxvOES_ptr) {
        _glGetTexGenxvOES_ptr = (PFN_GLGETTEXGENXVOES)_getPrivateProcAddress(_name);
        if (!_glGetTexGenxvOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetTexGenxvOES_ptr(coord, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLGETBUFFERPOINTERVOES)(GLenum target, GLenum pname, GLvoid * * params);
static PFN_GLGETBUFFERPOINTERVOES _glGetBufferPointervOES_ptr = NULL;

static inline void GL_APIENTRY _glGetBufferPointervOES(GLenum target, GLenum pname, GLvoid * * params) {
    const char *_name = "glGetBufferPointervOES";
    if (!_glGetBufferPointervOES_ptr) {
        _glGetBufferPointervOES_ptr = (PFN_GLGETBUFFERPOINTERVOES)_getPrivateProcAddress(_name);
        if (!_glGetBufferPointervOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetBufferPointervOES_ptr(target, pname, params);
}

typedef GLvoid * (GL_APIENTRY * PFN_GLMAPBUFFEROES)(GLenum target, GLenum access);
static PFN_GLMAPBUFFEROES _glMapBufferOES_ptr = NULL;

static inline GLvoid * GL_APIENTRY _glMapBufferOES(GLenum target, GLenum access) {
    const char *_name = "glMapBufferOES";
    if (!_glMapBufferOES_ptr) {
        _glMapBufferOES_ptr = (PFN_GLMAPBUFFEROES)_getPrivateProcAddress(_name);
        if (!_glMapBufferOES_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glMapBufferOES_ptr(target, access);
}

typedef GLboolean (GL_APIENTRY * PFN_GLUNMAPBUFFEROES)(GLenum target);
static PFN_GLUNMAPBUFFEROES _glUnmapBufferOES_ptr = NULL;

static inline GLboolean GL_APIENTRY _glUnmapBufferOES(GLenum target) {
    const char *_name = "glUnmapBufferOES";
    if (!_glUnmapBufferOES_ptr) {
        _glUnmapBufferOES_ptr = (PFN_GLUNMAPBUFFEROES)_getPrivateProcAddress(_name);
        if (!_glUnmapBufferOES_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glUnmapBufferOES_ptr(target);
}

typedef void (GL_APIENTRY * PFN_GLTEXIMAGE3DOES)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXIMAGE3DOES _glTexImage3DOES_ptr = NULL;

static inline void GL_APIENTRY _glTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexImage3DOES";
    if (!_glTexImage3DOES_ptr) {
        _glTexImage3DOES_ptr = (PFN_GLTEXIMAGE3DOES)_getPrivateProcAddress(_name);
        if (!_glTexImage3DOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexImage3DOES_ptr(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

typedef void (GL_APIENTRY * PFN_GLTEXSUBIMAGE3DOES)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels);
static PFN_GLTEXSUBIMAGE3DOES _glTexSubImage3DOES_ptr = NULL;

static inline void GL_APIENTRY _glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage3DOES";
    if (!_glTexSubImage3DOES_ptr) {
        _glTexSubImage3DOES_ptr = (PFN_GLTEXSUBIMAGE3DOES)_getPrivateProcAddress(_name);
        if (!_glTexSubImage3DOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glTexSubImage3DOES_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

typedef void (GL_APIENTRY * PFN_GLCOPYTEXSUBIMAGE3DOES)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
static PFN_GLCOPYTEXSUBIMAGE3DOES _glCopyTexSubImage3DOES_ptr = NULL;

static inline void GL_APIENTRY _glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTexSubImage3DOES";
    if (!_glCopyTexSubImage3DOES_ptr) {
        _glCopyTexSubImage3DOES_ptr = (PFN_GLCOPYTEXSUBIMAGE3DOES)_getPrivateProcAddress(_name);
        if (!_glCopyTexSubImage3DOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCopyTexSubImage3DOES_ptr(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

typedef void (GL_APIENTRY * PFN_GLCOMPRESSEDTEXIMAGE3DOES)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXIMAGE3DOES _glCompressedTexImage3DOES_ptr = NULL;

static inline void GL_APIENTRY _glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage3DOES";
    if (!_glCompressedTexImage3DOES_ptr) {
        _glCompressedTexImage3DOES_ptr = (PFN_GLCOMPRESSEDTEXIMAGE3DOES)_getPrivateProcAddress(_name);
        if (!_glCompressedTexImage3DOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexImage3DOES_ptr(target, level, internalformat, width, height, depth, border, imageSize, data);
}

typedef void (GL_APIENTRY * PFN_GLCOMPRESSEDTEXSUBIMAGE3DOES)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data);
static PFN_GLCOMPRESSEDTEXSUBIMAGE3DOES _glCompressedTexSubImage3DOES_ptr = NULL;

static inline void GL_APIENTRY _glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage3DOES";
    if (!_glCompressedTexSubImage3DOES_ptr) {
        _glCompressedTexSubImage3DOES_ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE3DOES)_getPrivateProcAddress(_name);
        if (!_glCompressedTexSubImage3DOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCompressedTexSubImage3DOES_ptr(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

typedef void (GL_APIENTRY * PFN_GLFRAMEBUFFERTEXTURE3DOES)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
static PFN_GLFRAMEBUFFERTEXTURE3DOES _glFramebufferTexture3DOES_ptr = NULL;

static inline void GL_APIENTRY _glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
    const char *_name = "glFramebufferTexture3DOES";
    if (!_glFramebufferTexture3DOES_ptr) {
        _glFramebufferTexture3DOES_ptr = (PFN_GLFRAMEBUFFERTEXTURE3DOES)_getPrivateProcAddress(_name);
        if (!_glFramebufferTexture3DOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTexture3DOES_ptr(target, attachment, textarget, texture, level, zoffset);
}

typedef void (GL_APIENTRY * PFN_GLGETPROGRAMBINARYOES)(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, GLvoid * binary);
static PFN_GLGETPROGRAMBINARYOES _glGetProgramBinaryOES_ptr = NULL;

static inline void GL_APIENTRY _glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, GLvoid * binary) {
    const char *_name = "glGetProgramBinaryOES";
    if (!_glGetProgramBinaryOES_ptr) {
        _glGetProgramBinaryOES_ptr = (PFN_GLGETPROGRAMBINARYOES)_getPrivateProcAddress(_name);
        if (!_glGetProgramBinaryOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramBinaryOES_ptr(program, bufSize, length, binaryFormat, binary);
}

typedef void (GL_APIENTRY * PFN_GLPROGRAMBINARYOES)(GLuint program, GLenum binaryFormat, const GLvoid * binary, GLsizei length);
static PFN_GLPROGRAMBINARYOES _glProgramBinaryOES_ptr = NULL;

static inline void GL_APIENTRY _glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid * binary, GLsizei length) {
    const char *_name = "glProgramBinaryOES";
    if (!_glProgramBinaryOES_ptr) {
        _glProgramBinaryOES_ptr = (PFN_GLPROGRAMBINARYOES)_getPrivateProcAddress(_name);
        if (!_glProgramBinaryOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glProgramBinaryOES_ptr(program, binaryFormat, binary, length);
}

typedef void (GL_APIENTRY * PFN_GLDRAWTEXFOES)(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height);
static PFN_GLDRAWTEXFOES _glDrawTexfOES_ptr = NULL;

static inline void GL_APIENTRY _glDrawTexfOES(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height) {
    const char *_name = "glDrawTexfOES";
    if (!_glDrawTexfOES_ptr) {
        _glDrawTexfOES_ptr = (PFN_GLDRAWTEXFOES)_getPrivateProcAddress(_name);
        if (!_glDrawTexfOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawTexfOES_ptr(x, y, z, width, height);
}

typedef void (GL_APIENTRY * PFN_GLDRAWTEXFVOES)(const GLfloat * coords);
static PFN_GLDRAWTEXFVOES _glDrawTexfvOES_ptr = NULL;

static inline void GL_APIENTRY _glDrawTexfvOES(const GLfloat * coords) {
    const char *_name = "glDrawTexfvOES";
    if (!_glDrawTexfvOES_ptr) {
        _glDrawTexfvOES_ptr = (PFN_GLDRAWTEXFVOES)_getPrivateProcAddress(_name);
        if (!_glDrawTexfvOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawTexfvOES_ptr(coords);
}

typedef void (GL_APIENTRY * PFN_GLDRAWTEXIOES)(GLint x, GLint y, GLint z, GLint width, GLint height);
static PFN_GLDRAWTEXIOES _glDrawTexiOES_ptr = NULL;

static inline void GL_APIENTRY _glDrawTexiOES(GLint x, GLint y, GLint z, GLint width, GLint height) {
    const char *_name = "glDrawTexiOES";
    if (!_glDrawTexiOES_ptr) {
        _glDrawTexiOES_ptr = (PFN_GLDRAWTEXIOES)_getPrivateProcAddress(_name);
        if (!_glDrawTexiOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawTexiOES_ptr(x, y, z, width, height);
}

typedef void (GL_APIENTRY * PFN_GLDRAWTEXIVOES)(const GLint * coords);
static PFN_GLDRAWTEXIVOES _glDrawTexivOES_ptr = NULL;

static inline void GL_APIENTRY _glDrawTexivOES(const GLint * coords) {
    const char *_name = "glDrawTexivOES";
    if (!_glDrawTexivOES_ptr) {
        _glDrawTexivOES_ptr = (PFN_GLDRAWTEXIVOES)_getPrivateProcAddress(_name);
        if (!_glDrawTexivOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawTexivOES_ptr(coords);
}

typedef void (GL_APIENTRY * PFN_GLDRAWTEXSOES)(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height);
static PFN_GLDRAWTEXSOES _glDrawTexsOES_ptr = NULL;

static inline void GL_APIENTRY _glDrawTexsOES(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height) {
    const char *_name = "glDrawTexsOES";
    if (!_glDrawTexsOES_ptr) {
        _glDrawTexsOES_ptr = (PFN_GLDRAWTEXSOES)_getPrivateProcAddress(_name);
        if (!_glDrawTexsOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawTexsOES_ptr(x, y, z, width, height);
}

typedef void (GL_APIENTRY * PFN_GLDRAWTEXSVOES)(const GLshort * coords);
static PFN_GLDRAWTEXSVOES _glDrawTexsvOES_ptr = NULL;

static inline void GL_APIENTRY _glDrawTexsvOES(const GLshort * coords) {
    const char *_name = "glDrawTexsvOES";
    if (!_glDrawTexsvOES_ptr) {
        _glDrawTexsvOES_ptr = (PFN_GLDRAWTEXSVOES)_getPrivateProcAddress(_name);
        if (!_glDrawTexsvOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawTexsvOES_ptr(coords);
}

typedef void (GL_APIENTRY * PFN_GLDISCARDFRAMEBUFFEREXT)(GLenum target, GLsizei numAttachments, const GLenum * attachments);
static PFN_GLDISCARDFRAMEBUFFEREXT _glDiscardFramebufferEXT_ptr = NULL;

static inline void GL_APIENTRY _glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum * attachments) {
    const char *_name = "glDiscardFramebufferEXT";
    if (!_glDiscardFramebufferEXT_ptr) {
        _glDiscardFramebufferEXT_ptr = (PFN_GLDISCARDFRAMEBUFFEREXT)_getPrivateProcAddress(_name);
        if (!_glDiscardFramebufferEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDiscardFramebufferEXT_ptr(target, numAttachments, attachments);
}

typedef void (GL_APIENTRY * PFN_GLBINDVERTEXARRAYOES)(GLuint array);
static PFN_GLBINDVERTEXARRAYOES _glBindVertexArrayOES_ptr = NULL;

static inline void GL_APIENTRY _glBindVertexArrayOES(GLuint array) {
    const char *_name = "glBindVertexArrayOES";
    if (!_glBindVertexArrayOES_ptr) {
        _glBindVertexArrayOES_ptr = (PFN_GLBINDVERTEXARRAYOES)_getPrivateProcAddress(_name);
        if (!_glBindVertexArrayOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindVertexArrayOES_ptr(array);
}

typedef void (GL_APIENTRY * PFN_GLDELETEVERTEXARRAYSOES)(GLsizei n, const GLuint * arrays);
static PFN_GLDELETEVERTEXARRAYSOES _glDeleteVertexArraysOES_ptr = NULL;

static inline void GL_APIENTRY _glDeleteVertexArraysOES(GLsizei n, const GLuint * arrays) {
    const char *_name = "glDeleteVertexArraysOES";
    if (!_glDeleteVertexArraysOES_ptr) {
        _glDeleteVertexArraysOES_ptr = (PFN_GLDELETEVERTEXARRAYSOES)_getPrivateProcAddress(_name);
        if (!_glDeleteVertexArraysOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteVertexArraysOES_ptr(n, arrays);
}

typedef void (GL_APIENTRY * PFN_GLGENVERTEXARRAYSOES)(GLsizei n, GLuint * arrays);
static PFN_GLGENVERTEXARRAYSOES _glGenVertexArraysOES_ptr = NULL;

static inline void GL_APIENTRY _glGenVertexArraysOES(GLsizei n, GLuint * arrays) {
    const char *_name = "glGenVertexArraysOES";
    if (!_glGenVertexArraysOES_ptr) {
        _glGenVertexArraysOES_ptr = (PFN_GLGENVERTEXARRAYSOES)_getPrivateProcAddress(_name);
        if (!_glGenVertexArraysOES_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenVertexArraysOES_ptr(n, arrays);
}

typedef GLboolean (GL_APIENTRY * PFN_GLISVERTEXARRAYOES)(GLuint array);
static PFN_GLISVERTEXARRAYOES _glIsVertexArrayOES_ptr = NULL;

static inline GLboolean GL_APIENTRY _glIsVertexArrayOES(GLuint array) {
    const char *_name = "glIsVertexArrayOES";
    if (!_glIsVertexArrayOES_ptr) {
        _glIsVertexArrayOES_ptr = (PFN_GLISVERTEXARRAYOES)_getPrivateProcAddress(_name);
        if (!_glIsVertexArrayOES_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsVertexArrayOES_ptr(array);
}

typedef void (GL_APIENTRY * PFN_GLCOVERAGEMASKNV)(GLboolean mask);
static PFN_GLCOVERAGEMASKNV _glCoverageMaskNV_ptr = NULL;

static inline void GL_APIENTRY _glCoverageMaskNV(GLboolean mask) {
    const char *_name = "glCoverageMaskNV";
    if (!_glCoverageMaskNV_ptr) {
        _glCoverageMaskNV_ptr = (PFN_GLCOVERAGEMASKNV)_getPrivateProcAddress(_name);
        if (!_glCoverageMaskNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCoverageMaskNV_ptr(mask);
}

typedef void (GL_APIENTRY * PFN_GLCOVERAGEOPERATIONNV)(GLenum operation);
static PFN_GLCOVERAGEOPERATIONNV _glCoverageOperationNV_ptr = NULL;

static inline void GL_APIENTRY _glCoverageOperationNV(GLenum operation) {
    const char *_name = "glCoverageOperationNV";
    if (!_glCoverageOperationNV_ptr) {
        _glCoverageOperationNV_ptr = (PFN_GLCOVERAGEOPERATIONNV)_getPrivateProcAddress(_name);
        if (!_glCoverageOperationNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glCoverageOperationNV_ptr(operation);
}

typedef void (GL_APIENTRY * PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEIMG)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEIMG _glRenderbufferStorageMultisampleIMG_ptr = NULL;

static inline void GL_APIENTRY _glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageMultisampleIMG";
    if (!_glRenderbufferStorageMultisampleIMG_ptr) {
        _glRenderbufferStorageMultisampleIMG_ptr = (PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEIMG)_getPrivateProcAddress(_name);
        if (!_glRenderbufferStorageMultisampleIMG_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRenderbufferStorageMultisampleIMG_ptr(target, samples, internalformat, width, height);
}

typedef void (GL_APIENTRY * PFN_GLFRAMEBUFFERTEXTURE2DMULTISAMPLEIMG)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);
static PFN_GLFRAMEBUFFERTEXTURE2DMULTISAMPLEIMG _glFramebufferTexture2DMultisampleIMG_ptr = NULL;

static inline void GL_APIENTRY _glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) {
    const char *_name = "glFramebufferTexture2DMultisampleIMG";
    if (!_glFramebufferTexture2DMultisampleIMG_ptr) {
        _glFramebufferTexture2DMultisampleIMG_ptr = (PFN_GLFRAMEBUFFERTEXTURE2DMULTISAMPLEIMG)_getPrivateProcAddress(_name);
        if (!_glFramebufferTexture2DMultisampleIMG_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glFramebufferTexture2DMultisampleIMG_ptr(target, attachment, textarget, texture, level, samples);
}

typedef void (GL_APIENTRY * PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEAPPLE)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEAPPLE _glRenderbufferStorageMultisampleAPPLE_ptr = NULL;

static inline void GL_APIENTRY _glRenderbufferStorageMultisampleAPPLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageMultisampleAPPLE";
    if (!_glRenderbufferStorageMultisampleAPPLE_ptr) {
        _glRenderbufferStorageMultisampleAPPLE_ptr = (PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEAPPLE)_getPrivateProcAddress(_name);
        if (!_glRenderbufferStorageMultisampleAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRenderbufferStorageMultisampleAPPLE_ptr(target, samples, internalformat, width, height);
}

typedef void (GL_APIENTRY * PFN_GLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLE)(void);
static PFN_GLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLE _glResolveMultisampleFramebufferAPPLE_ptr = NULL;

static inline void GL_APIENTRY _glResolveMultisampleFramebufferAPPLE(void) {
    const char *_name = "glResolveMultisampleFramebufferAPPLE";
    if (!_glResolveMultisampleFramebufferAPPLE_ptr) {
        _glResolveMultisampleFramebufferAPPLE_ptr = (PFN_GLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLE)_getPrivateProcAddress(_name);
        if (!_glResolveMultisampleFramebufferAPPLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glResolveMultisampleFramebufferAPPLE_ptr();
}

typedef void (GL_APIENTRY * PFN_GLBLITFRAMEBUFFERANGLE)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
static PFN_GLBLITFRAMEBUFFERANGLE _glBlitFramebufferANGLE_ptr = NULL;

static inline void GL_APIENTRY _glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    const char *_name = "glBlitFramebufferANGLE";
    if (!_glBlitFramebufferANGLE_ptr) {
        _glBlitFramebufferANGLE_ptr = (PFN_GLBLITFRAMEBUFFERANGLE)_getPrivateProcAddress(_name);
        if (!_glBlitFramebufferANGLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBlitFramebufferANGLE_ptr(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

typedef void (GL_APIENTRY * PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEANGLE)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
static PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEANGLE _glRenderbufferStorageMultisampleANGLE_ptr = NULL;

static inline void GL_APIENTRY _glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageMultisampleANGLE";
    if (!_glRenderbufferStorageMultisampleANGLE_ptr) {
        _glRenderbufferStorageMultisampleANGLE_ptr = (PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEANGLE)_getPrivateProcAddress(_name);
        if (!_glRenderbufferStorageMultisampleANGLE_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glRenderbufferStorageMultisampleANGLE_ptr(target, samples, internalformat, width, height);
}

typedef void (GL_APIENTRY * PFN_GLDRAWBUFFERSNV)(GLsizei n, const GLenum * bufs);
static PFN_GLDRAWBUFFERSNV _glDrawBuffersNV_ptr = NULL;

static inline void GL_APIENTRY _glDrawBuffersNV(GLsizei n, const GLenum * bufs) {
    const char *_name = "glDrawBuffersNV";
    if (!_glDrawBuffersNV_ptr) {
        _glDrawBuffersNV_ptr = (PFN_GLDRAWBUFFERSNV)_getPrivateProcAddress(_name);
        if (!_glDrawBuffersNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDrawBuffersNV_ptr(n, bufs);
}

typedef void (GL_APIENTRY * PFN_GLREADBUFFERNV)(GLenum mode);
static PFN_GLREADBUFFERNV _glReadBufferNV_ptr = NULL;

static inline void GL_APIENTRY _glReadBufferNV(GLenum mode) {
    const char *_name = "glReadBufferNV";
    if (!_glReadBufferNV_ptr) {
        _glReadBufferNV_ptr = (PFN_GLREADBUFFERNV)_getPrivateProcAddress(_name);
        if (!_glReadBufferNV_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glReadBufferNV_ptr(mode);
}

typedef void (GL_APIENTRY * PFN_GLLABELOBJECTEXT)(GLenum type, GLuint object, GLsizei length, const GLchar * label);
static PFN_GLLABELOBJECTEXT _glLabelObjectEXT_ptr = NULL;

static inline void GL_APIENTRY _glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar * label) {
    const char *_name = "glLabelObjectEXT";
    if (!_glLabelObjectEXT_ptr) {
        _glLabelObjectEXT_ptr = (PFN_GLLABELOBJECTEXT)_getPrivateProcAddress(_name);
        if (!_glLabelObjectEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glLabelObjectEXT_ptr(type, object, length, label);
}

typedef void (GL_APIENTRY * PFN_GLGETOBJECTLABELEXT)(GLenum type, GLuint object, GLsizei bufSize, GLsizei * length, GLchar * label);
static PFN_GLGETOBJECTLABELEXT _glGetObjectLabelEXT_ptr = NULL;

static inline void GL_APIENTRY _glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei * length, GLchar * label) {
    const char *_name = "glGetObjectLabelEXT";
    if (!_glGetObjectLabelEXT_ptr) {
        _glGetObjectLabelEXT_ptr = (PFN_GLGETOBJECTLABELEXT)_getPrivateProcAddress(_name);
        if (!_glGetObjectLabelEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetObjectLabelEXT_ptr(type, object, bufSize, length, label);
}

typedef void (GL_APIENTRY * PFN_GLINSERTEVENTMARKEREXT)(GLsizei length, const GLchar * marker);
static PFN_GLINSERTEVENTMARKEREXT _glInsertEventMarkerEXT_ptr = NULL;

static inline void GL_APIENTRY _glInsertEventMarkerEXT(GLsizei length, const GLchar * marker) {
    const char *_name = "glInsertEventMarkerEXT";
    if (!_glInsertEventMarkerEXT_ptr) {
        _glInsertEventMarkerEXT_ptr = (PFN_GLINSERTEVENTMARKEREXT)_getPrivateProcAddress(_name);
        if (!_glInsertEventMarkerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glInsertEventMarkerEXT_ptr(length, marker);
}

typedef void (GL_APIENTRY * PFN_GLPUSHGROUPMARKEREXT)(GLsizei length, const GLchar * marker);
static PFN_GLPUSHGROUPMARKEREXT _glPushGroupMarkerEXT_ptr = NULL;

static inline void GL_APIENTRY _glPushGroupMarkerEXT(GLsizei length, const GLchar * marker) {
    const char *_name = "glPushGroupMarkerEXT";
    if (!_glPushGroupMarkerEXT_ptr) {
        _glPushGroupMarkerEXT_ptr = (PFN_GLPUSHGROUPMARKEREXT)_getPrivateProcAddress(_name);
        if (!_glPushGroupMarkerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPushGroupMarkerEXT_ptr(length, marker);
}

typedef void (GL_APIENTRY * PFN_GLPOPGROUPMARKEREXT)(void);
static PFN_GLPOPGROUPMARKEREXT _glPopGroupMarkerEXT_ptr = NULL;

static inline void GL_APIENTRY _glPopGroupMarkerEXT(void) {
    const char *_name = "glPopGroupMarkerEXT";
    if (!_glPopGroupMarkerEXT_ptr) {
        _glPopGroupMarkerEXT_ptr = (PFN_GLPOPGROUPMARKEREXT)_getPrivateProcAddress(_name);
        if (!_glPopGroupMarkerEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glPopGroupMarkerEXT_ptr();
}

typedef void (GL_APIENTRY * PFN_GLGENQUERIESEXT)(GLsizei n, GLuint * ids);
static PFN_GLGENQUERIESEXT _glGenQueriesEXT_ptr = NULL;

static inline void GL_APIENTRY _glGenQueriesEXT(GLsizei n, GLuint * ids) {
    const char *_name = "glGenQueriesEXT";
    if (!_glGenQueriesEXT_ptr) {
        _glGenQueriesEXT_ptr = (PFN_GLGENQUERIESEXT)_getPrivateProcAddress(_name);
        if (!_glGenQueriesEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenQueriesEXT_ptr(n, ids);
}

typedef void (GL_APIENTRY * PFN_GLDELETEQUERIESEXT)(GLsizei n, const GLuint * ids);
static PFN_GLDELETEQUERIESEXT _glDeleteQueriesEXT_ptr = NULL;

static inline void GL_APIENTRY _glDeleteQueriesEXT(GLsizei n, const GLuint * ids) {
    const char *_name = "glDeleteQueriesEXT";
    if (!_glDeleteQueriesEXT_ptr) {
        _glDeleteQueriesEXT_ptr = (PFN_GLDELETEQUERIESEXT)_getPrivateProcAddress(_name);
        if (!_glDeleteQueriesEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteQueriesEXT_ptr(n, ids);
}

typedef GLboolean (GL_APIENTRY * PFN_GLISQUERYEXT)(GLuint id);
static PFN_GLISQUERYEXT _glIsQueryEXT_ptr = NULL;

static inline GLboolean GL_APIENTRY _glIsQueryEXT(GLuint id) {
    const char *_name = "glIsQueryEXT";
    if (!_glIsQueryEXT_ptr) {
        _glIsQueryEXT_ptr = (PFN_GLISQUERYEXT)_getPrivateProcAddress(_name);
        if (!_glIsQueryEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsQueryEXT_ptr(id);
}

typedef void (GL_APIENTRY * PFN_GLBEGINQUERYEXT)(GLenum target, GLuint id);
static PFN_GLBEGINQUERYEXT _glBeginQueryEXT_ptr = NULL;

static inline void GL_APIENTRY _glBeginQueryEXT(GLenum target, GLuint id) {
    const char *_name = "glBeginQueryEXT";
    if (!_glBeginQueryEXT_ptr) {
        _glBeginQueryEXT_ptr = (PFN_GLBEGINQUERYEXT)_getPrivateProcAddress(_name);
        if (!_glBeginQueryEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBeginQueryEXT_ptr(target, id);
}

typedef void (GL_APIENTRY * PFN_GLENDQUERYEXT)(GLenum target);
static PFN_GLENDQUERYEXT _glEndQueryEXT_ptr = NULL;

static inline void GL_APIENTRY _glEndQueryEXT(GLenum target) {
    const char *_name = "glEndQueryEXT";
    if (!_glEndQueryEXT_ptr) {
        _glEndQueryEXT_ptr = (PFN_GLENDQUERYEXT)_getPrivateProcAddress(_name);
        if (!_glEndQueryEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glEndQueryEXT_ptr(target);
}

typedef void (GL_APIENTRY * PFN_GLGETQUERYIVEXT)(GLenum target, GLenum pname, GLint * params);
static PFN_GLGETQUERYIVEXT _glGetQueryivEXT_ptr = NULL;

static inline void GL_APIENTRY _glGetQueryivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryivEXT";
    if (!_glGetQueryivEXT_ptr) {
        _glGetQueryivEXT_ptr = (PFN_GLGETQUERYIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetQueryivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetQueryivEXT_ptr(target, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLGETQUERYOBJECTUIVEXT)(GLuint id, GLenum pname, GLuint * params);
static PFN_GLGETQUERYOBJECTUIVEXT _glGetQueryObjectuivEXT_ptr = NULL;

static inline void GL_APIENTRY _glGetQueryObjectuivEXT(GLuint id, GLenum pname, GLuint * params) {
    const char *_name = "glGetQueryObjectuivEXT";
    if (!_glGetQueryObjectuivEXT_ptr) {
        _glGetQueryObjectuivEXT_ptr = (PFN_GLGETQUERYOBJECTUIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetQueryObjectuivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetQueryObjectuivEXT_ptr(id, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLUSEPROGRAMSTAGESEXT)(GLuint pipeline, GLbitfield stages, GLuint program);
static PFN_GLUSEPROGRAMSTAGESEXT _glUseProgramStagesEXT_ptr = NULL;

static inline void GL_APIENTRY _glUseProgramStagesEXT(GLuint pipeline, GLbitfield stages, GLuint program) {
    const char *_name = "glUseProgramStagesEXT";
    if (!_glUseProgramStagesEXT_ptr) {
        _glUseProgramStagesEXT_ptr = (PFN_GLUSEPROGRAMSTAGESEXT)_getPrivateProcAddress(_name);
        if (!_glUseProgramStagesEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glUseProgramStagesEXT_ptr(pipeline, stages, program);
}

typedef void (GL_APIENTRY * PFN_GLACTIVESHADERPROGRAMEXT)(GLuint pipeline, GLuint program);
static PFN_GLACTIVESHADERPROGRAMEXT _glActiveShaderProgramEXT_ptr = NULL;

static inline void GL_APIENTRY _glActiveShaderProgramEXT(GLuint pipeline, GLuint program) {
    const char *_name = "glActiveShaderProgramEXT";
    if (!_glActiveShaderProgramEXT_ptr) {
        _glActiveShaderProgramEXT_ptr = (PFN_GLACTIVESHADERPROGRAMEXT)_getPrivateProcAddress(_name);
        if (!_glActiveShaderProgramEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glActiveShaderProgramEXT_ptr(pipeline, program);
}

typedef GLuint (GL_APIENTRY * PFN_GLCREATESHADERPROGRAMVEXT)(GLenum type, GLsizei count, const GLchar * * const strings);
static PFN_GLCREATESHADERPROGRAMVEXT _glCreateShaderProgramvEXT_ptr = NULL;

static inline GLuint GL_APIENTRY _glCreateShaderProgramvEXT(GLenum type, GLsizei count, const GLchar * * const strings) {
    const char *_name = "glCreateShaderProgramvEXT";
    if (!_glCreateShaderProgramvEXT_ptr) {
        _glCreateShaderProgramvEXT_ptr = (PFN_GLCREATESHADERPROGRAMVEXT)_getPrivateProcAddress(_name);
        if (!_glCreateShaderProgramvEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glCreateShaderProgramvEXT_ptr(type, count, strings);
}

typedef void (GL_APIENTRY * PFN_GLBINDPROGRAMPIPELINEEXT)(GLuint pipeline);
static PFN_GLBINDPROGRAMPIPELINEEXT _glBindProgramPipelineEXT_ptr = NULL;

static inline void GL_APIENTRY _glBindProgramPipelineEXT(GLuint pipeline) {
    const char *_name = "glBindProgramPipelineEXT";
    if (!_glBindProgramPipelineEXT_ptr) {
        _glBindProgramPipelineEXT_ptr = (PFN_GLBINDPROGRAMPIPELINEEXT)_getPrivateProcAddress(_name);
        if (!_glBindProgramPipelineEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glBindProgramPipelineEXT_ptr(pipeline);
}

typedef void (GL_APIENTRY * PFN_GLDELETEPROGRAMPIPELINESEXT)(GLsizei n, const GLuint * pipelines);
static PFN_GLDELETEPROGRAMPIPELINESEXT _glDeleteProgramPipelinesEXT_ptr = NULL;

static inline void GL_APIENTRY _glDeleteProgramPipelinesEXT(GLsizei n, const GLuint * pipelines) {
    const char *_name = "glDeleteProgramPipelinesEXT";
    if (!_glDeleteProgramPipelinesEXT_ptr) {
        _glDeleteProgramPipelinesEXT_ptr = (PFN_GLDELETEPROGRAMPIPELINESEXT)_getPrivateProcAddress(_name);
        if (!_glDeleteProgramPipelinesEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glDeleteProgramPipelinesEXT_ptr(n, pipelines);
}

typedef void (GL_APIENTRY * PFN_GLGENPROGRAMPIPELINESEXT)(GLsizei n, GLuint * pipelines);
static PFN_GLGENPROGRAMPIPELINESEXT _glGenProgramPipelinesEXT_ptr = NULL;

static inline void GL_APIENTRY _glGenProgramPipelinesEXT(GLsizei n, GLuint * pipelines) {
    const char *_name = "glGenProgramPipelinesEXT";
    if (!_glGenProgramPipelinesEXT_ptr) {
        _glGenProgramPipelinesEXT_ptr = (PFN_GLGENPROGRAMPIPELINESEXT)_getPrivateProcAddress(_name);
        if (!_glGenProgramPipelinesEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGenProgramPipelinesEXT_ptr(n, pipelines);
}

typedef GLboolean (GL_APIENTRY * PFN_GLISPROGRAMPIPELINEEXT)(GLuint pipeline);
static PFN_GLISPROGRAMPIPELINEEXT _glIsProgramPipelineEXT_ptr = NULL;

static inline GLboolean GL_APIENTRY _glIsProgramPipelineEXT(GLuint pipeline) {
    const char *_name = "glIsProgramPipelineEXT";
    if (!_glIsProgramPipelineEXT_ptr) {
        _glIsProgramPipelineEXT_ptr = (PFN_GLISPROGRAMPIPELINEEXT)_getPrivateProcAddress(_name);
        if (!_glIsProgramPipelineEXT_ptr) {
            os::log("error: unavailable function %s\n", _name);
            os::abort();
        }
    }
    return _glIsProgramPipelineEXT_ptr(pipeline);
}

typedef void (GL_APIENTRY * PFN_GLGETPROGRAMPIPELINEIVEXT)(GLuint pipeline, GLenum pname, GLint * params);
static PFN_GLGETPROGRAMPIPELINEIVEXT _glGetProgramPipelineivEXT_ptr = NULL;

static inline void GL_APIENTRY _glGetProgramPipelineivEXT(GLuint pipeline, GLenum pname, GLint * params) {
    const char *_name = "glGetProgramPipelineivEXT";
    if (!_glGetProgramPipelineivEXT_ptr) {
        _glGetProgramPipelineivEXT_ptr = (PFN_GLGETPROGRAMPIPELINEIVEXT)_getPrivateProcAddress(_name);
        if (!_glGetProgramPipelineivEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramPipelineivEXT_ptr(pipeline, pname, params);
}

typedef void (GL_APIENTRY * PFN_GLVALIDATEPROGRAMPIPELINEEXT)(GLuint pipeline);
static PFN_GLVALIDATEPROGRAMPIPELINEEXT _glValidateProgramPipelineEXT_ptr = NULL;

static inline void GL_APIENTRY _glValidateProgramPipelineEXT(GLuint pipeline) {
    const char *_name = "glValidateProgramPipelineEXT";
    if (!_glValidateProgramPipelineEXT_ptr) {
        _glValidateProgramPipelineEXT_ptr = (PFN_GLVALIDATEPROGRAMPIPELINEEXT)_getPrivateProcAddress(_name);
        if (!_glValidateProgramPipelineEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glValidateProgramPipelineEXT_ptr(pipeline);
}

typedef void (GL_APIENTRY * PFN_GLGETPROGRAMPIPELINEINFOLOGEXT)(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
static PFN_GLGETPROGRAMPIPELINEINFOLOGEXT _glGetProgramPipelineInfoLogEXT_ptr = NULL;

static inline void GL_APIENTRY _glGetProgramPipelineInfoLogEXT(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog) {
    const char *_name = "glGetProgramPipelineInfoLogEXT";
    if (!_glGetProgramPipelineInfoLogEXT_ptr) {
        _glGetProgramPipelineInfoLogEXT_ptr = (PFN_GLGETPROGRAMPIPELINEINFOLOGEXT)_getPrivateProcAddress(_name);
        if (!_glGetProgramPipelineInfoLogEXT_ptr) {
            os::log("warning: ignoring call to unavailable function %s\n", _name);
            return;
        }
    }
    _glGetProgramPipelineInfoLogEXT_ptr(pipeline, bufSize, length, infoLog);
}

#ifdef RETRACE
#define glFrustumf _glFrustumf
#define glOrthof _glOrthof
#define glClipPlanef _glClipPlanef
#define glGetClipPlanef _glGetClipPlanef
#define glAlphaFuncx _glAlphaFuncx
#define glClearColorx _glClearColorx
#define glClearDepthx _glClearDepthx
#define glColor4x _glColor4x
#define glDepthRangex _glDepthRangex
#define glFogx _glFogx
#define glFogxv _glFogxv
#define glFrustumx _glFrustumx
#define glLightModelx _glLightModelx
#define glLightModelxv _glLightModelxv
#define glLightx _glLightx
#define glLightxv _glLightxv
#define glLineWidthx _glLineWidthx
#define glLoadMatrixx _glLoadMatrixx
#define glMaterialx _glMaterialx
#define glMaterialxv _glMaterialxv
#define glMultMatrixx _glMultMatrixx
#define glMultiTexCoord4x _glMultiTexCoord4x
#define glNormal3x _glNormal3x
#define glOrthox _glOrthox
#define glPointSizex _glPointSizex
#define glPolygonOffsetx _glPolygonOffsetx
#define glRotatex _glRotatex
#define glSampleCoveragex _glSampleCoveragex
#define glScalex _glScalex
#define glTexEnvx _glTexEnvx
#define glTexEnvxv _glTexEnvxv
#define glTexParameterx _glTexParameterx
#define glTranslatex _glTranslatex
#define glClipPlanex _glClipPlanex
#define glGetClipPlanex _glGetClipPlanex
#define glGetFixedv _glGetFixedv
#define glGetLightxv _glGetLightxv
#define glGetMaterialxv _glGetMaterialxv
#define glGetTexEnvxv _glGetTexEnvxv
#define glGetTexParameterxv _glGetTexParameterxv
#define glPointParameterx _glPointParameterx
#define glPointParameterxv _glPointParameterxv
#define glTexParameterxv _glTexParameterxv
#define glBlendEquationSeparateOES _glBlendEquationSeparateOES
#define glBlendFuncSeparateOES _glBlendFuncSeparateOES
#define glBlendEquationOES _glBlendEquationOES
#define glIsRenderbufferOES _glIsRenderbufferOES
#define glBindRenderbufferOES _glBindRenderbufferOES
#define glDeleteRenderbuffersOES _glDeleteRenderbuffersOES
#define glGenRenderbuffersOES _glGenRenderbuffersOES
#define glRenderbufferStorageOES _glRenderbufferStorageOES
#define glGetRenderbufferParameterivOES _glGetRenderbufferParameterivOES
#define glIsFramebufferOES _glIsFramebufferOES
#define glBindFramebufferOES _glBindFramebufferOES
#define glDeleteFramebuffersOES _glDeleteFramebuffersOES
#define glGenFramebuffersOES _glGenFramebuffersOES
#define glCheckFramebufferStatusOES _glCheckFramebufferStatusOES
#define glFramebufferTexture2DOES _glFramebufferTexture2DOES
#define glFramebufferRenderbufferOES _glFramebufferRenderbufferOES
#define glGetFramebufferAttachmentParameterivOES _glGetFramebufferAttachmentParameterivOES
#define glGenerateMipmapOES _glGenerateMipmapOES
#define glCurrentPaletteMatrixOES _glCurrentPaletteMatrixOES
#define glLoadPaletteFromModelViewMatrixOES _glLoadPaletteFromModelViewMatrixOES
#define glMatrixIndexPointerOES _glMatrixIndexPointerOES
#define glWeightPointerOES _glWeightPointerOES
#define glPointSizePointerOES _glPointSizePointerOES
#define glQueryMatrixxOES _glQueryMatrixxOES
#define glTexGenfOES _glTexGenfOES
#define glTexGenfvOES _glTexGenfvOES
#define glTexGeniOES _glTexGeniOES
#define glTexGenivOES _glTexGenivOES
#define glTexGenxOES _glTexGenxOES
#define glTexGenxvOES _glTexGenxvOES
#define glGetTexGenfvOES _glGetTexGenfvOES
#define glGetTexGenivOES _glGetTexGenivOES
#define glGetTexGenxvOES _glGetTexGenxvOES
#define glGetBufferPointervOES _glGetBufferPointervOES
#define glMapBufferOES _glMapBufferOES
#define glUnmapBufferOES _glUnmapBufferOES
#define glTexImage3DOES _glTexImage3DOES
#define glTexSubImage3DOES _glTexSubImage3DOES
#define glCopyTexSubImage3DOES _glCopyTexSubImage3DOES
#define glCompressedTexImage3DOES _glCompressedTexImage3DOES
#define glCompressedTexSubImage3DOES _glCompressedTexSubImage3DOES
#define glFramebufferTexture3DOES _glFramebufferTexture3DOES
#define glGetProgramBinaryOES _glGetProgramBinaryOES
#define glProgramBinaryOES _glProgramBinaryOES
#define glDrawTexfOES _glDrawTexfOES
#define glDrawTexfvOES _glDrawTexfvOES
#define glDrawTexiOES _glDrawTexiOES
#define glDrawTexivOES _glDrawTexivOES
#define glDrawTexsOES _glDrawTexsOES
#define glDrawTexsvOES _glDrawTexsvOES
#define glDiscardFramebufferEXT _glDiscardFramebufferEXT
#define glBindVertexArrayOES _glBindVertexArrayOES
#define glDeleteVertexArraysOES _glDeleteVertexArraysOES
#define glGenVertexArraysOES _glGenVertexArraysOES
#define glIsVertexArrayOES _glIsVertexArrayOES
#define glCoverageMaskNV _glCoverageMaskNV
#define glCoverageOperationNV _glCoverageOperationNV
#define glRenderbufferStorageMultisampleIMG _glRenderbufferStorageMultisampleIMG
#define glFramebufferTexture2DMultisampleIMG _glFramebufferTexture2DMultisampleIMG
#define glRenderbufferStorageMultisampleAPPLE _glRenderbufferStorageMultisampleAPPLE
#define glResolveMultisampleFramebufferAPPLE _glResolveMultisampleFramebufferAPPLE
#define glBlitFramebufferANGLE _glBlitFramebufferANGLE
#define glRenderbufferStorageMultisampleANGLE _glRenderbufferStorageMultisampleANGLE
#define glDrawBuffersNV _glDrawBuffersNV
#define glReadBufferNV _glReadBufferNV
#define glLabelObjectEXT _glLabelObjectEXT
#define glGetObjectLabelEXT _glGetObjectLabelEXT
#define glInsertEventMarkerEXT _glInsertEventMarkerEXT
#define glPushGroupMarkerEXT _glPushGroupMarkerEXT
#define glPopGroupMarkerEXT _glPopGroupMarkerEXT
#define glGenQueriesEXT _glGenQueriesEXT
#define glDeleteQueriesEXT _glDeleteQueriesEXT
#define glIsQueryEXT _glIsQueryEXT
#define glBeginQueryEXT _glBeginQueryEXT
#define glEndQueryEXT _glEndQueryEXT
#define glGetQueryivEXT _glGetQueryivEXT
#define glGetQueryObjectuivEXT _glGetQueryObjectuivEXT
#define glUseProgramStagesEXT _glUseProgramStagesEXT
#define glActiveShaderProgramEXT _glActiveShaderProgramEXT
#define glCreateShaderProgramvEXT _glCreateShaderProgramvEXT
#define glBindProgramPipelineEXT _glBindProgramPipelineEXT
#define glDeleteProgramPipelinesEXT _glDeleteProgramPipelinesEXT
#define glGenProgramPipelinesEXT _glGenProgramPipelinesEXT
#define glIsProgramPipelineEXT _glIsProgramPipelineEXT
#define glGetProgramPipelineivEXT _glGetProgramPipelineivEXT
#define glValidateProgramPipelineEXT _glValidateProgramPipelineEXT
#define glGetProgramPipelineInfoLogEXT _glGetProgramPipelineInfoLogEXT
#endif /* RETRACE */


#endif /* !_GLPROC_HPP_ */

